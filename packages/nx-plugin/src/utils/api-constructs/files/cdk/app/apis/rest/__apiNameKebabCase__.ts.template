import { Construct } from 'constructs';
import * as url from 'url';
import { Distribution } from 'aws-cdk-lib/aws-cloudfront';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
  <%_ if (backend.type === 'fastapi') { _%>
  LayerVersion,
  SnapStartConf,
  <%_ } _%>
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
  <%_ if (['trpc', 'fastapi'].includes(backend.type)) { _%>
  ResponseTransferMode,
  <%_ } _%>
  <%_ if (auth === 'Cognito') { _%>
  CognitoUserPoolsAuthorizer,
  <%_ } _%>
} from 'aws-cdk-lib/aws-apigateway';
import { Duration<%_ if (backend.type === 'fastapi') { _%>, Stack<%_ } _%> } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AnyPrincipal,
  <%_ if (auth === 'IAM') { _%>
  IGrantable,
  Grant,
  <%_ } _%>
} from 'aws-cdk-lib/aws-iam';
<%_ if (auth === 'Cognito') { _%>
import { IUserPool } from 'aws-cdk-lib/aws-cognito';
<%_ } _%>
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
<%_ if (backend.type === 'trpc') { _%>
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from '<%= backend.projectAlias %>';

// String union type for all API operation names
type Operations = Procedures<AppRouter>;
<%_ } else { _%>
import {
  OPERATION_DETAILS,
  Operations,
} from '../../generated/<%- apiNameKebabCase %>/metadata.gen.js';
<%_ } _%>

/**
 * Properties for creating a <%= apiNameClassName %> construct
 *
 * @template TIntegrations - Map of operation names to their integrations
 */
export interface <%= apiNameClassName %>Props<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Map of operation names to their API Gateway integrations
   */
  integrations: TIntegrations;
  <%_ if (auth === 'Cognito') { _%>
  /**
   * Identity details for Cognito Authentication
   */
  identity: {
    userPool: IUserPool;
  };
  <%_ } _%>
}

/**
 * A CDK construct that creates and configures an AWS API Gateway REST API
 * specifically for <%= apiNameClassName %>.
 * @template TIntegrations - Map of operation names to their integrations
 */
export class <%= apiNameClassName %><
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   <%_ if (backend.integrationStyle === 'Router') { _%>
   * Creates default integrations for all operations using a single shared
   * router lambda function.
   <%_ } else { _%>
   * Creates default integrations for all operations, which implement each operation as
   * its own individual lambda function.
   <%_ } _%>
   *
   * @param scope - The CDK construct scope
   * @returns An IntegrationBuilder with default lambda integrations
   */
  public static defaultIntegrations = (scope: Construct) => {
    <%_ if (backend.integrationStyle === 'Router') { _%>
    const handlerProps = {
      runtime: Runtime.NODEJS_LATEST,
      handler: 'index.handler',
      code: Code.fromAsset(
        url.fileURLToPath(
          new URL(
            '../../../../../../<%- backend.bundleOutputDir %>',
            import.meta.url,
          ),
        ),
      ),
      timeout: Duration.seconds(30),
      tracing: Tracing.ACTIVE,
      environment: {
        AWS_CONNECTION_REUSE_ENABLED: '1',
      },
    } satisfies FunctionProps;
    const handler = new Function(scope, '<%= apiNameClassName %>RouterHandler', handlerProps);

    <%_ } _%>
    return IntegrationBuilder.rest({
      <%_ if (backend.type === 'trpc') { _%>
      operations: routerToOperations(appRouter),
      <%_ } else { _%>
      operations: OPERATION_DETAILS,
      <%_ } _%>
      defaultIntegrationOptions: <%_ if (backend.integrationStyle === 'Router') { _%>handlerProps<%_ } else { _%>{
        <%_ if (['trpc', 'smithy'].includes(backend.type)) { _%>
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../<%- backend.bundleOutputDir %>',
              import.meta.url,
            ),
          ),
        ),
        <%_ } else if (backend.type === 'fastapi') { _%>
        runtime: Runtime.PYTHON_3_12,
        handler: 'run.sh',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../<%- backend.bundleOutputDir %>',
              import.meta.url,
            ),
          ),
        ),
        <%_ } _%>
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        <%_ if (backend.type === 'fastapi') { _%>
        snapStart: SnapStartConf.ON_PUBLISHED_VERSIONS,
        <%_ } _%>
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
          <%_ if (backend.type === 'fastapi') { _%>
          PORT: '8000',
          AWS_LWA_INVOKE_MODE: 'response_stream',
          AWS_LAMBDA_EXEC_WRAPPER: '/opt/bootstrap',
          <%_ } _%>
        },
      } satisfies FunctionProps<%_ } _%>,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        <%_ if (backend.integrationStyle === 'Router') { _%>
        void op;
        void props;
        return {
          handler,
          integration: new LambdaIntegration(handler, {
            scopePermissionToMethod: false,
            responseTransferMode: ResponseTransferMode.STREAM,
          }),
        };
        <%_ } else { _%>
        const handler = new Function(scope, `<%= apiNameClassName %>${op}Handler`, props);
        <%_ if (backend.type === 'fastapi') { _%>
        const stack = Stack.of(scope);
        handler.addLayers(
          LayerVersion.fromLayerVersionArn(
            scope,
            `<%= apiNameClassName %>${op}LWALayer`,
            `arn:aws:lambda:${stack.region}:753240598075:layer:LambdaAdapterLayerX86:24`,
          ),
        );
        <%_ } _%>
        return {
          handler,
          <%_ if (backend.type === 'fastapi') { _%>
          integration: new LambdaIntegration(handler.currentVersion, {
            responseTransferMode: ResponseTransferMode.STREAM,
          }),
          <%_ } else if (backend.type === 'trpc') { _%>
          integration: new LambdaIntegration(handler, {
            responseTransferMode: ResponseTransferMode.STREAM,
          }),
          <%_ } else { _%>
          integration: new LambdaIntegration(handler),
          <%_ } _%>
        };
        <%_ } _%>
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: <%= apiNameClassName %>Props<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: '<%= apiNameClassName %>',
      defaultMethodOptions: {
        <%_ if (auth === 'IAM') { _%>
        authorizationType: AuthorizationType.IAM,
        <%_ } else if (auth === 'Cognito') { _%>
        authorizationType: AuthorizationType.COGNITO,
        authorizer: new CognitoUserPoolsAuthorizer(scope, '<%= apiNameClassName %>Authorizer', {
          cognitoUserPools: [props.identity.userPool],
        }),
        <%_ } else if (auth === 'None') { _%>
        authorizationType: AuthorizationType.NONE,
        <%_ } _%>
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      deployOptions: {
        tracingEnabled: true,
      },
      policy: new PolicyDocument({
        statements: [
          <%_ if (auth === 'IAM') { _%>
          // Open up OPTIONS to allow browsers to make unauthenticated preflight requests
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
          <%_ } else { _%>
          // Allow all callers to invoke the API in the resource policy<% if (auth === 'Cognito') { %>, since auth is handled by Cognito<% } %>
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          <%_ } _%>
        ],
      }),
      <%_ if (backend.type === 'trpc') { _%>
      operations: routerToOperations(appRouter),
      <%_ } else { _%>
      operations: OPERATION_DETAILS,
      <%_ } _%>
      ...props,
    });
  }

  /**
   * Restricts CORS to the website CloudFront distribution domains
   *
   * Configures the CloudFront distribution domains as the only permitted CORS origins
   * (other than local host) in the AWS Lambda integrations
   * 
   * Note that this restriction is not applied to preflight OPTIONS
   *
   * @param websites - The CloudFront distribution to grant CORS from
   */
  public restrictCorsTo(
    ...websites: { cloudFrontDistribution: Distribution }[]
  ) {
    const allowedOrigins = websites
      .map(
        ({ cloudFrontDistribution }) =>
          `https://${cloudFrontDistribution.distributionDomainName}`,
      )
      .join(',');

    // Set ALLOWED_ORIGINS environment variable for all Lambda integrations
    Object.values(this.integrations).forEach((integration) => {
      if ('handler' in integration && integration.handler instanceof Function) {
        integration.handler.addEnvironment('ALLOWED_ORIGINS', allowedOrigins);
      }
    });
  }
  <%_ if (auth === 'IAM') { _%>

  /**
   * Grants IAM permissions to invoke any method on this API.
   *
   * @param grantee - The IAM principal to grant permissions to
   */
  public grantInvokeAccess(grantee: IGrantable) {
    // Here we grant grantee permission to call the api.
    // Machine to machine fine-grained access can be defined here using more specific principals (eg roles or
    // users) and resources (eg which api paths may be invoked by which principal) if required.
    this.api.addToResourcePolicy(
      new PolicyStatement({
        effect: Effect.ALLOW,
        principals: [grantee.grantPrincipal],
        actions: ['execute-api:Invoke'],
        resources: ['execute-api:/*'],
      }),
    );

    Grant.addToPrincipal({
      grantee,
      actions: ['execute-api:Invoke'],
      resourceArns: [this.api.arnForExecuteApi('*', '/*', '*')],
    });
  }
  <%_ } _%>
}
