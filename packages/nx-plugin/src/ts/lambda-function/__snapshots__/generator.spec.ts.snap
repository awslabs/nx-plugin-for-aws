// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`ts-lambda-function generator > should create CDK construct > cdk-construct.ts 1`] = `
"import { Construct } from 'constructs';
import * as url from 'url';
import { Code, Function, Runtime, Tracing } from 'aws-cdk-lib/aws-lambda';
import { Duration } from 'aws-cdk-lib';

export class TestProjectTestFunction extends Function {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      timeout: Duration.seconds(30),
      runtime: Runtime.NODEJS_LATEST,
      handler: 'index.handler',
      code: Code.fromAsset(
        url.fileURLToPath(
          new URL(
            '../../../../../../dist/packages/test-project/bundle-test-function',
            import.meta.url,
          ),
        ),
      ),
      tracing: Tracing.ACTIVE,
      environment: {
        AWS_CONNECTION_REUSE_ENABLED: '1',
      },
    });
  }
}
"
`;

exports[`ts-lambda-function generator > should create lambda function file with Any event source > lambda-handler-any.ts 1`] = `
"import middy from '@middy/core';
import { Tracer } from '@aws-lambda-powertools/tracer';
import { captureLambdaHandler } from '@aws-lambda-powertools/tracer/middleware';
import { injectLambdaContext } from '@aws-lambda-powertools/logger/middleware';
import { Logger } from '@aws-lambda-powertools/logger';
import { Metrics, MetricUnit } from '@aws-lambda-powertools/metrics';
import { logMetrics } from '@aws-lambda-powertools/metrics/middleware';

process.env.POWERTOOLS_METRICS_NAMESPACE = 'TestFunction';
process.env.POWERTOOLS_SERVICE_NAME = 'TestFunction';

const tracer = new Tracer();
const logger = new Logger();
const metrics = new Metrics();

export const handler = middy()
  .use(captureLambdaHandler(tracer))
  .use(injectLambdaContext(logger))
  .use(logMetrics(metrics))
  .handler(async (event: any) => {
    logger.info('Received event', event);

    metrics.addMetric('InvocationCount', MetricUnit.Count, 1);

    try {
      // TODO: Implement
      metrics.addMetric('SuccessCount', MetricUnit.Count, 1);
      // TODO: Implement success response if required
    } catch (e) {
      logger.error('Error processing event', e as Error);
      metrics.addMetric('ErrorCount', MetricUnit.Count, 1);
      // TODO: Implement error response if required
    }
  });
"
`;

exports[`ts-lambda-function generator > should create lambda function file with EventBridge schema > lambda-handler-eventbridge.ts 1`] = `
"import { parser } from '@aws-lambda-powertools/parser/middleware';
import { EventBridgeSchema } from '@aws-lambda-powertools/parser/schemas';
import middy from '@middy/core';
import { Tracer } from '@aws-lambda-powertools/tracer';
import { captureLambdaHandler } from '@aws-lambda-powertools/tracer/middleware';
import { injectLambdaContext } from '@aws-lambda-powertools/logger/middleware';
import { Logger } from '@aws-lambda-powertools/logger';
import { Metrics, MetricUnit } from '@aws-lambda-powertools/metrics';
import { logMetrics } from '@aws-lambda-powertools/metrics/middleware';

process.env.POWERTOOLS_METRICS_NAMESPACE = 'TestFunction';
process.env.POWERTOOLS_SERVICE_NAME = 'TestFunction';

const tracer = new Tracer();
const logger = new Logger();
const metrics = new Metrics();

export const handler = middy()
  .use(captureLambdaHandler(tracer))
  .use(injectLambdaContext(logger))
  .use(logMetrics(metrics))
  .use(parser({ schema: EventBridgeSchema }))
  .handler(async (event) => {
    logger.info('Received event', event);

    metrics.addMetric('InvocationCount', MetricUnit.Count, 1);

    try {
      // TODO: Implement
      metrics.addMetric('SuccessCount', MetricUnit.Count, 1);
      // TODO: Implement success response if required
    } catch (e) {
      logger.error('Error processing event', e as Error);
      metrics.addMetric('ErrorCount', MetricUnit.Count, 1);
      // TODO: Implement error response if required
    }
  });
"
`;

exports[`ts-lambda-function generator > should create lambda function file with SQS schema > lambda-handler-sqs.ts 1`] = `
"import { parser } from '@aws-lambda-powertools/parser/middleware';
import { SqsSchema } from '@aws-lambda-powertools/parser/schemas';
import middy from '@middy/core';
import { Tracer } from '@aws-lambda-powertools/tracer';
import { captureLambdaHandler } from '@aws-lambda-powertools/tracer/middleware';
import { injectLambdaContext } from '@aws-lambda-powertools/logger/middleware';
import { Logger } from '@aws-lambda-powertools/logger';
import { Metrics, MetricUnit } from '@aws-lambda-powertools/metrics';
import { logMetrics } from '@aws-lambda-powertools/metrics/middleware';

process.env.POWERTOOLS_METRICS_NAMESPACE = 'TestFunction';
process.env.POWERTOOLS_SERVICE_NAME = 'TestFunction';

const tracer = new Tracer();
const logger = new Logger();
const metrics = new Metrics();

export const handler = middy()
  .use(captureLambdaHandler(tracer))
  .use(injectLambdaContext(logger))
  .use(logMetrics(metrics))
  .use(parser({ schema: SqsSchema }))
  .handler(async (event) => {
    logger.info('Received event', event);

    metrics.addMetric('InvocationCount', MetricUnit.Count, 1);

    try {
      // TODO: Implement
      metrics.addMetric('SuccessCount', MetricUnit.Count, 1);
      // TODO: Implement success response if required
    } catch (e) {
      logger.error('Error processing event', e as Error);
      metrics.addMetric('ErrorCount', MetricUnit.Count, 1);
      // TODO: Implement error response if required
    }
  });
"
`;
