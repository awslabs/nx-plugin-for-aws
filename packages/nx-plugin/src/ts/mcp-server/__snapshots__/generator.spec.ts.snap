// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`ts#mcp-server generator > should match snapshot for BedrockAgentCoreRuntime generated constructs files > agent-core-runtime.ts 1`] = `
"import {
  Role,
  ServicePrincipal,
  PolicyStatement,
  Effect,
  PolicyDocument,
} from 'aws-cdk-lib/aws-iam';
import {
  AwsCustomResource,
  AwsCustomResourcePolicy,
  PhysicalResourceId,
  PhysicalResourceIdReference,
} from 'aws-cdk-lib/custom-resources';
import { Construct } from 'constructs';
import type { AuthorizerConfiguration } from '@aws-sdk/client-bedrock-agentcore-control';
import { Stack } from 'aws-cdk-lib';

/**
 * Options for the AgentCoreRuntime construct
 */
export interface AgentCoreRuntimeProps {
  runtimeName: string;
  description?: string;
  containerUri: string;
  serverProtocol: 'MCP' | 'HTTP';
  environment?: Record<string, string>;
  authorizerConfiguration?: AuthorizerConfiguration;
}

/**
 * A construct for creating a Bedrock AgentCore Runtime
 */
export class AgentCoreRuntime extends Construct {
  public readonly role: Role;
  public readonly arn: string;

  constructor(scope: Construct, id: string, props: AgentCoreRuntimeProps) {
    super(scope, id);

    const region = Stack.of(this).region;
    const accountId = Stack.of(this).account;

    this.role = new Role(this, 'AgentCoreRole', {
      assumedBy: new ServicePrincipal('bedrock-agentcore.amazonaws.com'),
      inlinePolicies: {
        AgentCorePolicy: new PolicyDocument({
          statements: [
            new PolicyStatement({
              sid: 'ECRImageAccess',
              effect: Effect.ALLOW,
              actions: ['ecr:BatchGetImage', 'ecr:GetDownloadUrlForLayer'],
              resources: [\`arn:aws:ecr:\${region}:\${accountId}:repository/*\`],
            }),
            new PolicyStatement({
              effect: Effect.ALLOW,
              actions: ['logs:DescribeLogStreams', 'logs:CreateLogGroup'],
              resources: [
                \`arn:aws:logs:\${region}:\${accountId}:log-group:/aws/bedrock-agentcore/runtimes/*\`,
              ],
            }),
            new PolicyStatement({
              effect: Effect.ALLOW,
              actions: ['logs:DescribeLogGroups'],
              resources: [\`arn:aws:logs:\${region}:\${accountId}:log-group:*\`],
            }),
            new PolicyStatement({
              effect: Effect.ALLOW,
              actions: ['logs:CreateLogStream', 'logs:PutLogEvents'],
              resources: [
                \`arn:aws:logs:\${region}:\${accountId}:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*\`,
              ],
            }),
            new PolicyStatement({
              sid: 'ECRTokenAccess',
              effect: Effect.ALLOW,
              actions: ['ecr:GetAuthorizationToken'],
              resources: ['*'],
            }),
            new PolicyStatement({
              effect: Effect.ALLOW,
              actions: [
                'xray:PutTraceSegments',
                'xray:PutTelemetryRecords',
                'xray:GetSamplingRules',
                'xray:GetSamplingTargets',
              ],
              resources: ['*'],
            }),
            new PolicyStatement({
              effect: Effect.ALLOW,
              actions: ['cloudwatch:PutMetricData'],
              resources: ['*'],
              conditions: {
                StringEquals: {
                  'cloudwatch:namespace': 'bedrock-agentcore',
                },
              },
            }),
            new PolicyStatement({
              sid: 'GetAgentAccessToken',
              effect: Effect.ALLOW,
              actions: [
                'bedrock-agentcore:GetWorkloadAccessToken',
                'bedrock-agentcore:GetWorkloadAccessTokenForJWT',
                'bedrock-agentcore:GetWorkloadAccessTokenForUserId',
              ],
              resources: [
                \`arn:aws:bedrock-agentcore:\${region}:\${accountId}:workload-identity-directory/default\`,
                \`arn:aws:bedrock-agentcore:\${region}:\${accountId}:workload-identity-directory/default/workload-identity/*\`,
              ],
            }),
            new PolicyStatement({
              sid: 'BedrockModelInvocation',
              effect: Effect.ALLOW,
              actions: [
                'bedrock:InvokeModel',
                'bedrock:InvokeModelWithResponseStream',
              ],
              resources: [
                'arn:aws:bedrock:*::foundation-model/*',
                \`arn:aws:bedrock:\${region}:\${accountId}:*\`,
              ],
            }),
          ],
        }),
      },
    });

    const agentRuntime = new AwsCustomResource(this, 'MCPSeverRuntime', {
      onCreate: {
        service: 'bedrock-agentcore-control',
        action: 'CreateAgentRuntime',
        parameters: {
          agentRuntimeName: props.runtimeName,
          agentRuntimeArtifact: {
            containerConfiguration: {
              containerUri: props.containerUri,
            },
          },
          networkConfiguration: {
            networkMode: 'PUBLIC',
          },
          protocolConfiguration: {
            serverProtocol: props.serverProtocol,
          },
          roleArn: this.role.roleArn,
          authorizerConfiguration: props.authorizerConfiguration,
        },
        physicalResourceId: PhysicalResourceId.fromResponse('agentRuntimeId'),
      },
      onUpdate: {
        service: 'bedrock-agentcore-control',
        action: 'UpdateAgentRuntime',
        parameters: {
          agentRuntimeId: new PhysicalResourceIdReference(),
          agentRuntimeName: props.runtimeName,
          agentRuntimeArtifact: {
            containerConfiguration: {
              containerUri: props.containerUri,
            },
          },
          networkConfiguration: {
            networkMode: 'PUBLIC',
          },
          protocolConfiguration: {
            serverProtocol: props.serverProtocol,
          },
          roleArn: this.role.roleArn,
          authorizerConfiguration: props.authorizerConfiguration,
        },
        physicalResourceId: PhysicalResourceId.fromResponse('agentRuntimeId'),
      },
      onDelete: {
        service: 'bedrock-agentcore-control',
        action: 'DeleteAgentRuntime',
        parameters: {
          agentRuntimeId: new PhysicalResourceIdReference(),
        },
      },
      policy: AwsCustomResourcePolicy.fromStatements([
        new PolicyStatement({
          actions: ['bedrock-agentcore:*'],
          resources: ['*'],
        }),
        new PolicyStatement({
          actions: ['iam:PassRole'],
          resources: [this.role.roleArn],
        }),
      ]),
      installLatestAwsSdk: true,
    });

    this.arn = agentRuntime.getResponseField('agentRuntimeArn');
  }
}
"
`;

exports[`ts#mcp-server generator > should match snapshot for BedrockAgentCoreRuntime generated constructs files > app-index.ts 1`] = `
"export * from './mcp-servers/index.js';
"
`;

exports[`ts#mcp-server generator > should match snapshot for BedrockAgentCoreRuntime generated constructs files > core-index.ts 1`] = `
"export * from './app.js';
export * from './runtime-config.js';
"
`;

exports[`ts#mcp-server generator > should match snapshot for BedrockAgentCoreRuntime generated constructs files > mcp-server-construct.ts 1`] = `
"import { DockerImageAsset } from 'aws-cdk-lib/aws-ecr-assets';
import { Construct } from 'constructs';
import { execSync } from 'child_process';
import * as path from 'path';
import * as url from 'url';
import {
  AgentCoreRuntime,
  AgentCoreRuntimeProps,
} from '../../../core/agent-core/runtime.js';

export type SnapshotBedrockServerProps = Omit<
  AgentCoreRuntimeProps,
  'runtimeName' | 'serverProtocol' | 'containerUri'
>;

export class SnapshotBedrockServer extends Construct {
  public readonly dockerImage: DockerImageAsset;
  public readonly agentCoreRuntime: AgentCoreRuntime;

  constructor(
    scope: Construct,
    id: string,
    props?: SnapshotBedrockServerProps,
  ) {
    super(scope, id);

    this.dockerImage = new DockerImageAsset(this, 'DockerImage', {
      directory: path.dirname(url.fileURLToPath(new URL(import.meta.url))),
      extraHash: execSync(
        \`docker inspect proj-snapshot-bedrock-server:latest --format '{{.Descriptor.digest}}'\`,
        { encoding: 'utf-8' },
      ).trim(),
    });

    this.agentCoreRuntime = new AgentCoreRuntime(this, 'AgentCore', {
      runtimeName: 'SnapshotBedrockServer',
      serverProtocol: 'MCP',
      containerUri: this.dockerImage.imageUri,
      ...props,
    });
  }
}
"
`;

exports[`ts#mcp-server generator > should match snapshot for BedrockAgentCoreRuntime generated constructs files > mcp-servers-index.ts 1`] = `
"export * from './snapshot-bedrock-server/snapshot-bedrock-server.js';
"
`;

exports[`ts#mcp-server generator > should match snapshot for generated files > mcp-server-http.ts 1`] = `
"#!/usr/bin/env node
import { createServer } from './server';
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
import express, { Request, Response } from 'express';

const PORT = 8000;

const app = express();
app.use(express.json());

app.post('/mcp', async (req: Request, res: Response) => {
  try {
    const server = createServer();
    const transport: StreamableHTTPServerTransport =
      new StreamableHTTPServerTransport({
        sessionIdGenerator: undefined,
      });
    res.on('close', () => {
      console.log('Request closed');
      transport.close();
      server.close();
    });
    await server.connect(transport);
    await transport.handleRequest(req, res, {
      ...req.body,
      // AgentCore pings with null parameters where the MCP SDK expects an empty object
      params: req.body.method === 'ping' ? {} : req.body.params,
    });
  } catch (error) {
    console.error('Error handling MCP request:', error);
    if (!res.headersSent) {
      res.status(500).json({
        jsonrpc: '2.0',
        error: {
          code: -32603,
          message: 'Internal server error',
        },
        id: null,
      });
    }
  }
});

// SSE notifications not supported in stateless mode
app.get('/mcp', async (req: Request, res: Response) => {
  console.log('Received GET MCP request');
  res.writeHead(405).end(
    JSON.stringify({
      jsonrpc: '2.0',
      error: {
        code: -32000,
        message: 'Method not allowed.',
      },
      id: null,
    }),
  );
});

// Session termination not needed in stateless mode
app.delete('/mcp', async (req: Request, res: Response) => {
  console.log('Received DELETE MCP request');
  res.writeHead(405).end(
    JSON.stringify({
      jsonrpc: '2.0',
      error: {
        code: -32000,
        message: 'Method not allowed.',
      },
      id: null,
    }),
  );
});

// Start the server
void (async () => {
  app.listen(PORT, (error) => {
    if (error) {
      console.error('Failed to start server:', error);
      process.exit(1);
    }
    console.log(
      \`MCP Stateless Streamable HTTP Server listening on port \${PORT}\`,
    );
  });
})();
"
`;

exports[`ts#mcp-server generator > should match snapshot for generated files > mcp-server-index.ts 1`] = `
"export * from './server';
"
`;

exports[`ts#mcp-server generator > should match snapshot for generated files > mcp-server-server.ts 1`] = `
"import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { registerAddTool } from './tools/add';
import { registerSampleGuidanceResource } from './resources/sample-guidance';

/**
 * Create the MCP Server
 */
export const createServer = () => {
  const server = new McpServer({
    name: 'snapshot-server',
    version: '1.0.0',
  });

  registerAddTool(server);
  registerSampleGuidanceResource(server);

  return server;
};
"
`;

exports[`ts#mcp-server generator > should match snapshot for generated files > mcp-server-stdio.ts 1`] = `
"#!/usr/bin/env node
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { createServer } from './server';

export const startMcpServer = async () => {
  const transport = new StdioServerTransport();
  await createServer().connect(transport);
  console.error('MCP Server listening on STDIO');
};

void (async () => {
  try {
    await startMcpServer();
  } catch (e) {
    console.error(e);
  }
})();
"
`;

exports[`ts#mcp-server generator > should match snapshot for generated files > updated-package.json 1`] = `
"{
  "name": "test-project",
  "version": "1.0.0",
  "bin": {
    "snapshot-server": "./src/snapshot-server/stdio.js"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.11.3",
    "express": "^5.1.0",
    "zod-v3": "npm:zod@^3"
  },
  "devDependencies": {
    "@types/express": "^5.0.3",
    "tsx": "4.20.1"
  }
}
"
`;
