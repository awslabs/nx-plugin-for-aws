// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`py#strands-agent generator > should match snapshot for BedrockAgentCoreRuntime generated constructs files > agent-Dockerfile 1`] = `
"FROM public.ecr.aws/docker/library/python:3.12-slim

WORKDIR /app

# Copy bundled package
COPY --from=workspace dist/apps/test-project/bundle-arm /app

EXPOSE 8080

ENV PYTHONPATH=/app

# Auto-instrument with AWS Distro for OpenTelemetry
# https://aws-otel.github.io/docs/getting-started/python-sdk/auto-instr
CMD ["python", "bin/opentelemetry-instrument", "python", "-m", "proj_test_project.snapshot_bedrock_agent.main"]
"
`;

exports[`py#strands-agent generator > should match snapshot for BedrockAgentCoreRuntime generated constructs files > agent-construct.ts 1`] = `
"import { Lazy, Names } from 'aws-cdk-lib';
import { Platform } from 'aws-cdk-lib/aws-ecr-assets';
import { Construct } from 'constructs';
import { execSync } from 'child_process';
import * as path from 'path';
import * as url from 'url';
import {
  AgentRuntimeArtifact,
  ProtocolType,
  Runtime,
  RuntimeProps,
} from '@aws-cdk/aws-bedrock-agentcore-alpha';

export type SnapshotBedrockAgentProps = Omit<
  RuntimeProps,
  'runtimeName' | 'protocolConfiguration' | 'agentRuntimeArtifact'
>;

export class SnapshotBedrockAgent extends Construct {
  public readonly dockerImage: AgentRuntimeArtifact;
  public readonly agentCoreRuntime: Runtime;

  constructor(scope: Construct, id: string, props?: SnapshotBedrockAgentProps) {
    super(scope, id);

    this.dockerImage = AgentRuntimeArtifact.fromAsset(
      path.dirname(url.fileURLToPath(new URL(import.meta.url))),
      {
        platform: Platform.LINUX_ARM64,
        extraHash: execSync(
          \`docker inspect proj-snapshot-bedrock-agent:latest --format '{{.Id}}'\`,
          { encoding: 'utf-8' },
        ).trim(),
      },
    );

    this.agentCoreRuntime = new Runtime(this, 'SnapshotBedrockAgent', {
      runtimeName: Lazy.string({
        produce: () =>
          Names.uniqueResourceName(this.agentCoreRuntime, { maxLength: 40 }),
      }),
      protocolConfiguration: ProtocolType.HTTP,
      agentRuntimeArtifact: this.dockerImage,
      ...props,
    });
  }
}
"
`;

exports[`py#strands-agent generator > should match snapshot for BedrockAgentCoreRuntime generated constructs files > agents-index.ts 1`] = `
"export * from './snapshot-bedrock-agent/snapshot-bedrock-agent.js';
"
`;

exports[`py#strands-agent generator > should match snapshot for BedrockAgentCoreRuntime generated constructs files > app-index.ts 1`] = `
"export * from './agents/index.js';
"
`;

exports[`py#strands-agent generator > should match snapshot for BedrockAgentCoreRuntime generated constructs files > core-index.ts 1`] = `
"export * from './app.js';
export * from './checkov.js';
export * from './runtime-config.js';
"
`;

exports[`py#strands-agent generator > should match snapshot for Terraform generated files > terraform-agent.tf 1`] = `
"variable "env" {
  description = "Environment variables to pass to the agent core runtime"
  type        = map(string)
  default     = {}
}

variable "additional_iam_policy_statements" {
  description = "Additional IAM policy statements to attach to the agent core runtime role"
  type = list(object({
    Effect   = string
    Action   = list(string)
    Resource = list(string)
  }))
  default = []
}

variable "tags" {
  description = "Tags to apply to resources"
  type        = map(string)
  default     = {}
}

module "agent_core_runtime" {
  source = "../../../core/agent-core"
  agent_runtime_name = "TerraformSnapshotAgent"
  docker_image_tag = "proj-terraform-snapshot-agent:latest"
  server_protocol = "HTTP"
#  authorizer_configuration = {
#    custom_jwt_authorizer = {
#      discovery_url = "https://xxx/.well-known/openid-configuration"
#      allowed_clients = [ "xxx" ]
#    }
#  }

  env = var.env
  additional_iam_policy_statements = var.additional_iam_policy_statements
  tags = var.tags
}

output "agent_core_runtime_role_arn" {
  description = "ARN of the agent core runtime role"
  value       = module.agent_core_runtime.agent_core_runtime_role_arn
}

output "agent_core_runtime_arn" {
  description = "ARN of the Bedrock Agent Core runtime"
  value       = module.agent_core_runtime.agent_core_runtime_arn
}
"
`;

exports[`py#strands-agent generator > should match snapshot for Terraform generated files > terraform-agent-core-runtime.tf 1`] = `
"terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 6.23"
    }
    null = {
      source  = "hashicorp/null"
      version = ">= 3.0"
    }
    random = {
      source  = "hashicorp/random"
      version = ">= 3.0"
    }
  }
}

# Variables
variable "agent_runtime_name" {
  description = "Name of the agent runtime"
  type        = string
  validation {
    condition     = can(regex("^[a-zA-Z][a-zA-Z0-9_]{0,42}$", var.agent_runtime_name))
    error_message = "Value must start with a letter and contain only letters, numbers, and underscores (1-43 characters)."
  }
}

variable "server_protocol" {
  description = "Server protocol for the agent runtime (HTTP, MCP, or A2A)"
  type        = string
  default     = "HTTP"
  validation {
    condition     = contains(["MCP", "HTTP", "A2A"], var.server_protocol)
    error_message = "Protocol type must be either 'MCP', 'HTTP', or 'A2A'."
  }
}

variable "authorizer_configuration" {
  description = "Authorization configuration for authenticating incoming requests"
  type = object({
    custom_jwt_authorizer = optional(object({
      discovery_url    = string
      allowed_audience = optional(list(string))
      allowed_clients  = optional(list(string))
    }))
  })
  default = null
}

variable "docker_image_tag" {
  description = "Name of the docker image tag to use as the agent core runtime"
  type        = string
}

variable "env" {
  description = "Environment variables to pass to the agent core runtime"
  type        = map(string)
  default     = {}
}

variable "additional_iam_policy_statements" {
  description = "Additional IAM policy statements to attach to the agent core runtime role"
  type = list(object({
    Effect   = string
    Action   = list(string)
    Resource = list(string)
  }))
  default = []
}

variable "tags" {
  description = "Tags to apply to resources"
  type        = map(string)
  default     = {}
}

# Data sources
data "aws_caller_identity" "current" {}
data "aws_region" "current" {}

locals {
  aws_account_id = data.aws_caller_identity.current.account_id
  aws_region     = data.aws_region.current.id
}

# Random ID for bucket suffix to ensure uniqueness
resource "random_id" "unique_suffix" {
  byte_length = 4
}

# ECR Repository
resource "aws_ecr_repository" "agent_core_repository" {
  #checkov:skip=CKV_AWS_136:AES256 encryption is sufficient for ECR repositories
  name = "\${lower(var.agent_runtime_name)}_repository_\${random_id.unique_suffix.hex}"

  #checkov:skip=CKV_AWS_51:Image tag is reused for latest deployments
  image_tag_mutability = "MUTABLE"
  force_delete         = true

  image_scanning_configuration {
    scan_on_push = true
  }

  tags = var.tags
}

# ECR Repository Policy
resource "aws_ecr_repository_policy" "agent_core_ecr_policy" {
  repository = aws_ecr_repository.agent_core_repository.name

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "AllowPushPull"
        Effect = "Allow"
        Principal = {
          AWS = "arn:aws:iam::\${local.aws_account_id}:root"
        }
        Action = [
          "ecr:GetDownloadUrlForLayer",
          "ecr:BatchGetImage",
          "ecr:BatchCheckLayerAvailability",
          "ecr:PutImage",
          "ecr:InitiateLayerUpload",
          "ecr:UploadLayerPart",
          "ecr:CompleteLayerUpload"
        ]
      }
    ]
  })
}

# IAM Role for Agent Core Runtime
resource "aws_iam_role" "agent_core_runtime_role" {
  name = "\${var.agent_runtime_name}-AgentCoreRuntimeRole-\${random_id.unique_suffix.hex}"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "AgentCoreAssumeRolePolicy"
        Effect = "Allow"
        Principal = {
          Service = "bedrock-agentcore.amazonaws.com"
        }
        Action = "sts:AssumeRole"
        Condition = {
          StringEquals = {
            "aws:SourceAccount" = local.aws_account_id
          }
          ArnLike = {
            "aws:SourceArn" = "arn:aws:bedrock-agentcore:\${local.aws_region}:\${local.aws_account_id}:*"
          }
        }
      }
    ]
  })

  tags = var.tags
}

# IAM Policy for Agent Core Runtime
resource "aws_iam_policy" "agent_core_runtime_policy" {
  name        = "\${var.agent_runtime_name}-QueryAgentPolicy-\${random_id.unique_suffix.hex}"
  description = "Restricted policy for Agent"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = concat([
      {
        Sid    = "ECRImageAccess"
        Effect = "Allow"
        Action = [
          "ecr:BatchGetImage",
          "ecr:GetDownloadUrlForLayer"
        ]
        Resource = [
          aws_ecr_repository.agent_core_repository.arn
        ]
      },
      {
        Sid    = "ECRTokenAccess"
        Effect = "Allow"
        Action = [
          "ecr:GetAuthorizationToken"
        ]
        Resource = [
          "*"
        ]
      },
      {
        "Effect" : "Allow",
        "Action" : [
          "logs:DescribeLogStreams",
          "logs:CreateLogGroup"
        ],
        "Resource" : [
          "arn:aws:logs:\${local.aws_region}:\${local.aws_account_id}:log-group:/aws/bedrock-agentcore/runtimes/*"
        ]
      },
      {
        "Effect" : "Allow",
        "Action" : [
          "logs:DescribeLogGroups"
        ],
        "Resource" : [
          "arn:aws:logs:\${local.aws_region}:\${local.aws_account_id}:log-group:*"
        ]
      },
      {
        "Effect" : "Allow",
        "Action" : [
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ],
        "Resource" : [
          "arn:aws:logs:\${local.aws_region}:\${local.aws_account_id}:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*"
        ]
      },
      {
        "Effect" : "Allow",
        "Action" : [
          "xray:PutTraceSegments",
          "xray:PutTelemetryRecords",
          "xray:GetSamplingRules",
          "xray:GetSamplingTargets"
        ],
        "Resource" : ["*"]
      },
      {
        "Effect" : "Allow",
        "Resource" : "*",
        "Action" : "cloudwatch:PutMetricData",
        "Condition" : {
          "StringEquals" : {
            "cloudwatch:namespace" : "bedrock-agentcore"
          }
        }
      },
      {
        "Sid" : "GetAgentAccessToken",
        "Effect" : "Allow",
        "Action" : [
          "bedrock-agentcore:GetWorkloadAccessToken",
          "bedrock-agentcore:GetWorkloadAccessTokenForJWT",
          "bedrock-agentcore:GetWorkloadAccessTokenForUserId"
        ],
        "Resource" : [
          "arn:aws:bedrock-agentcore:\${local.aws_region}:\${local.aws_account_id}:workload-identity-directory/default",
          "arn:aws:bedrock-agentcore:\${local.aws_region}:\${local.aws_account_id}:workload-identity-directory/default/workload-identity/*"
        ]
      }
    ], var.additional_iam_policy_statements)
  })

  tags = var.tags
}

# Attach the restricted policy to the role
resource "aws_iam_role_policy_attachment" "agent_core_policy" {
  role       = aws_iam_role.agent_core_runtime_role.name
  policy_arn = aws_iam_policy.agent_core_runtime_policy.arn
}

# Data source to get Docker image digest
data "external" "docker_digest" {
  program = ["sh", "-c", "echo '{\\"digest\\":\\"'$(docker inspect \${var.docker_image_tag} --format '{{.Id}}')'\\"}' "]
}

# Null resource for Docker publish
resource "null_resource" "docker_publish" {
  triggers = {
    docker_digest    = data.external.docker_digest.result.digest
    repository_url   = aws_ecr_repository.agent_core_repository.repository_url
    docker_image_tag = var.docker_image_tag
  }

  provisioner "local-exec" {
    command = <<-EOT
      # Get ECR login token
      aws ecr get-login-password --region \${local.aws_region} | docker login --username AWS --password-stdin \${self.triggers.repository_url}

      # Tag the image
      docker tag \${self.triggers.docker_image_tag} \${self.triggers.repository_url}:latest

      # Push the image
      docker push \${self.triggers.repository_url}:latest
    EOT
  }

  depends_on = [aws_ecr_repository_policy.agent_core_ecr_policy]
}

# Bedrock AgentCore Agent Runtime
resource "aws_bedrockagentcore_agent_runtime" "agent_runtime" {
  agent_runtime_name = "\${var.agent_runtime_name}_\${random_id.unique_suffix.hex}"
  description        = "Agent Runtime for \${var.agent_runtime_name}"
  role_arn           = aws_iam_role.agent_core_runtime_role.arn

  agent_runtime_artifact {
    container_configuration {
      container_uri = "\${aws_ecr_repository.agent_core_repository.repository_url}:latest"
    }
  }

  environment_variables = length(var.env) > 0 ? var.env : null

  dynamic "authorizer_configuration" {
    for_each = var.authorizer_configuration != null && var.authorizer_configuration.custom_jwt_authorizer != null ? [var.authorizer_configuration.custom_jwt_authorizer] : []
    content {
      custom_jwt_authorizer {
        discovery_url    = authorizer_configuration.value.discovery_url
        allowed_audience = authorizer_configuration.value.allowed_audience
        allowed_clients  = authorizer_configuration.value.allowed_clients
      }
    }
  }

  network_configuration {
    network_mode = "PUBLIC"
  }

  protocol_configuration {
    server_protocol = var.server_protocol
  }

  tags = var.tags

  depends_on = [
    null_resource.docker_publish,
    aws_iam_role_policy.agent_core_runtime_policy
  ]
}

# Outputs
output "agent_core_runtime_role_arn" {
  description = "ARN of the Agent Core Runtime IAM role"
  value       = aws_iam_role.agent_core_runtime_role.arn
}

output "agent_core_runtime_role_name" {
  description = "Name of the Agent Core Runtime IAM role"
  value       = aws_iam_role.agent_core_runtime_role.name
}

output "agent_runtime_name" {
  description = "Name of the deployed agent runtime"
  value       = aws_bedrockagentcore_agent_runtime.agent_runtime.agent_runtime_name
}

output "agent_core_runtime_arn" {
  description = "ARN of the Bedrock Agent Core runtime"
  value       = aws_bedrockagentcore_agent_runtime.agent_runtime.agent_runtime_arn
}

output "agent_runtime_id" {
  description = "ID of the Bedrock Agent Core runtime"
  value       = aws_bedrockagentcore_agent_runtime.agent_runtime.agent_runtime_id
}

output "agent_runtime_version" {
  description = "Version of the Bedrock Agent Core runtime"
  value       = aws_bedrockagentcore_agent_runtime.agent_runtime.agent_runtime_version
}
"
`;

exports[`py#strands-agent generator > should match snapshot for generated files > strands-agent-__init__.py 1`] = `""`;

exports[`py#strands-agent generator > should match snapshot for generated files > strands-agent-agent.py 1`] = `
"from contextlib import contextmanager

from strands import Agent, tool
from strands_tools import current_time


# Define a custom tool
@tool
def add(a: int, b: int) -> int:
    return a + b


@contextmanager
def get_agent(session_id: str):
    yield Agent(
        system_prompt="""
You are an addition wizard.
Use the 'add' tool for addition tasks.
Refer to tools as your 'spellbook'.
""",
        tools=[add, current_time],
    )
"
`;

exports[`py#strands-agent generator > should match snapshot for generated files > strands-agent-main.py 1`] = `
"import uvicorn
from bedrock_agentcore.runtime.models import PingStatus
from fastapi.responses import PlainTextResponse, StreamingResponse
from pydantic import BaseModel

from .agent import get_agent
from .init import app


class InvokeInput(BaseModel):
    prompt: str
    session_id: str


async def handle_invoke(input: InvokeInput):
    """Streaming handler for agent invocation"""
    with get_agent(session_id=input.session_id) as agent:
        stream = agent.stream_async(input.prompt)
        async for event in stream:
            print(event)
            content = event.get("event", {}).get("contentBlockDelta", {}).get("delta", {}).get("text")
            if content is not None:
                yield content
            elif event.get("event", {}).get("messageStop") is not None:
                yield "\\n"


@app.post("/invocations", openapi_extra={"x-streaming": True}, response_class=PlainTextResponse)
async def invoke(input: InvokeInput) -> str:
    """Entry point for agent invocation"""
    return StreamingResponse(handle_invoke(input), media_type="text/event-stream")


@app.get("/ping")
def ping() -> str:
    # TODO: if running an async task, return PingStatus.HEALTHY_BUSY
    return PingStatus.HEALTHY


if __name__ == "__main__":
    uvicorn.run("proj_test_project.snapshot_agent.main:app", port=8080)
"
`;

exports[`py#strands-agent generator > should match snapshot for generated files > updated-pyproject.toml 1`] = `
"[project]
name = "proj.test_project"
version = "0.1.0"
dependencies = [
  "aws-opentelemetry-distro==0.14.2",
  "bedrock-agentcore==0.1.7",
  "fastapi==0.128.0",
  "boto3==1.42.34",
  "mcp==1.26.0",
  "strands-agents==1.23.0",
  "strands-agents-tools==0.2.19",
  "uvicorn==0.40.0"
]

[dependency-groups]
dev = [ "fastapi[standard]==0.128.0" ]

[tool.uv]
dev-dependencies = [ ]
"
`;
