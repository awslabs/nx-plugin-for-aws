// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`fastapi project generator > should match snapshot > main-snapshot 1`] = `
{
  "apps/test_api/proj_test_api/__init__.py": """"Automatically generated by Nx."""
",
  "apps/test_api/proj_test_api/init.py": "import os
import uuid
from collections.abc import Callable

from aws_lambda_powertools import Logger, Metrics, Tracer
from aws_lambda_powertools.metrics import MetricUnit
from fastapi import FastAPI, Request, Response
from fastapi.middleware.cors import CORSMiddleware
from fastapi.openapi.utils import get_openapi
from fastapi.responses import JSONResponse
from fastapi.routing import APIRoute
from mangum import Mangum
from pydantic import BaseModel
from starlette.middleware.exceptions import ExceptionMiddleware

os.environ["POWERTOOLS_METRICS_NAMESPACE"] = "TestApi"
os.environ["POWERTOOLS_SERVICE_NAME"] = "TestApi"

logger: Logger = Logger()
metrics: Metrics = Metrics()
tracer: Tracer = Tracer()

class InternalServerErrorDetails(BaseModel):
    detail: str

app = FastAPI(
    title="TestApi",
    responses={
        500: {"model": InternalServerErrorDetails}
    }
)
lambda_handler = Mangum(app)

# Add tracing
lambda_handler.__name__ = "handler"  # tracer requires __name__ to be set
lambda_handler = tracer.capture_lambda_handler(lambda_handler)
# Add logging
lambda_handler = logger.inject_lambda_context(lambda_handler, clear_state=True)
# Add metrics last to properly flush metrics.
lambda_handler = metrics.log_metrics(lambda_handler, capture_cold_start_metric=True)

# Add cors middleware
app.add_middleware(CORSMiddleware,
                   allow_origins=['*'],
                   allow_methods=['*'],
                   allow_headers=['*'])

# Add exception middleware(s)
app.add_middleware(ExceptionMiddleware, handlers=app.exception_handlers)

@app.exception_handler(Exception)
async def unhandled_exception_handler(request, err):
    logger.exception("Unhandled exception")

    metrics.add_metric(name="Failure", unit=MetricUnit.Count, value=1)

    return JSONResponse(status_code=500,
                        content=InternalServerErrorDetails(
                            detail="Internal Server Error").model_dump())

@app.middleware("http")
async def metrics_handler(request: Request, call_next):
    metrics.add_dimension("route", f"{request.method} {request.url.path}")
    metrics.add_metric(name="RequestCount", unit=MetricUnit.Count, value=1)

    response = await call_next(request)

    if response.status_code == 200:
        metrics.add_metric(name="Success", unit=MetricUnit.Count, value=1)

    return response

# Add correlation id middleware
@app.middleware("http")
async def add_correlation_id(request: Request, call_next):
    # Get correlation id from X-Correlation-Id header
    corr_id = request.headers.get("x-correlation-id")
    if not corr_id and "aws.context" in request.scope:
        # If empty, use request id from aws context
        corr_id = request.scope["aws.context"].aws_request_id
    elif not corr_id:
        # If still empty, use uuid
        corr_id = uuid.uuid4().hex

    # Add correlation id to logs
    logger.set_correlation_id(corr_id)

    response = await call_next(request)

    # Return correlation header in response
    response.headers["X-Correlation-Id"] = corr_id
    return response

class LoggerRouteHandler(APIRoute):
    def get_route_handler(self) -> Callable:
        original_route_handler = super().get_route_handler()

        async def route_handler(request: Request) -> Response:
            # Add fastapi context to logs
            ctx = {
                "path": request.url.path,
                "route": self.path,
                "method": request.method,
            }
            logger.append_keys(fastapi=ctx)
            logger.info("Received request")

            return await original_route_handler(request)

        return route_handler

app.router.route_class = LoggerRouteHandler

def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    for route in app.routes:
        if isinstance(route, APIRoute):
            route.operation_id = route.name
    openapi_schema = get_openapi(
        title=app.title,
        version=app.version,
        openapi_version=app.openapi_version,
        description=app.description,
        routes=app.routes,
    )
    app.openapi_schema = openapi_schema
    return app.openapi_schema

app.openapi = custom_openapi
",
  "apps/test_api/proj_test_api/main.py": "from pydantic import BaseModel

from .init import app, lambda_handler, tracer

handler = lambda_handler

class EchoOutput(BaseModel):
    message: str

@app.get("/echo")
@tracer.capture_method
def echo(message: str) -> EchoOutput:
    return EchoOutput(message=f"{message}")
",
  "apps/test_api/scripts/generate_open_api.py": "from proj_test_api.main import app
import json, os, sys

os.makedirs(os.path.dirname(sys.argv[1]), exist_ok=True)
with open(sys.argv[1], 'w') as f:
  json.dump(app.openapi(), f)
",
  "apps/test_api/tests/__init__.py": """"unit tests."""
",
  "apps/test_api/tests/conftest.py": """"Unit tests configuration module."""
",
  "apps/test_api/tests/test_main.py": "# 
# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0
# 

def test_main():
    pass
",
}
`;

exports[`fastapi project generator > should set up shared constructs for http > http-api.ts 1`] = `
"import { Construct } from 'constructs';
import { RuntimeConfig } from '../runtime-config.js';
import { HttpApiIntegration, OperationDetails } from './utils.js';
import { CfnOutput } from 'aws-cdk-lib';
import {
  HttpApi as _HttpApi,
  HttpApiProps as _HttpApiProps,
  HttpMethod,
  HttpStage,
  LogGroupLogDestination,
} from 'aws-cdk-lib/aws-apigatewayv2';
import { LogGroup } from 'aws-cdk-lib/aws-logs';
import { suppressRules } from '../checkov.js';

/**
 * Properties for creating an HttpApi construct.
 *
 * @template TIntegrations - Record mapping operation names to their integrations
 * @template TOperation - String literal type representing operation names
 */
export interface HttpApiProps<
  TIntegrations extends Record<TOperation, HttpApiIntegration>,
  TOperation extends string,
> extends _HttpApiProps {
  /**
   * Unique name for the API, used in runtime configuration
   */
  readonly apiName: string;
  /**
   * Map of operation names to their API path and HTTP method details
   */
  readonly operations: Record<TOperation, OperationDetails>;
  /**
   * Map of operation names to their API Gateway integrations
   */
  readonly integrations: TIntegrations;
}

/**
 * A CDK construct that creates and configures an AWS API Gateway HTTP API.
 *
 * This class extends the base CDK HttpApi with additional functionality:
 * - Type-safe operation and integration management
 * - Automatic resource creation based on path patterns
 * - Integration with runtime configuration for client discovery
 *
 * @template TOperation - String literal type representing operation names
 * @template TIntegrations - Record mapping operation names to their integrations
 */
export class HttpApi<
  TOperation extends string,
  TIntegrations extends Record<TOperation, HttpApiIntegration>,
> extends Construct {
  /** The underlying CDK HttpApi instance */
  public readonly api: _HttpApi;

  /** Default auto-deployed stage */
  public readonly defaultStage: HttpStage;

  /** Map of operation names to their API Gateway integrations */
  public readonly integrations: TIntegrations;

  constructor(
    scope: Construct,
    id: string,
    {
      apiName,
      operations,
      integrations,
      ...props
    }: HttpApiProps<TIntegrations, TOperation>,
  ) {
    super(scope, id);
    this.integrations = integrations;

    // Create the API Gateway REST API
    this.api = new _HttpApi(this, 'Api', {
      createDefaultStage: false,
      ...props,
    });

    const accessLogGroup = new LogGroup(this, 'AccessLogs');
    suppressRules(
      accessLogGroup,
      ['CKV_AWS_158'],
      'Using default CloudWatch log encryption',
    );
    suppressRules(
      accessLogGroup,
      ['CKV_AWS_66', 'CKV_AWS_338'],
      'Logs are retained forever',
    );

    this.defaultStage = new HttpStage(this, 'DefaultStage', {
      httpApi: this.api,
      autoDeploy: true,
      accessLogSettings: {
        destination: new LogGroupLogDestination(accessLogGroup),
      },
    });

    // Create API resources and methods for each operation
    (Object.entries(operations) as [TOperation, OperationDetails][]).map(
      ([op, details]) => {
        this.api.addRoutes({
          path: details.path.startsWith('/')
            ? details.path
            : \`/\${details.path}\`,
          methods: [details.method as HttpMethod],
          integration: integrations[op].integration,
          ...integrations[op].options,
        });
      },
    );

    new CfnOutput(this, \`\${apiName}Url\`, {
      value: this.defaultStage.url!,
    });

    // Register the API URL in runtime configuration for client discovery
    RuntimeConfig.ensure(this).config.apis = {
      ...RuntimeConfig.ensure(this).config.apis!,
      [apiName]: this.defaultStage.url!,
    };
  }

  /**
   * Return the API url
   */
  public get url() {
    return this.defaultStage.url;
  }
}
"
`;

exports[`fastapi project generator > should set up shared constructs for http > test-api.ts 1`] = `
"import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import { Duration } from 'aws-cdk-lib';
import { CorsHttpMethod } from 'aws-cdk-lib/aws-apigatewayv2';
import { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';
import { HttpLambdaIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';
import { Grant, IGrantable } from 'aws-cdk-lib/aws-iam';
import {
  HttpApiIntegration,
  IntegrationBuilder,
} from '../../core/api/utils.js';
import { HttpApi } from '../../core/api/http-api.js';
import {
  OPERATION_DETAILS,
  Operations,
} from '../../generated/test-api/metadata.gen.js';

/**
 * Properties for creating a TestApi construct
 *
 * @template TIntegrations - Map of operation names to their integrations
 */
export interface TestApiProps<
  TIntegrations extends Record<Operations, HttpApiIntegration>,
> {
  /**
   * Map of operation names to their API Gateway integrations
   */
  integrations: TIntegrations;
}

/**
 * A CDK construct that creates and configures an AWS API Gateway HTTP API
 * specifically for TestApi.
 * @template TIntegrations - Map of operation names to their integrations
 */
export class TestApi<
  TIntegrations extends Record<Operations, HttpApiIntegration>,
> extends HttpApi<Operations, TIntegrations> {
  /**
   * Creates default integrations for all operations, which implement each operation as
   * its own individual lambda function.
   *
   * @param scope - The CDK construct scope
   * @returns An IntegrationBuilder with default lambda integrations
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.http({
      operations: OPERATION_DETAILS,
      defaultIntegrationOptions: {
        runtime: Runtime.PYTHON_3_12,
        handler: 'proj_test_api.main.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/apps/nested/path/test_api/bundle-x86',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, \`TestApi\${op}Handler\`, props);
        return {
          handler,
          integration: new HttpLambdaIntegration(
            \`TestApi\${op}Integration\`,
            handler,
          ),
        };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: TestApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'TestApi',
      corsPreflight: {
        allowOrigins: ['*'],
        allowMethods: [CorsHttpMethod.ANY],
        allowHeaders: [
          'authorization',
          'content-type',
          'x-amz-content-sha256',
          'x-amz-date',
          'x-amz-security-token',
        ],
      },
      defaultAuthorizer: new HttpIamAuthorizer(),
      operations: OPERATION_DETAILS,
      ...props,
    });
  }

  /**
   * Grants IAM permissions to invoke any method on this API.
   *
   * @param grantee - The IAM principal to grant permissions to
   */
  public grantInvokeAccess(grantee: IGrantable) {
    Grant.addToPrincipal({
      grantee,
      actions: ['execute-api:Invoke'],
      resourceArns: [this.api.arnForExecuteApi('*', '/*', '*')],
    });
  }
}
"
`;

exports[`fastapi project generator > should set up shared constructs for http > utils.ts 1`] = `
"import { Integration, MethodOptions } from 'aws-cdk-lib/aws-apigateway';
import {
  HttpRouteIntegration,
  AddRoutesOptions,
} from 'aws-cdk-lib/aws-apigatewayv2';

/**
 * Type representing applicable HTTP Methods in API Gateway
 */
export type HttpMethod =
  | 'ANY'
  | 'DELETE'
  | 'GET'
  | 'HEAD'
  | 'OPTIONS'
  | 'PATCH'
  | 'POST'
  | 'PUT';

/**
 * Defines the details of an API operation.
 */
export interface OperationDetails {
  /**
   * The URL path for the operation
   */
  path: string;

  /**
   * The HTTP method for the operation
   */
  method: HttpMethod;
}

/**
 * Represents an API Gateway REST API integration that can be attached to API methods.
 */
export interface RestApiIntegration {
  integration: Integration;
  options?: MethodOptions;
}

/**
 * Represents an API Gateway HTTP API that can be attached to API methods.
 */
export interface HttpApiIntegration {
  integration: HttpRouteIntegration;
  options?: Omit<AddRoutesOptions, 'path' | 'methods' | 'integration'>;
}

/**
 * Options for constructing an IntegrationBuilder
 */
export interface IntegrationBuilderProps<
  TOperation extends string,
  TBaseIntegration,
  TDefaultIntegrationProps extends object,
  TDefaultIntegration extends TBaseIntegration,
> {
  /** Map of operation names to their API path and HTTP method details */
  operations: Record<TOperation, OperationDetails>;

  /** Default configuration options for integrations */
  defaultIntegrationOptions: TDefaultIntegrationProps;

  /** Function to create a default integration for an operation */
  buildDefaultIntegration: (
    op: TOperation,
    props: TDefaultIntegrationProps,
  ) => TDefaultIntegration;
}

/**
 * A builder class for creating API integrations with flexible configuration options.
 *
 * This class implements the builder pattern to create a set of API integrations
 * with support for default configurations and selective overrides.
 *
 * @template TOperation - String literal type representing operation names
 * @template TBaseIntegration - Base type for all integrations
 * @template TIntegrations - Record mapping operation names to their integrations
 * @template TDefaultIntegrationProps - Type for default integration properties
 * @template TDefaultIntegration - Type for default integration implementation
 */
export class IntegrationBuilder<
  TOperation extends string,
  TBaseIntegration,
  TIntegrations extends Record<TOperation, TBaseIntegration>,
  TDefaultIntegrationProps extends object,
  TDefaultIntegration extends TBaseIntegration,
> {
  /** Options for the integration builder */
  private options: IntegrationBuilderProps<
    TOperation,
    TBaseIntegration,
    TDefaultIntegrationProps,
    TDefaultIntegration
  >;

  /** Map of operation names to their custom integrations */
  private integrations: Partial<TIntegrations> = {};

  /**
   * Create an Integration Builder for an HTTP API
   */
  public static http = <
    TOperation extends string,
    TIntegrations extends Record<TOperation, TDefaultIntegration>,
    TDefaultIntegrationProps extends object,
    TDefaultIntegration extends HttpApiIntegration,
  >(
    options: IntegrationBuilderProps<
      TOperation,
      HttpApiIntegration,
      TDefaultIntegrationProps,
      TDefaultIntegration
    >,
  ) => {
    return new IntegrationBuilder<
      TOperation,
      HttpApiIntegration,
      TIntegrations,
      TDefaultIntegrationProps,
      TDefaultIntegration
    >(options);
  };

  /**
   * Create an Integration Builder for a REST API
   */
  public static rest = <
    TOperation extends string,
    TIntegrations extends Record<TOperation, TDefaultIntegration>,
    TDefaultIntegrationProps extends object,
    TDefaultIntegration extends RestApiIntegration,
  >(
    options: IntegrationBuilderProps<
      TOperation,
      RestApiIntegration,
      TDefaultIntegrationProps,
      TDefaultIntegration
    >,
  ) => {
    return new IntegrationBuilder<
      TOperation,
      RestApiIntegration,
      TIntegrations,
      TDefaultIntegrationProps,
      TDefaultIntegration
    >(options);
  };

  private constructor(
    options: IntegrationBuilderProps<
      TOperation,
      TBaseIntegration,
      TDefaultIntegrationProps,
      TDefaultIntegration
    >,
  ) {
    this.options = options;
  }

  /**
   * Overrides default integrations with custom implementations for specific operations.
   *
   * @param overrides - Map of operation names to their custom integration implementations
   * @returns The builder instance with updated type information reflecting the overrides
   */
  public withOverrides<
    TOverrideIntegrations extends Partial<Record<TOperation, TBaseIntegration>>,
  >(overrides: TOverrideIntegrations) {
    this.integrations = { ...this.integrations, ...overrides };
    // Re-type to include the overridden integration types
    return this as unknown as IntegrationBuilder<
      TOperation,
      TBaseIntegration,
      Omit<TIntegrations, keyof TOverrideIntegrations> & TOverrideIntegrations,
      TDefaultIntegrationProps,
      TDefaultIntegration
    >;
  }

  /**
   * Updates the default integration options that will be used for operations
   * without custom overrides.
   *
   * @param options - Partial default integration options to merge with existing defaults
   * @returns The builder instance
   */
  public withDefaultOptions(options: Partial<TDefaultIntegrationProps>) {
    this.options.defaultIntegrationOptions = {
      ...this.options.defaultIntegrationOptions,
      ...options,
    };
    return this;
  }

  /**
   * Builds and returns the complete set of integrations.
   *
   * This method creates the final integration map by:
   * 1. Including all custom overrides provided via withOverrides()
   * 2. Creating default integrations for any operations without custom overrides
   *
   * @returns A complete map of operation names to their integrations
   */
  public build(): TIntegrations {
    return {
      ...this.integrations,
      ...Object.fromEntries(
        (Object.keys(this.options.operations) as TOperation[])
          .filter(
            (op) => !this.integrations[op as keyof typeof this.integrations],
          )
          .map((op) => [
            op,
            this.options.buildDefaultIntegration(
              op,
              this.options.defaultIntegrationOptions,
            ),
          ]),
      ),
    } as unknown as TIntegrations;
  }
}
"
`;

exports[`fastapi project generator > should set up shared constructs for rest > rest-api.ts 1`] = `
"import { Construct } from 'constructs';
import {
  RestApi as _RestApi,
  RestApiProps as _RestApiProps,
  IResource,
  Stage,
} from 'aws-cdk-lib/aws-apigateway';
import { RuntimeConfig } from '../runtime-config.js';
import { OperationDetails, RestApiIntegration } from './utils.js';
import { suppressRules } from '../checkov.js';

/**
 * Properties for creating a RestApi construct.
 *
 * @template TIntegrations - Record mapping operation names to their integrations
 * @template TOperation - String literal type representing operation names
 */
export interface RestApiProps<
  TIntegrations extends Record<TOperation, RestApiIntegration>,
  TOperation extends string,
> extends _RestApiProps {
  /**
   * Unique name for the API, used in runtime configuration
   */
  readonly apiName: string;
  /**
   * Map of operation names to their API path and HTTP method details
   */
  readonly operations: Record<TOperation, OperationDetails>;
  /**
   * Map of operation names to their API Gateway integrations
   */
  readonly integrations: TIntegrations;
}

/**
 * A CDK construct that creates and configures an AWS API Gateway REST API.
 *
 * This class extends the base CDK RestApi with additional functionality:
 * - Type-safe operation and integration management
 * - Automatic resource creation based on path patterns
 * - Integration with runtime configuration for client discovery
 *
 * @template TOperation - String literal type representing operation names
 * @template TIntegrations - Record mapping operation names to their integrations
 */
export class RestApi<
  TOperation extends string,
  TIntegrations extends Record<TOperation, RestApiIntegration>,
> extends Construct {
  /** The underlying CDK RestApi instance */
  public readonly api: _RestApi;

  /** Map of operation names to their API Gateway integrations */
  public readonly integrations: TIntegrations;

  constructor(
    scope: Construct,
    id: string,
    {
      apiName,
      operations,
      integrations,
      ...props
    }: RestApiProps<TIntegrations, TOperation>,
  ) {
    super(scope, id);
    this.integrations = integrations;

    // Create the API Gateway REST API
    this.api = new _RestApi(this, 'Api', props);

    suppressRules(
      this.api,
      ['CKV_AWS_120'],
      'Caching not required for this use case',
      (c) => c instanceof Stage,
    );
    suppressRules(
      this.api,
      ['CKV_AWS_76'],
      'API Gateway access logging disabled due to account-level CloudWatch Logs role ARN requirement',
      (c) => c instanceof Stage,
    );

    // Create API resources and methods for each operation
    (Object.entries(operations) as [TOperation, OperationDetails][]).map(
      ([op, details]) => {
        const resource = this.getOrCreateResource(
          this.api.root,
          (details.path.startsWith('/')
            ? details.path.slice(1)
            : details.path
          ).split('/'),
        );
        resource.addMethod(
          details.method,
          integrations[op].integration,
          integrations[op].options,
        );
      },
    );

    // Register the API URL in runtime configuration for client discovery
    RuntimeConfig.ensure(this).config.apis = {
      ...RuntimeConfig.ensure(this).config.apis!,
      [apiName]: this.api.url!,
    };
  }

  /**
   * Recursively creates or retrieves API Gateway resources based on a path pattern.
   *
   * @param resource - The parent API Gateway resource
   * @param pathParts - Array of path segments to create or retrieve
   * @returns The API Gateway resource at the end of the path
   */
  private getOrCreateResource(
    resource: IResource,
    [nextPathPart, ...pathParts]: string[],
  ): IResource {
    if (!nextPathPart) {
      return resource;
    }
    const childResource =
      resource.getResource(nextPathPart) ?? resource.addResource(nextPathPart);
    return this.getOrCreateResource(childResource, pathParts);
  }
}
"
`;

exports[`fastapi project generator > should set up shared constructs for rest > test-api.ts 1`] = `
"import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AnyPrincipal,
  AccountPrincipal,
  IGrantable,
  Grant,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import {
  OPERATION_DETAILS,
  Operations,
} from '../../generated/test-api/metadata.gen.js';

/**
 * Properties for creating a TestApi construct
 *
 * @template TIntegrations - Map of operation names to their integrations
 */
export interface TestApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Map of operation names to their API Gateway integrations
   */
  integrations: TIntegrations;
}

/**
 * A CDK construct that creates and configures an AWS API Gateway REST API
 * specifically for TestApi.
 * @template TIntegrations - Map of operation names to their integrations
 */
export class TestApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Creates default integrations for all operations, which implement each operation as
   * its own individual lambda function.
   *
   * @param scope - The CDK construct scope
   * @returns An IntegrationBuilder with default lambda integrations
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: OPERATION_DETAILS,
      defaultIntegrationOptions: {
        runtime: Runtime.PYTHON_3_12,
        handler: 'proj_test_api.main.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/apps/nested/path/test_api/bundle-x86',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, \`TestApi\${op}Handler\`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: TestApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'TestApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      deployOptions: {
        tracingEnabled: true,
      },
      policy: new PolicyDocument({
        statements: [
          // Here we grant any AWS credentials from the account that the project is deployed in to call the api.
          // Machine to machine fine-grained access can be defined here using more specific principals (eg roles or
          // users) and resources (eg which api paths may be invoked by which principal) if required.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Open up OPTIONS to allow browsers to make unauthenticated preflight requests
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: OPERATION_DETAILS,
      ...props,
    });
  }

  /**
   * Grants IAM permissions to invoke any method on this API.
   *
   * @param grantee - The IAM principal to grant permissions to
   */
  public grantInvokeAccess(grantee: IGrantable) {
    Grant.addToPrincipal({
      grantee,
      actions: ['execute-api:Invoke'],
      resourceArns: [this.api.arnForExecuteApi('*', '/*', '*')],
    });
  }
}
"
`;

exports[`fastapi project generator > should set up shared constructs for rest > utils.ts 1`] = `
"import { Integration, MethodOptions } from 'aws-cdk-lib/aws-apigateway';
import {
  HttpRouteIntegration,
  AddRoutesOptions,
} from 'aws-cdk-lib/aws-apigatewayv2';

/**
 * Type representing applicable HTTP Methods in API Gateway
 */
export type HttpMethod =
  | 'ANY'
  | 'DELETE'
  | 'GET'
  | 'HEAD'
  | 'OPTIONS'
  | 'PATCH'
  | 'POST'
  | 'PUT';

/**
 * Defines the details of an API operation.
 */
export interface OperationDetails {
  /**
   * The URL path for the operation
   */
  path: string;

  /**
   * The HTTP method for the operation
   */
  method: HttpMethod;
}

/**
 * Represents an API Gateway REST API integration that can be attached to API methods.
 */
export interface RestApiIntegration {
  integration: Integration;
  options?: MethodOptions;
}

/**
 * Represents an API Gateway HTTP API that can be attached to API methods.
 */
export interface HttpApiIntegration {
  integration: HttpRouteIntegration;
  options?: Omit<AddRoutesOptions, 'path' | 'methods' | 'integration'>;
}

/**
 * Options for constructing an IntegrationBuilder
 */
export interface IntegrationBuilderProps<
  TOperation extends string,
  TBaseIntegration,
  TDefaultIntegrationProps extends object,
  TDefaultIntegration extends TBaseIntegration,
> {
  /** Map of operation names to their API path and HTTP method details */
  operations: Record<TOperation, OperationDetails>;

  /** Default configuration options for integrations */
  defaultIntegrationOptions: TDefaultIntegrationProps;

  /** Function to create a default integration for an operation */
  buildDefaultIntegration: (
    op: TOperation,
    props: TDefaultIntegrationProps,
  ) => TDefaultIntegration;
}

/**
 * A builder class for creating API integrations with flexible configuration options.
 *
 * This class implements the builder pattern to create a set of API integrations
 * with support for default configurations and selective overrides.
 *
 * @template TOperation - String literal type representing operation names
 * @template TBaseIntegration - Base type for all integrations
 * @template TIntegrations - Record mapping operation names to their integrations
 * @template TDefaultIntegrationProps - Type for default integration properties
 * @template TDefaultIntegration - Type for default integration implementation
 */
export class IntegrationBuilder<
  TOperation extends string,
  TBaseIntegration,
  TIntegrations extends Record<TOperation, TBaseIntegration>,
  TDefaultIntegrationProps extends object,
  TDefaultIntegration extends TBaseIntegration,
> {
  /** Options for the integration builder */
  private options: IntegrationBuilderProps<
    TOperation,
    TBaseIntegration,
    TDefaultIntegrationProps,
    TDefaultIntegration
  >;

  /** Map of operation names to their custom integrations */
  private integrations: Partial<TIntegrations> = {};

  /**
   * Create an Integration Builder for an HTTP API
   */
  public static http = <
    TOperation extends string,
    TIntegrations extends Record<TOperation, TDefaultIntegration>,
    TDefaultIntegrationProps extends object,
    TDefaultIntegration extends HttpApiIntegration,
  >(
    options: IntegrationBuilderProps<
      TOperation,
      HttpApiIntegration,
      TDefaultIntegrationProps,
      TDefaultIntegration
    >,
  ) => {
    return new IntegrationBuilder<
      TOperation,
      HttpApiIntegration,
      TIntegrations,
      TDefaultIntegrationProps,
      TDefaultIntegration
    >(options);
  };

  /**
   * Create an Integration Builder for a REST API
   */
  public static rest = <
    TOperation extends string,
    TIntegrations extends Record<TOperation, TDefaultIntegration>,
    TDefaultIntegrationProps extends object,
    TDefaultIntegration extends RestApiIntegration,
  >(
    options: IntegrationBuilderProps<
      TOperation,
      RestApiIntegration,
      TDefaultIntegrationProps,
      TDefaultIntegration
    >,
  ) => {
    return new IntegrationBuilder<
      TOperation,
      RestApiIntegration,
      TIntegrations,
      TDefaultIntegrationProps,
      TDefaultIntegration
    >(options);
  };

  private constructor(
    options: IntegrationBuilderProps<
      TOperation,
      TBaseIntegration,
      TDefaultIntegrationProps,
      TDefaultIntegration
    >,
  ) {
    this.options = options;
  }

  /**
   * Overrides default integrations with custom implementations for specific operations.
   *
   * @param overrides - Map of operation names to their custom integration implementations
   * @returns The builder instance with updated type information reflecting the overrides
   */
  public withOverrides<
    TOverrideIntegrations extends Partial<Record<TOperation, TBaseIntegration>>,
  >(overrides: TOverrideIntegrations) {
    this.integrations = { ...this.integrations, ...overrides };
    // Re-type to include the overridden integration types
    return this as unknown as IntegrationBuilder<
      TOperation,
      TBaseIntegration,
      Omit<TIntegrations, keyof TOverrideIntegrations> & TOverrideIntegrations,
      TDefaultIntegrationProps,
      TDefaultIntegration
    >;
  }

  /**
   * Updates the default integration options that will be used for operations
   * without custom overrides.
   *
   * @param options - Partial default integration options to merge with existing defaults
   * @returns The builder instance
   */
  public withDefaultOptions(options: Partial<TDefaultIntegrationProps>) {
    this.options.defaultIntegrationOptions = {
      ...this.options.defaultIntegrationOptions,
      ...options,
    };
    return this;
  }

  /**
   * Builds and returns the complete set of integrations.
   *
   * This method creates the final integration map by:
   * 1. Including all custom overrides provided via withOverrides()
   * 2. Creating default integrations for any operations without custom overrides
   *
   * @returns A complete map of operation names to their integrations
   */
  public build(): TIntegrations {
    return {
      ...this.integrations,
      ...Object.fromEntries(
        (Object.keys(this.options.operations) as TOperation[])
          .filter(
            (op) => !this.integrations[op as keyof typeof this.integrations],
          )
          .map((op) => [
            op,
            this.options.buildDefaultIntegration(
              op,
              this.options.defaultIntegrationOptions,
            ),
          ]),
      ),
    } as unknown as TIntegrations;
  }
}
"
`;

exports[`fastapi project generator > terraform iacProvider > should generate terraform files for HTTP API with Cognito auth and snapshot them > terraform-http-cognito-files 1`] = `
{
  "http-api.tf": "# Core HTTP API Gateway module
# This module creates the API Gateway HTTP API, stage, and logging resources

terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 6.0"
    }
  }
}

# Core HTTP API Gateway Variables

variable "api_name" {
  description = "Name of the HTTP API Gateway"
  type        = string
}

variable "api_description" {
  description = "Description of the HTTP API Gateway"
  type        = string
  default     = "HTTP API Gateway"
}

variable "stage_name" {
  description = "Name of the API Gateway stage"
  type        = string
  default     = "prod"
}

variable "stage_auto_deploy" {
  description = "Whether to automatically deploy the API stage"
  type        = bool
  default     = true
}

# CORS Configuration

variable "cors_allow_credentials" {
  description = "Whether to allow credentials in CORS requests"
  type        = bool
  default     = false
}

variable "cors_allow_headers" {
  description = "List of allowed headers for CORS"
  type        = list(string)
  default     = ["authorization", "content-type", "x-amz-content-sha256", "x-amz-date", "x-amz-security-token"]
}

variable "cors_allow_methods" {
  description = "List of allowed HTTP methods for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_allow_origins" {
  description = "List of allowed origins for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_expose_headers" {
  description = "List of headers to expose in CORS responses"
  type        = list(string)
  default     = []
}

variable "cors_max_age" {
  description = "Maximum age for CORS preflight requests in seconds"
  type        = number
  default     = 86400
}

# Tags

variable "tags" {
  description = "Tags to apply to all resources"
  type        = map(string)
  default     = {}
}

# Data sources
data "aws_region" "current" {}
data "aws_caller_identity" "current" {}

# Resources

# KMS key for CloudWatch log group encryption
resource "aws_kms_key" "logs_key" {
  description             = "KMS key for CloudWatch log group encryption"
  deletion_window_in_days = 7
  enable_key_rotation     = true

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "Enable IAM User Permissions"
        Effect = "Allow"
        Principal = {
          AWS = "arn:aws:iam::\${data.aws_caller_identity.current.account_id}:root"
        }
        Action   = "kms:*"
        Resource = "*"
      },
      {
        Sid    = "Allow CloudWatch Logs"
        Effect = "Allow"
        Principal = {
          Service = "logs.\${data.aws_region.current.name}.amazonaws.com"
        }
        Action = [
          "kms:Encrypt",
          "kms:Decrypt",
          "kms:ReEncrypt*",
          "kms:GenerateDataKey*",
          "kms:DescribeKey"
        ]
        Resource = "*"
        Condition = {
          ArnEquals = {
            "kms:EncryptionContext:aws:logs:arn" = "arn:aws:logs:\${data.aws_region.current.name}:\${data.aws_caller_identity.current.account_id}:log-group:/aws/apigateway/\${var.api_name}"
          }
        }
      }
    ]
  })

  tags = var.tags
}

resource "aws_kms_alias" "logs_key_alias" {
  name          = "alias/\${var.api_name}-api-logs-encryption"
  target_key_id = aws_kms_key.logs_key.key_id
}

# HTTP API Gateway
resource "aws_apigatewayv2_api" "http_api" {
  name          = var.api_name
  protocol_type = "HTTP"
  description   = var.api_description

  cors_configuration {
    allow_credentials = var.cors_allow_credentials
    allow_headers     = var.cors_allow_headers
    allow_methods     = var.cors_allow_methods
    allow_origins     = var.cors_allow_origins
    expose_headers    = var.cors_expose_headers
    max_age          = var.cors_max_age
  }

  tags = var.tags
}

# API Gateway stage
resource "aws_apigatewayv2_stage" "api_stage" {
  api_id      = aws_apigatewayv2_api.http_api.id
  name        = var.stage_name
  auto_deploy = var.stage_auto_deploy

  access_log_settings {
    destination_arn = aws_cloudwatch_log_group.api_logs.arn
    format = jsonencode({
      requestId      = "$context.requestId"
      ip            = "$context.identity.sourceIp"
      requestTime   = "$context.requestTime"
      httpMethod    = "$context.httpMethod"
      routeKey      = "$context.routeKey"
      status        = "$context.status"
      protocol      = "$context.protocol"
      responseLength = "$context.responseLength"
      error         = "$context.error.message"
      integrationError = "$context.integrationErrorMessage"
    })
  }

  default_route_settings {
    throttling_burst_limit = 5000
    throttling_rate_limit = 10000
  }

  tags = var.tags

  depends_on = [aws_cloudwatch_log_group.api_logs]
}

# CloudWatch Log Group for API Gateway
resource "aws_cloudwatch_log_group" "api_logs" {
  #checkov:skip=CKV_AWS_338:Log retention set to forever
  #checkov:skip=CKV_AWS_66:Log retention set to forever
  name         = "/aws/apigateway/\${var.api_name}"
  kms_key_id   = aws_kms_key.logs_key.arn
  tags         = var.tags
}

# Outputs

output "api_id" {
  description = "ID of the HTTP API Gateway"
  value       = aws_apigatewayv2_api.http_api.id
}

output "api_arn" {
  description = "ARN of the HTTP API Gateway"
  value       = aws_apigatewayv2_api.http_api.arn
}

output "api_endpoint" {
  description = "Base URL of the HTTP API Gateway"
  value       = aws_apigatewayv2_api.http_api.api_endpoint
}

output "api_execution_arn" {
  description = "Execution ARN of the HTTP API Gateway"
  value       = aws_apigatewayv2_api.http_api.execution_arn
}

output "stage_id" {
  description = "ID of the API Gateway stage"
  value       = aws_apigatewayv2_stage.api_stage.id
}

output "stage_arn" {
  description = "ARN of the API Gateway stage"
  value       = aws_apigatewayv2_stage.api_stage.arn
}

output "stage_execution_arn" {
  description = "Execution ARN of the API Gateway stage"
  value       = aws_apigatewayv2_stage.api_stage.execution_arn
}

output "stage_invoke_url" {
  description = "Invoke URL of the API Gateway stage"
  value       = aws_apigatewayv2_stage.api_stage.invoke_url
}

output "api_log_group_name" {
  description = "Name of the API Gateway CloudWatch log group"
  value       = aws_cloudwatch_log_group.api_logs.name
}

output "api_log_group_arn" {
  description = "ARN of the API Gateway CloudWatch log group"
  value       = aws_cloudwatch_log_group.api_logs.arn
}",
  "test-api.tf": "terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 6.0"
    }
  }
}

# Authentication Configuration
variable "user_pool_id" {
  description = "Cognito User Pool ID for authentication"
  type        = string
}

variable "user_pool_client_ids" {
  description = "List of Cognito User Pool Client IDs"
  type        = list(string)
}

variable "env" {
  description = "Environment variables for the Lambda function"
  type        = map(string)
  default     = {}
}

variable "additional_iam_policy_statements" {
  description = "Additional IAM policy statements for the Lambda function"
  type        = list(object({
    Effect   = string
    Action   = list(string)
    Resource = list(string)
  }))
  default = []
}

# CORS Configuration (passed to core module)
variable "cors_allow_credentials" {
  description = "Whether to allow credentials in CORS requests"
  type        = bool
  default     = false
}

variable "cors_allow_headers" {
  description = "List of allowed headers for CORS"
  type        = list(string)
  default     = ["authorization", "content-type", "x-amz-content-sha256", "x-amz-date", "x-amz-security-token"]
}

variable "cors_allow_methods" {
  description = "List of allowed HTTP methods for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_allow_origins" {
  description = "List of allowed origins for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_expose_headers" {
  description = "List of headers to expose in CORS responses"
  type        = list(string)
  default     = []
}

variable "cors_max_age" {
  description = "Maximum age for CORS preflight requests in seconds"
  type        = number
  default     = 0
}

# Tags
variable "tags" {
  description = "Tags to apply to all resources"
  type        = map(string)
  default     = {}
}

# Get current AWS region and account ID
data "aws_region" "current" {}
data "aws_caller_identity" "current" {}

# Resources

# Create Lambda ZIP file from the bundle directory
data "archive_file" "lambda_zip" {
  type        = "zip"
  source_dir  = "\${path.module}/../../../../../../../dist/apps/test_api/bundle-x86"
  output_path = "\${path.module}/../../../../../../../dist/packages/common/terraform/apis/test-api/lambda.zip"
}


# Use the core HTTP API module
module "http_api" {
  source = "../../../core/api/http-api"

  api_name        = "TestApi"
  api_description = "TestApi HTTP API"
  stage_name      = "$default"
  stage_auto_deploy = true

  # CORS Configuration
  cors_allow_credentials = var.cors_allow_credentials
  cors_allow_headers     = var.cors_allow_headers
  cors_allow_methods     = var.cors_allow_methods
  cors_allow_origins     = var.cors_allow_origins
  cors_expose_headers    = var.cors_expose_headers
  cors_max_age           = var.cors_max_age

  # Tags
  tags = var.tags
}

# Lambda function
# This configures a single "router" lambda to serve all requests
resource "aws_lambda_function" "api_lambda" {
  #checkov:skip=CKV_AWS_117:Lambda function does not need to be in VPC for this use case
  #checkov:skip=CKV_AWS_116:Dead Letter Queue not required for this simple API use case
  #checkov:skip=CKV_AWS_272:Code signing not required for this use case
  #checkov:skip=CKV_AWS_115:Concurrent execution limit not required for this use case
  #checkov:skip=CKV_AWS_173:Lambda environment variables encrypted by managed key
  filename         = data.archive_file.lambda_zip.output_path
  function_name    = "TestApiHandler"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "proj_test_api.main.handler"
  runtime         = "python3.12"
  timeout         = 30
  memory_size     = 128

  source_code_hash = data.archive_file.lambda_zip.output_base64sha256

  # Enable X-Ray tracing
  tracing_config {
    mode = "Active"
  }

  environment {
    variables = merge({
      AWS_CONNECTION_REUSE_ENABLED = "1"
    }, var.env)
  }

  tags = var.tags
}

# IAM role for Lambda execution
resource "aws_iam_role" "lambda_execution_role" {
  name = "TestApiHandler-execution-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })

  tags = var.tags
}

# Attach basic execution policy to Lambda role
resource "aws_iam_role_policy_attachment" "lambda_basic_execution" {
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
  role       = aws_iam_role.lambda_execution_role.name
}

# Attach X-Ray tracing policy to Lambda role
resource "aws_iam_role_policy_attachment" "lambda_xray_execution" {
  policy_arn = "arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess"
  role       = aws_iam_role.lambda_execution_role.name
}

# Additional IAM policies for Lambda (if provided)
resource "aws_iam_role_policy" "lambda_additional_policies" {
  count = length(var.additional_iam_policy_statements) > 0 ? 1 : 0
  name  = "TestApiHandler-additional-policies"
  role  = aws_iam_role.lambda_execution_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = var.additional_iam_policy_statements
  })
}

# CloudWatch Log Group for Lambda
resource "aws_cloudwatch_log_group" "lambda_logs" {
  #checkov:skip=CKV_AWS_158:Using default CloudWatch log encryption
  #checkov:skip=CKV_AWS_338:Log retention set to forever
  #checkov:skip=CKV_AWS_66:Log retention set to forever
  name              = "/aws/lambda/TestApiHandler"
  tags              = var.tags
}

# Cognito User Pool Authorizer
resource "aws_apigatewayv2_authorizer" "cognito_authorizer" {
  api_id           = module.http_api.api_id
  authorizer_type  = "JWT"
  identity_sources = ["$request.header.Authorization"]
  name             = "TestApiAuthorizer"

  jwt_configuration {
    audience = var.user_pool_client_ids
    issuer   = "https://cognito-idp.\${data.aws_region.current.name}.amazonaws.com/\${var.user_pool_id}"
  }
}

# Lambda integration for HTTP API
resource "aws_apigatewayv2_integration" "lambda_integration" {
  api_id           = module.http_api.api_id
  integration_type = "AWS_PROXY"
  integration_uri  = aws_lambda_function.api_lambda.invoke_arn

  payload_format_version = "2.0"
  timeout_milliseconds   = 30000

  depends_on = [aws_lambda_function.api_lambda]
}

# Route for proxy integration (catches all requests)
resource "aws_apigatewayv2_route" "proxy_routes" {
  # NB: OPTIONS is omitted here since API Gateway manages responding to preflight requests
  # when cors settings are configured
  for_each = toset(["GET", "POST", "PUT", "PATCH", "DELETE", "HEAD"])

  api_id    = module.http_api.api_id
  route_key = "\${each.key} /{proxy+}"
  target    = "integrations/\${aws_apigatewayv2_integration.lambda_integration.id}"

  authorization_type = "JWT"
  authorizer_id      = aws_apigatewayv2_authorizer.cognito_authorizer.id

  depends_on = [aws_apigatewayv2_integration.lambda_integration, aws_apigatewayv2_authorizer.cognito_authorizer]
}

# Add API url to runtime config
module "add_url_to_runtime_config" {
  source = "../../../core/runtime-config/entry"

  key_path = "apis.TestApi"
  value    = module.http_api.stage_invoke_url

  depends_on = [module.http_api]
}

# Lambda permission for API Gateway to invoke the function
resource "aws_lambda_permission" "api_gateway_invoke" {
  statement_id  = "AllowExecutionFromAPIGateway"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.api_lambda.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "\${module.http_api.api_execution_arn}/*/*"

  depends_on = [module.http_api, aws_lambda_function.api_lambda]
}

# Outputs

# API Gateway Outputs (from core module)
output "api_id" {
  description = "ID of the HTTP API Gateway"
  value       = module.http_api.api_id
}

output "api_arn" {
  description = "ARN of the HTTP API Gateway"
  value       = module.http_api.api_arn
}

output "api_endpoint" {
  description = "Base URL of the HTTP API Gateway"
  value       = module.http_api.api_endpoint
}

output "api_execution_arn" {
  description = "Execution ARN of the HTTP API Gateway"
  value       = module.http_api.api_execution_arn
}

output "stage_invoke_url" {
  description = "Invoke URL of the API Gateway stage"
  value       = module.http_api.stage_invoke_url
}

output "stage_arn" {
  description = "ARN of the API Gateway stage"
  value       = module.http_api.stage_arn
}

output "stage_execution_arn" {
  description = "Execution ARN of the API Gateway stage"
  value       = module.http_api.stage_execution_arn
}

# Lambda Function Outputs
output "lambda_function_name" {
  description = "Name of the Lambda function"
  value       = aws_lambda_function.api_lambda.function_name
}

output "lambda_function_arn" {
  description = "ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.arn
}

output "lambda_invoke_arn" {
  description = "Invoke ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.invoke_arn
}

output "lambda_qualified_arn" {
  description = "Qualified ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.qualified_arn
}

output "lambda_version" {
  description = "Version of the Lambda function"
  value       = aws_lambda_function.api_lambda.version
}

output "lambda_source_code_hash" {
  description = "Base64-encoded SHA256 hash of the Lambda deployment package"
  value       = aws_lambda_function.api_lambda.source_code_hash
}

output "lambda_source_code_size" {
  description = "Size of the Lambda deployment package in bytes"
  value       = aws_lambda_function.api_lambda.source_code_size
}

# IAM Role Outputs
output "lambda_execution_role_arn" {
  description = "ARN of the Lambda execution role"
  value       = aws_iam_role.lambda_execution_role.arn
}

output "lambda_execution_role_name" {
  description = "Name of the Lambda execution role"
  value       = aws_iam_role.lambda_execution_role.name
}

# Integration Outputs
output "integration_id" {
  description = "ID of the Lambda integration"
  value       = aws_apigatewayv2_integration.lambda_integration.id
}

# CloudWatch Log Groups
output "lambda_log_group_name" {
  description = "Name of the Lambda CloudWatch log group"
  value       = aws_cloudwatch_log_group.lambda_logs.name
}

output "lambda_log_group_arn" {
  description = "ARN of the Lambda CloudWatch log group"
  value       = aws_cloudwatch_log_group.lambda_logs.arn
}

output "api_log_group_name" {
  description = "Name of the API Gateway CloudWatch log group"
  value       = module.http_api.api_log_group_name
}

output "api_log_group_arn" {
  description = "ARN of the API Gateway CloudWatch log group"
  value       = module.http_api.api_log_group_arn
}",
}
`;

exports[`fastapi project generator > terraform iacProvider > should generate terraform files for HTTP API with IAM auth and snapshot them > terraform-http-iam-files 1`] = `
{
  "http-api.tf": "# Core HTTP API Gateway module
# This module creates the API Gateway HTTP API, stage, and logging resources

terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 6.0"
    }
  }
}

# Core HTTP API Gateway Variables

variable "api_name" {
  description = "Name of the HTTP API Gateway"
  type        = string
}

variable "api_description" {
  description = "Description of the HTTP API Gateway"
  type        = string
  default     = "HTTP API Gateway"
}

variable "stage_name" {
  description = "Name of the API Gateway stage"
  type        = string
  default     = "prod"
}

variable "stage_auto_deploy" {
  description = "Whether to automatically deploy the API stage"
  type        = bool
  default     = true
}

# CORS Configuration

variable "cors_allow_credentials" {
  description = "Whether to allow credentials in CORS requests"
  type        = bool
  default     = false
}

variable "cors_allow_headers" {
  description = "List of allowed headers for CORS"
  type        = list(string)
  default     = ["authorization", "content-type", "x-amz-content-sha256", "x-amz-date", "x-amz-security-token"]
}

variable "cors_allow_methods" {
  description = "List of allowed HTTP methods for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_allow_origins" {
  description = "List of allowed origins for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_expose_headers" {
  description = "List of headers to expose in CORS responses"
  type        = list(string)
  default     = []
}

variable "cors_max_age" {
  description = "Maximum age for CORS preflight requests in seconds"
  type        = number
  default     = 86400
}

# Tags

variable "tags" {
  description = "Tags to apply to all resources"
  type        = map(string)
  default     = {}
}

# Data sources
data "aws_region" "current" {}
data "aws_caller_identity" "current" {}

# Resources

# KMS key for CloudWatch log group encryption
resource "aws_kms_key" "logs_key" {
  description             = "KMS key for CloudWatch log group encryption"
  deletion_window_in_days = 7
  enable_key_rotation     = true

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "Enable IAM User Permissions"
        Effect = "Allow"
        Principal = {
          AWS = "arn:aws:iam::\${data.aws_caller_identity.current.account_id}:root"
        }
        Action   = "kms:*"
        Resource = "*"
      },
      {
        Sid    = "Allow CloudWatch Logs"
        Effect = "Allow"
        Principal = {
          Service = "logs.\${data.aws_region.current.name}.amazonaws.com"
        }
        Action = [
          "kms:Encrypt",
          "kms:Decrypt",
          "kms:ReEncrypt*",
          "kms:GenerateDataKey*",
          "kms:DescribeKey"
        ]
        Resource = "*"
        Condition = {
          ArnEquals = {
            "kms:EncryptionContext:aws:logs:arn" = "arn:aws:logs:\${data.aws_region.current.name}:\${data.aws_caller_identity.current.account_id}:log-group:/aws/apigateway/\${var.api_name}"
          }
        }
      }
    ]
  })

  tags = var.tags
}

resource "aws_kms_alias" "logs_key_alias" {
  name          = "alias/\${var.api_name}-api-logs-encryption"
  target_key_id = aws_kms_key.logs_key.key_id
}

# HTTP API Gateway
resource "aws_apigatewayv2_api" "http_api" {
  name          = var.api_name
  protocol_type = "HTTP"
  description   = var.api_description

  cors_configuration {
    allow_credentials = var.cors_allow_credentials
    allow_headers     = var.cors_allow_headers
    allow_methods     = var.cors_allow_methods
    allow_origins     = var.cors_allow_origins
    expose_headers    = var.cors_expose_headers
    max_age          = var.cors_max_age
  }

  tags = var.tags
}

# API Gateway stage
resource "aws_apigatewayv2_stage" "api_stage" {
  api_id      = aws_apigatewayv2_api.http_api.id
  name        = var.stage_name
  auto_deploy = var.stage_auto_deploy

  access_log_settings {
    destination_arn = aws_cloudwatch_log_group.api_logs.arn
    format = jsonencode({
      requestId      = "$context.requestId"
      ip            = "$context.identity.sourceIp"
      requestTime   = "$context.requestTime"
      httpMethod    = "$context.httpMethod"
      routeKey      = "$context.routeKey"
      status        = "$context.status"
      protocol      = "$context.protocol"
      responseLength = "$context.responseLength"
      error         = "$context.error.message"
      integrationError = "$context.integrationErrorMessage"
    })
  }

  default_route_settings {
    throttling_burst_limit = 5000
    throttling_rate_limit = 10000
  }

  tags = var.tags

  depends_on = [aws_cloudwatch_log_group.api_logs]
}

# CloudWatch Log Group for API Gateway
resource "aws_cloudwatch_log_group" "api_logs" {
  #checkov:skip=CKV_AWS_338:Log retention set to forever
  #checkov:skip=CKV_AWS_66:Log retention set to forever
  name         = "/aws/apigateway/\${var.api_name}"
  kms_key_id   = aws_kms_key.logs_key.arn
  tags         = var.tags
}

# Outputs

output "api_id" {
  description = "ID of the HTTP API Gateway"
  value       = aws_apigatewayv2_api.http_api.id
}

output "api_arn" {
  description = "ARN of the HTTP API Gateway"
  value       = aws_apigatewayv2_api.http_api.arn
}

output "api_endpoint" {
  description = "Base URL of the HTTP API Gateway"
  value       = aws_apigatewayv2_api.http_api.api_endpoint
}

output "api_execution_arn" {
  description = "Execution ARN of the HTTP API Gateway"
  value       = aws_apigatewayv2_api.http_api.execution_arn
}

output "stage_id" {
  description = "ID of the API Gateway stage"
  value       = aws_apigatewayv2_stage.api_stage.id
}

output "stage_arn" {
  description = "ARN of the API Gateway stage"
  value       = aws_apigatewayv2_stage.api_stage.arn
}

output "stage_execution_arn" {
  description = "Execution ARN of the API Gateway stage"
  value       = aws_apigatewayv2_stage.api_stage.execution_arn
}

output "stage_invoke_url" {
  description = "Invoke URL of the API Gateway stage"
  value       = aws_apigatewayv2_stage.api_stage.invoke_url
}

output "api_log_group_name" {
  description = "Name of the API Gateway CloudWatch log group"
  value       = aws_cloudwatch_log_group.api_logs.name
}

output "api_log_group_arn" {
  description = "ARN of the API Gateway CloudWatch log group"
  value       = aws_cloudwatch_log_group.api_logs.arn
}",
  "test-api.tf": "terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 6.0"
    }
  }
}


variable "env" {
  description = "Environment variables for the Lambda function"
  type        = map(string)
  default     = {}
}

variable "additional_iam_policy_statements" {
  description = "Additional IAM policy statements for the Lambda function"
  type        = list(object({
    Effect   = string
    Action   = list(string)
    Resource = list(string)
  }))
  default = []
}

# CORS Configuration (passed to core module)
variable "cors_allow_credentials" {
  description = "Whether to allow credentials in CORS requests"
  type        = bool
  default     = false
}

variable "cors_allow_headers" {
  description = "List of allowed headers for CORS"
  type        = list(string)
  default     = ["authorization", "content-type", "x-amz-content-sha256", "x-amz-date", "x-amz-security-token"]
}

variable "cors_allow_methods" {
  description = "List of allowed HTTP methods for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_allow_origins" {
  description = "List of allowed origins for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_expose_headers" {
  description = "List of headers to expose in CORS responses"
  type        = list(string)
  default     = []
}

variable "cors_max_age" {
  description = "Maximum age for CORS preflight requests in seconds"
  type        = number
  default     = 0
}

# Tags
variable "tags" {
  description = "Tags to apply to all resources"
  type        = map(string)
  default     = {}
}

# Get current AWS region and account ID
data "aws_region" "current" {}
data "aws_caller_identity" "current" {}

# Resources

# Create Lambda ZIP file from the bundle directory
data "archive_file" "lambda_zip" {
  type        = "zip"
  source_dir  = "\${path.module}/../../../../../../../dist/apps/test_api/bundle-x86"
  output_path = "\${path.module}/../../../../../../../dist/packages/common/terraform/apis/test-api/lambda.zip"
}


# Use the core HTTP API module
module "http_api" {
  source = "../../../core/api/http-api"

  api_name        = "TestApi"
  api_description = "TestApi HTTP API"
  stage_name      = "$default"
  stage_auto_deploy = true

  # CORS Configuration
  cors_allow_credentials = var.cors_allow_credentials
  cors_allow_headers     = var.cors_allow_headers
  cors_allow_methods     = var.cors_allow_methods
  cors_allow_origins     = var.cors_allow_origins
  cors_expose_headers    = var.cors_expose_headers
  cors_max_age           = var.cors_max_age

  # Tags
  tags = var.tags
}

# Lambda function
# This configures a single "router" lambda to serve all requests
resource "aws_lambda_function" "api_lambda" {
  #checkov:skip=CKV_AWS_117:Lambda function does not need to be in VPC for this use case
  #checkov:skip=CKV_AWS_116:Dead Letter Queue not required for this simple API use case
  #checkov:skip=CKV_AWS_272:Code signing not required for this use case
  #checkov:skip=CKV_AWS_115:Concurrent execution limit not required for this use case
  #checkov:skip=CKV_AWS_173:Lambda environment variables encrypted by managed key
  filename         = data.archive_file.lambda_zip.output_path
  function_name    = "TestApiHandler"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "proj_test_api.main.handler"
  runtime         = "python3.12"
  timeout         = 30
  memory_size     = 128

  source_code_hash = data.archive_file.lambda_zip.output_base64sha256

  # Enable X-Ray tracing
  tracing_config {
    mode = "Active"
  }

  environment {
    variables = merge({
      AWS_CONNECTION_REUSE_ENABLED = "1"
    }, var.env)
  }

  tags = var.tags
}

# IAM role for Lambda execution
resource "aws_iam_role" "lambda_execution_role" {
  name = "TestApiHandler-execution-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })

  tags = var.tags
}

# Attach basic execution policy to Lambda role
resource "aws_iam_role_policy_attachment" "lambda_basic_execution" {
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
  role       = aws_iam_role.lambda_execution_role.name
}

# Attach X-Ray tracing policy to Lambda role
resource "aws_iam_role_policy_attachment" "lambda_xray_execution" {
  policy_arn = "arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess"
  role       = aws_iam_role.lambda_execution_role.name
}

# Additional IAM policies for Lambda (if provided)
resource "aws_iam_role_policy" "lambda_additional_policies" {
  count = length(var.additional_iam_policy_statements) > 0 ? 1 : 0
  name  = "TestApiHandler-additional-policies"
  role  = aws_iam_role.lambda_execution_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = var.additional_iam_policy_statements
  })
}

# CloudWatch Log Group for Lambda
resource "aws_cloudwatch_log_group" "lambda_logs" {
  #checkov:skip=CKV_AWS_158:Using default CloudWatch log encryption
  #checkov:skip=CKV_AWS_338:Log retention set to forever
  #checkov:skip=CKV_AWS_66:Log retention set to forever
  name              = "/aws/lambda/TestApiHandler"
  tags              = var.tags
}


# Lambda integration for HTTP API
resource "aws_apigatewayv2_integration" "lambda_integration" {
  api_id           = module.http_api.api_id
  integration_type = "AWS_PROXY"
  integration_uri  = aws_lambda_function.api_lambda.invoke_arn

  payload_format_version = "2.0"
  timeout_milliseconds   = 30000

  depends_on = [aws_lambda_function.api_lambda]
}

# Route for proxy integration (catches all requests)
resource "aws_apigatewayv2_route" "proxy_routes" {
  # NB: OPTIONS is omitted here since API Gateway manages responding to preflight requests
  # when cors settings are configured
  for_each = toset(["GET", "POST", "PUT", "PATCH", "DELETE", "HEAD"])

  api_id    = module.http_api.api_id
  route_key = "\${each.key} /{proxy+}"
  target    = "integrations/\${aws_apigatewayv2_integration.lambda_integration.id}"

  authorization_type = "AWS_IAM"

  depends_on = [aws_apigatewayv2_integration.lambda_integration]
}

# Add API url to runtime config
module "add_url_to_runtime_config" {
  source = "../../../core/runtime-config/entry"

  key_path = "apis.TestApi"
  value    = module.http_api.stage_invoke_url

  depends_on = [module.http_api]
}

# Lambda permission for API Gateway to invoke the function
resource "aws_lambda_permission" "api_gateway_invoke" {
  statement_id  = "AllowExecutionFromAPIGateway"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.api_lambda.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "\${module.http_api.api_execution_arn}/*/*"

  depends_on = [module.http_api, aws_lambda_function.api_lambda]
}

# Outputs

# API Gateway Outputs (from core module)
output "api_id" {
  description = "ID of the HTTP API Gateway"
  value       = module.http_api.api_id
}

output "api_arn" {
  description = "ARN of the HTTP API Gateway"
  value       = module.http_api.api_arn
}

output "api_endpoint" {
  description = "Base URL of the HTTP API Gateway"
  value       = module.http_api.api_endpoint
}

output "api_execution_arn" {
  description = "Execution ARN of the HTTP API Gateway"
  value       = module.http_api.api_execution_arn
}

output "stage_invoke_url" {
  description = "Invoke URL of the API Gateway stage"
  value       = module.http_api.stage_invoke_url
}

output "stage_arn" {
  description = "ARN of the API Gateway stage"
  value       = module.http_api.stage_arn
}

output "stage_execution_arn" {
  description = "Execution ARN of the API Gateway stage"
  value       = module.http_api.stage_execution_arn
}

# Lambda Function Outputs
output "lambda_function_name" {
  description = "Name of the Lambda function"
  value       = aws_lambda_function.api_lambda.function_name
}

output "lambda_function_arn" {
  description = "ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.arn
}

output "lambda_invoke_arn" {
  description = "Invoke ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.invoke_arn
}

output "lambda_qualified_arn" {
  description = "Qualified ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.qualified_arn
}

output "lambda_version" {
  description = "Version of the Lambda function"
  value       = aws_lambda_function.api_lambda.version
}

output "lambda_source_code_hash" {
  description = "Base64-encoded SHA256 hash of the Lambda deployment package"
  value       = aws_lambda_function.api_lambda.source_code_hash
}

output "lambda_source_code_size" {
  description = "Size of the Lambda deployment package in bytes"
  value       = aws_lambda_function.api_lambda.source_code_size
}

# IAM Role Outputs
output "lambda_execution_role_arn" {
  description = "ARN of the Lambda execution role"
  value       = aws_iam_role.lambda_execution_role.arn
}

output "lambda_execution_role_name" {
  description = "Name of the Lambda execution role"
  value       = aws_iam_role.lambda_execution_role.name
}

# Integration Outputs
output "integration_id" {
  description = "ID of the Lambda integration"
  value       = aws_apigatewayv2_integration.lambda_integration.id
}

# CloudWatch Log Groups
output "lambda_log_group_name" {
  description = "Name of the Lambda CloudWatch log group"
  value       = aws_cloudwatch_log_group.lambda_logs.name
}

output "lambda_log_group_arn" {
  description = "ARN of the Lambda CloudWatch log group"
  value       = aws_cloudwatch_log_group.lambda_logs.arn
}

output "api_log_group_name" {
  description = "Name of the API Gateway CloudWatch log group"
  value       = module.http_api.api_log_group_name
}

output "api_log_group_arn" {
  description = "ARN of the API Gateway CloudWatch log group"
  value       = module.http_api.api_log_group_arn
}",
}
`;

exports[`fastapi project generator > terraform iacProvider > should generate terraform files for HTTP API with None auth and snapshot them > terraform-http-none-files 1`] = `
{
  "http-api.tf": "# Core HTTP API Gateway module
# This module creates the API Gateway HTTP API, stage, and logging resources

terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 6.0"
    }
  }
}

# Core HTTP API Gateway Variables

variable "api_name" {
  description = "Name of the HTTP API Gateway"
  type        = string
}

variable "api_description" {
  description = "Description of the HTTP API Gateway"
  type        = string
  default     = "HTTP API Gateway"
}

variable "stage_name" {
  description = "Name of the API Gateway stage"
  type        = string
  default     = "prod"
}

variable "stage_auto_deploy" {
  description = "Whether to automatically deploy the API stage"
  type        = bool
  default     = true
}

# CORS Configuration

variable "cors_allow_credentials" {
  description = "Whether to allow credentials in CORS requests"
  type        = bool
  default     = false
}

variable "cors_allow_headers" {
  description = "List of allowed headers for CORS"
  type        = list(string)
  default     = ["authorization", "content-type", "x-amz-content-sha256", "x-amz-date", "x-amz-security-token"]
}

variable "cors_allow_methods" {
  description = "List of allowed HTTP methods for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_allow_origins" {
  description = "List of allowed origins for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_expose_headers" {
  description = "List of headers to expose in CORS responses"
  type        = list(string)
  default     = []
}

variable "cors_max_age" {
  description = "Maximum age for CORS preflight requests in seconds"
  type        = number
  default     = 86400
}

# Tags

variable "tags" {
  description = "Tags to apply to all resources"
  type        = map(string)
  default     = {}
}

# Data sources
data "aws_region" "current" {}
data "aws_caller_identity" "current" {}

# Resources

# KMS key for CloudWatch log group encryption
resource "aws_kms_key" "logs_key" {
  description             = "KMS key for CloudWatch log group encryption"
  deletion_window_in_days = 7
  enable_key_rotation     = true

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "Enable IAM User Permissions"
        Effect = "Allow"
        Principal = {
          AWS = "arn:aws:iam::\${data.aws_caller_identity.current.account_id}:root"
        }
        Action   = "kms:*"
        Resource = "*"
      },
      {
        Sid    = "Allow CloudWatch Logs"
        Effect = "Allow"
        Principal = {
          Service = "logs.\${data.aws_region.current.name}.amazonaws.com"
        }
        Action = [
          "kms:Encrypt",
          "kms:Decrypt",
          "kms:ReEncrypt*",
          "kms:GenerateDataKey*",
          "kms:DescribeKey"
        ]
        Resource = "*"
        Condition = {
          ArnEquals = {
            "kms:EncryptionContext:aws:logs:arn" = "arn:aws:logs:\${data.aws_region.current.name}:\${data.aws_caller_identity.current.account_id}:log-group:/aws/apigateway/\${var.api_name}"
          }
        }
      }
    ]
  })

  tags = var.tags
}

resource "aws_kms_alias" "logs_key_alias" {
  name          = "alias/\${var.api_name}-api-logs-encryption"
  target_key_id = aws_kms_key.logs_key.key_id
}

# HTTP API Gateway
resource "aws_apigatewayv2_api" "http_api" {
  name          = var.api_name
  protocol_type = "HTTP"
  description   = var.api_description

  cors_configuration {
    allow_credentials = var.cors_allow_credentials
    allow_headers     = var.cors_allow_headers
    allow_methods     = var.cors_allow_methods
    allow_origins     = var.cors_allow_origins
    expose_headers    = var.cors_expose_headers
    max_age          = var.cors_max_age
  }

  tags = var.tags
}

# API Gateway stage
resource "aws_apigatewayv2_stage" "api_stage" {
  api_id      = aws_apigatewayv2_api.http_api.id
  name        = var.stage_name
  auto_deploy = var.stage_auto_deploy

  access_log_settings {
    destination_arn = aws_cloudwatch_log_group.api_logs.arn
    format = jsonencode({
      requestId      = "$context.requestId"
      ip            = "$context.identity.sourceIp"
      requestTime   = "$context.requestTime"
      httpMethod    = "$context.httpMethod"
      routeKey      = "$context.routeKey"
      status        = "$context.status"
      protocol      = "$context.protocol"
      responseLength = "$context.responseLength"
      error         = "$context.error.message"
      integrationError = "$context.integrationErrorMessage"
    })
  }

  default_route_settings {
    throttling_burst_limit = 5000
    throttling_rate_limit = 10000
  }

  tags = var.tags

  depends_on = [aws_cloudwatch_log_group.api_logs]
}

# CloudWatch Log Group for API Gateway
resource "aws_cloudwatch_log_group" "api_logs" {
  #checkov:skip=CKV_AWS_338:Log retention set to forever
  #checkov:skip=CKV_AWS_66:Log retention set to forever
  name         = "/aws/apigateway/\${var.api_name}"
  kms_key_id   = aws_kms_key.logs_key.arn
  tags         = var.tags
}

# Outputs

output "api_id" {
  description = "ID of the HTTP API Gateway"
  value       = aws_apigatewayv2_api.http_api.id
}

output "api_arn" {
  description = "ARN of the HTTP API Gateway"
  value       = aws_apigatewayv2_api.http_api.arn
}

output "api_endpoint" {
  description = "Base URL of the HTTP API Gateway"
  value       = aws_apigatewayv2_api.http_api.api_endpoint
}

output "api_execution_arn" {
  description = "Execution ARN of the HTTP API Gateway"
  value       = aws_apigatewayv2_api.http_api.execution_arn
}

output "stage_id" {
  description = "ID of the API Gateway stage"
  value       = aws_apigatewayv2_stage.api_stage.id
}

output "stage_arn" {
  description = "ARN of the API Gateway stage"
  value       = aws_apigatewayv2_stage.api_stage.arn
}

output "stage_execution_arn" {
  description = "Execution ARN of the API Gateway stage"
  value       = aws_apigatewayv2_stage.api_stage.execution_arn
}

output "stage_invoke_url" {
  description = "Invoke URL of the API Gateway stage"
  value       = aws_apigatewayv2_stage.api_stage.invoke_url
}

output "api_log_group_name" {
  description = "Name of the API Gateway CloudWatch log group"
  value       = aws_cloudwatch_log_group.api_logs.name
}

output "api_log_group_arn" {
  description = "ARN of the API Gateway CloudWatch log group"
  value       = aws_cloudwatch_log_group.api_logs.arn
}",
  "test-api.tf": "terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 6.0"
    }
  }
}


variable "env" {
  description = "Environment variables for the Lambda function"
  type        = map(string)
  default     = {}
}

variable "additional_iam_policy_statements" {
  description = "Additional IAM policy statements for the Lambda function"
  type        = list(object({
    Effect   = string
    Action   = list(string)
    Resource = list(string)
  }))
  default = []
}

# CORS Configuration (passed to core module)
variable "cors_allow_credentials" {
  description = "Whether to allow credentials in CORS requests"
  type        = bool
  default     = false
}

variable "cors_allow_headers" {
  description = "List of allowed headers for CORS"
  type        = list(string)
  default     = ["authorization", "content-type", "x-amz-content-sha256", "x-amz-date", "x-amz-security-token"]
}

variable "cors_allow_methods" {
  description = "List of allowed HTTP methods for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_allow_origins" {
  description = "List of allowed origins for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_expose_headers" {
  description = "List of headers to expose in CORS responses"
  type        = list(string)
  default     = []
}

variable "cors_max_age" {
  description = "Maximum age for CORS preflight requests in seconds"
  type        = number
  default     = 0
}

# Tags
variable "tags" {
  description = "Tags to apply to all resources"
  type        = map(string)
  default     = {}
}

# Get current AWS region and account ID
data "aws_region" "current" {}
data "aws_caller_identity" "current" {}

# Resources

# Create Lambda ZIP file from the bundle directory
data "archive_file" "lambda_zip" {
  type        = "zip"
  source_dir  = "\${path.module}/../../../../../../../dist/apps/test_api/bundle-x86"
  output_path = "\${path.module}/../../../../../../../dist/packages/common/terraform/apis/test-api/lambda.zip"
}


# Use the core HTTP API module
module "http_api" {
  source = "../../../core/api/http-api"

  api_name        = "TestApi"
  api_description = "TestApi HTTP API"
  stage_name      = "$default"
  stage_auto_deploy = true

  # CORS Configuration
  cors_allow_credentials = var.cors_allow_credentials
  cors_allow_headers     = var.cors_allow_headers
  cors_allow_methods     = var.cors_allow_methods
  cors_allow_origins     = var.cors_allow_origins
  cors_expose_headers    = var.cors_expose_headers
  cors_max_age           = var.cors_max_age

  # Tags
  tags = var.tags
}

# Lambda function
# This configures a single "router" lambda to serve all requests
resource "aws_lambda_function" "api_lambda" {
  #checkov:skip=CKV_AWS_117:Lambda function does not need to be in VPC for this use case
  #checkov:skip=CKV_AWS_116:Dead Letter Queue not required for this simple API use case
  #checkov:skip=CKV_AWS_272:Code signing not required for this use case
  #checkov:skip=CKV_AWS_115:Concurrent execution limit not required for this use case
  #checkov:skip=CKV_AWS_173:Lambda environment variables encrypted by managed key
  filename         = data.archive_file.lambda_zip.output_path
  function_name    = "TestApiHandler"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "proj_test_api.main.handler"
  runtime         = "python3.12"
  timeout         = 30
  memory_size     = 128

  source_code_hash = data.archive_file.lambda_zip.output_base64sha256

  # Enable X-Ray tracing
  tracing_config {
    mode = "Active"
  }

  environment {
    variables = merge({
      AWS_CONNECTION_REUSE_ENABLED = "1"
    }, var.env)
  }

  tags = var.tags
}

# IAM role for Lambda execution
resource "aws_iam_role" "lambda_execution_role" {
  name = "TestApiHandler-execution-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })

  tags = var.tags
}

# Attach basic execution policy to Lambda role
resource "aws_iam_role_policy_attachment" "lambda_basic_execution" {
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
  role       = aws_iam_role.lambda_execution_role.name
}

# Attach X-Ray tracing policy to Lambda role
resource "aws_iam_role_policy_attachment" "lambda_xray_execution" {
  policy_arn = "arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess"
  role       = aws_iam_role.lambda_execution_role.name
}

# Additional IAM policies for Lambda (if provided)
resource "aws_iam_role_policy" "lambda_additional_policies" {
  count = length(var.additional_iam_policy_statements) > 0 ? 1 : 0
  name  = "TestApiHandler-additional-policies"
  role  = aws_iam_role.lambda_execution_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = var.additional_iam_policy_statements
  })
}

# CloudWatch Log Group for Lambda
resource "aws_cloudwatch_log_group" "lambda_logs" {
  #checkov:skip=CKV_AWS_158:Using default CloudWatch log encryption
  #checkov:skip=CKV_AWS_338:Log retention set to forever
  #checkov:skip=CKV_AWS_66:Log retention set to forever
  name              = "/aws/lambda/TestApiHandler"
  tags              = var.tags
}


# Lambda integration for HTTP API
resource "aws_apigatewayv2_integration" "lambda_integration" {
  api_id           = module.http_api.api_id
  integration_type = "AWS_PROXY"
  integration_uri  = aws_lambda_function.api_lambda.invoke_arn

  payload_format_version = "2.0"
  timeout_milliseconds   = 30000

  depends_on = [aws_lambda_function.api_lambda]
}

# Route for proxy integration (catches all requests)
resource "aws_apigatewayv2_route" "proxy_routes" {
  # NB: OPTIONS is omitted here since API Gateway manages responding to preflight requests
  # when cors settings are configured
  for_each = toset(["GET", "POST", "PUT", "PATCH", "DELETE", "HEAD"])

  api_id    = module.http_api.api_id
  route_key = "\${each.key} /{proxy+}"
  target    = "integrations/\${aws_apigatewayv2_integration.lambda_integration.id}"

  # Note: you may wish to suppress the checkov rule CKV_AWS_309 if you are absolutely sure you
  # need a public API without authentication
  authorization_type = "NONE"

  depends_on = [aws_apigatewayv2_integration.lambda_integration]
}

# Add API url to runtime config
module "add_url_to_runtime_config" {
  source = "../../../core/runtime-config/entry"

  key_path = "apis.TestApi"
  value    = module.http_api.stage_invoke_url

  depends_on = [module.http_api]
}

# Lambda permission for API Gateway to invoke the function
resource "aws_lambda_permission" "api_gateway_invoke" {
  statement_id  = "AllowExecutionFromAPIGateway"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.api_lambda.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "\${module.http_api.api_execution_arn}/*/*"

  depends_on = [module.http_api, aws_lambda_function.api_lambda]
}

# Outputs

# API Gateway Outputs (from core module)
output "api_id" {
  description = "ID of the HTTP API Gateway"
  value       = module.http_api.api_id
}

output "api_arn" {
  description = "ARN of the HTTP API Gateway"
  value       = module.http_api.api_arn
}

output "api_endpoint" {
  description = "Base URL of the HTTP API Gateway"
  value       = module.http_api.api_endpoint
}

output "api_execution_arn" {
  description = "Execution ARN of the HTTP API Gateway"
  value       = module.http_api.api_execution_arn
}

output "stage_invoke_url" {
  description = "Invoke URL of the API Gateway stage"
  value       = module.http_api.stage_invoke_url
}

output "stage_arn" {
  description = "ARN of the API Gateway stage"
  value       = module.http_api.stage_arn
}

output "stage_execution_arn" {
  description = "Execution ARN of the API Gateway stage"
  value       = module.http_api.stage_execution_arn
}

# Lambda Function Outputs
output "lambda_function_name" {
  description = "Name of the Lambda function"
  value       = aws_lambda_function.api_lambda.function_name
}

output "lambda_function_arn" {
  description = "ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.arn
}

output "lambda_invoke_arn" {
  description = "Invoke ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.invoke_arn
}

output "lambda_qualified_arn" {
  description = "Qualified ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.qualified_arn
}

output "lambda_version" {
  description = "Version of the Lambda function"
  value       = aws_lambda_function.api_lambda.version
}

output "lambda_source_code_hash" {
  description = "Base64-encoded SHA256 hash of the Lambda deployment package"
  value       = aws_lambda_function.api_lambda.source_code_hash
}

output "lambda_source_code_size" {
  description = "Size of the Lambda deployment package in bytes"
  value       = aws_lambda_function.api_lambda.source_code_size
}

# IAM Role Outputs
output "lambda_execution_role_arn" {
  description = "ARN of the Lambda execution role"
  value       = aws_iam_role.lambda_execution_role.arn
}

output "lambda_execution_role_name" {
  description = "Name of the Lambda execution role"
  value       = aws_iam_role.lambda_execution_role.name
}

# Integration Outputs
output "integration_id" {
  description = "ID of the Lambda integration"
  value       = aws_apigatewayv2_integration.lambda_integration.id
}

# CloudWatch Log Groups
output "lambda_log_group_name" {
  description = "Name of the Lambda CloudWatch log group"
  value       = aws_cloudwatch_log_group.lambda_logs.name
}

output "lambda_log_group_arn" {
  description = "ARN of the Lambda CloudWatch log group"
  value       = aws_cloudwatch_log_group.lambda_logs.arn
}

output "api_log_group_name" {
  description = "Name of the API Gateway CloudWatch log group"
  value       = module.http_api.api_log_group_name
}

output "api_log_group_arn" {
  description = "ARN of the API Gateway CloudWatch log group"
  value       = module.http_api.api_log_group_arn
}",
}
`;

exports[`fastapi project generator > terraform iacProvider > should generate terraform files for REST API with Cognito auth and snapshot them > terraform-rest-cognito-files 1`] = `
{
  "rest-api.tf": "# Core REST API Gateway module
# This module creates the API Gateway REST API, deployment, stage, and logging resources

terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 6.0"
    }
  }
}

# Core REST API Gateway Variables

variable "api_name" {
  description = "Name of the REST API Gateway"
  type        = string
}

variable "api_description" {
  description = "Description of the REST API Gateway"
  type        = string
  default     = "REST API Gateway"
}

variable "stage_name" {
  description = "Name of the API Gateway stage"
  type        = string
  default     = "prod"
}

variable "stage_auto_deploy" {
  description = "Whether to automatically deploy the API stage"
  type        = bool
  default     = true
}

# CORS Configuration

variable "cors_allow_headers" {
  description = "List of allowed headers for CORS"
  type        = list(string)
  default     = ["authorization", "content-type", "x-amz-content-sha256", "x-amz-date", "x-amz-security-token"]
}

variable "cors_allow_methods" {
  description = "List of allowed HTTP methods for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_allow_origins" {
  description = "List of allowed origins for CORS"
  type        = list(string)
  default     = ["*"]
}

# Tags

variable "tags" {
  description = "Tags to apply to all resources"
  type        = map(string)
  default     = {}
}

# Data sources
data "aws_region" "current" {}
data "aws_caller_identity" "current" {}

# Resources

# Note: CloudWatch logging removed due to account-level CloudWatch Logs role ARN requirement

# REST API Gateway
resource "aws_api_gateway_rest_api" "rest_api" {
  name        = var.api_name
  description = var.api_description

  endpoint_configuration {
    types = ["REGIONAL"]
  }

  lifecycle {
    create_before_destroy = true
  }

  tags = var.tags
}

# Note: Deployment and stage are created in the consuming module (e.g., foo-api.tf)
# after all methods and integrations are defined

# Note: CloudWatch Log Group removed due to account-level CloudWatch Logs role ARN requirement

# Gateway Response for CORS (4XX errors)
resource "aws_api_gateway_gateway_response" "cors_4xx" {
  rest_api_id   = aws_api_gateway_rest_api.rest_api.id
  response_type = "DEFAULT_4XX"

  response_parameters = {
    "gatewayresponse.header.Access-Control-Allow-Origin"  = "'\${join(",", var.cors_allow_origins)}'"
    "gatewayresponse.header.Access-Control-Allow-Headers" = "'\${join(",", var.cors_allow_headers)}'"
    "gatewayresponse.header.Access-Control-Allow-Methods" = "'\${join(",", var.cors_allow_methods)}'"
  }
}

# Gateway Response for CORS (5XX errors)
resource "aws_api_gateway_gateway_response" "cors_5xx" {
  rest_api_id   = aws_api_gateway_rest_api.rest_api.id
  response_type = "DEFAULT_5XX"

  response_parameters = {
    "gatewayresponse.header.Access-Control-Allow-Origin"  = "'\${join(",", var.cors_allow_origins)}'"
    "gatewayresponse.header.Access-Control-Allow-Headers" = "'\${join(",", var.cors_allow_headers)}'"
    "gatewayresponse.header.Access-Control-Allow-Methods" = "'\${join(",", var.cors_allow_methods)}'"
  }
}

# Outputs

output "api_id" {
  description = "ID of the REST API Gateway"
  value       = aws_api_gateway_rest_api.rest_api.id
}

output "api_arn" {
  description = "ARN of the REST API Gateway"
  value       = aws_api_gateway_rest_api.rest_api.arn
}

output "api_endpoint" {
  description = "Base URL of the REST API Gateway"
  value       = "https://\${aws_api_gateway_rest_api.rest_api.id}.execute-api.\${data.aws_region.current.id}.amazonaws.com"
}

output "api_execution_arn" {
  description = "Execution ARN of the REST API Gateway"
  value       = aws_api_gateway_rest_api.rest_api.execution_arn
}

output "api_root_resource_id" {
  description = "Root resource ID of the REST API Gateway"
  value       = aws_api_gateway_rest_api.rest_api.root_resource_id
}

# Note: Stage and deployment outputs are provided by the consuming module

# Note: CloudWatch log group outputs removed due to account-level CloudWatch Logs role ARN requirement",
  "test-api.tf": "terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 6.0"
    }
  }
}

# Authentication Configuration
variable "user_pool_id" {
  description = "Cognito User Pool ID for authentication"
  type        = string
}

variable "user_pool_client_ids" {
  description = "List of Cognito User Pool Client IDs"
  type        = list(string)
}

variable "env" {
  description = "Environment variables for the Lambda function"
  type        = map(string)
  default     = {}
}

variable "additional_iam_policy_statements" {
  description = "Additional IAM policy statements for the Lambda function"
  type        = list(object({
    Effect   = string
    Action   = list(string)
    Resource = list(string)
  }))
  default = []
}

# CORS Configuration (passed to core module)

variable "cors_allow_headers" {
  description = "List of allowed headers for CORS"
  type        = list(string)
  default     = ["authorization", "content-type", "x-amz-content-sha256", "x-amz-date", "x-amz-security-token"]
}

variable "cors_allow_methods" {
  description = "List of allowed HTTP methods for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_allow_origins" {
  description = "List of allowed origins for CORS"
  type        = list(string)
  default     = ["*"]
}

# Tags
variable "tags" {
  description = "Tags to apply to all resources"
  type        = map(string)
  default     = {}
}

# Get current AWS region and account ID
data "aws_region" "current" {}
data "aws_caller_identity" "current" {}

# Resources

# Create Lambda ZIP file from the FastAPI bundle directory
data "archive_file" "lambda_zip" {
  type        = "zip"
  source_dir  = "\${path.module}/../../../../../../../dist/apps/test_api/bundle-x86"
  output_path = "\${path.module}/../../../../../../../dist/packages/common/terraform/apis/test-api/lambda.zip"
}

# Use the core REST API module
module "rest_api" {
  source = "../../../core/api/rest-api"

  api_name        = "TestApi"
  api_description = "TestApi REST API"
  stage_name      = "prod"
  stage_auto_deploy = true

  # CORS Configuration
  cors_allow_headers     = var.cors_allow_headers
  cors_allow_methods     = var.cors_allow_methods
  cors_allow_origins     = var.cors_allow_origins

  # Tags
  tags = var.tags
}

# Lambda function
resource "aws_lambda_function" "api_lambda" {
  #checkov:skip=CKV_AWS_117:Lambda function does not need to be in VPC for this use case
  #checkov:skip=CKV_AWS_116:Dead Letter Queue not required for this simple API use case
  #checkov:skip=CKV_AWS_272:Code signing not required for this use case
  #checkov:skip=CKV_AWS_115:Concurrent execution limit not required for this use case
  #checkov:skip=CKV_AWS_173:Lambda environment variables encrypted by managed key
  filename         = data.archive_file.lambda_zip.output_path
  function_name    = "TestApiHandler"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "proj_test_api.main.handler"
  runtime         = "python3.12"
  timeout         = 30
  memory_size     = 128

  source_code_hash = data.archive_file.lambda_zip.output_base64sha256

  # Enable X-Ray tracing
  tracing_config {
    mode = "Active"
  }

  environment {
    variables = merge({
      AWS_CONNECTION_REUSE_ENABLED = "1"
    }, var.env)
  }

  tags = var.tags
}

# IAM role for Lambda execution
resource "aws_iam_role" "lambda_execution_role" {
  name = "TestApiHandler-execution-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })

  tags = var.tags
}

# Attach basic execution policy to Lambda role
resource "aws_iam_role_policy_attachment" "lambda_basic_execution" {
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
  role       = aws_iam_role.lambda_execution_role.name
}

# Attach X-Ray tracing policy to Lambda role
resource "aws_iam_role_policy_attachment" "lambda_xray_execution" {
  policy_arn = "arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess"
  role       = aws_iam_role.lambda_execution_role.name
}

# Additional IAM policies for Lambda (if provided)
resource "aws_iam_role_policy" "lambda_additional_policies" {
  count = length(var.additional_iam_policy_statements) > 0 ? 1 : 0
  name  = "TestApiHandler-additional-policies"
  role  = aws_iam_role.lambda_execution_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = var.additional_iam_policy_statements
  })
}

# CloudWatch Log Group for Lambda
resource "aws_cloudwatch_log_group" "lambda_logs" {
  #checkov:skip=CKV_AWS_158:Using default CloudWatch log encryption
  #checkov:skip=CKV_AWS_338:Log retention set to forever
  #checkov:skip=CKV_AWS_66:Log retention set to forever
  name              = "/aws/lambda/TestApiHandler"
  tags              = var.tags
}

# Cognito User Pool Authorizer
resource "aws_api_gateway_authorizer" "cognito_authorizer" {
  name                   = "TestApiAuthorizer"
  rest_api_id           = module.rest_api.api_id
  type                  = "COGNITO_USER_POOLS"
  provider_arns         = ["arn:aws:cognito-idp:\${data.aws_region.current.name}:\${data.aws_caller_identity.current.account_id}:userpool/\${var.user_pool_id}"]
  identity_source       = "method.request.header.Authorization"
}

# Create proxy resource (captures all paths)
resource "aws_api_gateway_resource" "proxy_resource" {
  rest_api_id = module.rest_api.api_id
  parent_id   = module.rest_api.api_root_resource_id
  path_part   = "{proxy+}"
}

# Lambda integration for REST API
resource "aws_api_gateway_integration" "lambda_integration" {
  rest_api_id = module.rest_api.api_id
  resource_id = aws_api_gateway_resource.proxy_resource.id
  http_method = aws_api_gateway_method.proxy_method.http_method

  integration_http_method = "POST"
  type                   = "AWS_PROXY"
  uri                    = aws_lambda_function.api_lambda.invoke_arn

  depends_on = [aws_lambda_function.api_lambda]
}

# Method for proxy integration
resource "aws_api_gateway_method" "proxy_method" {
  #checkov:skip=CKV2_AWS_53:Request validation not required for proxy integration as Lambda handles validation
  rest_api_id   = module.rest_api.api_id
  resource_id   = aws_api_gateway_resource.proxy_resource.id
  http_method   = "ANY"

  authorization = "COGNITO_USER_POOLS"
  authorizer_id = aws_api_gateway_authorizer.cognito_authorizer.id

  request_parameters = {
    "method.request.path.proxy" = true
  }

  depends_on = [aws_api_gateway_authorizer.cognito_authorizer]
}

# OPTIONS method for CORS preflight
resource "aws_api_gateway_method" "options_method" {
  #checkov:skip=CKV2_AWS_70:OPTIONS method must be unauthenticated for CORS preflight requests
  #checkov:skip=CKV2_AWS_53:Request validation not required for OPTIONS CORS preflight method
  rest_api_id   = module.rest_api.api_id
  resource_id   = aws_api_gateway_resource.proxy_resource.id
  http_method   = "OPTIONS"
  authorization = "NONE"
}

# CORS integration for OPTIONS method
resource "aws_api_gateway_integration" "options_integration" {
  rest_api_id = module.rest_api.api_id
  resource_id = aws_api_gateway_resource.proxy_resource.id
  http_method = aws_api_gateway_method.options_method.http_method

  type = "MOCK"
  request_templates = {
    "application/json" = "{\\"statusCode\\": 204}"
  }
}

# OPTIONS method response
resource "aws_api_gateway_method_response" "options_response" {
  rest_api_id = module.rest_api.api_id
  resource_id = aws_api_gateway_resource.proxy_resource.id
  http_method = aws_api_gateway_method.options_method.http_method
  status_code = "204"

  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = true
    "method.response.header.Access-Control-Allow-Methods" = true
    "method.response.header.Access-Control-Allow-Origin"  = true
  }
}

# OPTIONS integration response
resource "aws_api_gateway_integration_response" "options_integration_response" {
  rest_api_id = module.rest_api.api_id
  resource_id = aws_api_gateway_resource.proxy_resource.id
  http_method = aws_api_gateway_method.options_method.http_method
  status_code = aws_api_gateway_method_response.options_response.status_code

  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = "'\${join(",", var.cors_allow_headers)}'"
    "method.response.header.Access-Control-Allow-Methods" = "'\${join(",", var.cors_allow_methods)}'"
    "method.response.header.Access-Control-Allow-Origin"  = "'\${join(",", var.cors_allow_origins)}'"
  }
}

# API Gateway deployment
resource "aws_api_gateway_deployment" "api_deployment" {
  rest_api_id = module.rest_api.api_id

  triggers = {
    redeployment = sha1(jsonencode([
      aws_api_gateway_resource.proxy_resource.id,
      aws_api_gateway_method.proxy_method.id,
      aws_api_gateway_integration.lambda_integration.id,
      aws_api_gateway_method.options_method.id,
      aws_api_gateway_integration.options_integration.id,
    ]))
  }

  lifecycle {
    create_before_destroy = true
  }

  depends_on = [
    aws_api_gateway_method.proxy_method,
    aws_api_gateway_integration.lambda_integration,
    aws_api_gateway_method.options_method,
    aws_api_gateway_integration.options_integration,
    aws_api_gateway_method_response.options_response,
    aws_api_gateway_integration_response.options_integration_response,
  ]
}

# API Gateway stage
resource "aws_api_gateway_stage" "api_stage" {
  #checkov:skip=CKV_AWS_120:API Gateway caching not required for this use case
  #checkov:skip=CKV_AWS_76:API Gateway access logging disabled due to account-level CloudWatch Logs role ARN requirement
  #checkov:skip=CKV2_AWS_4:API Gateway logging level not applicable as access logging is disabled
  #checkov:skip=CKV2_AWS_51:Client certificate authentication not required for this use case
  deployment_id        = aws_api_gateway_deployment.api_deployment.id
  rest_api_id          = module.rest_api.api_id
  stage_name           = "prod"
  xray_tracing_enabled = true

  tags = var.tags

  depends_on = [aws_api_gateway_deployment.api_deployment]
}

# API Gateway Resource Policy
resource "aws_api_gateway_rest_api_policy" "api_policy" {
  rest_api_id = module.rest_api.api_id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        # Allow all callers to invoke the API in the resource policy, since auth is handled by Cognito
        Effect = "Allow"
        Principal = "*"
        Action   = "execute-api:Invoke"
        Resource = "execute-api:/*"
      }
    ]
  })
}

# Lambda permission for API Gateway to invoke the function
resource "aws_lambda_permission" "api_gateway_invoke" {
  statement_id  = "AllowExecutionFromAPIGateway"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.api_lambda.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "\${module.rest_api.api_execution_arn}/*/*"

  depends_on = [module.rest_api, aws_lambda_function.api_lambda]
}

# Add API url to runtime config
module "add_url_to_runtime_config" {
  source = "../../../core/runtime-config/entry"

  key_path = "apis.TestApi"
  value    = aws_api_gateway_stage.api_stage.invoke_url

  depends_on = [aws_api_gateway_stage.api_stage]
}

# Outputs

# API Gateway Outputs (from core module)
output "api_id" {
  description = "ID of the REST API Gateway"
  value       = module.rest_api.api_id
}

output "api_arn" {
  description = "ARN of the REST API Gateway"
  value       = module.rest_api.api_arn
}

output "api_endpoint" {
  description = "Base URL of the REST API Gateway"
  value       = module.rest_api.api_endpoint
}

output "api_execution_arn" {
  description = "Execution ARN of the REST API Gateway"
  value       = module.rest_api.api_execution_arn
}

output "stage_invoke_url" {
  description = "Invoke URL of the API Gateway stage"
  value       = aws_api_gateway_stage.api_stage.invoke_url
}

output "stage_arn" {
  description = "ARN of the API Gateway stage"
  value       = aws_api_gateway_stage.api_stage.arn
}

output "stage_execution_arn" {
  description = "Execution ARN of the API Gateway stage"
  value       = aws_api_gateway_stage.api_stage.execution_arn
}

output "deployment_id" {
  description = "ID of the API Gateway deployment"
  value       = aws_api_gateway_deployment.api_deployment.id
}

output "stage_id" {
  description = "ID of the API Gateway stage"
  value       = aws_api_gateway_stage.api_stage.id
}

# Lambda Function Outputs
output "lambda_function_name" {
  description = "Name of the Lambda function"
  value       = aws_lambda_function.api_lambda.function_name
}

output "lambda_function_arn" {
  description = "ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.arn
}

output "lambda_invoke_arn" {
  description = "Invoke ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.invoke_arn
}

output "lambda_qualified_arn" {
  description = "Qualified ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.qualified_arn
}

output "lambda_version" {
  description = "Version of the Lambda function"
  value       = aws_lambda_function.api_lambda.version
}

output "lambda_source_code_hash" {
  description = "Base64-encoded SHA256 hash of the Lambda deployment package"
  value       = aws_lambda_function.api_lambda.source_code_hash
}

output "lambda_source_code_size" {
  description = "Size of the Lambda deployment package in bytes"
  value       = aws_lambda_function.api_lambda.source_code_size
}

# IAM Role Outputs
output "lambda_execution_role_arn" {
  description = "ARN of the Lambda execution role"
  value       = aws_iam_role.lambda_execution_role.arn
}

output "lambda_execution_role_name" {
  description = "Name of the Lambda execution role"
  value       = aws_iam_role.lambda_execution_role.name
}

# Integration Outputs
output "integration_id" {
  description = "ID of the Lambda integration"
  value       = aws_api_gateway_integration.lambda_integration.id
}

output "proxy_resource_id" {
  description = "ID of the proxy resource"
  value       = aws_api_gateway_resource.proxy_resource.id
}

output "proxy_method_id" {
  description = "ID of the proxy method"
  value       = aws_api_gateway_method.proxy_method.id
}

# CloudWatch Log Groups
output "lambda_log_group_name" {
  description = "Name of the Lambda CloudWatch log group"
  value       = aws_cloudwatch_log_group.lambda_logs.name
}

output "lambda_log_group_arn" {
  description = "ARN of the Lambda CloudWatch log group"
  value       = aws_cloudwatch_log_group.lambda_logs.arn
}
",
}
`;

exports[`fastapi project generator > terraform iacProvider > should generate terraform files for REST API with IAM auth and snapshot them > terraform-rest-iam-files 1`] = `
{
  "rest-api.tf": "# Core REST API Gateway module
# This module creates the API Gateway REST API, deployment, stage, and logging resources

terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 6.0"
    }
  }
}

# Core REST API Gateway Variables

variable "api_name" {
  description = "Name of the REST API Gateway"
  type        = string
}

variable "api_description" {
  description = "Description of the REST API Gateway"
  type        = string
  default     = "REST API Gateway"
}

variable "stage_name" {
  description = "Name of the API Gateway stage"
  type        = string
  default     = "prod"
}

variable "stage_auto_deploy" {
  description = "Whether to automatically deploy the API stage"
  type        = bool
  default     = true
}

# CORS Configuration

variable "cors_allow_headers" {
  description = "List of allowed headers for CORS"
  type        = list(string)
  default     = ["authorization", "content-type", "x-amz-content-sha256", "x-amz-date", "x-amz-security-token"]
}

variable "cors_allow_methods" {
  description = "List of allowed HTTP methods for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_allow_origins" {
  description = "List of allowed origins for CORS"
  type        = list(string)
  default     = ["*"]
}

# Tags

variable "tags" {
  description = "Tags to apply to all resources"
  type        = map(string)
  default     = {}
}

# Data sources
data "aws_region" "current" {}
data "aws_caller_identity" "current" {}

# Resources

# Note: CloudWatch logging removed due to account-level CloudWatch Logs role ARN requirement

# REST API Gateway
resource "aws_api_gateway_rest_api" "rest_api" {
  name        = var.api_name
  description = var.api_description

  endpoint_configuration {
    types = ["REGIONAL"]
  }

  lifecycle {
    create_before_destroy = true
  }

  tags = var.tags
}

# Note: Deployment and stage are created in the consuming module (e.g., foo-api.tf)
# after all methods and integrations are defined

# Note: CloudWatch Log Group removed due to account-level CloudWatch Logs role ARN requirement

# Gateway Response for CORS (4XX errors)
resource "aws_api_gateway_gateway_response" "cors_4xx" {
  rest_api_id   = aws_api_gateway_rest_api.rest_api.id
  response_type = "DEFAULT_4XX"

  response_parameters = {
    "gatewayresponse.header.Access-Control-Allow-Origin"  = "'\${join(",", var.cors_allow_origins)}'"
    "gatewayresponse.header.Access-Control-Allow-Headers" = "'\${join(",", var.cors_allow_headers)}'"
    "gatewayresponse.header.Access-Control-Allow-Methods" = "'\${join(",", var.cors_allow_methods)}'"
  }
}

# Gateway Response for CORS (5XX errors)
resource "aws_api_gateway_gateway_response" "cors_5xx" {
  rest_api_id   = aws_api_gateway_rest_api.rest_api.id
  response_type = "DEFAULT_5XX"

  response_parameters = {
    "gatewayresponse.header.Access-Control-Allow-Origin"  = "'\${join(",", var.cors_allow_origins)}'"
    "gatewayresponse.header.Access-Control-Allow-Headers" = "'\${join(",", var.cors_allow_headers)}'"
    "gatewayresponse.header.Access-Control-Allow-Methods" = "'\${join(",", var.cors_allow_methods)}'"
  }
}

# Outputs

output "api_id" {
  description = "ID of the REST API Gateway"
  value       = aws_api_gateway_rest_api.rest_api.id
}

output "api_arn" {
  description = "ARN of the REST API Gateway"
  value       = aws_api_gateway_rest_api.rest_api.arn
}

output "api_endpoint" {
  description = "Base URL of the REST API Gateway"
  value       = "https://\${aws_api_gateway_rest_api.rest_api.id}.execute-api.\${data.aws_region.current.id}.amazonaws.com"
}

output "api_execution_arn" {
  description = "Execution ARN of the REST API Gateway"
  value       = aws_api_gateway_rest_api.rest_api.execution_arn
}

output "api_root_resource_id" {
  description = "Root resource ID of the REST API Gateway"
  value       = aws_api_gateway_rest_api.rest_api.root_resource_id
}

# Note: Stage and deployment outputs are provided by the consuming module

# Note: CloudWatch log group outputs removed due to account-level CloudWatch Logs role ARN requirement",
  "test-api.tf": "terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 6.0"
    }
  }
}


variable "env" {
  description = "Environment variables for the Lambda function"
  type        = map(string)
  default     = {}
}

variable "additional_iam_policy_statements" {
  description = "Additional IAM policy statements for the Lambda function"
  type        = list(object({
    Effect   = string
    Action   = list(string)
    Resource = list(string)
  }))
  default = []
}

# CORS Configuration (passed to core module)

variable "cors_allow_headers" {
  description = "List of allowed headers for CORS"
  type        = list(string)
  default     = ["authorization", "content-type", "x-amz-content-sha256", "x-amz-date", "x-amz-security-token"]
}

variable "cors_allow_methods" {
  description = "List of allowed HTTP methods for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_allow_origins" {
  description = "List of allowed origins for CORS"
  type        = list(string)
  default     = ["*"]
}

# Tags
variable "tags" {
  description = "Tags to apply to all resources"
  type        = map(string)
  default     = {}
}

# Get current AWS region and account ID
data "aws_region" "current" {}
data "aws_caller_identity" "current" {}

# Resources

# Create Lambda ZIP file from the FastAPI bundle directory
data "archive_file" "lambda_zip" {
  type        = "zip"
  source_dir  = "\${path.module}/../../../../../../../dist/apps/test_api/bundle-x86"
  output_path = "\${path.module}/../../../../../../../dist/packages/common/terraform/apis/test-api/lambda.zip"
}

# Use the core REST API module
module "rest_api" {
  source = "../../../core/api/rest-api"

  api_name        = "TestApi"
  api_description = "TestApi REST API"
  stage_name      = "prod"
  stage_auto_deploy = true

  # CORS Configuration
  cors_allow_headers     = var.cors_allow_headers
  cors_allow_methods     = var.cors_allow_methods
  cors_allow_origins     = var.cors_allow_origins

  # Tags
  tags = var.tags
}

# Lambda function
resource "aws_lambda_function" "api_lambda" {
  #checkov:skip=CKV_AWS_117:Lambda function does not need to be in VPC for this use case
  #checkov:skip=CKV_AWS_116:Dead Letter Queue not required for this simple API use case
  #checkov:skip=CKV_AWS_272:Code signing not required for this use case
  #checkov:skip=CKV_AWS_115:Concurrent execution limit not required for this use case
  #checkov:skip=CKV_AWS_173:Lambda environment variables encrypted by managed key
  filename         = data.archive_file.lambda_zip.output_path
  function_name    = "TestApiHandler"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "proj_test_api.main.handler"
  runtime         = "python3.12"
  timeout         = 30
  memory_size     = 128

  source_code_hash = data.archive_file.lambda_zip.output_base64sha256

  # Enable X-Ray tracing
  tracing_config {
    mode = "Active"
  }

  environment {
    variables = merge({
      AWS_CONNECTION_REUSE_ENABLED = "1"
    }, var.env)
  }

  tags = var.tags
}

# IAM role for Lambda execution
resource "aws_iam_role" "lambda_execution_role" {
  name = "TestApiHandler-execution-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })

  tags = var.tags
}

# Attach basic execution policy to Lambda role
resource "aws_iam_role_policy_attachment" "lambda_basic_execution" {
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
  role       = aws_iam_role.lambda_execution_role.name
}

# Attach X-Ray tracing policy to Lambda role
resource "aws_iam_role_policy_attachment" "lambda_xray_execution" {
  policy_arn = "arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess"
  role       = aws_iam_role.lambda_execution_role.name
}

# Additional IAM policies for Lambda (if provided)
resource "aws_iam_role_policy" "lambda_additional_policies" {
  count = length(var.additional_iam_policy_statements) > 0 ? 1 : 0
  name  = "TestApiHandler-additional-policies"
  role  = aws_iam_role.lambda_execution_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = var.additional_iam_policy_statements
  })
}

# CloudWatch Log Group for Lambda
resource "aws_cloudwatch_log_group" "lambda_logs" {
  #checkov:skip=CKV_AWS_158:Using default CloudWatch log encryption
  #checkov:skip=CKV_AWS_338:Log retention set to forever
  #checkov:skip=CKV_AWS_66:Log retention set to forever
  name              = "/aws/lambda/TestApiHandler"
  tags              = var.tags
}


# Create proxy resource (captures all paths)
resource "aws_api_gateway_resource" "proxy_resource" {
  rest_api_id = module.rest_api.api_id
  parent_id   = module.rest_api.api_root_resource_id
  path_part   = "{proxy+}"
}

# Lambda integration for REST API
resource "aws_api_gateway_integration" "lambda_integration" {
  rest_api_id = module.rest_api.api_id
  resource_id = aws_api_gateway_resource.proxy_resource.id
  http_method = aws_api_gateway_method.proxy_method.http_method

  integration_http_method = "POST"
  type                   = "AWS_PROXY"
  uri                    = aws_lambda_function.api_lambda.invoke_arn

  depends_on = [aws_lambda_function.api_lambda]
}

# Method for proxy integration
resource "aws_api_gateway_method" "proxy_method" {
  #checkov:skip=CKV2_AWS_53:Request validation not required for proxy integration as Lambda handles validation
  rest_api_id   = module.rest_api.api_id
  resource_id   = aws_api_gateway_resource.proxy_resource.id
  http_method   = "ANY"

  authorization = "AWS_IAM"

  request_parameters = {
    "method.request.path.proxy" = true
  }

  depends_on = []
}

# OPTIONS method for CORS preflight
resource "aws_api_gateway_method" "options_method" {
  #checkov:skip=CKV2_AWS_70:OPTIONS method must be unauthenticated for CORS preflight requests
  #checkov:skip=CKV2_AWS_53:Request validation not required for OPTIONS CORS preflight method
  rest_api_id   = module.rest_api.api_id
  resource_id   = aws_api_gateway_resource.proxy_resource.id
  http_method   = "OPTIONS"
  authorization = "NONE"
}

# CORS integration for OPTIONS method
resource "aws_api_gateway_integration" "options_integration" {
  rest_api_id = module.rest_api.api_id
  resource_id = aws_api_gateway_resource.proxy_resource.id
  http_method = aws_api_gateway_method.options_method.http_method

  type = "MOCK"
  request_templates = {
    "application/json" = "{\\"statusCode\\": 204}"
  }
}

# OPTIONS method response
resource "aws_api_gateway_method_response" "options_response" {
  rest_api_id = module.rest_api.api_id
  resource_id = aws_api_gateway_resource.proxy_resource.id
  http_method = aws_api_gateway_method.options_method.http_method
  status_code = "204"

  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = true
    "method.response.header.Access-Control-Allow-Methods" = true
    "method.response.header.Access-Control-Allow-Origin"  = true
  }
}

# OPTIONS integration response
resource "aws_api_gateway_integration_response" "options_integration_response" {
  rest_api_id = module.rest_api.api_id
  resource_id = aws_api_gateway_resource.proxy_resource.id
  http_method = aws_api_gateway_method.options_method.http_method
  status_code = aws_api_gateway_method_response.options_response.status_code

  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = "'\${join(",", var.cors_allow_headers)}'"
    "method.response.header.Access-Control-Allow-Methods" = "'\${join(",", var.cors_allow_methods)}'"
    "method.response.header.Access-Control-Allow-Origin"  = "'\${join(",", var.cors_allow_origins)}'"
  }
}

# API Gateway deployment
resource "aws_api_gateway_deployment" "api_deployment" {
  rest_api_id = module.rest_api.api_id

  triggers = {
    redeployment = sha1(jsonencode([
      aws_api_gateway_resource.proxy_resource.id,
      aws_api_gateway_method.proxy_method.id,
      aws_api_gateway_integration.lambda_integration.id,
      aws_api_gateway_method.options_method.id,
      aws_api_gateway_integration.options_integration.id,
    ]))
  }

  lifecycle {
    create_before_destroy = true
  }

  depends_on = [
    aws_api_gateway_method.proxy_method,
    aws_api_gateway_integration.lambda_integration,
    aws_api_gateway_method.options_method,
    aws_api_gateway_integration.options_integration,
    aws_api_gateway_method_response.options_response,
    aws_api_gateway_integration_response.options_integration_response,
  ]
}

# API Gateway stage
resource "aws_api_gateway_stage" "api_stage" {
  #checkov:skip=CKV_AWS_120:API Gateway caching not required for this use case
  #checkov:skip=CKV_AWS_76:API Gateway access logging disabled due to account-level CloudWatch Logs role ARN requirement
  #checkov:skip=CKV2_AWS_4:API Gateway logging level not applicable as access logging is disabled
  #checkov:skip=CKV2_AWS_51:Client certificate authentication not required for this use case
  deployment_id        = aws_api_gateway_deployment.api_deployment.id
  rest_api_id          = module.rest_api.api_id
  stage_name           = "prod"
  xray_tracing_enabled = true

  tags = var.tags

  depends_on = [aws_api_gateway_deployment.api_deployment]
}

# API Gateway Resource Policy
resource "aws_api_gateway_rest_api_policy" "api_policy" {
  rest_api_id = module.rest_api.api_id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        # Grant any AWS credentials from the account to call the API
        # Machine to machine fine-grained access can be defined here using more specific principals
        # (eg roles or users) and resources (eg which api paths may be invoked by which principal) if required
        Effect = "Allow"
        Principal = {
          AWS = "arn:aws:iam::\${data.aws_caller_identity.current.account_id}:root"
        }
        Action   = "execute-api:Invoke"
        Resource = "execute-api:/*"
      },
      {
        # Open up OPTIONS to allow browsers to make unauthenticated preflight requests
        Effect = "Allow"
        Principal = "*"
        Action   = "execute-api:Invoke"
        Resource = "execute-api:/*/OPTIONS/*"
      }
    ]
  })
}

# Lambda permission for API Gateway to invoke the function
resource "aws_lambda_permission" "api_gateway_invoke" {
  statement_id  = "AllowExecutionFromAPIGateway"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.api_lambda.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "\${module.rest_api.api_execution_arn}/*/*"

  depends_on = [module.rest_api, aws_lambda_function.api_lambda]
}

# Add API url to runtime config
module "add_url_to_runtime_config" {
  source = "../../../core/runtime-config/entry"

  key_path = "apis.TestApi"
  value    = aws_api_gateway_stage.api_stage.invoke_url

  depends_on = [aws_api_gateway_stage.api_stage]
}

# Outputs

# API Gateway Outputs (from core module)
output "api_id" {
  description = "ID of the REST API Gateway"
  value       = module.rest_api.api_id
}

output "api_arn" {
  description = "ARN of the REST API Gateway"
  value       = module.rest_api.api_arn
}

output "api_endpoint" {
  description = "Base URL of the REST API Gateway"
  value       = module.rest_api.api_endpoint
}

output "api_execution_arn" {
  description = "Execution ARN of the REST API Gateway"
  value       = module.rest_api.api_execution_arn
}

output "stage_invoke_url" {
  description = "Invoke URL of the API Gateway stage"
  value       = aws_api_gateway_stage.api_stage.invoke_url
}

output "stage_arn" {
  description = "ARN of the API Gateway stage"
  value       = aws_api_gateway_stage.api_stage.arn
}

output "stage_execution_arn" {
  description = "Execution ARN of the API Gateway stage"
  value       = aws_api_gateway_stage.api_stage.execution_arn
}

output "deployment_id" {
  description = "ID of the API Gateway deployment"
  value       = aws_api_gateway_deployment.api_deployment.id
}

output "stage_id" {
  description = "ID of the API Gateway stage"
  value       = aws_api_gateway_stage.api_stage.id
}

# Lambda Function Outputs
output "lambda_function_name" {
  description = "Name of the Lambda function"
  value       = aws_lambda_function.api_lambda.function_name
}

output "lambda_function_arn" {
  description = "ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.arn
}

output "lambda_invoke_arn" {
  description = "Invoke ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.invoke_arn
}

output "lambda_qualified_arn" {
  description = "Qualified ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.qualified_arn
}

output "lambda_version" {
  description = "Version of the Lambda function"
  value       = aws_lambda_function.api_lambda.version
}

output "lambda_source_code_hash" {
  description = "Base64-encoded SHA256 hash of the Lambda deployment package"
  value       = aws_lambda_function.api_lambda.source_code_hash
}

output "lambda_source_code_size" {
  description = "Size of the Lambda deployment package in bytes"
  value       = aws_lambda_function.api_lambda.source_code_size
}

# IAM Role Outputs
output "lambda_execution_role_arn" {
  description = "ARN of the Lambda execution role"
  value       = aws_iam_role.lambda_execution_role.arn
}

output "lambda_execution_role_name" {
  description = "Name of the Lambda execution role"
  value       = aws_iam_role.lambda_execution_role.name
}

# Integration Outputs
output "integration_id" {
  description = "ID of the Lambda integration"
  value       = aws_api_gateway_integration.lambda_integration.id
}

output "proxy_resource_id" {
  description = "ID of the proxy resource"
  value       = aws_api_gateway_resource.proxy_resource.id
}

output "proxy_method_id" {
  description = "ID of the proxy method"
  value       = aws_api_gateway_method.proxy_method.id
}

# CloudWatch Log Groups
output "lambda_log_group_name" {
  description = "Name of the Lambda CloudWatch log group"
  value       = aws_cloudwatch_log_group.lambda_logs.name
}

output "lambda_log_group_arn" {
  description = "ARN of the Lambda CloudWatch log group"
  value       = aws_cloudwatch_log_group.lambda_logs.arn
}
",
}
`;

exports[`fastapi project generator > terraform iacProvider > should generate terraform files for REST API with None auth and snapshot them > terraform-rest-none-files 1`] = `
{
  "rest-api.tf": "# Core REST API Gateway module
# This module creates the API Gateway REST API, deployment, stage, and logging resources

terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 6.0"
    }
  }
}

# Core REST API Gateway Variables

variable "api_name" {
  description = "Name of the REST API Gateway"
  type        = string
}

variable "api_description" {
  description = "Description of the REST API Gateway"
  type        = string
  default     = "REST API Gateway"
}

variable "stage_name" {
  description = "Name of the API Gateway stage"
  type        = string
  default     = "prod"
}

variable "stage_auto_deploy" {
  description = "Whether to automatically deploy the API stage"
  type        = bool
  default     = true
}

# CORS Configuration

variable "cors_allow_headers" {
  description = "List of allowed headers for CORS"
  type        = list(string)
  default     = ["authorization", "content-type", "x-amz-content-sha256", "x-amz-date", "x-amz-security-token"]
}

variable "cors_allow_methods" {
  description = "List of allowed HTTP methods for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_allow_origins" {
  description = "List of allowed origins for CORS"
  type        = list(string)
  default     = ["*"]
}

# Tags

variable "tags" {
  description = "Tags to apply to all resources"
  type        = map(string)
  default     = {}
}

# Data sources
data "aws_region" "current" {}
data "aws_caller_identity" "current" {}

# Resources

# Note: CloudWatch logging removed due to account-level CloudWatch Logs role ARN requirement

# REST API Gateway
resource "aws_api_gateway_rest_api" "rest_api" {
  name        = var.api_name
  description = var.api_description

  endpoint_configuration {
    types = ["REGIONAL"]
  }

  lifecycle {
    create_before_destroy = true
  }

  tags = var.tags
}

# Note: Deployment and stage are created in the consuming module (e.g., foo-api.tf)
# after all methods and integrations are defined

# Note: CloudWatch Log Group removed due to account-level CloudWatch Logs role ARN requirement

# Gateway Response for CORS (4XX errors)
resource "aws_api_gateway_gateway_response" "cors_4xx" {
  rest_api_id   = aws_api_gateway_rest_api.rest_api.id
  response_type = "DEFAULT_4XX"

  response_parameters = {
    "gatewayresponse.header.Access-Control-Allow-Origin"  = "'\${join(",", var.cors_allow_origins)}'"
    "gatewayresponse.header.Access-Control-Allow-Headers" = "'\${join(",", var.cors_allow_headers)}'"
    "gatewayresponse.header.Access-Control-Allow-Methods" = "'\${join(",", var.cors_allow_methods)}'"
  }
}

# Gateway Response for CORS (5XX errors)
resource "aws_api_gateway_gateway_response" "cors_5xx" {
  rest_api_id   = aws_api_gateway_rest_api.rest_api.id
  response_type = "DEFAULT_5XX"

  response_parameters = {
    "gatewayresponse.header.Access-Control-Allow-Origin"  = "'\${join(",", var.cors_allow_origins)}'"
    "gatewayresponse.header.Access-Control-Allow-Headers" = "'\${join(",", var.cors_allow_headers)}'"
    "gatewayresponse.header.Access-Control-Allow-Methods" = "'\${join(",", var.cors_allow_methods)}'"
  }
}

# Outputs

output "api_id" {
  description = "ID of the REST API Gateway"
  value       = aws_api_gateway_rest_api.rest_api.id
}

output "api_arn" {
  description = "ARN of the REST API Gateway"
  value       = aws_api_gateway_rest_api.rest_api.arn
}

output "api_endpoint" {
  description = "Base URL of the REST API Gateway"
  value       = "https://\${aws_api_gateway_rest_api.rest_api.id}.execute-api.\${data.aws_region.current.id}.amazonaws.com"
}

output "api_execution_arn" {
  description = "Execution ARN of the REST API Gateway"
  value       = aws_api_gateway_rest_api.rest_api.execution_arn
}

output "api_root_resource_id" {
  description = "Root resource ID of the REST API Gateway"
  value       = aws_api_gateway_rest_api.rest_api.root_resource_id
}

# Note: Stage and deployment outputs are provided by the consuming module

# Note: CloudWatch log group outputs removed due to account-level CloudWatch Logs role ARN requirement",
  "test-api.tf": "terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 6.0"
    }
  }
}


variable "env" {
  description = "Environment variables for the Lambda function"
  type        = map(string)
  default     = {}
}

variable "additional_iam_policy_statements" {
  description = "Additional IAM policy statements for the Lambda function"
  type        = list(object({
    Effect   = string
    Action   = list(string)
    Resource = list(string)
  }))
  default = []
}

# CORS Configuration (passed to core module)

variable "cors_allow_headers" {
  description = "List of allowed headers for CORS"
  type        = list(string)
  default     = ["authorization", "content-type", "x-amz-content-sha256", "x-amz-date", "x-amz-security-token"]
}

variable "cors_allow_methods" {
  description = "List of allowed HTTP methods for CORS"
  type        = list(string)
  default     = ["*"]
}

variable "cors_allow_origins" {
  description = "List of allowed origins for CORS"
  type        = list(string)
  default     = ["*"]
}

# Tags
variable "tags" {
  description = "Tags to apply to all resources"
  type        = map(string)
  default     = {}
}

# Get current AWS region and account ID
data "aws_region" "current" {}
data "aws_caller_identity" "current" {}

# Resources

# Create Lambda ZIP file from the FastAPI bundle directory
data "archive_file" "lambda_zip" {
  type        = "zip"
  source_dir  = "\${path.module}/../../../../../../../dist/apps/test_api/bundle-x86"
  output_path = "\${path.module}/../../../../../../../dist/packages/common/terraform/apis/test-api/lambda.zip"
}

# Use the core REST API module
module "rest_api" {
  source = "../../../core/api/rest-api"

  api_name        = "TestApi"
  api_description = "TestApi REST API"
  stage_name      = "prod"
  stage_auto_deploy = true

  # CORS Configuration
  cors_allow_headers     = var.cors_allow_headers
  cors_allow_methods     = var.cors_allow_methods
  cors_allow_origins     = var.cors_allow_origins

  # Tags
  tags = var.tags
}

# Lambda function
resource "aws_lambda_function" "api_lambda" {
  #checkov:skip=CKV_AWS_117:Lambda function does not need to be in VPC for this use case
  #checkov:skip=CKV_AWS_116:Dead Letter Queue not required for this simple API use case
  #checkov:skip=CKV_AWS_272:Code signing not required for this use case
  #checkov:skip=CKV_AWS_115:Concurrent execution limit not required for this use case
  #checkov:skip=CKV_AWS_173:Lambda environment variables encrypted by managed key
  filename         = data.archive_file.lambda_zip.output_path
  function_name    = "TestApiHandler"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "proj_test_api.main.handler"
  runtime         = "python3.12"
  timeout         = 30
  memory_size     = 128

  source_code_hash = data.archive_file.lambda_zip.output_base64sha256

  # Enable X-Ray tracing
  tracing_config {
    mode = "Active"
  }

  environment {
    variables = merge({
      AWS_CONNECTION_REUSE_ENABLED = "1"
    }, var.env)
  }

  tags = var.tags
}

# IAM role for Lambda execution
resource "aws_iam_role" "lambda_execution_role" {
  name = "TestApiHandler-execution-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })

  tags = var.tags
}

# Attach basic execution policy to Lambda role
resource "aws_iam_role_policy_attachment" "lambda_basic_execution" {
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
  role       = aws_iam_role.lambda_execution_role.name
}

# Attach X-Ray tracing policy to Lambda role
resource "aws_iam_role_policy_attachment" "lambda_xray_execution" {
  policy_arn = "arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess"
  role       = aws_iam_role.lambda_execution_role.name
}

# Additional IAM policies for Lambda (if provided)
resource "aws_iam_role_policy" "lambda_additional_policies" {
  count = length(var.additional_iam_policy_statements) > 0 ? 1 : 0
  name  = "TestApiHandler-additional-policies"
  role  = aws_iam_role.lambda_execution_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = var.additional_iam_policy_statements
  })
}

# CloudWatch Log Group for Lambda
resource "aws_cloudwatch_log_group" "lambda_logs" {
  #checkov:skip=CKV_AWS_158:Using default CloudWatch log encryption
  #checkov:skip=CKV_AWS_338:Log retention set to forever
  #checkov:skip=CKV_AWS_66:Log retention set to forever
  name              = "/aws/lambda/TestApiHandler"
  tags              = var.tags
}


# Create proxy resource (captures all paths)
resource "aws_api_gateway_resource" "proxy_resource" {
  rest_api_id = module.rest_api.api_id
  parent_id   = module.rest_api.api_root_resource_id
  path_part   = "{proxy+}"
}

# Lambda integration for REST API
resource "aws_api_gateway_integration" "lambda_integration" {
  rest_api_id = module.rest_api.api_id
  resource_id = aws_api_gateway_resource.proxy_resource.id
  http_method = aws_api_gateway_method.proxy_method.http_method

  integration_http_method = "POST"
  type                   = "AWS_PROXY"
  uri                    = aws_lambda_function.api_lambda.invoke_arn

  depends_on = [aws_lambda_function.api_lambda]
}

# Method for proxy integration
resource "aws_api_gateway_method" "proxy_method" {
  #checkov:skip=CKV2_AWS_53:Request validation not required for proxy integration as Lambda handles validation
  rest_api_id   = module.rest_api.api_id
  resource_id   = aws_api_gateway_resource.proxy_resource.id
  http_method   = "ANY"

  # Note: you may wish to suppress the checkov rule CKV_AWS_59 if you are absolutely sure you
  # need a public API without authentication
  authorization = "NONE"

  request_parameters = {
    "method.request.path.proxy" = true
  }

  depends_on = []
}

# OPTIONS method for CORS preflight
resource "aws_api_gateway_method" "options_method" {
  #checkov:skip=CKV2_AWS_70:OPTIONS method must be unauthenticated for CORS preflight requests
  #checkov:skip=CKV2_AWS_53:Request validation not required for OPTIONS CORS preflight method
  rest_api_id   = module.rest_api.api_id
  resource_id   = aws_api_gateway_resource.proxy_resource.id
  http_method   = "OPTIONS"
  authorization = "NONE"
}

# CORS integration for OPTIONS method
resource "aws_api_gateway_integration" "options_integration" {
  rest_api_id = module.rest_api.api_id
  resource_id = aws_api_gateway_resource.proxy_resource.id
  http_method = aws_api_gateway_method.options_method.http_method

  type = "MOCK"
  request_templates = {
    "application/json" = "{\\"statusCode\\": 204}"
  }
}

# OPTIONS method response
resource "aws_api_gateway_method_response" "options_response" {
  rest_api_id = module.rest_api.api_id
  resource_id = aws_api_gateway_resource.proxy_resource.id
  http_method = aws_api_gateway_method.options_method.http_method
  status_code = "204"

  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = true
    "method.response.header.Access-Control-Allow-Methods" = true
    "method.response.header.Access-Control-Allow-Origin"  = true
  }
}

# OPTIONS integration response
resource "aws_api_gateway_integration_response" "options_integration_response" {
  rest_api_id = module.rest_api.api_id
  resource_id = aws_api_gateway_resource.proxy_resource.id
  http_method = aws_api_gateway_method.options_method.http_method
  status_code = aws_api_gateway_method_response.options_response.status_code

  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = "'\${join(",", var.cors_allow_headers)}'"
    "method.response.header.Access-Control-Allow-Methods" = "'\${join(",", var.cors_allow_methods)}'"
    "method.response.header.Access-Control-Allow-Origin"  = "'\${join(",", var.cors_allow_origins)}'"
  }
}

# API Gateway deployment
resource "aws_api_gateway_deployment" "api_deployment" {
  rest_api_id = module.rest_api.api_id

  triggers = {
    redeployment = sha1(jsonencode([
      aws_api_gateway_resource.proxy_resource.id,
      aws_api_gateway_method.proxy_method.id,
      aws_api_gateway_integration.lambda_integration.id,
      aws_api_gateway_method.options_method.id,
      aws_api_gateway_integration.options_integration.id,
    ]))
  }

  lifecycle {
    create_before_destroy = true
  }

  depends_on = [
    aws_api_gateway_method.proxy_method,
    aws_api_gateway_integration.lambda_integration,
    aws_api_gateway_method.options_method,
    aws_api_gateway_integration.options_integration,
    aws_api_gateway_method_response.options_response,
    aws_api_gateway_integration_response.options_integration_response,
  ]
}

# API Gateway stage
resource "aws_api_gateway_stage" "api_stage" {
  #checkov:skip=CKV_AWS_120:API Gateway caching not required for this use case
  #checkov:skip=CKV_AWS_76:API Gateway access logging disabled due to account-level CloudWatch Logs role ARN requirement
  #checkov:skip=CKV2_AWS_4:API Gateway logging level not applicable as access logging is disabled
  #checkov:skip=CKV2_AWS_51:Client certificate authentication not required for this use case
  deployment_id        = aws_api_gateway_deployment.api_deployment.id
  rest_api_id          = module.rest_api.api_id
  stage_name           = "prod"
  xray_tracing_enabled = true

  tags = var.tags

  depends_on = [aws_api_gateway_deployment.api_deployment]
}

# API Gateway Resource Policy
resource "aws_api_gateway_rest_api_policy" "api_policy" {
  rest_api_id = module.rest_api.api_id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        # Allow all callers to invoke the API in the resource policy
        Effect = "Allow"
        Principal = "*"
        Action   = "execute-api:Invoke"
        Resource = "execute-api:/*"
      }
    ]
  })
}

# Lambda permission for API Gateway to invoke the function
resource "aws_lambda_permission" "api_gateway_invoke" {
  statement_id  = "AllowExecutionFromAPIGateway"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.api_lambda.function_name
  principal     = "apigateway.amazonaws.com"
  source_arn    = "\${module.rest_api.api_execution_arn}/*/*"

  depends_on = [module.rest_api, aws_lambda_function.api_lambda]
}

# Add API url to runtime config
module "add_url_to_runtime_config" {
  source = "../../../core/runtime-config/entry"

  key_path = "apis.TestApi"
  value    = aws_api_gateway_stage.api_stage.invoke_url

  depends_on = [aws_api_gateway_stage.api_stage]
}

# Outputs

# API Gateway Outputs (from core module)
output "api_id" {
  description = "ID of the REST API Gateway"
  value       = module.rest_api.api_id
}

output "api_arn" {
  description = "ARN of the REST API Gateway"
  value       = module.rest_api.api_arn
}

output "api_endpoint" {
  description = "Base URL of the REST API Gateway"
  value       = module.rest_api.api_endpoint
}

output "api_execution_arn" {
  description = "Execution ARN of the REST API Gateway"
  value       = module.rest_api.api_execution_arn
}

output "stage_invoke_url" {
  description = "Invoke URL of the API Gateway stage"
  value       = aws_api_gateway_stage.api_stage.invoke_url
}

output "stage_arn" {
  description = "ARN of the API Gateway stage"
  value       = aws_api_gateway_stage.api_stage.arn
}

output "stage_execution_arn" {
  description = "Execution ARN of the API Gateway stage"
  value       = aws_api_gateway_stage.api_stage.execution_arn
}

output "deployment_id" {
  description = "ID of the API Gateway deployment"
  value       = aws_api_gateway_deployment.api_deployment.id
}

output "stage_id" {
  description = "ID of the API Gateway stage"
  value       = aws_api_gateway_stage.api_stage.id
}

# Lambda Function Outputs
output "lambda_function_name" {
  description = "Name of the Lambda function"
  value       = aws_lambda_function.api_lambda.function_name
}

output "lambda_function_arn" {
  description = "ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.arn
}

output "lambda_invoke_arn" {
  description = "Invoke ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.invoke_arn
}

output "lambda_qualified_arn" {
  description = "Qualified ARN of the Lambda function"
  value       = aws_lambda_function.api_lambda.qualified_arn
}

output "lambda_version" {
  description = "Version of the Lambda function"
  value       = aws_lambda_function.api_lambda.version
}

output "lambda_source_code_hash" {
  description = "Base64-encoded SHA256 hash of the Lambda deployment package"
  value       = aws_lambda_function.api_lambda.source_code_hash
}

output "lambda_source_code_size" {
  description = "Size of the Lambda deployment package in bytes"
  value       = aws_lambda_function.api_lambda.source_code_size
}

# IAM Role Outputs
output "lambda_execution_role_arn" {
  description = "ARN of the Lambda execution role"
  value       = aws_iam_role.lambda_execution_role.arn
}

output "lambda_execution_role_name" {
  description = "Name of the Lambda execution role"
  value       = aws_iam_role.lambda_execution_role.name
}

# Integration Outputs
output "integration_id" {
  description = "ID of the Lambda integration"
  value       = aws_api_gateway_integration.lambda_integration.id
}

output "proxy_resource_id" {
  description = "ID of the proxy resource"
  value       = aws_api_gateway_resource.proxy_resource.id
}

output "proxy_method_id" {
  description = "ID of the proxy method"
  value       = aws_api_gateway_method.proxy_method.id
}

# CloudWatch Log Groups
output "lambda_log_group_name" {
  description = "Name of the Lambda CloudWatch log group"
  value       = aws_cloudwatch_log_group.lambda_logs.name
}

output "lambda_log_group_arn" {
  description = "ARN of the Lambda CloudWatch log group"
  value       = aws_cloudwatch_log_group.lambda_logs.arn
}
",
}
`;
