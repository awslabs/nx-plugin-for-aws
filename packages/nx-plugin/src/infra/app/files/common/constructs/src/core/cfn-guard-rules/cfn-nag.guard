#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    ENCRYPTED_VOLUMES
#
# Description:
#    Checks if the EBS volumes that are in an attached state are encrypted. 
#
# Reports on:
#    AWS::EC2::Volume
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   F1
#
# Scenarios:
# a) SKIP: when there are no EBS volume resources present
# b) PASS: when all EBS volumes have the KmsKeyId property set or the Encrypted property set to true 
# c) FAIL: when any EC2 volumes do not have the KmsKeyId or Encrypted property set
# e) SKIP: hen metadata includes the suppression for rule ENCRYPTED_VOLUMES

#
# Select all EC2 Instance resources from incoming template (payload)
#
let ebs_volumes_encrypted = Resources.*[ Type == 'AWS::EC2::Volume' 
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "F1"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ENCRYPTED_VOLUMES"
]

rule ENCRYPTED_VOLUMES when %ebs_volumes_encrypted !empty {
  let violations = %ebs_volumes_encrypted[
    Properties.KmsKeyId empty
    Properties.Encrypted !exists
    or Properties.Encrypted != true
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F1    
    Violation: EBS volumes in an attached state must be encrypted.
    Fix: Set the KmsKeyId property to a key ID, key alias, key ARN, or alias ARN 
		or set the Encrypted property to true to encrypt the volume with the account default key or AWS managed key. 
  >>
}
#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   IAM_ROLE_NO_FULL_ACCESS_ON_TRUST_POLICY
#
# Description:
#   Checks if AWS Identity and Access Management (IAM) roles grant permissions to all actions in the trust policy.
#
# Reports on:
#   AWS::IAM::Role
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
# 
# CFN_NAG Rule Id:
#   F2
#
# Scenarios:
# a) SKIP: when there are no IAM Roles present
# b) PASS: when all IAM Roles do not allow full access to at least 1 AWS service
# c) FAIL: when any IAM Role allows full access to at least 1 AWS service.
# d) SKIP: when metada has rule suppression for IAM_ROLE_NO_FULL_ACCESS_ON_TRUST_POLICY or CFN_NAG F2

#
# Select all IAM Role resources from incoming template (payload)
# 
let aws_iam_role_no_full_acess_on_trust_policy = Resources.*[ Type == 'AWS::IAM::Role'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "F2"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_ROLE_NO_FULL_ACCESS_ON_TRUST_POLICY" 
]

rule IAM_ROLE_NO_FULL_ACCESS_ON_TRUST_POLICY when %aws_iam_role_no_full_acess_on_trust_policy !empty {
  let violations = %aws_iam_role_no_full_acess_on_trust_policy[
    some Properties.AssumeRolePolicyDocument.Statement[*] {
      some Action[*] in ["*", /^[a-zA-Z0-9]*:\*$/]
      Effect == "Allow"
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F2    
    Violation: One or more IAM Roles allow full access in the trust policy
    Fix: Remove AssumeRole policy statements that match {"Effect": "Allow", "Action": "<service-name>:*" ... } or {"Effect": "Allow", "Action": "*" ... }
  >>
} 
#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   IAM_ROLE_NO_WILDCARD_ACTIONS_ON_PERMISSIONS
#
# Description:
#   Checks if AWS Identity and Access Management (IAM) roles grant Action "*" in it's permission policy.
#
# Reports on:
#   AWS::IAM::Role
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
# 
# CFN_NAG Rule Id:
#   F3
#
# Scenarios:
# a) SKIP: when there are no IAM Roles present
# b) PASS: when all IAM Roles do not allow full Action * for at least 1 AWS service
# c) FAIL: when any IAM Role allows Action * access for at least 1 AWS service.
# d) SKIP: when metada has rule suppression for IAM_ROLE_NO_WILDCARD_ACTIONS_ON_PERMISSIONS or CFN_NAG F3

#
# Select all IAM Role resources from incoming template (payload)
# 
let aws_iam_role_no_wildcard_actions_on_permissions = Resources.*[ Type == 'AWS::IAM::Role'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "F3"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_ROLE_NO_WILDCARD_ACTIONS_ON_PERMISSIONS" 
]

rule IAM_ROLE_NO_WILDCARD_ACTIONS_ON_PERMISSIONS when %aws_iam_role_no_wildcard_actions_on_permissions !empty {
  let violations = %aws_iam_role_no_wildcard_actions_on_permissions[
    some Properties.PolicyDocument.Statement[*] {
      some Action[*] in ["*", /^[a-zA-Z0-9]*:\*$/]
      Effect == "Allow"
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F3    
    Violation: IAM role should not allow * action on its permissions policy
    Fix: Remove policy statements that match {"Effect": "Allow", "Action": "<service-name>:*" ... } or {"Effect": "Allow", "Action": "*" ... }
  >>
} 
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   IAM_POLICY_NO_STATEMENTS_WITH_FULL_ACCESS
#
# Description:
#   Checks if AWS Identity and Access Management (IAM) policies grant permissions to all actions on individual AWS resources.
#
# Reports on:
#   AWS::IAM::Policy
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F4
#
# Scenarios:
# a) SKIP: when there are no IAM Policies present
# b) PASS: when all IAM Policies do not allow full access to at least 1 AWS service
# c) FAIL: when any IAM Policy allows full access to at least 1 AWS service.
# d) SKIP: when metadata has rule suppression for IAM_POLICY_NO_STATEMENTS_WITH_FULL_ACCESS or F4

#
# Select all IAM Policy resources from incoming template (payload)
# 
let aws_iam_policies = Resources.*[ Type == 'AWS::IAM::Policy'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "F4"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_POLICY_NO_STATEMENTS_WITH_FULL_ACCESS" 
]

rule IAM_POLICY_NO_STATEMENTS_WITH_FULL_ACCESS when %aws_iam_policies !empty {
  let violations = %aws_iam_policies[
    Type == 'AWS::IAM::Policy'
    some Properties.PolicyDocument.Statement[*] {
      some Action[*] in ["*", /^[a-zA-Z0-9]*:\*$/]
      Effect == "Allow"
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F4    
    Violation: One or more IAM Policies allow full access to at least 1 AWS service
    Fix: Remove policy statements that match {"Effect": "Allow", "Action": "<service-name>:*" ... } or {"Effect": "Allow", "Action": "*" ... }
  >>
} 
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   IAM_MANAGEDPOLICY_NO_STATEMENTS_WITH_FULL_ACCESS
#
# Description:
#   Checks if AWS Identity and Access Management (IAM) managed policies grant permissions to all actions on individual AWS resources.
#
# Reports on:
#   AWS::IAM::ManagedPolicy
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F5
#
# Scenarios:
# a) SKIP: when there are no IAM Managed Policies present
# b) PASS: when all IAM Managed Policies do not allow full access to at least 1 AWS service
# c) FAIL: when any IAM Managed Policy allows full access to at least 1 AWS service.
# d) SKIP: when metada has rule suppression for IAM_MANAGEDPOLICY_NO_STATEMENTS_WITH_FULL_ACCESS or F5

#
# Select all IAM Managed Policy resources from incoming template (payload)
# 
let aws_iam_managed_policies = Resources.*[ Type == 'AWS::IAM::ManagedPolicy'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "F5"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_MANAGEDPOLICY_NO_STATEMENTS_WITH_FULL_ACCESS" 
]

rule IAM_MANAGEDPOLICY_NO_STATEMENTS_WITH_FULL_ACCESS when %aws_iam_managed_policies !empty {
  let violations = %aws_iam_managed_policies[
    Type == 'AWS::IAM::ManagedPolicy'
    some Properties.PolicyDocument.Statement[*] {
      some Action[*] in ["*", /^[a-zA-Z0-9]*:\*$/]
      Effect == "Allow"
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F5    
    Violation: One or more IAM Managed Policies allow full access to at least 1 AWS service
    Fix: Remove policy statements that match {"Effect": "Allow", "Action": "<service-name>:*" ... } or {"Effect": "Allow", "Action": "*" ... }
  >>
} 
#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   IAM_ROLE_NO_ALLOW_PLUS_NOT_PRINCIPAL
#
# Description:
#   Checks that AWS Identity and Access Management (IAM) roles do not use Allow+NotPrincipal in its trust policy
#
# Reports on:
#   AWS::IAM::Role
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F6
#
# Documentation:
# https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_notprincipal.html
#
# Scenarios:
# a) SKIP: when there are no IAM Roles present
# b) PASS: when all IAM Roles do not allow full Action * for at least 1 AWS service
# c) FAIL: when any IAM Role AssumeRolePolicyDocument statement has both Effect: Allow and NotPrincipal
# d) SKIP: when metadata has rule suppression for IAM_ROLE_NO_ALLOW_PLUS_NOT_PRINCIPAL or CFN_NAG F6

#
# Select all IAM Role resources from incoming template (payload)
#
let aws_iam_role_resources = Resources.*[ Type == 'AWS::IAM::Role'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F6"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_ROLE_NO_ALLOW_PLUS_NOT_PRINCIPAL"
]

rule IAM_ROLE_NO_ALLOW_PLUS_NOT_PRINCIPAL when %aws_iam_role_resources !empty {
  let violations = %aws_iam_role_resources[
    Type == 'AWS::IAM::Role'
    some Properties.AssumeRolePolicyDocument.Statement[*] {
      Effect == "Allow"
      NotPrincipal exists
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F6    
    Violation: IAM role AssumeRolePolicyDocument should not allow Allow+NotPrincipal in its trust policy
    Fix: Remove policy statements that match {"Effect": "Allow", "NotPrincipal": ... }
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   SQS_QUEUEPOLICY_NO_ALLOW_PLUS_NOTPRINCIPAL
#
# Description:
#   Checks that Amazon SQS Queue Policies do not use Effect:Allow with NotPrincipal
#
# Reports on:
#   AWS::SQS::QueuePolicy
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
# 
# CFN_NAG Rule Id:
#   F7
#
# Documentation:
# https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_notprincipal.html
#
# Scenarios:
# a) SKIP: when there are no SQS QueuePolicies present
# b) PASS: when all SQS QueuePolicies do not Allow with NotPrincipal
# c) FAIL: when any SQS QueuePolicy PolicyDocument statement has both Effect: Allow and NotPrincipal
# d) SKIP: when metada has rule suppression for SQS_NO_QUEUE_POLICY_NOT_PRINCIPAL or CFN_NAG F7

#
# Select all SQS QueuePolicy resources from incoming template (payload)
# 
let aws_sqs_queuepolicy_resources = Resources.*[ Type == 'AWS::SQS::QueuePolicy'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "F7"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SQS_QUEUEPOLICY_NO_ALLOW_PLUS_NOTPRINCIPAL" 
]

rule SQS_QUEUEPOLICY_NO_ALLOW_PLUS_NOTPRINCIPAL when %aws_sqs_queuepolicy_resources !empty {
  let violations = %aws_sqs_queuepolicy_resources[
    Type == 'AWS::SQS::QueuePolicy' 
    some Properties.PolicyDocument.Statement[*] {
      Effect == "Allow"
      NotPrincipal exists
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F7    
    Violation: SQS QueuePolicy should not allow Allow+NotPrincipal
    Fix: Remove policy statements that match {"Effect": "Allow", "NotPrincipal": ... }
  >>
} 
#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   SNS_TOPICPOLICY_NO_ALLOW_PLUS_NOTPRINCIPAL
#
# Description:
#   Checks that Amazon SNS TopicPolicies do not use Effect:Allow with NotPrincipal
#
# Reports on:
#   AWS::SNS::TopicPolicy
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
# 
# CFN_NAG Rule Id:
#   F8
#
# Documentation:
# https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_notprincipal.html
#
# Scenarios:
# a) SKIP: when there are no SNS TopicPolicies present
# b) PASS: when all SNS TopicPolicies do not Allow with NotPrincipal
# c) FAIL: when any SNS TopicPolicy PolicyDocument statement has both Effect: Allow and NotPrincipal
# d) SKIP: when metada has rule suppression for SNS_TOPICPOLICY_NO_ALLOW_PLUS_NOTPRINCIPAL or CFN_NAG F8

#
# Select all SNS TopicPolicy resources from incoming template (payload)
# 
let aws_sqs_queuepolicy_resources = Resources.*[ Type == 'AWS::SNS::TopicPolicy'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "F8"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SNS_TOPICPOLICY_NO_ALLOW_PLUS_NOTPRINCIPAL" 
]

rule SNS_TOPICPOLICY_NO_ALLOW_PLUS_NOTPRINCIPAL when %aws_sqs_queuepolicy_resources !empty {
  let violations = %aws_sqs_queuepolicy_resources[
    some Properties.PolicyDocument.Statement[*] {
      Effect == "Allow"
      NotPrincipal exists
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F8    
    Violation: SNS TopciPolicy should not allow Allow+NotPrincipal
    Fix: Remove policy statements that match {"Effect": "Allow", "NotPrincipal": ... }
  >>
} 
#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   S3_BUCKETPOLICY_NO_ALLOW_PLUS_NOTPRINCIPAL
#
# Description:
#   Checks that Amazon S3 BucketPolicies do not use Effect:Allow with NotPrincipal
#
# Reports on:
#   AWS::S3::BucketPolicy
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
# 
# CFN_NAG Rule Id:
#   F9
#
# Documentation:
# https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_notprincipal.html
#
# Scenarios:
# a) SKIP: when there are no S3 BucketPolicies present
# b) PASS: when all S3 BucketPolicies do not Allow with NotPrincipal
# c) FAIL: when any S3 BucketPolicies PolicyDocument statement has both Effect: Allow and NotPrincipal
# d) SKIP: when metada has rule suppression for S3_BUCKETPOLICY_NO_ALLOW_PLUS_NOTPRINCIPAL or CFN_NAG F9

#
# Select all S3 BucketPolicy resources from incoming template (payload)
# 
let aws_s3_bucketpolicy_resources = Resources.*[ Type == 'AWS::S3::BucketPolicy'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "F9"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_BUCKETPOLICY_NO_ALLOW_PLUS_NOTPRINCIPAL" 
]

rule S3_BUCKETPOLICY_NO_ALLOW_PLUS_NOTPRINCIPAL when %aws_s3_bucketpolicy_resources !empty {
  let violations = %aws_s3_bucketpolicy_resources[
    some Properties.PolicyDocument.Statement[*] {
      Effect == "Allow"
      NotPrincipal exists
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F9    
    Violation: S3 Bucket policy should not allow Allow+NotPrincipal
    Fix: Remove policy statements that match {"Effect": "Allow", "NotPrincipal": ... }
  >>
} 
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   IAM_NO_INLINE_POLICY_CHECK 
#
# Description:
#   Checks that inline policy feature is not in use.
#
# Reports on:
#   AWS::IAM::User
#   AWS::IAM::Role
#   AWS::IAM::Group
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no IAM Users, Roles, or Groups present
# b) PASS: when all IAM Users, Roles, or Groups present have no inline policies listed
# c) FAIL: when any IAM Users, Roles, or Groups present have inline policies listed
# d) SKIP: when metada has rule suppression for IAM_NO_INLINE_POLICY_CHECK

#
# Select all IAM User, Role, and Group resources from incoming template (payload)
#
let aws_iam_entities_no_inline_policy = Resources.*[
  Type in [ /AWS::IAM::User/,
            /AWS::IAM::Role/,
            /AWS::IAM::Group/ ]
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "F10"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_NO_INLINE_POLICY_CHECK"
]

rule IAM_NO_INLINE_POLICY_CHECK when %aws_iam_entities_no_inline_policy !empty {
  %aws_iam_entities_no_inline_policy.Properties.Policies empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F10    
    Violation: Inline policies are not allowed on IAM Users, Roles, or Groups.
    Fix: Remove the Policies list property from any IAM Users, Roles, or Groups.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   IAM_NO_POLICY_ON_USER
#
# Description:
#   Checks that IAM Policies are not attached to IAM Users
#
# Reports on:
#   AWS::IAM::Policy
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F11, F12
#
# Scenarios:
# a) SKIP: when there are no IAM Policies present
# b) PASS: when no IAM Policies attach to Users
# c) FAIL: when any S3 BucketPolicies PolicyDocument statement has both Effect: Allow and NotPrincipal
# d) SKIP: when metadata has rule suppression for IAM_NO_POLICY_ON_USER or CFN_NAG F11, F12

let applicable_types = [
  "AWS::IAM::Policy",
  "AWS::IAM::ManagedPolicy"
]

let iam_no_policy_on_user = Resources.*[ Type in %applicable_types
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id !in [ "F11", "F12" ]
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_NO_POLICY_ON_USER"
]

rule IAM_NO_POLICY_ON_USER when %iam_no_policy_on_user !empty {
  let violations = %iam_no_policy_on_user[
    Type == 'AWS::IAM::Policy'
    or
    Type == 'AWS::IAM::ManagedPolicy'
    Properties.Users !empty
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F11,F12    
    Violation: IAM policy/managedpolicy should not apply directly to users.  Should be on group
    Fix: Associate the IAM Policy/ManagedPolicy with a Group and make the IAM User a member of the group.
  >>
}

#
#####################################
##         AWS Solutions           ##
#####################################
# Rule Identifier:
#    LAMBDA_NO_WILDCARD_PRINCIPALS
#
# Description:
#    Checks if the AWS Lambda permission uses open principal
#
# Reports on:
#    AWS::Lambda::Permission
#    AWS::Lambda::LayerVersionPermission
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   F13
#
# Scenarios:
# a) SKIP: when no AWS Lambda permission policies are present
# b) PASS: when no AWS Lambda permission policies allow all principals
# c) FAIL: when any AWS Lambda permission allows all principals
# d) SKIP: hen metadata includes the suppression for rule LAMBDA_NO_WILDCARD_PRINCIPALS

let applicable_types = [
  "AWS::Lambda::Permission",
  "AWS::Lambda::LayerVersionPermission"
]

let lambda_no_wildcard_principal = Resources.*[ Type in %applicable_types
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F13"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "LAMBDA_NO_WILDCARD_PRINCIPALS"
]

rule LAMBDA_NO_WILDCARD_PRINCIPALS when %lambda_no_wildcard_principal !empty {
  let violations = %lambda_no_wildcard_principal[
    Properties.Principal == '*'
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F13    
    Violation: Lambda permission principal should not be wildcard.
    Fix: Specify principal or a list of principals.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    S3_BUCKET_NO_PUBLIC_RW_ACL
#
# Description:
#   Checks if Amazon Simple Storage Service (Amazon S3) buckets are publicly readable via the public ACL
#
# Reports on:
#    AWS::S3::Bucket
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   F14
#
# Scenarios:
# a) SKIP: when there are no S3 resource present
# b) PASS: when no S3 resources have PublicReadWrite ACL applied at the bucket level
# c) FAIL: when any S3 resources has PublicReadWrite ACL
# d) SKIP: when metada has rule suppression for S3_BUCKET_NO_PUBLIC_RW_ACL

#
# Select all S3 resources from incoming template (payload)
#
let s3_bucket_public_rw_acl = Resources.*[ Type == 'AWS::S3::Bucket'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F14"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_BUCKET_NO_PUBLIC_RW_ACL"
]

rule S3_BUCKET_NO_PUBLIC_RW_ACL when %s3_bucket_public_rw_acl !empty {
  %s3_bucket_public_rw_acl.Properties.AccessControl != 'PublicReadWrite'
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F14    
    Violation: S3 Bucket should not have the PublicReadWrite ACL.
    Fix: Allow ReadWrite access only to authorized, authenticated users.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    S3_BUCKET_POLICY_NO_WILDCARD_ACTION
#
# Description:
#   S3 Bucket policy should not allow * action
#
# Reports on:
#    AWS::S3::BucketPolicy
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   F15
#
# Scenarios:
# a) SKIP: when there is no S3 BucketPolicy resource present
# b) PASS: when no S3 BucketPolicy resources have open Action
# c) FAIL: when any S3 resources has Action "*"
# d) SKIP: when metada has rule suppression for S3_BUCKET_POLICY_NO_WILDCARD_ACTION

#
# Select all S3 BucketPolicy resources from incoming template (payload)
#
let s3_bucket_policy_no_wildcard_action = Resources.*[ Type == 'AWS::S3::BucketPolicy'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F15"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_BUCKET_POLICY_NO_WILDCARD_ACTION"
]

rule S3_BUCKET_POLICY_NO_WILDCARD_ACTION when %s3_bucket_policy_no_wildcard_action !empty {
  let violations = %s3_bucket_policy_no_wildcard_action[
    some Properties.PolicyDocument.Statement[*] {
      some Action[*] in ["*", /^[a-zA-Z0-9]*:\*$/]
      Effect == "Allow"
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F15    
    Violation: S3 Bucket policy should not allow * action.
    Fix: Specify explicit actions in the S3 BucketPolicy
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    S3_BUCKET_POLICY_NO_WILDCARD_PRINCIPAL
#
# Description:
#   S3 Bucket policy should not allow * principal
#
# Reports on:
#    AWS::S3::BucketPolicy
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   F16
#
# Scenarios:
# a) SKIP: when there is no S3 BucketPolicy resource present
# b) PASS: when no S3 BucketPolicy resources have open Principal
# c) FAIL: when any S3 resources has Principal "*"
# d) SKIP: when metada has rule suppression for S3_BUCKET_POLICY_NO_WILDCARD_PRINCIPAL

#
# Select all S3 BucketPolicy resources from incoming template (payload)
#
let s3_bucket_policy_no_wildcard_principal = Resources.*[ Type == 'AWS::S3::BucketPolicy'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F16"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_BUCKET_POLICY_NO_WILDCARD_PRINCIPAL"
]

rule S3_BUCKET_POLICY_NO_WILDCARD_PRINCIPAL when %s3_bucket_policy_no_wildcard_principal !empty {
  let violations = %s3_bucket_policy_no_wildcard_principal[
    some Properties.PolicyDocument.Statement[*] {
      Principal == "*"
      Effect == "Allow"
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F16    
    Violation: S3 Bucket policy should not allow * principal
    Fix: Specify explicit principals in the S3 BucketPolicy
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    SNS_TOPICPOLICY_NO_WILDCARD_PRINCIPAL
#
# Description:
#   SNS Topic policy should not allow * principal
#
# Reports on:
#    AWS::SNS::TopicPolicy
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   F18
#
# Reference:
#   https://docs.aws.amazon.com/sns/latest/dg/sns-access-policy-use-cases.html
#
# Scenarios:
# a) SKIP: when there is no SNS TopicPolicy resource present
# b) PASS: when no SNS TopicPolicy resources have open Principal
# c) FAIL: when any SNS TopicPolicy has Principal "*"
# d) SKIP: when metada has rule suppression for SNS_TOPICPOLICY_NO_WILDCARD_PRINCIPAL

#
# Select all SNS TopicPolicy resources from incoming template (payload)
#
let sns_topicpolicy_no_wildcard_principal = Resources.*[ Type == 'AWS::SNS::TopicPolicy'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F18"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SNS_TOPICPOLICY_NO_WILDCARD_PRINCIPAL"
]

rule SNS_TOPICPOLICY_NO_WILDCARD_PRINCIPAL when %sns_topicpolicy_no_wildcard_principal !empty {
  let violations = %sns_topicpolicy_no_wildcard_principal[
    some Properties.PolicyDocument.Statement[*] {
      Principal == "*" OR Principal.AWS == "*" OR Principal == "arn:aws:iam::*"
      Effect == "Allow"
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F18    
    Violation: SNS Topic policy should not allow * principal
    Fix: Specify explicit principals in the SNS TopicPolicy
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    CMK_BACKING_KEY_ROTATION_ENABLED
#
# Description:
#   Key rotation should be enabled for KMS
#
# Reports on:
#    AWS::KMS::Key
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no KMS CMKs
# b) SKIP: when metada has rule suppression for CMK_BACKING_KEY_ROTATION_ENABLED
# c) FAIL: when EnableKeyRotation is missing for any KMS CMKs
# d) FAIL: when EnableKeyRotation is set to false for any KMS CMKs
# e) PASS: when EnableKeyRotation is set to true on all KMS CMKs

#
# Select all KMS Key resources from incoming template (payload)
#

let cmk_backing_key_rotation_enabled = Resources.*[ Type == "AWS::KMS::Key"
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "F19"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CMK_BACKING_KEY_ROTATION_ENABLED"
]


rule CMK_BACKING_KEY_ROTATION_ENABLED when %cmk_backing_key_rotation_enabled !empty {
     %cmk_backing_key_rotation_enabled.Properties.EnableKeyRotation == true
      <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F19    
        Violation: Key rotation should be enabled for KMS keys.
        Fix: Set the EnableKeyRotation property to true.
      >>
}
#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    SQS_QUEUEPOLICY_NO_WILDCARD_ACTION
#
# Description:
#   SQS Queue policy should not allow * action
#
# Reports on:
#    AWS::SQS::QueuePolicy
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   F20
#
# Reference:
#   https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-overview-of-managing-access.html
#
# Scenarios:
# a) SKIP: when there is no SQS QueuePolicy resource present
# b) PASS: when no SQS QueuePolicy resources have open Actions
# c) FAIL: when any SQS QueuePolicy has Action "*" or contains <service:*>
# d) SKIP: when metada has rule suppression for SQS_QUEUEPOLICY_NO_WILDCARD_ACTION

#
# Select all SQS QueuePolicy resources from incoming template (payload)
#
let sqs_queuepolicy_no_wildcard_action = Resources.*[ Type == 'AWS::SQS::QueuePolicy'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F20"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SQS_QUEUEPOLICY_NO_WILDCARD_ACTION"
]

rule SQS_QUEUEPOLICY_NO_WILDCARD_ACTION when %sqs_queuepolicy_no_wildcard_action !empty {
  let violations = %sqs_queuepolicy_no_wildcard_action[
    some Properties.PolicyDocument.Statement[*] {
      some Action[*] in ["*", /^[a-zA-Z0-9]*:\*$/]
      Effect == "Allow"
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F20    
    Violation: SQS Queue policy should not allow * Action
    Fix: Specify explicit Action(s) in the SQS QueuePolicy
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    SQS_QUEUEPOLICY_NO_WILDCARD_PRINCIPAL
#
# Description:
#   SQS Queue policy should not allow * principal
#
# Reports on:
#    AWS::SQS::QueuePolicy
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   F21
#
# Reference:
#   https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-overview-of-managing-access.html
#
# Scenarios:
# a) SKIP: when there is no SQS QueuePolicy resource present
# b) PASS: when no SQS QueuePolicy resources have open Principal
# c) FAIL: when any SQS QueuePolicy has Principal "*"
# d) SKIP: when metada has rule suppression for SQS_QUEUEPOLICY_NO_WILDCARD_PRINCIPAL

#
# Select all SQS QueuePolicy resources from incoming template (payload)
#
let sqs_queuepolicy_no_wildcard_principal = Resources.*[ Type == 'AWS::SQS::QueuePolicy'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F21"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SQS_QUEUEPOLICY_NO_WILDCARD_PRINCIPAL"
]

rule SQS_QUEUEPOLICY_NO_WILDCARD_PRINCIPAL when %sqs_queuepolicy_no_wildcard_principal !empty {
  let violations = %sqs_queuepolicy_no_wildcard_principal[
    some Properties.PolicyDocument.Statement[*] {
      Principal == "*" OR Principal.AWS == "*" OR Principal == "arn:aws:iam::*"
      Effect == "Allow"
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F21    
    Violation: SQS QueuePolicy should not allow * principal
    Fix: Specify explicit principals in the SQS QueuePolicy
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    RDS_INSTANCE_PUBLIC_ACCESS_CHECK
#
# Description:
#    Checks if an RDS instances has Publicly Accessible not set.
#
# Reports on:
#    AWS::RDS::DBInstance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no RDS instances present
# b) PASS: when all RDS instances have PubliclyAccessible set to true
# c) FAIL: when all RDS instances have PubliclyAccessible set to false
# d) FAIL: when there are RDS instances with PubliclyAccessible property is not present
# e) SKIP: when metadata includes the suppression for rule RDS_INSTANCE_PUBLIC_ACCESS_CHECK

#
# Select all RDS instance resources from incoming template (payload)
#
let aws_rds_instances_not_public = Resources.*[ Type == 'AWS::RDS::DBInstance'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "F22"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "RDS_INSTANCE_PUBLIC_ACCESS_CHECK"
]

rule RDS_INSTANCE_PUBLIC_ACCESS_CHECK when %aws_rds_instances_not_public !empty {
  # ALL RDS instances must have PubliclyAccessible set to false
  %aws_rds_instances_not_public.Properties.PubliclyAccessible == false
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F22    
    Violation: All RDS instances must not be publicly accessible. 
    Fix: The default depends on the VPC configuration, so it is recommended to eplicitly set PubliclyAccessible to false.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   RDS_MASTER_USER_PASSWORD_NO_PLAINTEXT_PASSWORD
#
# Description:
#  RDS instance master user password must not be a plaintext string or a Ref to a Parameter with a Default value.
#  Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager/ssm-secure value.
#  with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
#
# Reports on:
#   AWS::RDS::DBInstance
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F23
#
# Note: this rule works, however it sends the custom message twice for each resource
#
# Scenarios:
# a) SKIP: when there are no AWS::RDS::DBInstance present
# b) PASS: when all AWS::RDS::DBInstance use passwords from secure sources
# c) FAIL: when any AWS::RDS::DBInstance has a Password property not using a secure source
# d) SKIP: when metadata has rule suppression for RDS_MASTER_USER_PASSWORD_NO_PLAINTEXT_PASSWORD or CFN_NAG F23

let rds_master_user_password_no_plaintext_password = Resources.*[ Type == 'AWS::RDS::DBInstance'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F23"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "RDS_MASTER_USER_PASSWORD_NO_PLAINTEXT_PASSWORD"
]

# Get any AWS::RDS::DBInstance Refs for Password?
let rds_master_user_password_refs = %rds_master_user_password_no_plaintext_password.Properties.MasterUserPassword.'!Ref'

# Rule 1: when rds master user password no plaintext password have Ref to Parameter for Password
rule RDS_MASTER_USER_PASSWORD_USES_SECURE_PARAMETER when
  %rds_master_user_password_no_plaintext_password not empty
{
  Parameters exists
  Parameters not empty
  %rds_master_user_password_refs not empty
  let parameter_refs = Parameters.%rds_master_user_password_refs
  when %parameter_refs !empty {
    %parameter_refs.Type == 'String'
    %parameter_refs.NoEcho exists
    %parameter_refs.NoEcho == true
    %parameter_refs.Default !exists
  }
}

# Rule 2: when rds master user password no plaintext password and above rule did not pass
rule RDS_MASTER_USER_PASSWORD_USES_SECURE_SERVICE when
  %rds_master_user_password_no_plaintext_password not empty
  !RDS_MASTER_USER_PASSWORD_USES_SECURE_PARAMETER
{
  %rds_master_user_password_no_plaintext_password.Properties.MasterUserPassword !exists
  OR
  %rds_master_user_password_no_plaintext_password.Properties.MasterUserPassword in [ /{{resolve\:secretsmanager\:.*}}/, /{{resolve\:ssm-secure\:.*}}/ ]
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F23    
    Violation: RDS MasterUserPassword Endpoint password must not be a plaintext string or a Ref to a Parameter with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
    Fix: Replace plaintext value with a secure one.
  >>
}

# One rule to rule them all...
rule RDS_MASTER_USER_PASSWORD_NO_PLAINTEXT_PASSWORD when
  %rds_master_user_password_no_plaintext_password not empty
{
  RDS_MASTER_USER_PASSWORD_USES_SECURE_PARAMETER
  OR
  RDS_MASTER_USER_PASSWORD_USES_SECURE_SERVICE
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   RDS_MASTER_USER_NAME_NO_PLAINTEXT_PASSWORD
#
# Description:
#  RDS instance master user name must not be a plaintext string or a Ref to a Parameter with a Default value.
#  Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager/ssm-secure value.
#  with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
#
# Reports on:
#   AWS::RDS::DBInstance
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F24
#
# Note: this rule works, however it sends the custom message twice for each resource
#
# Scenarios:
# a) SKIP: when there are no AWS::RDS::DBInstance present
# b) PASS: when all AWS::RDS::DBInstance use user names from secure sources
# c) FAIL: when any AWS::RDS::DBInstance has a MasterUserName property not using a secure source
# d) SKIP: when metadata has rule suppression for RDS_MASTER_USER_NAME_NO_PLAINTEXT_PASSWORD or CFN_NAG F24

let rds_master_user_name_no_plaintext_password = Resources.*[ Type == 'AWS::RDS::DBInstance'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F24"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "RDS_MASTER_USER_NAME_NO_PLAINTEXT_PASSWORD"
]

# Get any AWS::RDS::DBInstance Refs for Password?
let rds_master_user_name_refs = %rds_master_user_name_no_plaintext_password.Properties.MasterUsername.'!Ref'

# Rule 1: when rds master user name no plaintext password have Ref to Parameter for Password
rule RDS_MASTER_USER_NAME_USES_SECURE_PARAMETER when
  %rds_master_user_name_no_plaintext_password not empty
{
  Parameters exists
  Parameters not empty
  %rds_master_user_name_refs not empty
  let parameter_refs = Parameters.%rds_master_user_name_refs
  when %parameter_refs !empty {
    %parameter_refs.Type == 'String'
    %parameter_refs.NoEcho exists
    %parameter_refs.NoEcho == true
    %parameter_refs.Default !exists
  }
}

# Rule 2: when rds master user name no plaintext password and above rule did not pass
rule RDS_MASTER_USER_NAME_USES_SECURE_SERVICE when
  %rds_master_user_name_no_plaintext_password not empty
  !RDS_MASTER_USER_NAME_USES_SECURE_PARAMETER
{
  %rds_master_user_name_no_plaintext_password.Properties.MasterUsername !exists
  OR
  %rds_master_user_name_no_plaintext_password.Properties.MasterUsername in [ /{{resolve\:secretsmanager\:.*}}/, /{{resolve\:ssm-secure\:.*}}/ ]
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F24    
    Violation: RDS MasterUsername must not be a plaintext string or a Ref to a Parameter with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
    Fix: Replace plaintext value with a secure one.
  >>
}

# One rule to rule them all...
rule RDS_MASTER_USER_NAME_NO_PLAINTEXT_PASSWORD when
  %rds_master_user_name_no_plaintext_password not empty
{
  RDS_MASTER_USER_NAME_USES_SECURE_PARAMETER
  OR
  RDS_MASTER_USER_NAME_USES_SECURE_SERVICE
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    ELASTICACHE_REPLICATION_GROUP_ENCRYPTION_AT_REST
#
# Description:
#    ElastiCache ReplicationGroup should have encryption enabled for at rest
#
# Reports on:
#    AWS::Elasticache::ReplicationGroup
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   F25
#
# Scenarios:
# a) SKIP: when no AWS::Elasticache::ReplicationGroup resources are present
# b) PASS: when all AWS::Elasticache::ReplicationGroup resources have the AtRestEncryptionEnabled property set to true
# c) FAIL: when any AWS::Elasticache::ReplicationGroup resources have the AtRestEncryptionEnabled set to false or absent (default false)
# e) SKIP: when metadata includes the suppression for rule ELASTICACHE_REPLICATION_GROUP_ENCRYPTION_AT_REST

#
# Select all AWS::Elasticache::ReplicationGroup resources from incoming template (payload)
#
let elasticache_replication_group_encryption_at_rest = Resources.*[ Type == 'AWS::ElastiCache::ReplicationGroup'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F25"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELASTICACHE_REPLICATION_GROUP_ENCRYPTION_AT_REST"
]

rule ELASTICACHE_REPLICATION_GROUP_ENCRYPTION_AT_REST when %elasticache_replication_group_encryption_at_rest !empty {
    %elasticache_replication_group_encryption_at_rest.Properties.AtRestEncryptionEnabled == true
		<<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F25    
			Violation: ElastiCache ReplicationGroup should have encryption enabled for at rest
			Fix: Set AtRestEncryptionEnabled property to true
		>>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    RDS_STORAGE_ENCRYPTED
#
# Description:
#    Checks whether storage encryption is enabled for your RDS DB instances.
#
#
# Reports on:
#    AWS::RDS::DBInstance
#    AWS::RDS::DBCluster
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   F26, F27
#
# Scenarios:
# a) SKIP: when there are no RDS instances present
# b) PASS: when all RDS instances / clusters have StorageEncrypted set to true
# c) FAIL: when any RDS instances / clusters have StorageEncrypted set to false
# d) FAIL: when there are RDS instances / clusters with StorageEncrypted property is not present
# e) SKIP: when metadata includes the suppression for rule RDS_STORAGE_ENCRYPTED

#
# Select all RDS instance resources from incoming template (payload)
#
let aws_rds_instances_storage_encrypted = Resources.*[ Type in [ /AWS::RDS::DBInstance/, /AWS::RDS::DBCluster/ ]
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id !in [ "F26", "F27" ]
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "RDS_STORAGE_ENCRYPTED"
]


rule RDS_STORAGE_ENCRYPTED when %aws_rds_instances_storage_encrypted !empty {
  let violations = %aws_rds_instances_storage_encrypted[
    Properties.StorageEncrypted !EXISTS
    or
    Properties.StorageEncrypted != true
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F26,F27    
    Violation: All RDS instances must have encrypted storage.
    Fix: Set the StorageEncrypted parameter to true.
  >>
}

####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    REDSHIFT_CLUSTER_CONFIGURATION_CHECK
#
# Description:
#    Checks whether Amazon Redshift clusters have the specified settings (Encrypted Only)  
#
# Reports on:
#   AWS::Redshift::Cluster
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   F28
#
# Scenarios:
# a) SKIP: when there are no Redshift Cluster resource present
# b) PASS: when Redshift Cluster resources have the Encrypted property set to true
# c) FAIL: when any Redshift Cluster resources do not have Encrypted property set (default false)
# d) FAIL: when any Redshift Cluster resources have Encrypted property set to false 
# e) SKIP: when metadata includes the suppression for rule REDSHIFT_CLUSTER_CONFIGURATION_CHECK

#
# Select all Redshift Cluster resources from incoming template (payload)
#
let redhshift_clusters_configuration_check = Resources.*[ Type == 'AWS::Redshift::Cluster' 
    Metadata.cfn_nag.rules_to_suppress not exists or 
    Metadata.cfn_nag.rules_to_suppress.*.id != "F28"
	Metadata.guard.SuppressedRules not exists or
    Metadata.guard.SuppressedRules.* != "REDSHIFT_CLUSTER_CONFIGURATION_CHECK"
]

rule REDSHIFT_CLUSTER_CONFIGURATION_CHECK when %redhshift_clusters_configuration_check !empty {
    %redhshift_clusters_configuration_check.Properties.Encrypted == true

    <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F28    
			Violation: Amazon Redshift configuration should have encryption enabled
			Fix: Set the Encrypted property to true 
    >>
}
#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    WORKSPACE_ENCRYPTION_ENABLED
#
# Description:
#    Workspace should have encryption enabled
#
#
# Reports on:
#    AWS::WorkSpaces::Workspace
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   F29
#
# Scenarios:
# a) SKIP: when there are no RDS instances present
# b) PASS: when all RDS instances / clusters have StorageEncrypted set to true
# c) FAIL: when any RDS instances / clusters have StorageEncrypted set to false
# d) FAIL: when there are RDS instances / clusters with StorageEncrypted property is not present
# e) SKIP: when metadata includes the suppression for rule RDS_STORAGE_ENCRYPTED

#
# Select all RDS instance resources from incoming template (payload)
#
let workspace_encryption_enabled = Resources.*[ Type in [ /AWS::WorkSpaces::Workspace/ ]
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F29"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "WORKSPACE_ENCRYPTION_ENABLED"
]


rule WORKSPACE_ENCRYPTION_ENABLED when %workspace_encryption_enabled !empty {
  let violations = %workspace_encryption_enabled[
    Properties.UserVolumeEncryptionEnabled !EXISTS
    or
    Properties.UserVolumeEncryptionEnabled != true
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F29    
    Violation: Workspace should have encryption enabled
    Fix: Set UserVolumeEncryptionEnabled to true and set the VolumeEncryptionKey to your KMS key
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    EFS_ENCRYPTED_CHECK
#
# Description:
#   Checks if Amazon Elastic File System (Amazon EFS) is configured to encrypt the file data
#   using AWS Key Management Service (AWS KMS). The rule is NON_COMPLIANT if the encrypted
#   key is set to false on DescribeFileSystems or if the KmsKeyId key on DescribeFileSystems
#   does not match the KmsKeyId parameter.
#
# Reports on:
#    AWS::EFS::FileSystem
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no EFS resource present
# b) PASS: when all EFS resources have encrypted key property set to true
# c) FAIL: when all EFS resources have encrypted key property not set or set to false
# d) SKIP: when guard metadata states EFS_ENCRYPTED_CHECK to be suppressed

#
# Select all EFS resources from incoming template (payload)
#
let efs_file_systems_encrypted_check = Resources.*[ Type == 'AWS::EFS::FileSystem'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "F32"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EFS_ENCRYPTED_CHECK"
]

rule EFS_ENCRYPTED_CHECK when %efs_file_systems_encrypted_check !empty {
  %efs_file_systems_encrypted_check.Properties.Encrypted == true
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F32    
    Violation: EFS filesystem must be encrypted.
    Fix: Set the EFS Filesystem property Encrypted parameter to true.
  >>
}
#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    ELASTICACHE_REPLICATION_GROUP_ENCRYPTION_IN_TRANSIT
#
# Description:
#    ElastiCache ReplicationGroup should have encryption enabled for in transit
#
# Reports on:
#    AWS::Elasticache::ReplicationGroup
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   F33
#
# Scenarios:
# a) SKIP: when no AWS::Elasticache::ReplicationGroup resources are present
# b) PASS: when all AWS::Elasticache::ReplicationGroup resources have the TransitEncryptionEnabled property set to true
# c) FAIL: when any AWS::Elasticache::ReplicationGroup resources have the TransitEncryptionEnabled set to false or absent (default false)
# e) SKIP: when metadata includes the suppression for rule ELASTICACHE_REPLICATION_GROUP_ENCRYPTION_IN_TRANSIT

#
# Select all AWS::Elasticache::ReplicationGroup resources from incoming template (payload)
#
let elasticache_replication_group_transit_encryption = Resources.*[ Type == 'AWS::ElastiCache::ReplicationGroup'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F33"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELASTICACHE_REPLICATION_GROUP_ENCRYPTION_AT_REST"
  Properties.Engine == "redis"
  Properties.EngineVersion not in [ /^2\..*/, /^3\.1\..*/, /^3\.2\.5$/ ] # v3.2.6 or 4.x+
]

rule ELASTICACHE_REPLICATION_GROUP_ENCRYPTION_IN_TRANSIT when %elasticache_replication_group_transit_encryption !empty {
    %elasticache_replication_group_transit_encryption.Properties.TransitEncryptionEnabled == true
		<<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F33    
			Violation: ElastiCache ReplicationGroup should have encryption enabled for in transit
			Fix: Set TransitEncryptionEnabled property to true
		>>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   RDS_CLUSTER_MASTER_USER_PASSWORD_NO_PLAINTEXT_PASSWORD
#
# Description:
#  RDS Cluster DB instance master user password must not be a plaintext string or a Ref to a Parameter with a Default value.
#  Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager/ssm-secure value.
#  with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
#
# Reports on:
#   AWS::RDS::DBCluster
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F34
#
# Note: this rule works, however it sends the custom message twice for each resource
#
# Scenarios:
# a) SKIP: when there are no AWS::RDS::DBCluster present
# b) PASS: when all AWS::RDS::DBCluster use passwords from secure sources
# c) FAIL: when any AWS::RDS::DBCluster has a Password property not using a secure source
# d) SKIP: when metadata has rule suppression for RDS_CLUSTER_MASTER_USER_PASSWORD_NO_PLAINTEXT_PASSWORD or CFN_NAG F34

let rds_cluster_master_user_password_no_plaintext_password = Resources.*[ Type == 'AWS::RDS::DBCluster'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F34"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "RDS_CLUSTER_MASTER_USER_PASSWORD_NO_PLAINTEXT_PASSWORD"
]

# Get any AWS::RDS::DBCluster Refs for Password?
let rds_cluster_master_user_password_refs = %rds_cluster_master_user_password_no_plaintext_password.Properties.MasterUserPassword.'!Ref'

# Rule 1: when rds cluster master user password no plaintext password have Ref to Parameter for Password
rule RDS_CLUSTER_MASTER_USER_PASSWORD_USES_SECURE_PARAMETER when
  %rds_cluster_master_user_password_no_plaintext_password not empty
{
  Parameters exists
  Parameters not empty
  %rds_cluster_master_user_password_refs not empty
  let parameter_refs = Parameters.%rds_cluster_master_user_password_refs
  when %parameter_refs !empty {
    %parameter_refs.Type == 'String'
    %parameter_refs.NoEcho exists
    %parameter_refs.NoEcho == true
    %parameter_refs.Default !exists
  }
}

# Rule 2: when rds cluster master user password no plaintext password and above rule did not pass
rule RDS_CLUSTER_MASTER_USER_PASSWORD_USES_SECURE_SERVICE when
  %rds_cluster_master_user_password_no_plaintext_password not empty
  !RDS_CLUSTER_MASTER_USER_PASSWORD_USES_SECURE_PARAMETER
{
  %rds_cluster_master_user_password_no_plaintext_password.Properties.MasterUserPassword !exists
  OR
  %rds_cluster_master_user_password_no_plaintext_password.Properties.MasterUserPassword in [ /{{resolve\:secretsmanager\:.*}}/, /{{resolve\:ssm-secure\:.*}}/ ]
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F34    
    Violation: RDS Cluster MasterUserPassword password must not be a plaintext string or a Ref to a Parameter with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
    Fix: Replace plaintext value with a secure one.
  >>
}

# One rule to rule them all...
rule RDS_CLUSTER_MASTER_USER_PASSWORD_NO_PLAINTEXT_PASSWORD when
  %rds_cluster_master_user_password_no_plaintext_password not empty
{
  RDS_CLUSTER_MASTER_USER_PASSWORD_USES_SECURE_PARAMETER
  OR
  RDS_CLUSTER_MASTER_USER_PASSWORD_USES_SECURE_SERVICE
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   REDSHIFT_CLUSTER_MASTER_USER_PASSWORD_NO_PLAINTEXT_PASSWORD
#
# Description:
#  Redshift Cluster master user password must not be a plaintext string or a Ref to a Parameter with a Default value.
#  Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager/ssm-secure value.
#  with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
#
# Reports on:
#   AWS::Redshift::Cluster
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F35
#
# Note: this rule works, however it sends the custom message twice for each resource
#
# Scenarios:
# a) SKIP: when there are no AWS::Redshift::Cluster present
# b) PASS: when all AWS::Redshift::Cluster use passwords from secure sources
# c) FAIL: when any AWS::Redshift::Cluster has a Password property not using a secure source
# d) SKIP: when metadata has rule suppression for REDSHIFT_CLUSTER_MASTER_USER_PASSWORD_NO_PLAINTEXT_PASSWORD or CFN_NAG F35

let redshift_cluster_master_user_password_no_plaintext_password = Resources.*[ Type == 'AWS::Redshift::Cluster'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F35"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "REDSHIFT_CLUSTER_MASTER_USER_PASSWORD_NO_PLAINTEXT_PASSWORD"
]

# Get any AWS::Redshift::Cluster Refs for Password?
let redshift_cluster_master_user_password_refs = %redshift_cluster_master_user_password_no_plaintext_password.Properties.MasterUserPassword.'!Ref'

# Rule 1: when redshift cluster master user password no plaintext password have Ref to Parameter for Password
rule REDSHIFT_CLUSTER_MASTER_USER_PASSWORD_USES_SECURE_PARAMETER when
  %redshift_cluster_master_user_password_no_plaintext_password not empty
{
  Parameters exists
  Parameters not empty
  %redshift_cluster_master_user_password_refs not empty
  let parameter_refs = Parameters.%redshift_cluster_master_user_password_refs
  when %parameter_refs !empty {
    %parameter_refs.Type == 'String'
    %parameter_refs.NoEcho exists
    %parameter_refs.NoEcho == true
    %parameter_refs.Default !exists
  }
}

# Rule 2: when redshift cluster master user password no plaintext password and above rule did not pass
rule REDSHIFT_CLUSTER_MASTER_USER_PASSWORD_USES_SECURE_SERVICE when
  %redshift_cluster_master_user_password_no_plaintext_password not empty
  !REDSHIFT_CLUSTER_MASTER_USER_PASSWORD_USES_SECURE_PARAMETER
{
  %redshift_cluster_master_user_password_no_plaintext_password.Properties.MasterUserPassword !exists
  OR
  %redshift_cluster_master_user_password_no_plaintext_password.Properties.MasterUserPassword in [ /{{resolve\:secretsmanager\:.*}}/, /{{resolve\:ssm-secure\:.*}}/ ]
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F35    
    Violation: Redshift Cluster MasterUserPassword password must not be a plaintext string or a Ref to a Parameter with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
    Fix: Replace plaintext value with a secure one.
  >>
}

# One rule to rule them all...
rule REDSHIFT_CLUSTER_MASTER_USER_PASSWORD_NO_PLAINTEXT_PASSWORD when
  %redshift_cluster_master_user_password_no_plaintext_password not empty
{
  REDSHIFT_CLUSTER_MASTER_USER_PASSWORD_USES_SECURE_PARAMETER
  OR
  REDSHIFT_CLUSTER_MASTER_USER_PASSWORD_USES_SECURE_SERVICE
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   MICROSOFT_AD_NO_PLAINTEXT_PASSWORD
#
# Description:
#  Directory Service Microsoft AD password must not be a plaintext string or a Ref to a Parameter with a Default value.
#  Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager/ssm-secure value.
#  with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
#
# Reports on:
#   AWS::DirectoryService::MicrosoftAD
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F36
#
# Note: this rule works, however it sends the custom message twice for each resource
#
# Scenarios:
# a) SKIP: when there are no AWS::DirectoryService::MicrosoftAD present
# b) PASS: when all AWS::DirectoryService::MicrosoftAD use passwords from secure sources
# c) FAIL: when any AWS::DirectoryService::MicrosoftAD has a Password property not using a secure source
# d) SKIP: when metadata has rule suppression for MICROSOFT_AD_NO_PLAINTEXT_PASSWORD or CFN_NAG F36

let microsoft_ad_no_plaintext_password = Resources.*[ Type == 'AWS::DirectoryService::MicrosoftAD'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F36"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "MICROSOFT_AD_NO_PLAINTEXT_PASSWORD"
]

# Get any AWS::DirectoryService::MicrosoftAD Refs for Password?
let microsoft_ad_password_refs = %microsoft_ad_no_plaintext_password.Properties.Password.'!Ref'

# Rule 1: when Microsoft AD password no plaintext password have Ref to Parameter for Password
rule MICROSOFT_AD_PASSWORD_USES_SECURE_PARAMETER when
  %microsoft_ad_no_plaintext_password not empty
{
  Parameters exists
  Parameters not empty
  %microsoft_ad_password_refs not empty
  let parameter_refs = Parameters.%microsoft_ad_password_refs
  when %parameter_refs !empty {
    %parameter_refs.Type == 'String'
    %parameter_refs.NoEcho exists
    %parameter_refs.NoEcho == true
    %parameter_refs.Default !exists
  }
}

# Rule 2: when Microsoft AD password no plaintext password and above rule did not pass
rule MICROSOFT_AD_PASSWORD_USES_SECURE_SERVICE when
  %microsoft_ad_no_plaintext_password not empty
  !MICROSOFT_AD_PASSWORD_USES_SECURE_PARAMETER
{
  %microsoft_ad_no_plaintext_password.Properties.Password exists
  %microsoft_ad_no_plaintext_password.Properties.Password in [ /{{resolve\:secretsmanager\:.*}}/, /{{resolve\:ssm-secure\:.*}}/ ]
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F36    
    Violation: Microsoft AD Password Endpoint password must not be a plaintext string or a Ref to a Parameter with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
    Fix: Replace plaintext value with a secure one.
  >>
}

# One rule to rule them all...
rule MICROSOFT_AD_NO_PLAINTEXT_PASSWORD when
  %microsoft_ad_no_plaintext_password not empty
{
  MICROSOFT_AD_PASSWORD_USES_SECURE_PARAMETER
  OR
  MICROSOFT_AD_PASSWORD_USES_SECURE_SERVICE
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   DMS_NO_PLAINTEXT_PASSWORD
#
# Description:
#   DMS Endpoint password must not be a plaintext string or a Ref to a Parameter
#   with a Default value. Can be Ref to a NoEcho Parameter without a Default, or
#   a dynamic reference to a secretsmanager value.
#
# Reports on:
#   AWS::DMS::Endpoint
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F37
#
# Note: this rule works, however it sends the custom message twice for each resource
#
# Scenarios:
# a) SKIP: when there are no AWS::DMS::Endpoint present
# b) PASS: when all AWS::DMS::Endpoint use passwords from secure sources
# c) FAIL: when any AWS::DMS::Endpoint has a Password property not using a secure source
# d) SKIP: when metada has rule suppression for DMS_NO_PLAINTEXT_PASSWORD or CFN_NAG F37

let dms_no_plaintext_password = Resources.*[ Type == 'AWS::DMS::Endpoint'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F37"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "DMS_NO_PLAINTEXT_PASSWORD"
]

# Get any AWS::DMS::Endpoint Refs for Password?
let password_refs = %dms_no_plaintext_password.Properties.Password.'!Ref'

# Rule 1: when dms no plaintext password have Ref to Parameter for Password
rule DMS_USES_SECURE_PARAMETER when
  %dms_no_plaintext_password not empty
{
  Parameters exists
  Parameters not empty
  %password_refs not empty
  let parameter_refs = Parameters.%password_refs
  when %parameter_refs !empty {
    %parameter_refs.Type == 'String'
    %parameter_refs.NoEcho exists
    %parameter_refs.NoEcho == true
    %parameter_refs.Default !exists
  }
}

# Rule 2: when dms no plaintext password and above rule did not pass
rule DMS_USES_SECURE_SERVICE when
  %dms_no_plaintext_password not empty
  not DMS_USES_SECURE_PARAMETER
{
  %dms_no_plaintext_password.Properties.Password !exists
  OR
  %dms_no_plaintext_password.Properties.Password in [ /{{resolve\:secretsmanager\:.*}}/, /{{resolve\:ssm-secure\:.*}}/ ]
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F37    
    Violation: DMS Endpoint password must not be a plaintext string or a Ref to a Parameter with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
    Fix: Replace plaintext value with a secure one.
  >>
}

# One rule to rule them all...
rule DMS_NO_PLAINTEXT_PASSWORD when
  %dms_no_plaintext_password not empty
{
  DMS_USES_SECURE_PARAMETER
  OR
  DMS_USES_SECURE_SERVICE
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   IAM_ROLE_NO_WILDCARD_RESOURCE_ON_PASSROLE
#
# Description:
#   IAM role should not allow * resource with PassRole action on its permissions policy
#
# Reports on:
#   AWS::IAM::Role
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F38
#
# Scenarios:
# a) SKIP: when there are no IAM Roles that contain Policies present
# b) PASS: when no IAM Roles with Policies use Resource *
# c) FAIL: when any IAM Role with a Policy allows Resource *
# d) SKIP: when metada has rule suppression for IAM_ROLE_NO_WILDCARD_RESOURCE_ON_PASSROLE or CFN_NAG F38

let iam_role_no_wildcard_resource_on_passrole = Resources.*[ Type == /AWS::IAM::Role/
  Properties.Policies exists
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F38"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_ROLE_NO_WILDCARD_RESOURCE_ON_PASSROLE"
]

rule IAM_ROLE_NO_WILDCARD_RESOURCE_ON_PASSROLE when %iam_role_no_wildcard_resource_on_passrole !empty {
  let violations = %iam_role_no_wildcard_resource_on_passrole[
    some Properties.Policies[*].PolicyDocument.Statement[*] {
      some Action[*] == 'iam:PassRole'
      Resource == "*"
      Effect == "Allow"
      Condition not exists
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F38    
    Violation: IAM role should not allow * resource with PassRole action on its permissions policy
    Fix: Limit the scope of the Resource for iam:PassRole as much as possible
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   IAM_POLICY_NO_WILDCARD_RESOURCE_ON_PASSROLE
#
# Description:
#   IAM policy should not allow * resource with PassRole action on its permissions policy
#
# Reports on:
#   AWS::IAM::Policy
#   AWS::IAM::ManagedPolicy
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F39, F40
#
# Scenarios:
# a) SKIP: when there are no IAM Policies present
# b) PASS: when no IAM Policies use Resource *
# c) FAIL: when any IAM Policy allows unrestricted Resource *
# d) SKIP: when metada has rule suppression for IAM_POLICY_NO_WILDCARD_RESOURCE_ON_PASSROLE or CFN_NAG F39

let iam_policy_no_wildcard_resource_on_passrole = Resources.*[ Type in [ /AWS::IAM::Policy/, /AWS::IAM::ManagedPolicy/ ]
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id !in [ "F39", "F40" ]
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_POLICY_NO_WILDCARD_RESOURCE_ON_PASSROLE"
]

rule IAM_POLICY_NO_WILDCARD_RESOURCE_ON_PASSROLE when %iam_policy_no_wildcard_resource_on_passrole !empty {
  let violations = %iam_policy_no_wildcard_resource_on_passrole[
    some Properties.PolicyDocument.Statement[*] {
      some Action[*] == 'iam:PassRole'
      Resource == "*"
      Effect == "Allow"
      Condition not exists
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F39    
    Violation: IAM policy should not allow * resource with PassRole action on its permissions policy
    Fix: Limit the scope of the Resource for iam:PassRole as much as possible
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   IAM_USER_LOGIN_PROFILE_NO_PLAINTEXT_PASSWORD
#
# Description:
#  IAM User LoginProfile password must not be a plaintext string or a Ref to a Parameter with a Default value.
#  Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager/ssm-secure value.
#  with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
#
# Reports on:
#   AWS::IAM::User
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F51
#
# Note: this rule works, however it sends the custom message twice for each resource
#
# Scenarios:
# a) SKIP: when there are no AWS::IAM::User present
# b) PASS: when all AWS::IAM::User use passwords from secure sources
# c) FAIL: when any AWS::IAM::User has a Password property not using a secure source
# d) SKIP: when metadata has rule suppression for IAM_USER_LOGIN_PROFILE_NO_PLAINTEXT_PASSWORD or CFN_NAG F51

let iam_user_login_profile_no_plaintext_password = Resources.*[ Type == 'AWS::IAM::User'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F51"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_USER_LOGIN_PROFILE_NO_PLAINTEXT_PASSWORD"
]

# Get any AWS::IAM::User Refs for Password?
let iam_user_login_profile_password_refs = %iam_user_login_profile_no_plaintext_password.Properties.LoginProfile.Password.'!Ref'

# Rule 1: when IAM User Login Profile password no plaintext password have Ref to Parameter for Password
rule IAM_USER_LOGIN_PROFILE_USES_SECURE_PARAMETER when
  %iam_user_login_profile_no_plaintext_password not empty
{
  Parameters exists
  Parameters not empty
  %iam_user_login_profile_password_refs not empty
  let parameter_refs = Parameters.%iam_user_login_profile_password_refs
  when %parameter_refs !empty {
    %parameter_refs.Type == 'String'
    %parameter_refs.NoEcho exists
    %parameter_refs.NoEcho == true
    %parameter_refs.Default !exists
  }
}

# Rule 2: when IAM User Login Profile password no plaintext password and above rule did not pass
rule IAM_USER_LOGIN_PROFILE_USES_SECURE_SERVICE when
  %iam_user_login_profile_no_plaintext_password not empty
  !IAM_USER_LOGIN_PROFILE_USES_SECURE_PARAMETER
{
  let violations = %iam_user_login_profile_no_plaintext_password[
    Properties.LoginProfile exists
    Properties.LoginProfile.Password !exists
    OR
    Properties.LoginProfile.Password not in [ /{{resolve\:secretsmanager\:.*}}/, /{{resolve\:ssm-secure\:.*}}/ ]
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F51    
    Violation: IAM User Login Profile password must not be a plaintext string or a Ref to a Parameter with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
    Fix: Replace plaintext value with a secure one.
  >>
}

# One rule to rule them all...
rule IAM_USER_LOGIN_PROFILE_NO_PLAINTEXT_PASSWORD when
  %iam_user_login_profile_no_plaintext_password not empty
{
  IAM_USER_LOGIN_PROFILE_USES_SECURE_PARAMETER
  OR
  IAM_USER_LOGIN_PROFILE_USES_SECURE_SERVICE
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   AMAZON_MQ_BROKER_USERS_NO_PLAINTEXT_PASSWORD
#
# Description:
#  Amazon MQ Broker Users password must not be a plaintext string or a Ref to a Parameter with a Default value.
#  Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager/ssm-secure value.
#  with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
#
# Reports on:
#   AWS::AmazonMQ::Broker
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F52
#
# Note: this rule works, however it sends the custom message twice for each resource
#
# Scenarios:
# a) SKIP: when there are no AWS::AmazonMQ::Broker present
# b) PASS: when all AWS::AmazonMQ::Broker use passwords from secure sources
# c) FAIL: when any AWS::AmazonMQ::Broker has a Password property not using a secure source
# d) SKIP: when metadata has rule suppression for AMAZON_MQ_BROKER_USERS_NO_PLAINTEXT_PASSWORD or CFN_NAG F52

let amazon_mq_broker_users_no_plaintext_password = Resources.*[ Type == 'AWS::AmazonMQ::Broker'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F52"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "AMAZON_MQ_BROKER_USERS_NO_PLAINTEXT_PASSWORD"
]

# Get any AWS::AmazonMQ::Broker Refs for Password?
let amazon_mq_broker_users_password_refs = %amazon_mq_broker_users_no_plaintext_password.Properties.Users[*].Password.'!Ref'

# Rule 1: when Amazon MQ Broker Users password no plaintext password have Ref to Parameter for Password
rule  AMAZON_MQ_BROKER_USERS_USES_SECURE_PARAMETER when
  %amazon_mq_broker_users_no_plaintext_password not empty
{
  Parameters exists
  Parameters not empty
  %amazon_mq_broker_users_password_refs not empty
  let parameter_refs = Parameters.%amazon_mq_broker_users_password_refs
  when %parameter_refs !empty {
    %parameter_refs.Type == 'String'
    %parameter_refs.NoEcho exists
    %parameter_refs.NoEcho == true
    %parameter_refs.Default !exists
  }
}

# Rule 2: when Amazon MQ Broker Users password no plaintext password and above rule did not pass
rule  AMAZON_MQ_BROKER_USERS_USES_SECURE_SERVICE when
  %amazon_mq_broker_users_no_plaintext_password not empty
  !AMAZON_MQ_BROKER_USERS_USES_SECURE_PARAMETER
{
  let violations = %amazon_mq_broker_users_no_plaintext_password[
    Properties.Users !exists
    OR
    Properties.Users[*].Password !exists
    OR
    some Properties.Users[*].Password not in [ /{{resolve\:secretsmanager\:.*}}/, /{{resolve\:ssm-secure\:.*}}/ ]
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F52    
    Violation: Amazon MQ Broker Users password must not be a plaintext string or a Ref to a Parameter with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
    Fix: Replace plaintext value with a secure one.
  >>
}

# One rule to rule them all...
rule AMAZON_MQ_BROKER_USERS_NO_PLAINTEXT_PASSWORD when
  %amazon_mq_broker_users_no_plaintext_password not empty
{
   AMAZON_MQ_BROKER_USERS_USES_SECURE_PARAMETER
  OR
   AMAZON_MQ_BROKER_USERS_USES_SECURE_SERVICE
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   KINESIS_FIREHOSE_REDSHIFT_DESTINATION_CONFIGURATION_NO_PLAINTEXT_PASSWORD
#
# Description:
#  Kinesis Firehose Redshift Destination Configuration password must not be a plaintext string or a Ref to a Parameter with a Default value.
#  Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager/ssm-secure value.
#  with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
#
# Reports on:
#   AWS::KinesisFirehose::DeliveryStream
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F66
#
# Note: this rule works, however it sends the custom message twice for each resource
#
# Scenarios:
# a) SKIP: when there are no AWS::KinesisFirehose::DeliveryStream present
# b) PASS: when all AWS::KinesisFirehose::DeliveryStream use passwords from secure sources
# c) FAIL: when any AWS::KinesisFirehose::DeliveryStream has a Password property not using a secure source
# d) SKIP: when metadata has rule suppression for KINESIS_FIREHOSE_REDSHIFT_DESTINATION_CONFIGURATION_NO_PLAINTEXT_PASSWORD or CFN_NAG F66

let kinesis_firehose_redshift_destination_configuration_no_plaintext_password = Resources.*[ Type == 'AWS::KinesisFirehose::DeliveryStream'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F66"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "KINESIS_FIREHOSE_REDSHIFT_DESTINATION_CONFIGURATION_NO_PLAINTEXT_PASSWORD"
]

# Get any AWS::KinesisFirehose::DeliveryStream Refs for Password?
let kinesis_firehose_redshift_destination_configuration_password_refs = %kinesis_firehose_redshift_destination_configuration_no_plaintext_password.Properties.RedshiftDestinationConfiguration.Password.'!Ref'

# Rule 1: when Kinesis Firehose Redshift Destination Configuration password no plaintext password have Ref to Parameter for Password
rule KINESIS_FIREHOSE_REDSHIFT_DESTINATION_CONFIGURATION_USES_SECURE_PARAMETER when
  %kinesis_firehose_redshift_destination_configuration_no_plaintext_password not empty
{
  Parameters exists
  Parameters not empty
  %kinesis_firehose_redshift_destination_configuration_password_refs not empty
  let parameter_refs = Parameters.%kinesis_firehose_redshift_destination_configuration_password_refs
  when %parameter_refs !empty {
    %parameter_refs.Type == 'String'
    %parameter_refs.NoEcho exists
    %parameter_refs.NoEcho == true
    %parameter_refs.Default !exists
  }
}

# Rule 2: when Kinesis Firehose Redshift Destination Configuration password no plaintext password and above rule did not pass
rule KINESIS_FIREHOSE_REDSHIFT_DESTINATION_CONFIGURATION_USES_SECURE_SERVICE when
  %kinesis_firehose_redshift_destination_configuration_no_plaintext_password not empty
  !KINESIS_FIREHOSE_REDSHIFT_DESTINATION_CONFIGURATION_USES_SECURE_PARAMETER
{
  let violations = %kinesis_firehose_redshift_destination_configuration_no_plaintext_password[
    Properties.RedshiftDestinationConfiguration exists
    Properties.RedshiftDestinationConfiguration.Password !exists
    OR
    Properties.RedshiftDestinationConfiguration.Password not in [ /{{resolve\:secretsmanager\:.*}}/, /{{resolve\:ssm-secure\:.*}}/ ]
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F66    
    Violation: Kinesis Firehose Redshift Destination Configuration password must not be a plaintext string or a Ref to a Parameter with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
    Fix: Replace plaintext value with a secure one.
  >>
}

# One rule to rule them all...
rule KINESIS_FIREHOSE_REDSHIFT_DESTINATION_CONFIGURATION_NO_PLAINTEXT_PASSWORD when
  %kinesis_firehose_redshift_destination_configuration_no_plaintext_password not empty
{
  KINESIS_FIREHOSE_REDSHIFT_DESTINATION_CONFIGURATION_USES_SECURE_PARAMETER
  OR
  KINESIS_FIREHOSE_REDSHIFT_DESTINATION_CONFIGURATION_USES_SECURE_SERVICE
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   KINESIS_FIREHOSE_SPLUNK_DESTINATION_CONFIGURATION_NO_PLAINTEXT_PASSWORD
#
# Description:
#  Kinesis Firehose Splunk Destination Configuration password must not be a plaintext string or a Ref to a Parameter with a Default value.
#  Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager/ssm-secure value.
#  with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
#
# Reports on:
#   AWS::KinesisFirehose::DeliveryStream
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F68
#
# Note: this rule works, however it sends the custom message twice for each resource
#
# Scenarios:
# a) SKIP: when there are no AWS::KinesisFirehose::DeliveryStream present
# b) PASS: when all AWS::KinesisFirehose::DeliveryStream use passwords from secure sources
# c) FAIL: when any AWS::KinesisFirehose::DeliveryStream has a Password property not using a secure source
# d) SKIP: when metadata has rule suppression for KINESIS_FIREHOSE_SPLUNK_DESTINATION_CONFIGURATION_NO_PLAINTEXT_PASSWORD or CFN_NAG F68

let kinesis_firehose_splunk_destination_configuration_no_plaintext_password = Resources.*[ Type == 'AWS::KinesisFirehose::DeliveryStream'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F68"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "KINESIS_FIREHOSE_SPLUNK_DESTINATION_CONFIGURATION_NO_PLAINTEXT_PASSWORD"
]

# Get any AWS::KinesisFirehose::DeliveryStream Refs for Password?
let kinesis_firehose_splunk_destination_configuration_password_refs = %kinesis_firehose_splunk_destination_configuration_no_plaintext_password.Properties.SplunkDestinationConfiguration.HECToken.'!Ref'

# Rule 1: when Kinesis Firehose Splunk Destination Configuration password no plaintext password have Ref to Parameter for Password
rule KINESIS_FIREHOSE_SPLUNK_DESTINATION_CONFIGURATION_USES_SECURE_PARAMETER when
  %kinesis_firehose_splunk_destination_configuration_no_plaintext_password not empty
{
  Parameters exists
  Parameters not empty
  %kinesis_firehose_splunk_destination_configuration_password_refs not empty
  let parameter_refs = Parameters.%kinesis_firehose_splunk_destination_configuration_password_refs
  when %parameter_refs !empty {
    %parameter_refs.Type == 'String'
    %parameter_refs.NoEcho exists
    %parameter_refs.NoEcho == true
    %parameter_refs.Default !exists
  }
}

# Rule 2: when Kinesis Firehose Splunk Destination Configuration password no plaintext password and above rule did not pass
rule KINESIS_FIREHOSE_SPLUNK_DESTINATION_CONFIGURATION_USES_SECURE_SERVICE when
  %kinesis_firehose_splunk_destination_configuration_no_plaintext_password not empty
  !KINESIS_FIREHOSE_SPLUNK_DESTINATION_CONFIGURATION_USES_SECURE_PARAMETER
{
  let violations = %kinesis_firehose_splunk_destination_configuration_no_plaintext_password[
    Properties.SplunkDestinationConfiguration exists
    Properties.SplunkDestinationConfiguration.HECToken !exists
    OR
    Properties.SplunkDestinationConfiguration.HECToken not in [ /{{resolve\:secretsmanager\:.*}}/, /{{resolve\:ssm-secure\:.*}}/ ]
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F68    
    Violation: Kinesis Firehose Splunk Destination Configuration password must not be a plaintext string or a Ref to a Parameter with a Default value. Can be Ref to a NoEcho Parameter without a Default, or a dynamic reference to a secretsmanager value.
    Fix: Replace plaintext value with a secure one.
  >>
}

# One rule to rule them all...
rule KINESIS_FIREHOSE_SPLUNK_DESTINATION_CONFIGURATION_NO_PLAINTEXT_PASSWORD when
  %kinesis_firehose_splunk_destination_configuration_no_plaintext_password not empty
{
  KINESIS_FIREHOSE_SPLUNK_DESTINATION_CONFIGURATION_USES_SECURE_PARAMETER
  OR
  KINESIS_FIREHOSE_SPLUNK_DESTINATION_CONFIGURATION_USES_SECURE_SERVICE
}

#
#####################################
##         AWS Solutions           ##
#####################################
#
# Rule Identifier:
#    KMS_NO_WILDCARD_PRINCIPAL
#
# Description:
#   KMS key should not allow * principal
#
# Reports on:
#    AWS::KMS::Key
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN-NAG Rule
#    F76
#
# Documentation:
#    https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html
#
# Scenarios:
# a) SKIP: when there are no KMS CMKs
# b) SKIP: when metada has rule suppression for KMS_NO_WILDCARD_PRINCIPAL
# c) FAIL: when Principal: '*' appears in any KeyPolicy
# d) PASS: when no keypolicy has Principle: '*'

let kms_no_wildcard_principal = Resources.*[ Type == "AWS::KMS::Key"
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F76"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "KMS_NO_WILDCARD_PRINCIPAL"
]

rule KMS_NO_WILDCARD_PRINCIPAL when %kms_no_wildcard_principal !empty {
  let violations = %kms_no_wildcard_principal[
    some Properties.KeyPolicy.Statement[*] {
      Principal == '*'
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F76    
    Violation: KMS key should not allow * principal.
    Fix: Set the EnableKeyRotation property to true.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   COGNITO_USER_POOL_MFA_CONFIGURATION_RULE
#
# Description:
#   AWS Cognito UserPool should have MfaConfiguration set to 'ON' (MUST be wrapped in quotes) or at least 'OPTIONAL.
#
# Reports on:
#   AWS::Cognito::UserPool
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F78
#
# Scenarios:
# a) SKIP: when there are no cognito userpool resources present.
# b) PASS: when all cognito userpool resources have mfa configuration as ON or OPTIONAL.
# c) FAIL: when any cognito userpool resources have mfa configuration as OFF.
# d) SKIP: when metadata has rule suppression for COGNITO_USER_POOL_MFA_CONFIGURATION_RULE or CFN_NAG F78

#
# Select all cognito UserPool resources from incoming template (payload)
#
let cognito_user_pool_mfa_configuration_rule = Resources.*[ Type == 'AWS::Cognito::UserPool'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F78"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "COGNITO_USER_POOL_MFA_CONFIGURATION_RULE"
]

rule COGNITO_USER_POOL_MFA_CONFIGURATION_RULE when %cognito_user_pool_mfa_configuration_rule !empty {
  let violation = %cognito_user_pool_mfa_configuration_rule[
    Type == 'AWS::Cognito::UserPool'
    Properties.MfaConfiguration exists
    Properties.MfaConfiguration == 'OFF'
  ]

  %violation empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F78    
    Violation: cognito userpool resources have mfa configuration as OFF.
    Fix: Change mfa configuration to ON or OPTIONAL.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    RDS_INSTANCE_DELETION_PROTECTION_ENABLED
#
# Description:
#    Checks if an Amazon Relational Database Service (Amazon RDS) instance has deletion protection enabled.
#
# Reports on:
#    AWS::RDS::DBInstance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no RDS instances present
# b) PASS: when all RDS instances have DeletionProtection set to true
# c) FAIL: when all RDS instances have DeletionProtection set to false
# d) FAIL: when there are RDS instances with DeletionProtection property is not present
# e) SKIP: when metadata includes the suppression for rule RDS_INSTANCE_DELETION_PROTECTION_ENABLED

#
# Select all RDS instance resources from incoming template (payload)
#
let aws_rds_instances_deletion_protection_enabled = Resources.*[ Type == 'AWS::RDS::DBInstance'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "F80"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "RDS_INSTANCE_DELETION_PROTECTION_ENABLED"
]

rule RDS_INSTANCE_DELETION_PROTECTION_ENABLED when %aws_rds_instances_deletion_protection_enabled !empty {
  %aws_rds_instances_deletion_protection_enabled.Properties.DeletionProtection EXISTS
  %aws_rds_instances_deletion_protection_enabled.Properties.DeletionProtection == true
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F80    
    Violation: All RDS instances must deletion protection enabled.
    Fix: Set the parameter for DeletionProtection to true.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   WAF_WEB_ACL_DEFAULT_ACTION_RULE
#
# Description:
#   WebAcl DefaultAction should not be ALLOW.
#
# Reports on:
#   AWS::WAF::WebACL
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F665
#
# Scenarios:
# a) SKIP: when there are no WAF ACL resources present.
# b) PASS: when all WAF ACL resources do not have default action as allow.
# c) FAIL: when any WAF ACL resources have default action as allow.
# d) SKIP: when metadata has rule suppression for WAF_WEB_ACL_DEFAULT_ACTION_RULE or CFN_NAG F665

#
# Select all WAF ACL resources from incoming template (payload)
#
let waf_web_acl_default_action_rule = Resources.*[ Type == 'AWS::WAF::WebACL'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F665"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "WAF_WEB_ACL_DEFAULT_ACTION_RULE"
]

rule WAF_WEB_ACL_DEFAULT_ACTION_RULE when %waf_web_acl_default_action_rule !empty {
  let violation = %waf_web_acl_default_action_rule[
    Type == 'AWS::WAF::WebACL'
    Properties.DefaultAction.Type == 'ALLOW'
  ]

  %violation empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F665    
    Violation: WAF ACL resources have default action as allow.
    Fix: Change Default Action on WAF ACL resources.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    SECURITY_GROUP_MISSING_EGRESS_RULE
#
# Description:
#   Missing egress rule means all traffic is allowed outbound. Make this explicit if it is desired configuration.
#
# Reports on:
#    AWS::EC2::SecurityGroup
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   F1000
#
# Scenarios:
# a) SKIP: when there are no Security Groups resource present
# b) PASS: When all Security Groups has Egresses specified.
# c) FAIL: When any Security Groups does not have Egresses specified.
# d) SKIP: when metadata has rule suppression for SECURITY_GROUP_MISSING_EGRESS_RULE

#
# Select all Security Group resources from incoming template (payload)
#
let security_group_missing_egress_rule = Resources.*[ Type == 'AWS::EC2::SecurityGroup'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F1000"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SECURITY_GROUP_MISSING_EGRESS_RULE"
]

rule SECURITY_GROUP_MISSING_EGRESS_RULE when %security_group_missing_egress_rule !empty {
  %security_group_missing_egress_rule.Type == 'AWS::EC2::SecurityGroup'
  %security_group_missing_egress_rule.Properties.SecurityGroupEgress exists
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F1000    
    Violation: Security Groups resources does not have Egresses specified.
    Fix: Specify Egresses for all security group resources exists
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   IAM_USER_MISSING_GROUP_RULE
#
# Description:
#   IAM User is not assigned to a group.
#
# Reports on:
#   AWS::IAM::User
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   F2000
#
# Scenarios:
# a) SKIP: when there are no IAM Users present
# b) PASS: when all IAM Users have been assigned to a group.
# c) FAIL: when any IAM Users have not been assigned to a group.
# d) SKIP: when metadata has rule suppression for IAM_USER_MISSING_GROUP_RULE or CFN_NAG F2000

#
# Select all IAM User resources from incoming template (payload)
#
let iam_user_missing_group_rule = Resources.*[ Type == 'AWS::IAM::User'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "F2000"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_USER_MISSING_GROUP_RULE"
]

rule IAM_USER_MISSING_GROUP_RULE when %iam_user_missing_group_rule !empty {
  %iam_user_missing_group_rule.Type == 'AWS::IAM::User'
  %iam_user_missing_group_rule.Properties.Groups exists
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F2000    
    Violation: IAM Users have not been assigned to a group.
    Fix: Assign IAM user to a group.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    CFN_AUTHENTICATION_RULE
#
# Description:
#   Specifying credentials in the template itself is probably not the safest thing.
#
# Reports on:
#    All Resources
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W1
#
# Scenarios:
# a) SKIP: when there are no resource present
# b) PASS: When no resources specifies credentials in template.
# c) FAIL: When any resource specifies credentials in template.
# d) SKIP: when metadata has rule suppression for CFN_AUTHENTICATION_RULE

#
# Select all Security Group resources from incoming template (payload)
#
let cfn_authentication_rule = Resources.Metadata
let skip_cfn_authentication = %cfn_authentication_rule[
      "AWS::CloudFormation::Authentication" exists
      Metadata.cfn_nag.rules_to_suppress not exists or
      Metadata.cfn_nag.rules_to_suppress.*.id != "W1"
      Metadata.guard.SuppressedRules not exists or
      Metadata.guard.SuppressedRules.* != "CFN_AUTHENTICATION_RULE"
]

rule CFN_AUTHENTICATION_RULE when
    %cfn_authentication_rule !empty
    %skip_cfn_authentication !empty
 {
  let violation = %cfn_authentication_rule[
    "AWS::CloudFormation::Authentication".*.accessKeyId exists
    OR
    "AWS::CloudFormation::Authentication".*.password exists
    OR
    "AWS::CloudFormation::Authentication".*.secretKey exists
  ]

  %violation empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W1    
    Violation: CFN template has sensitive credentials defined.
    Fix: Remove sensitive credentials.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    EC2_SECURITY_GROUP_INGRESS_OPEN_TO_WORLD_RULE
#
# Description:
#   Check if cidr FOR ipv4 and ipv6 on security group ingress is open or private.
#
# Reports on:
#    [AWS::EC2::SecurityGroupIngress, AWS::EC2::SecurityGroup]
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W2
#
# Scenarios:
# a) SKIP: when there are no Security Ingress Groups resource present
# b) PASS: When all Security Ingress Groups do not use open to world cidr
# c) FAIL: when any Security Ingress Groups uses open to world cidr
# d) SKIP: when metadata has rule suppression for EC2_SECURITY_GROUP_INGRESS_OPEN_TO_WORLD_RULE

#
# Select all Security Group Ingress resources from incoming template (payload)
#

let ec2_security_group_ingress_open_to_world_rule_sg_ingress_resources = Resources.*[ Type == 'AWS::EC2::SecurityGroup'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W2"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EC2_SECURITY_GROUP_INGRESS_OPEN_TO_WORLD_RULE"
]

let ec2_security_group_ingress_open_to_world_rule_sgi_resources = Resources.*[ Type == 'AWS::EC2::SecurityGroupIngress'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W2"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EC2_SECURITY_GROUP_INGRESS_OPEN_TO_WORLD_RULE"
]

rule EC2_SECURITY_GROUP_INGRESS_OPEN_TO_WORLD_RULE when %ec2_security_group_ingress_open_to_world_rule_sgi_resources !empty OR %ec2_security_group_ingress_open_to_world_rule_sg_ingress_resources !empty {
  let violations_sg = %ec2_security_group_ingress_open_to_world_rule_sg_ingress_resources[
    Type == 'AWS::EC2::SecurityGroup'
    Properties.SecurityGroupIngress exists
    some Properties.SecurityGroupIngress[*].CidrIp == '0.0.0.0/0'
    OR
    some Properties.SecurityGroupIngress[*].CidrIpv6 == '::/0'
  ]

  let violations_sgi = %ec2_security_group_ingress_open_to_world_rule_sgi_resources[
    Type == 'AWS::EC2::SecurityGroupIngress'
    Properties.CidrIp == '0.0.0.0/0'
    OR
    Properties.CidrIpv6 == '::/0'
  ]

  %violations_sg empty
  %violations_sgi empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W2    
    Violation: Security Group Ingress has a range of ports instead of a single port
    Fix: Use single port instead of range of ports for ingress rules
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    EC2_SECURITY_GROUP_EGRESS_OPEN_TO_WORLD_RULE
#
# Description:
#   Check if cidr FOR ipv4 and ipv6 on security group egress is open or private.
#
# Reports on:
#    AWS::EC2::SecurityGroup, AWS::EC2::SecurityGroupEgress
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W5
#
# Scenarios:
# a) SKIP: when there are no Security Egress Groups resource present
# b) PASS: When all Security Egress Groups do not use open to world cidr
# c) FAIL: when any Security Egress Groups uses open to world cidr
# d) SKIP: when metadata has rule suppression for EC2_SECURITY_GROUP_EGRESS_OPEN_TO_WORLD_RULE

#
# Select all Security Group Egress resources from incoming template (payload)
#

let ec2_security_group_ingress_open_to_world_rule_sg_egress_resources = Resources.*[ Type == 'AWS::EC2::SecurityGroup'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W5"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EC2_SECURITY_GROUP_EGRESS_OPEN_TO_WORLD_RULE"
]

let ec2_security_group_egress_open_to_world_rule_sge_resources = Resources.*[ Type == 'AWS::EC2::SecurityGroupEgress'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W5"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EC2_SECURITY_GROUP_EGRESS_OPEN_TO_WORLD_RULE"
]

rule EC2_SECURITY_GROUP_EGRESS_OPEN_TO_WORLD_RULE when %ec2_security_group_egress_open_to_world_rule_sge_resources !empty OR %ec2_security_group_ingress_open_to_world_rule_sg_egress_resources !empty {
  let violations_sg = %ec2_security_group_ingress_open_to_world_rule_sg_egress_resources[
    Type == 'AWS::EC2::SecurityGroup'
    Properties.SecurityGroupEgress exists
    some Properties.SecurityGroupEgress[*].CidrIp == '0.0.0.0/0'
    OR
    some Properties.SecurityGroupEgress[*].CidrIpv6 == '::/0'
  ]

  let violations_sge = %ec2_security_group_egress_open_to_world_rule_sge_resources[
    Type == 'AWS::EC2::SecurityGroupEgress'
    Properties.CidrIp == '0.0.0.0/0'
    OR
    Properties.CidrIpv6 == '::/0'
  ]

  %violations_sg empty
  %violations_sge empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W5    
    Violation: Security Group Egress has a range of ports instead of a single port
    Fix: Use single port instead of range of ports for egress rules
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    SECURITY_GROUP_INGRESS_CIDR_NON_32_RULE
#
# Description:
#   Check if Security Groups found ingress cidr is not /32
#
# Reports on:
#    [AWS::EC2::SecurityGroup, AWS::EC2::SecurityGroupIngress]
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W9
#
# Scenarios:
# a) SKIP: when there are no Security Ingress Groups resource present
# b) PASS: When all Security Ingress Groups cidr is /32 for ipv4 or /128 for ipv6
# c) FAIL: when any Security Ingress Groups cidr is not /32 for ipv4 or /128 for ipv6
# d) SKIP: when metadata has rule suppression for SECURITY_GROUP_INGRESS_CIDR_NON_32_RULE

#
# Select all Security Group Ingress resources from incoming template (payload)
#
let security_group_ingress_cidr_non_32_rule_sg_resources = Resources.*[ Type == 'AWS::EC2::SecurityGroup'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W9"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SECURITY_GROUP_INGRESS_CIDR_NON_32_RULE"
]

let security_group_ingress_cidr_non_32_rule_sgi_resources = Resources.*[ Type == 'AWS::EC2::SecurityGroupIngress'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W9"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SECURITY_GROUP_INGRESS_CIDR_NON_32_RULE"
]

rule SECURITY_GROUP_INGRESS_CIDR_NON_32_RULE when %security_group_ingress_cidr_non_32_rule_sgi_resources !empty OR %security_group_ingress_cidr_non_32_rule_sg_resources !empty {
   let violations_sg = %security_group_ingress_cidr_non_32_rule_sg_resources[
     Type == 'AWS::EC2::SecurityGroup'
     Properties.SecurityGroupIngress exists
     some Properties.SecurityGroupIngress[*].CidrIp != /\/32/
     OR
     some Properties.SecurityGroupIngress[*].CidrIpv6 != /\/128/
   ]

   let violations_sgi = %security_group_ingress_cidr_non_32_rule_sgi_resources[
     Type == 'AWS::EC2::SecurityGroupIngress'
     Properties.CidrIp != /\/32/
     OR
     Properties.CidrIpv6 != /\/128/
  ]

  %violations_sg empty
  %violations_sgi empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W9    
    Violation: Security Group Ingress cidr has ipv4 that is not /32 or ipv6 that is not /128
    Fix: Use /32 for ipv4 cidr and /128 for ipv6 cidr
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CLOUDFRONT_ACCESSLOGS_ENABLED
#
# Description:
#  Checks if Amazon CloudFront Distributions are configured with access logging.
#
# Reports on:
#    AWS::CloudFront::Distribution
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no CloudFront Distribution Resources
# b) SKIP: when metada has rule suppression for CLOUDFRONT_ACCESSLOGS_ENABLED
# c) FAIL: when all CloudFront Distribution Resources do not have the Logging Configuration element present
# d) PASS: when all CloudFront Distribution Resources have a Logging Configuration element present

#
# Select all CloudFront Distribution Resources from incoming template (payload)
#
let cloudfront_accesslogs_enabled_resources = Resources.*[ Type == 'AWS::CloudFront::Distribution'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W10"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CLOUDFRONT_ACCESSLOGS_ENABLED"
]

rule CLOUDFRONT_ACCESSLOGS_ENABLED when %cloudfront_accesslogs_enabled_resources !empty {
  %cloudfront_accesslogs_enabled_resources.Properties.DistributionConfig.Logging exists
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W10    
    Violation: CloudFront Distributions need to be configured to log informaiton about requests the Distribution receives.
    Fix: Set the CloudFront Distribution DistributionConfig.Logging.Bucket property to an S3 bucket you own that has been configured to receive CloudFront standard logs.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   IAM_POLICYDOCUMENT_NO_WILDCARD_RESOURCE
#
# Description:
#   Checks that no IAM Role in-line policies use resource: "*"
#
# Reports on:
#   AWS::IAM::Role
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   W10, W11, W12
#
# Scenarios:
# a) SKIP: when there are no IAM Roles, Policies, or ManagedPolicies present
# b) PASS: when all IAM Roles do not use resource: "*"
# c) FAIL: when any IAM Roles allow a wildcard for a resource
# d) SKIP: when metadata has rule suppression for IAM_POLICYDOCUMENT_NO_WILDCARD_RESOURCE or W11, W12, or W13

let applicable_types = [
  "AWS::IAM::Role",
  "AWS::IAM::Policy",
  "AWS::IAM::ManagedPolicy"
]

let iam_policydocument_no_wildcard_resource = Resources.*[ Type in %applicable_types
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id !in [ "W11", "W12", "W13" ]
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_POLICYDOCUMENT_NO_WILDCARD_RESOURCE"
]

rule IAM_POLICYDOCUMENT_NO_WILDCARD_RESOURCE when %iam_policydocument_no_wildcard_resource not empty {
  let violations = %iam_policydocument_no_wildcard_resource[
    some Properties.Policies[*].PolicyDocument.Statement[*] {
      some Resource[*] == "*"
      Effect == "Allow"
    }
    or
    some Properties.PolicyDocument.Statement[*] {
      some Resource[*] == "*"
      Effect == "Allow"
    }
    or
    some Properties.PolicyDocument.Statement[*] {
      some Resource[*] == "*"
      Effect == "Allow"
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W11,W12,W13    
    Violation: IAM Role inline policy should not allow resource: "*"
    Fix: Limit resource as specifically as possible within your use case.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   IAM_ROLE_NO_ALLOW_PLUS_NOT_ACTION_ON_TRUST_POLICY
#
# Description:
#   Checks that IDENTITY ACCESS MANAGEMENT (IAM) Role do not use Allow+NotAction on Trust Policy
#
# Reports on:
#   AWS::IAM::Role
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   W14
#
# Documentation:
# https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_notaction.html
#
# Scenarios:
# a) SKIP: when there are no IAM Roles present
# b) PASS: when all IAM Roles do not use Allow+NotAction on Trust Permission
# c) FAIL: when any IAM Roles allow both Effect: Allow and NotAction on Trust Permission
# d) SKIP: when metadata has rule suppression for IAM_ROLE_NO_ALLOW_PLUS_NOT_ACTION_ON_TRUST_POLICY or CFN_NAG W14

let iam_role_no_allow_plus_not_action_on_trust_policy = Resources.*[ Type == 'AWS::IAM::Role'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W14"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_ROLE_NO_ALLOW_PLUS_NOT_ACTION_ON_TRUST_POLICY"
]

rule IAM_ROLE_NO_ALLOW_PLUS_NOT_ACTION_ON_TRUST_POLICY when %iam_role_no_allow_plus_not_action_on_trust_policy !empty {
  let violations = %iam_role_no_allow_plus_not_action_on_trust_policy[
    Type == 'AWS::IAM::Role'
    some Properties.AssumeRolePolicyDocument.Statement[*] {
      Effect == "Allow"
      NotAction exists
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W14    
    Violation: IAM Roles should not allow Allow+NotAction on trust permissions
    Fix: Remove IAM Roles on trust permissions that match {"Effect": "Allow", "NotAction": ... }
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   IAM_ROLE_OR_POLICY_NO_ALLOW_PLUS_NOT_ACTION
#
# Description:
#   Checks that AWS Identity and Access Management (IAM) roles do not use Allow+NotAction
#
# Reports on:
#   AWS::IAM::Role, AWS::IAM::Policy, AWS::IAM::ManagedPolicy
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   W15, W16, W17
#
# Documentation:
# https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_notaction.html
#
# Scenarios:
# a) SKIP: when there are no IAM Roles or Policies present
# b) PASS: when all IAM Roles and Policies do not use Allow+NotAction
# c) FAIL: when any IAM Roles or Policies has both Effect: Allow and NotAction
# d) SKIP: when metadata has rule suppression for IAM_ROLE_OR_POLICY_NO_ALLOW_PLUS_NOT_ACTION or CFN_NAG W15, W16, W17

let applicable_types = [
  "AWS::IAM::Role",
  "AWS::IAM::Policy",
  "AWS::IAM::ManagedPolicy"
]

let iam_role_or_policy_no_allow_plus_not_action = Resources.*[ Type in %applicable_types
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id !in ["W15", "W16", "W17"]
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_ROLE_OR_POLICY_NO_ALLOW_PLUS_NOT_ACTION"
]

rule IAM_ROLE_OR_POLICY_NO_ALLOW_PLUS_NOT_ACTION when %iam_role_or_policy_no_allow_plus_not_action !empty {
  let violations = %iam_role_or_policy_no_allow_plus_not_action[
    Type == 'AWS::IAM::Role'
    or
    Type == 'AWS::IAM::Policy'
    or
    Type == 'AWS::IAM::ManagedPolicy'
    some Properties.PolicyDocument.Statement[*] {
      Effect == "Allow"
      NotAction exists
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W15,W16,W17    
    Violation: IAM role or policy should not allow Allow+NotAction
    Fix: Remove roles or policy statements that match {"Effect": "Allow", "NotAction": ... }
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   SQS_QUEUEPOLICY_NO_ALLOW_PLUS_NOT_ACTION
#
# Description:
#   Checks that SIMPLE QUEUE SERVICE (SQS) Queue Policy do not use Allow+NotAction
#
# Reports on:
#   AWS::SQS::QueuePolicy
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   W18
#
# Documentation:
# https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-overview-of-managing-access.html
#
# Scenarios:
# a) SKIP: when there are no SQS Queue Policies present
# b) PASS: when all SQS Queue Policies do not use Allow+NotAction
# c) FAIL: when any SQS Queue Policies allow both Effect: Allow and NotAction
# d) SKIP: when metadata has rule suppression for SQS_QUEUEPOLICY_NO_ALLOW_PLUS_NOT_ACTION or CFN_NAG W18

let sqs_queuepolicy_no_allow_plus_not_action = Resources.*[ Type == 'AWS::SQS::QueuePolicy'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W18"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SQS_QUEUEPOLICY_NO_ALLOW_PLUS_NOT_ACTION"
]

rule SQS_QUEUEPOLICY_NO_ALLOW_PLUS_NOT_ACTION when %sqs_queuepolicy_no_allow_plus_not_action !empty {
  let violations = %sqs_queuepolicy_no_allow_plus_not_action[
    Type == 'AWS::SQS::QueuePolicy'
    some Properties.PolicyDocument.Statement[*] {
      Effect == "Allow"
      NotAction exists
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W18    
    Violation: SQS QueuePolicy should not allow Allow+NotAction
    Fix: Remove SQS Queue Policies that match {"Effect": "Allow", "NotAction": ... }
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   SNS_TOPICPOLICY_NO_ALLOW_PLUS_NOT_ACTION
#
# Description:
#   Checks that SIMPLE NOTIFICATION SERVICE (SNS) TOPIC Policy do not use Allow+NotAction
#
# Reports on:
#   AWS::SNS::TopicPolicy
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   W19
#
# Documentation:
# https://docs.aws.amazon.com/sns/latest/dg/sns-using-identity-based-policies.html
#
# Scenarios:
# a) SKIP: when there are no SNS Topic Policies present
# b) PASS: when all SNS Topic Policies do not use Allow+NotAction
# c) FAIL: when any SNS Topic Policies allow both Effect: Allow and NotAction
# d) SKIP: when metadata has rule suppression for SNS_TOPICPOLICY_NO_ALLOW_PLUS_NOT_ACTION or CFN_NAG W19

let sns_topicpolicy_no_allow_plus_not_action = Resources.*[ Type == 'AWS::SNS::TopicPolicy'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W19"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SNS_TOPICPOLICY_NO_ALLOW_PLUS_NOT_ACTION"
]

rule SNS_TOPICPOLICY_NO_ALLOW_PLUS_NOT_ACTION when %sns_topicpolicy_no_allow_plus_not_action !empty {
  let violations = %sns_topicpolicy_no_allow_plus_not_action[
    Type == 'AWS::SNS::TopicPolicy'
    some Properties.PolicyDocument.Statement[*] {
      Effect == "Allow"
      NotAction exists
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W19    
    Violation: SNS TopicPolicy should not allow Allow+NotAction
    Fix: Remove SNS Topic Policies that match {"Effect": "Allow", "NotAction": ... }
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   S3_BUCKET_POLICY_NO_ALLOW_PLUS_NOT_ACTION
#
# Description:
#   Checks that SIMPLE STORAGE SERVICE (S3) TOPIC Policy do not use Allow+NotAction
#
# Reports on:
#   AWS::S3::BucketPolicy
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   W20
#
# Documentation:
# https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-access-control.html
#
# Scenarios:
# a) SKIP: when there are no S3 Bucket Policies present
# b) PASS: when all S3 Bucket Policies do not use Allow+NotAction
# c) FAIL: when any S3 Bucket Policies allow both Effect: Allow and NotAction
# d) SKIP: when metadata has rule suppression for S3_BUCKET_POLICY_NO_ALLOW_PLUS_NOT_ACTION or CFN_NAG W20

let s3_bucket_policy_no_allow_plus_not_action = Resources.*[ Type == 'AWS::S3::BucketPolicy'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W20"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_BUCKET_POLICY_NO_ALLOW_PLUS_NOT_ACTION"
]

rule S3_BUCKET_POLICY_NO_ALLOW_PLUS_NOT_ACTION when %s3_bucket_policy_no_allow_plus_not_action !empty {
  let violations = %s3_bucket_policy_no_allow_plus_not_action[
    Type == 'AWS::S3::BucketPolicy'
    some Properties.PolicyDocument.Statement[*] {
      Effect == "Allow"
      NotAction exists
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W20    
    Violation: S3 BucketPolicy should not allow Allow+NotAction
    Fix: Remove S3 Bucket Policies that match {"Effect": "Allow", "NotAction": ... }
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   IAM_ROLE_OR_POLICY_NO_ALLOW_PLUS_NOT_RESOURCE
#
# Description:
#   Checks that AWS Identity and Access Management (IAM) roles do not use Allow+NotResource
#
# Reports on:
#   AWS::IAM::Role, AWS::IAM::Policy, AWS::IAM::ManagedPolicy
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   W21, W22, W23
#
# Documentation:
# https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_notresource.html
#
# Scenarios:
# a) SKIP: when there are no IAM Roles or Policies present
# b) PASS: when all IAM Roles and Policies do not use Allow+NotResource
# c) FAIL: when any IAM Roles or Policies has both Effect: Allow and NotResource
# d) SKIP: when metadata has rule suppression for IAM_ROLE_OR_POLICY_NO_ALLOW_PLUS_NOT_RESOURCE or CFN_NAG W21, W22, W23

let applicable_types = [
  "AWS::IAM::Role",
  "AWS::IAM::Policy",
  "AWS::IAM::ManagedPolicy"
]

let iam_role_or_policy_no_allow_plus_not_resource = Resources.*[ Type in %applicable_types
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id !in ["W21", "W22", "W23"]
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_ROLE_OR_POLICY_NO_ALLOW_PLUS_NOT_RESOURCE"
]

rule IAM_ROLE_OR_POLICY_NO_ALLOW_PLUS_NOT_RESOURCE when %iam_role_or_policy_no_allow_plus_not_resource !empty {
  let violations = %iam_role_or_policy_no_allow_plus_not_resource[
    Type == 'AWS::IAM::Role'
    or
    Type == 'AWS::IAM::Policy'
    or
    Type == 'AWS::IAM::ManagedPolicy'
    some Properties.PolicyDocument.Statement[*] {
      Effect == "Allow"
      NotResource exists
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W21,W22,W23    
    Violation: IAM role or policy should not allow Allow+NotResource
    Fix: Remove roles or policy statements that match {"Effect": "Allow", "NotResource": ... }
  >>
}

#
#####################################
##         AWS Solutions           ##
#####################################
# Rule Identifier:
#    LAMBDA_PERMISSION_INVOKE_FUNCTION_ACTION
#
# Description:
#    Checks if the AWS Lambda permission uses any other action apart from 'lambda:InvokeFunction'
#
# Reports on:
#    AWS::Lambda::Permission
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W24
#
# Scenarios:
# a) SKIP: when no AWS Lambda permission policies are present
# b) PASS: when no AWS Lambda permission uses any other action apart from 'lambda:InvokeFunction'
# c) FAIL: when any AWS Lambda permission allows action apart from 'lambda:InvokeFunction'
# d) SKIP: When metadata includes the suppression for rule LAMBDA_PERMISSION_INVOKE_FUNCTION_ACTION

let applicable_types = [
  "AWS::Lambda::Permission"
]

let lambda_permission_invoke_function_action = Resources.*[ Type in %applicable_types
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W24"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "LAMBDA_PERMISSION_INVOKE_FUNCTION_ACTION"
]

rule LAMBDA_PERMISSION_INVOKE_FUNCTION_ACTION when %lambda_permission_invoke_function_action !empty {
  let violations = %lambda_permission_invoke_function_action[
    some Properties.Action != 'lambda:InvokeFunction'
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W24    
    Violation: Lambda permission beside InvokeFunction might not be what you want.
    Fix: Remove Actions beside 'lambda:InvokeFunction'.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#   ELB_LOGGING_ENABLED
#
# Description:
#   This rule checks whether Classic Load Balancers have logging enabled.
#
# Reports on:
#   AWS::ElasticLoadBalancing::LoadBalancer
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   None
#
# Scenarios:
# a) SKIP: when there are no Elastic Load Balancing Resources
# b) SKIP: when metadata has rule suppression for ELB_LOGGING_ENABLED
# c) FAIL: when 'AccessLoggingPolicy' has not been specified
# d) FAIL: when 'AccessLoggingPolicy' has been specified and 'Enabled' in 'AccessLoggingPolicy' has been set to false
# e) PASS: when 'AccessLoggingPolicy' has been specified and 'Enabled' in 'AccessLoggingPolicy' has been set to true

#
# Select all Elastic Load Balancing Resources from incoming template (payload)
#
let elb_logging_enabled_resources = Resources.*[ Type == 'AWS::ElasticLoadBalancing::LoadBalancer'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W26"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELB_LOGGING_ENABLED"
]

rule ELB_LOGGING_ENABLED when %elb_logging_enabled_resources !empty {
    %elb_logging_enabled_resources.Properties {
        AccessLoggingPolicy exists
        AccessLoggingPolicy {
            Enabled == true
            <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W26    
                Violation: This rule checks whether Classic Load Balancers have logging enabled.
                Fix: Set the Classic Load Balancer 'AccessLoggingPolicy.Enabled' property to true and 'S3BucketName' to an S3 bucket you own that has been configured to receive ELB logs.
            >>
        }
    }
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    SECURITY_GROUP_INGRESS_PORT_RANGE_RULE
#
# Description:
#   Check if Security Groups found ingress with port range instead of just a single PORT
#
# Reports on:
#    [AWS::EC2::SecurityGroup, AWS::EC2::SecurityGroupIngress]
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W27
#
# Scenarios:
# a) SKIP: when there are no Security Ingress Groups resource present
# b) PASS: When all Security Ingress Groups uses a single port and not range
# c) FAIL: when any Security Ingress Groups uses a range of ports
# d) SKIP: when metadata has rule suppression for SECURITY_GROUP_INGRESS_PORT_RANGE_RULE

#
# Select all Security Group Ingress resources from incoming template (payload)
#
let security_group_ingress_port_range_rule_sg_ingress_resources = Resources.*[ Type == 'AWS::EC2::SecurityGroup'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W27"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SECURITY_GROUP_INGRESS_PORT_RANGE_RULE"
]

let security_group_ingress_port_range_rule_sgi_resources = Resources.*[ Type == 'AWS::EC2::SecurityGroupIngress'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W27"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SECURITY_GROUP_INGRESS_PORT_RANGE_RULE"
]

rule SECURITY_GROUP_INGRESS_PORT_RANGE_RULE when %security_group_ingress_port_range_rule_sgi_resources !empty OR %security_group_ingress_port_range_rule_sg_ingress_resources !empty {
  let violations_sg = %security_group_ingress_port_range_rule_sg_ingress_resources[
    Type == 'AWS::EC2::SecurityGroup'
    Properties.SecurityGroupIngress exists
    some Properties.SecurityGroupIngress[*] {
        FromPort exists
        ToPort exists
        FromPort not in ToPort
    }
  ]

  let violations_sgi = %security_group_ingress_port_range_rule_sgi_resources[
    Type == 'AWS::EC2::SecurityGroupIngress'
    Properties.FromPort exists
    Properties.ToPort exists
    Properties.FromPort not in Properties.ToPort
  ]

  %violations_sg empty
  %violations_sgi empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W27    
    Violation: Security Group Ingress has a range of ports instead of a single port
    Fix: Use single port instead of range of ports for ingress rules
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   CFN_NO_EXPLICIT_RESOURCE_NAMES
#
# Description:
#   Checks that the template does not explicitely name resources.
#
# Reports on:
#   Various
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   W28
#
# Scenarios:
# a) SKIP: when none of the covered resources types are present
# b) PASS: when none of the applicable types have static resource names
# c) FAIL: when any applicable types has a static resource name
# d) SKIP: when metada has rule suppression for CFN_NO_EXPLICIT_RESOURCE_NAMES or CFN_NAG W28

let applicable_types = [
  "AWS::ApiGateway::ApiKey",
  "AWS::CloudWatch::Alarm",
  "AWS::CodeDeploy::DeploymentConfig",
  "AWS::CodeDeploy::DeploymentGroup",
  "AWS::DynamoDB::Table",
  "AWS::EC2::SecurityGroup",
  "AWS::ECR::Repository",
  "AWS::ElasticLoadBalancingV2::LoadBalancer",
  "AWS::Elasticsearch::Domain",
  "AWS::IAM::Group",
  "AWS::IAM::ManagedPolicy",
  "AWS::IAM::Role",
  "AWS::Kinesis::Stream",
  "AWS::RDS::DBInstance"
]

# Select applicable resources less suppressed resources
let cloudformation_no_static_name_resources = Resources.*[Type in %applicable_types
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W28"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CFN_NO_EXPLICIT_RESOURCE_NAMES"
]

rule CFN_NO_EXPLICIT_RESOURCE_NAMES
  when %cloudformation_no_static_name_resources !empty {
    AWS::ApiGateway::ApiKey {
      Properties{
        Name empty
      }
    }
    AWS::CloudWatch::Alarm {
      Properties{
        AlarmName empty
      }
    }
    AWS::CodeDeploy::DeploymentConfig {
      Properties{
        DeploymentConfigName empty
      }
    }
    AWS::CodeDeploy::DeploymentGroup {
      Properties{
        DeploymentGroupName empty
      }
    }
    AWS::DynamoDB::Table {
      Properties{
        TableName empty
      }
    }
    AWS::EC2::SecurityGroup {
      Properties{
        GroupName empty
      }
    }
    AWS::ECR::Repository {
      Properties{
        RepositoryName empty
      }
    }
    AWS::ElasticLoadBalancingV2::LoadBalancer {
      Properties{
        Name empty
      }
    }
    AWS::Elasticsearch::Domain {
      Properties{
        DomainName empty
      }
    }
    AWS::IAM::Group {
      Properties{
        GroupName empty
      }
    }
    AWS::IAM::ManagedPolicy {
      Properties{
        ManagedPolicyName empty
      }
    }
    AWS::IAM::Role {
      Properties{
        RoleName empty
      }
    }
    AWS::Kinesis::Stream {
      Properties{
        Name empty
      }
    }
    AWS::RDS::DBInstance {
      Properties{
        DBInstanceIdentifier empty
      }
    }
    %cloudformation_no_static_name_resources not empty
    <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W28    
      Violation: Resource found with an explicit name, this disallows updates that require replacement of this resource.
      Fix: Remove static name from the resource
    >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    SECURITY_GROUP_EGRESS_PORT_RANGE_RULE
#
# Description:
#   Check if Security Groups found egress with port range instead of just a single PORT
#
# Reports on:
#    [AWS::EC2::SecurityGroupEgress, AWS::EC2::SecurityGroup]
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W29
#
# Scenarios:
# a) SKIP: when there are no Security Egress Groups resource present
# b) PASS: When all Security Egress Groups uses a single port and not range
# c) FAIL: when any Security Egress Groups uses a range of ports
# d) SKIP: when metadata has rule suppression for SECURITY_GROUP_EGRESS_PORT_RANGE_RULE

#
# Select all Security Group Egress resources from incoming template (payload)
#
let security_group_egress_port_range_rule_sg_egress_resources = Resources.*[ Type == 'AWS::EC2::SecurityGroup'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W29"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SECURITY_GROUP_EGRESS_PORT_RANGE_RULE"
]

let security_group_egress_port_range_rule_sge_resources = Resources.*[ Type == 'AWS::EC2::SecurityGroupEgress'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W29"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SECURITY_GROUP_EGRESS_PORT_RANGE_RULE"
]

rule SECURITY_GROUP_EGRESS_PORT_RANGE_RULE when %security_group_egress_port_range_rule_sge_resources !empty OR %security_group_egress_port_range_rule_sg_egress_resources !empty {
  let violations_sg = %security_group_egress_port_range_rule_sg_egress_resources[
    Type == 'AWS::EC2::SecurityGroup'
    Properties.SecurityGroupEgress exists
    some Properties.SecurityGroupEgress[*] {
        FromPort exists
        ToPort exists
        FromPort not in ToPort
    }
  ]

  let violations_sge = %security_group_egress_port_range_rule_sge_resources[
    Type == 'AWS::EC2::SecurityGroupEgress'
    Properties.FromPort exists
    Properties.ToPort exists
    Properties.FromPort not in Properties.ToPort
  ]

  %violations_sg empty
  %violations_sge empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W29    
    Violation: Security Group Egress has a range of ports instead of a single port
    Fix: Use single port instead of range of ports for egress rules
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    S3_BUCKET_PUBLIC_READ_ACL
#
# Description:
#   Checks if Amazon Simple Storage Service (Amazon S3) buckets are publicly readable via the public ACL
#
# Reports on:
#    AWS::S3::Bucket
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W31
#
# Scenarios:
# a) SKIP: when there are no S3 resource present
# b) PASS: when no S3 resources have PublicRead ACL applied at the bucket level
# c) FAIL: when any S3 resources has PublicRead ACL
# d) SKIP: when metadata has rule suppression for S3_BUCKET_PUBLIC_READ_ACL

#
# Select all S3 resources from incoming template (payload)
#
let s3_bucket_public_read_acl = Resources.*[ Type == 'AWS::S3::Bucket'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W31"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_BUCKET_PUBLIC_READ_ACL"
]

rule S3_BUCKET_PUBLIC_READ_ACL when %s3_bucket_public_read_acl !empty {
  let violations = %s3_bucket_public_read_acl[
    Properties.AccessControl == 'PublicRead'
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W31    
    Violation: S3 Bucket should not have the PublicRead ALC.
    Fix: Allow Read access only to authorized, authenticated users.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    CODEBUILD_ENCRYPTION_KEY_RULE
#
# Description:
#   CodeBuild project should specify an EncryptionKey value
#
# Reports on:
#    AWS::CodeBuild::Project
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W32
#
# Scenarios:
# a) SKIP: when there is no CodeBuild Project resource present.
# b) PASS: when CodeBuild Project resources have Encryption Key.
# c) FAIL: when CodeBuild Project resources does have Encryption Key.
# d) SKIP: when metadata has rule suppression for CODEBUILD_ENCRYPTION_KEY_RULE

#
# Select all CodeBuild Project resources from incoming template (payload)
#
let codebuild_encryption_key_rule = Resources.*[ Type == 'AWS::CodeBuild::Project'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W32"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CODEBUILD_ENCRYPTION_KEY_RULE"
]

rule CODEBUILD_ENCRYPTION_KEY_RULE when %codebuild_encryption_key_rule !empty {
  %codebuild_encryption_key_rule.Type == 'AWS::CodeBuild::Project'
  %codebuild_encryption_key_rule.Properties.EncryptionKey exists
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W32    
    Violation: CodeBuild project encryption key does not exist
    Fix: Specify encryption key value
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    SUBNET_AUTO_ASSIGN_PUBLIC_IP_DISABLED
#
# Description:
#    Checks if Amazon Virtual Private Cloud (Amazon VPC) subnets are assigned a public IP address.  
#
# Reports on:
#    AWS::EC2::Subnet
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no EC2 Subnet resource present
# b) PASS: when all EC2 Subnet resources have the MapPublicIpOnLaunch property set to false or it is missing (default false)
# c) FAIL: when any EC2 Subnet resources have the MapPublicIpOnLaunch property set to true
# d) SKIP: hen metadata includes the suppression for rule SUBNET_AUTO_ASSIGN_PUBLIC_IP_DISABLED

#
# Select all EC2 Subnet resources from incoming template (payload)
#
let ec2_subnets_auto_assign_public_ip_disabled = Resources.*[ Type == 'AWS::EC2::Subnet' 
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W33"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SUBNET_AUTO_ASSIGN_PUBLIC_IP_DISABLED"
]

rule SUBNET_AUTO_ASSIGN_PUBLIC_IP_DISABLED when %ec2_subnets_auto_assign_public_ip_disabled !empty {
	%ec2_subnets_auto_assign_public_ip_disabled.Properties.MapPublicIpOnLaunch !exists
  OR %ec2_subnets_auto_assign_public_ip_disabled.Properties.MapPublicIpOnLaunch == false
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W33    
    Violation: VPCs should not have subnets that are assigned a public IP address.
    Fix: remove the MapPublicIpOnLaucnh property or set it to false
	>>
}
#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    BATCH_JOB_CONTAINER_PROPERTIES_PRIVILEGED_RULE
#
# Description:
#   Batch Job Definition Container Properties should not have Privileged set to true
#
# Reports on:
#    AWS::Batch::JobDefinition
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W34
#
# Scenarios:
# a) SKIP: when there is no Batch Job resource present.
# b) PASS: when Batch Job resources does not have container properties or privileged is set to false.
# c) FAIL: when Batch Job resources does have container properties and privileged is set to true.
# d) SKIP: when metadata has rule suppression for BATCH_JOB_CONTAINER_PROPERTIES_PRIVILEGED_RULE

#
# Select all Batch Job Definition resources from incoming template (payload)
#
let batch_job_container_properties_privileged_rule = Resources.*[ Type == 'AWS::Batch::JobDefinition'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W34"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "BATCH_JOB_CONTAINER_PROPERTIES_PRIVILEGED_RULE"
]

rule BATCH_JOB_CONTAINER_PROPERTIES_PRIVILEGED_RULE when %batch_job_container_properties_privileged_rule !empty {
  let violations = %batch_job_container_properties_privileged_rule[
    Type == 'AWS::Batch::JobDefinition'
    Properties.ContainerProperties exists
    Properties.ContainerProperties.Privileged == true
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W34    
    Violation: Batch job definition resource has container properties set to true
    Fix: set privileged to false or remove privileged field to make it false by default.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    S3_BUCKET_LOGGING_ENABLED
#
# Description:
#   Checks whether logging is enabled for your S3 buckets.
#
# Reports on:
#    AWS::S3::Bucket
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no S3 resource present
# b) PASS: when all S3 resources Logging Configuration exists
# c) FAIL: when all S3 resources have Logging Configuration is not set
# d) SKIP: when metadata includes the suppression for rule S3_BUCKET_LOGGING_ENABLED

#
# Select all S3 resources from incoming template (payload)
#

let s3_buckets_bucket_logging_enabled = Resources.*[ Type == 'AWS::S3::Bucket'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W35"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_BUCKET_LOGGING_ENABLED"
]

rule S3_BUCKET_LOGGING_ENABLED when %s3_buckets_bucket_logging_enabled  !empty {
  %s3_buckets_bucket_logging_enabled.Properties.LoggingConfiguration exists
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W35    
    Violation: S3 Bucket Logging needs to be configured to enable logging.
    Fix: Set the S3 Bucket property LoggingConfiguration to start logging into S3 bucket.
  >>
}
#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    SECURITY_GROUP_DESCRIPTION_RULE
#
# Description:
#   Security group rules without a description obscure their purpose and may lead to bad practices in ensuring they only allow traffic from the ports and sources/destinations required.
#
# Reports on:
#    [AWS::EC2::SecurityGroupEgress, AWS::EC2::SecurityGroup, AWS::EC2::SecurityGroupIngress]
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W36
#
# Scenarios:
# a) SKIP: when there are no Security Groups, Ingress or Egress resource present.
# b) PASS: When all Security Groups, Ingress or Egress resources has descriptions.
# c) FAIL: when any Security Groups, Ingress or Egress resources haas no description.
# d) SKIP: when metadata has rule suppression for SECURITY_GROUP_DESCRIPTION_RULE

#
# Select all Security Group Egress resources from incoming template (payload)
#
let security_group_description_rule_sg_resources = Resources.*[ Type == 'AWS::EC2::SecurityGroup'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W36"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SECURITY_GROUP_DESCRIPTION_RULE"
]

let security_group_description_rule_sge_resources = Resources.*[ Type == 'AWS::EC2::SecurityGroupEgress'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W36"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SECURITY_GROUP_DESCRIPTION_RULE"
]

let security_group_description_rule_sgi_resources = Resources.*[ Type == 'AWS::EC2::SecurityGroupIngress'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W36"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SECURITY_GROUP_DESCRIPTION_RULE"
]

rule SECURITY_GROUP_DESCRIPTION_RULE when %security_group_description_rule_sg_resources !empty OR %security_group_description_rule_sge_resources !empty OR %security_group_description_rule_sgi_resources !empty {
  let violations_sg = %security_group_description_rule_sg_resources[
    Type == 'AWS::EC2::SecurityGroup'
    Properties {
        SecurityGroupEgress exists
        some SecurityGroupEgress[*].Description !exists
    }
    OR
    Properties {
        SecurityGroupIngress exists
        some SecurityGroupIngress[*].Description !exists
    }
  ]

  let violation_sge = %security_group_description_rule_sge_resources[
    Type == 'AWS::EC2::SecurityGroupEgress'
    Properties.Description !exists
  ]

  let violation_sgi = %security_group_description_rule_sgi_resources[
    Type == 'AWS::EC2::SecurityGroupIngress'
    Properties.Description !exists
  ]

  %violations_sg empty
  %violation_sge empty
  %violation_sgi empty

  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W36    
    Violation: Security Group or Security Group Egress or Security Group Ingress resources do not have description.
    Fix: Specify the description for Security Group and Security Group Egress and Security Group Ingress resources.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    EBS_VOLUME_ENCRYPTION_KEY_RULE
#
# Description:
#   EBS Volume should specify a KmsKeyId value
#
# Reports on:
#    AWS::EC2::Volume
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W37
#
# Scenarios:
# a) SKIP: when there is no EC2 Volume resource present.
# b) PASS: when EC2 Volume resources have KmsKeyId Key.
# c) FAIL: when EC2 Volume resources does not have KmsKeyId Key.
# d) SKIP: when metadata has rule suppression for EBS_VOLUME_ENCRYPTION_KEY_RULE

#
# Select all EC2 Volume resources from incoming template (payload)
#
let ebs_volume_encryption_key_rule = Resources.*[ Type == 'AWS::EC2::Volume'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W37"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EBS_VOLUME_ENCRYPTION_KEY_RULE"
]

rule EBS_VOLUME_ENCRYPTION_KEY_RULE when %ebs_volume_encryption_key_rule !empty {
  %ebs_volume_encryption_key_rule.Type == 'AWS::EC2::Volume'
  %ebs_volume_encryption_key_rule.Properties.KmsKeyId exists
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W37    
    Violation: EC2 Volume KmsKeyId does not exist
    Fix: Specify KmsKeyId value
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    IOT_POLICY_WILDCARD_ACTION_RULE
#
# Description:
#   IOT policy should not allow * action
#
# Reports on:
#    AWS::IoT::Policy
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W38
#
# Scenarios:
# a) SKIP: when there is no Iot Policy resource present
# b) PASS: when no Iot Policy resources have open Action
# c) FAIL: when any Iot Policy has Action "*"
# d) SKIP: when metadata has rule suppression for IOT_POLICY_WILDCARD_ACTION_RULE

#
# Select all IoT Policy resources from incoming template (payload)
#
let iot_policy_wildcard_action_rule = Resources.*[ Type == 'AWS::IoT::Policy'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W38"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IOT_POLICY_WILDCARD_ACTION_RULE"
]

rule IOT_POLICY_WILDCARD_ACTION_RULE when %iot_policy_wildcard_action_rule !empty {
  let violations = %iot_policy_wildcard_action_rule[
    some Properties.PolicyDocument.Statement[*] {
      some Action[*] in ["*", /^[a-zA-Z0-9]*:\*$/]
      Effect == "Allow"
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W38    
    Violation: IoT policy should not allow * action.
    Fix: Specify explicit actions in the IoT Policy.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    IOT_POLICY_WILDCARD_RESOURCE_RULE
#
# Description:
#   IOT policy should not allow * resource
#
# Reports on:
#    AWS::IoT::Policy
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W39
#
# Scenarios:
# a) SKIP: when there is no Iot Policy resource present
# b) PASS: when no Iot Policy resources have open Resource
# c) FAIL: when any Iot Policy has Resource "*"
# d) SKIP: when metadata has rule suppression for IOT_POLICY_WILDCARD_RESOURCE_RULE

#
# Select all IoT Policy resources from incoming template (payload)
#
let iot_policy_wildcard_resource_rule = Resources.*[ Type == 'AWS::IoT::Policy'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W39"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IOT_POLICY_WILDCARD_RESOURCE_RULE"
]

rule IOT_POLICY_WILDCARD_RESOURCE_RULE when %iot_policy_wildcard_resource_rule !empty {
  let violations = %iot_policy_wildcard_resource_rule[
    some Properties.PolicyDocument.Statement[*] {
      some Resource[*] == "*"
      Effect == "Allow"
    }
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W39    
    Violation: IoT policy should not allow * resource.
    Fix: Specify explicit resources in the IoT Policy.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    SECURITY_GROUP_EGRESS_ALL_PROTOCOLS_RULE
#
# Description:
#   Check if Security Groups found egress with IpProtocol of -1.
#
# Reports on:
#    [AWS::EC2::SecurityGroup, AWS::EC2::SecurityGroupEgress]
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W40
#
# Scenarios:
# a) SKIP: when there are no Security Egress Groups resource present
# b) PASS: When no Security Egress Groups uses IpProtocol value as -1
# c) FAIL: when any Security Egress Groups uses IpProtocol value as -1
# d) SKIP: when metadata has rule suppression for SECURITY_GROUP_EGRESS_ALL_PROTOCOLS_RULE

#
# Select all Security Group Egress resources from incoming template (payload)
#

let security_group_egress_all_protocols_rule_sg_egress_resources = Resources.*[ Type == 'AWS::EC2::SecurityGroup'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W40"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SECURITY_GROUP_EGRESS_ALL_PROTOCOLS_RULE"
]

let security_group_egress_all_protocols_rule_sge_resources = Resources.*[ Type == 'AWS::EC2::SecurityGroupEgress'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W40"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SECURITY_GROUP_EGRESS_ALL_PROTOCOLS_RULE"
]

rule SECURITY_GROUP_EGRESS_ALL_PROTOCOLS_RULE when %security_group_egress_all_protocols_rule_sge_resources !empty OR %security_group_egress_all_protocols_rule_sg_egress_resources !empty {
   let violations_sg = %security_group_egress_all_protocols_rule_sg_egress_resources[
     Type == 'AWS::EC2::SecurityGroup'
     Properties.SecurityGroupEgress exists
     some Properties.SecurityGroupEgress[*] {
        IpProtocol == '-1'
        OR
        IpProtocol == -1
        CidrIp !exists
        OR
        CidrIp != '127.0.0.1/32'
        CidrIpv6 !exists
        OR
        CidrIpv6 != '::1/128'
        CidrIpv6 !exists
        OR
        CidrIpv6 != ':1/128'
     }
   ]

   let violations_sge = %security_group_egress_all_protocols_rule_sge_resources[
     Type == 'AWS::EC2::SecurityGroupEgress'
     Properties.IpProtocol == '-1'
     OR
     Properties.IpProtocol == -1
     Properties.CidrIp !exists
     OR
     Properties.CidrIp != '127.0.0.1/32'
     Properties.CidrIpv6 !exists
     OR
     Properties.CidrIpv6 != '::1/128'
     Properties.CidrIpv6 !exists
     OR
     Properties.CidrIpv6 != ':1/128'
  ]

  %violations_sg empty
  %violations_sge empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W40    
    Violation: Security Group Egress has a IpProtocol value of -1.
    Fix: Update IpProtocol value of -1 as tcp, udp, icmp, or icmpv6 or something else.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    S3_BUCKET_SERVER_SIDE_ENCRYPTION_ENABLED
#
# Description:
#   Checks if your Amazon S3 bucket either has the Amazon S3 default encryption enabled or that the Amazon S3 bucket policy
#   explicitly denies put-object requests without server side encryption that uses AES-256 or AWS Key Management Service.
#
# Reports on:
#    AWS::S3::Bucket
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no S3 resource present
# b) PASS: when all S3 resources Bucket Encryption ServerSideEncryptionByDefault is set to either "aws:kms" or "AES256"
# c) FAIL: when all S3 resources have Bucket Encryption ServerSideEncryptionByDefault is not set or does not have "aws:kms" or "AES256" configurations
# d) SKIP: when metadata includes the suppression for rule S3_BUCKET_SERVER_SIDE_ENCRYPTION_ENABLED

#
# Select all S3 resources from incoming template (payload)
#

let s3_buckets_server_side_encryption = Resources.*[ Type == 'AWS::S3::Bucket'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W41"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "S3_BUCKET_SERVER_SIDE_ENCRYPTION_ENABLED"
]

rule S3_BUCKET_SERVER_SIDE_ENCRYPTION_ENABLED when %s3_buckets_server_side_encryption !empty {
  %s3_buckets_server_side_encryption.Properties.BucketEncryption exists
  %s3_buckets_server_side_encryption.Properties.BucketEncryption.ServerSideEncryptionConfiguration[*].ServerSideEncryptionByDefault.SSEAlgorithm in ["aws:kms","AES256"]
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W41    
    Violation: S3 Bucket must enable server-side encryption.
    Fix: Set the S3 Bucket property BucketEncryption.ServerSideEncryptionConfiguration.ServerSideEncryptionByDefault.SSEAlgorithm to either "aws:kms" or "AES256"
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    SECURITY_GROUP_INGRESS_ALL_PROTOCOLS_RULE
#
# Description:
#   Check if Security Groups found ingress has IpProtocol as -1
#
# Reports on:
#    AWS::EC2::SecurityGroupIngress
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W42
#
# Scenarios:
# a) SKIP: when there are no Security Ingress Groups resource present
# b) PASS: When no Security Ingress Groups uses IpProtocol value as -1
# c) FAIL: when any Security Ingress Groups uses IpProtocol value as -1
# d) SKIP: when metadata has rule suppression for SECURITY_GROUP_INGRESS_ALL_PROTOCOLS_RULE

#
# Select all Security Group Ingress resources from incoming template (payload)
#

let security_group_ingress_all_protocols_rule_sg_ingress_resources = Resources.*[ Type == 'AWS::EC2::SecurityGroup'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W42"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SECURITY_GROUP_INGRESS_ALL_PROTOCOLS_RULE"
]

let security_group_ingress_all_protocols_rule_sgi_resources = Resources.*[ Type == 'AWS::EC2::SecurityGroupIngress'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W42"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SECURITY_GROUP_INGRESS_ALL_PROTOCOLS_RULE"
]

rule SECURITY_GROUP_INGRESS_ALL_PROTOCOLS_RULE when %security_group_ingress_all_protocols_rule_sgi_resources !empty OR %security_group_ingress_all_protocols_rule_sg_ingress_resources !empty {
   let violations_sg = %security_group_ingress_all_protocols_rule_sg_ingress_resources[
     Type == 'AWS::EC2::SecurityGroup'
     Properties.SecurityGroupIngress exists
     some Properties.SecurityGroupIngress[*].IpProtocol == '-1'
     OR
     some Properties.SecurityGroupIngress[*].IpProtocol == -1
   ]

   let violations_sgi = %security_group_ingress_all_protocols_rule_sgi_resources[
     Type == 'AWS::EC2::SecurityGroupIngress'
     Properties.IpProtocol == '-1'
     OR
     Properties.IpProtocol == -1
  ]

  %violations_sg empty
  %violations_sgi empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W42    
    Violation: Security Group Ingress has a IpProtocol value of -1 and
    Fix: Update IpProtocol value of -1 as tcp, udp, icmp, or icmpv6 or something else.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   IAM_ROLE_ADMINISTRATOR_ACCESS_POLICY_RULE
#
# Description:
#   IAM role should not have AdministratorAccess policy
#
# Reports on:
#   AWS::IAM::Role
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   W43
#
# Scenarios:
# a) SKIP: when there are no IAM Roles present
# b) PASS: when no IAM Roles have AdministratorAccess policy
# c) FAIL: when any IAM Roles have AdministratorAccess policy
# d) SKIP: when metadata has rule suppression for IAM_ROLE_ADMINISTRATOR_ACCESS_POLICY_RULE or CFN_NAG W43

#
# Select all IAM Role resources from incoming template (payload)
#
let iam_role_administrator_access_policy_rule = Resources.*[ Type == 'AWS::IAM::Role'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W43"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_ROLE_ADMINISTRATOR_ACCESS_POLICY_RULE"
]

rule IAM_ROLE_ADMINISTRATOR_ACCESS_POLICY_RULE when %iam_role_administrator_access_policy_rule !empty {
  let violations = %iam_role_administrator_access_policy_rule[
    Type == 'AWS::IAM::Role'
    Properties.ManagedPolicyArns exists
    some Properties.ManagedPolicyArns[*] == 'arn:aws:iam::aws:policy/AdministratorAccess'
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W43    
    Violation: IAM role ManagedPolicyArns has AdministratorAccess policy access.
    Fix: Remove AdministratorAccess policy access from ManagedPolicyArns in IAM Roles.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   IAM_ROLE_ELEVATED_MANAGED_POLICY_RULE
#
# Description:
#   IAM role should not have Elevated Managed policy
#
# Reports on:
#   AWS::IAM::Role
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   W44
#
# Scenarios:
# a) SKIP: when there are no IAM Roles present
# b) PASS: when no IAM Roles have Elevated Managed policy
# c) FAIL: when any IAM Roles have Elevated Managed policy
# d) SKIP: when metadata has rule suppression for IAM_ROLE_ELEVATED_MANAGED_POLICY_RULE or CFN_NAG W44

#
# Select all IAM Role resources from incoming template (payload)
#
let iam_role_elevated_managed_policy_rule = Resources.*[ Type == 'AWS::IAM::Role'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W44"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_ROLE_ELEVATED_MANAGED_POLICY_RULE"
]

rule IAM_ROLE_ELEVATED_MANAGED_POLICY_RULE when %iam_role_elevated_managed_policy_rule !empty {
  let violations = %iam_role_elevated_managed_policy_rule[
    Type == 'AWS::IAM::Role'
    Properties.ManagedPolicyArns exists
    some Properties.ManagedPolicyArns[*] == 'arn:aws:iam::aws:policy/PowerUserAccess'
    OR
    some Properties.ManagedPolicyArns[*] == 'arn:aws:iam::aws:policy/IAMFullAccess'
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W44    
    Violation: IAM role ManagedPolicyArns has Elevated Managed policy access.
    Fix: Remove Elevated Managed policy access from ManagedPolicyArns in IAM Roles.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   API_GWV2_ACCESS_LOGS_ENABLED
#
# Description:
#   Amazon API Gateway V2 stages have access logging enabled.
#
# Reports on:
#   AWS::ApiGateway::Stage
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there are no API GW Stage Methods present
# b) SKIP: when metadata includes the suppression for rule API_GWV2_ACCESS_LOGS_ENABLED
# c) FAIL: when an API Gateway V2 Stage Method is missing AccessLogSettings.DestinationArn or AccessLogSettings.Format
# d) FAIL: when an API Gateway V2 Stage Method has AccessLogSettings.DestinationArn or AccessLogSettings.Format set to a value other than a string or struct
# e) PASS: when an API Gateway V2 Stage Method have an AccessLogSettings configuration with DestinationArn and Format set to a string or struct

let api_gwv2_access_logs_enabled = Resources.*[ Type == "AWS::ApiGatewayV2::Stage"
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W46"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "API_GWV2_ACCESS_LOGS_ENABLED"
]

rule API_GWV2_ACCESS_LOGS_ENABLED when %api_gwv2_access_logs_enabled !empty {
    %api_gwv2_access_logs_enabled.Properties {
        AccessLogSettings exists
        AccessLogSettings is_struct

        AccessLogSettings {
            DestinationArn exists
            DestinationArn is_string or 
            DestinationArn is_struct
            <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W46    
                Violation: Amazon API Gateway V2 stages have access logging enabled
                Fix: In AccessLogSettings, set DestinationArn to the ARN of an Amazon CloudWatch log group and Format to a single line log format configuration.
            >>

            Format exists
            Format is_string or 
            Format is_struct
            <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W46    
                Violation: Amazon API Gateway V2 stages have access logging enabled
                Fix: In AccessLogSettings, set DestinationArn to the ARN of an Amazon CloudWatch log group and Format to a single line log format configuration.
            >>
        }
  }
}
#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    SNS_ENCRYPTED_KMS
#
# Description:
#   Checks if Amazon SNS topic is encrypted with AWS Key Management Service (AWS KMS)
#
# Reports on:
#    AWS::SNS::Topic
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no SNS Topics present
# b) SKIP: when metada has rule suppression for SNS_ENCRYPTED_KMS
# c) FAIL: when SNS topics are present, they are not encrypted with KMS
# d) PASS: when SNS topics are present, they are encrypted with KMS

#
# Select all AWS::SNS::Topic resources from incoming template (payload)
#

let sns_encrypted_kms = Resources.*[ Type == "AWS::SNS::Topic"
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W47"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SNS_ENCRYPTED_KMS"
]


rule SNS_ENCRYPTED_KMS when %sns_encrypted_kms !empty {
  %sns_encrypted_kms.Properties.KmsMasterKeyId exists
	<<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W47    
		Violation: Amazon SNS Topics are configured with a Key Management Service (KMS) key 
		Fix: Set the KmsMasterKeyId property
	>>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    SQS_QUEUE_KMS_MASTER_KEY_ID_RULE
#
# Description:
#   SQS Queue should specify KmsMasterKeyId property
#
# Reports on:
#    AWS::SQS::Queue
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W48
#
# Scenarios:
# a) SKIP: when there is no SQS Queue resource present.
# b) PASS: when SQS Queue resources have KmsMasterKeyId Key.
# c) FAIL: when SQS Queue resources does not have KmsMasterKeyId Key.
# d) SKIP: when metadata has rule suppression for SQS_QUEUE_KMS_MASTER_KEY_ID_RULE

#
# Select all SQS Queue resources from incoming template (payload)
#
let sqs_queue_kms_master_key_id_rule = Resources.*[ Type == 'AWS::SQS::Queue'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W48"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SQS_QUEUE_KMS_MASTER_KEY_ID_RULE"
]

rule SQS_QUEUE_KMS_MASTER_KEY_ID_RULE when %sqs_queue_kms_master_key_id_rule !empty {
  %sqs_queue_kms_master_key_id_rule.Type == 'AWS::SQS::Queue'
  %sqs_queue_kms_master_key_id_rule.Properties.KmsMasterKeyId exists
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W48    
    Violation: SQS Queue KmsMasterKeyId does not exist
    Fix: Specify KmsMasterKeyId value
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    KINESIS_STREAM_ENCRYPTION_RULE
#
# Description:
#   Kinesis Stream should specify StreamEncryption. EncryptionType should be KMS and specify KMS Key Id.
#
# Reports on:
#    AWS::Kinesis::Stream
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W49
#
# Scenarios:
# a) SKIP: when there is no Kinesis Stream resource present.
# b) PASS: when Kinesis Stream have StreamEncryption in which KeyId and EncryptionType set to 'KMS'.
# c) FAIL: when Kinesis Stream does not have StreamEncryption in which KeyId or EncryptionType is not set to 'KMS'.
# d) SKIP: when metadata has rule suppression for KINESIS_STREAM_ENCRYPTION_RULE

#
# Select all Kinesis Stream resources from incoming template (payload)
#
let kinesis_stream_encryption_rule = Resources.*[ Type == 'AWS::Kinesis::Stream'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W49"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "KINESIS_STREAM_ENCRYPTION_RULE"
]

rule KINESIS_STREAM_ENCRYPTION_RULE when %kinesis_stream_encryption_rule !empty {
  let violations = %kinesis_stream_encryption_rule[
    Type == 'AWS::Kinesis::Stream'
    Properties.StreamEncryption !exists
    OR
    Properties.StreamEncryption.EncryptionType !exists
    OR
    Properties.StreamEncryption.EncryptionType != 'KMS'
    OR
    Properties.StreamEncryption.KeyId !exists
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W49    
    Violation: Kinesis Streams does not have streamEncryption in which KeyId should be specified and EncryptionType should be 'KMS'.
    Fix: Specify streamEncryption in which KeyId should be specified and EncryptionType should be 'KMS'.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#   IAM_USER_LOGIN_PROFILE_PASSWORD_RESET_RULE
#
# Description:
#   IAM User Login Profile should exist and have PasswordResetRequired property set to true.
#
# Reports on:
#   AWS::IAM::User
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# CFN_NAG Rule Id:
#   W50
#
# Scenarios:
# a) SKIP: when there are no IAM Users present
# b) PASS: when all IAM Users have Login Profile and have PasswordResetRequired property set to true.
# c) FAIL: when any IAM Users do not have Login Profile or have PasswordResetRequired property is not set to true.
# d) SKIP: when metadata has rule suppression for IAM_USER_LOGIN_PROFILE_PASSWORD_RESET_RULE or CFN_NAG W50

#
# Select all IAM User resources from incoming template (payload)
#
let iam_user_login_profile_password_reset_rule = Resources.*[ Type == 'AWS::IAM::User'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W50"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "IAM_USER_LOGIN_PROFILE_PASSWORD_RESET_RULE"
]

rule IAM_USER_LOGIN_PROFILE_PASSWORD_RESET_RULE when %iam_user_login_profile_password_reset_rule !empty {
  let violations = %iam_user_login_profile_password_reset_rule[
    Type == 'AWS::IAM::User'
    Properties.LoginProfile !exists
    OR
    Properties.LoginProfile.PasswordResetRequired !exists
    OR
    Properties.LoginProfile.PasswordResetRequired == 'false'
    OR
    Properties.LoginProfile.PasswordResetRequired == false
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W50    
    Violation: IAM User Login Profile should exist and have PasswordResetRequired property set to true
    Fix: Create IAM User LoginProfile and make sure that PasswordResetRequired is set to true.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
#
# Rule Identifier:
#   ELBV2_ACCESS_LOGGING_RULE
#
# Description:
#   Elastic Load Balancer V2 should have access logging enabled
#
# Reports on:
#   AWS::ElasticLoadBalancingV2::LoadBalancer
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   None
#
# CFN_NAG Rule Id:
#   W52
#
# Scenarios:
# a) SKIP: when there are no Elastic Load Balancing V2 LoadBalancer Resources
# b) SKIP: when metadata has rule suppression for ELBV2_ACCESS_LOGGING_RULE
# c) FAIL: when loadBalancerAttributes does not exists or access logging is disabled.
# d) PASS: when loadBalancerAttributes exists or access logging is enabled.

#
# Select all Elastic Load Balancing Resources from incoming template (payload)
#
let elbv2_access_logging_rule = Resources.*[ Type == 'AWS::ElasticLoadBalancingV2::LoadBalancer'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W52"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELBV2_ACCESS_LOGGING_RULE"
]

rule ELBV2_ACCESS_LOGGING_RULE when %elbv2_access_logging_rule !empty {
  let violations = %elbv2_access_logging_rule[
    Type == 'AWS::ElasticLoadBalancingV2::LoadBalancer'
    Properties.LoadBalancerAttributes !exists
    OR
    Properties.LoadBalancerAttributes[*].key != 'access_logs.s3.enabled'
    OR
    some Properties.LoadBalancerAttributes[*] {
      key == 'access_logs.s3.enabled'
      value !exists
      OR
      value == 'false'
      OR
      value == 'False'
      OR
      value == 'FALSE'
    }
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W52    
   Violation: Elastic Load Balancer V2 does not have loadBalancerAttributes or access logging is disabled.
   Fix: Specify loadBalancerAttributes and make sure access logging is enabled.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    AMAZON_MQ_BROKER_ENCRYPTION_OPTIONS_RULE
#
# Description:
#   AmazonMQ Broker should specify EncryptionOptions
#
# Reports on:
#    AWS::AmazonMQ::Broker
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W53
#
# Scenarios:
# a) SKIP: when there is no Amazon MQ Broker present
# b) PASS: when all Amazon MQ Broker resources have Encryption Options
# c) FAIL: when any Amazon MQ Broker resources do not have Encryption Options
# d) SKIP: when metadata has rule suppression for AMAZON_MQ_BROKER_ENCRYPTION_OPTIONS_RULE

#
# Select all Amazon MQ Broker resources from incoming template (payload)
#
let amazon_mq_broker_encryption_options_rule = Resources.*[ Type == 'AWS::AmazonMQ::Broker'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W53"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "AMAZON_MQ_BROKER_ENCRYPTION_OPTIONS_RULE"
]

rule AMAZON_MQ_BROKER_ENCRYPTION_OPTIONS_RULE when %amazon_mq_broker_encryption_options_rule !empty {
  %amazon_mq_broker_encryption_options_rule.Properties.EncryptionOptions exists
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W53    
    Violation: AmazonMQ Broker does not specify EncryptionOptions.
    Fix: Specify EncryptionOptions in AmazonMQ Broker.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   ELASTICSEARCH_ENCRYPTED_AT_REST
#
# Description:
#   Elasticsearch domains must enforce server side encryption
#
# Reports on:
#   AWS::Elasticsearch::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there is no Elasticsearch domain present
# b) SKIP: when metada has rule suppression for ELASTICSEARCH_ENCRYPTED_AT_REST
# c) FAIL: when Elasticsearch domain has server side encryption property is missing
# d) FAIL: when Elasticsearch domain has server side encryption set to false
# e) PASS: when Elasticsearch domain has server side encryption set to true

#
# Select all elasticsearch domains from incoming template
#
let elasticsearch_domains_encrypted = Resources.*[ Type == "AWS::Elasticsearch::Domain"
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W54"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELASTICSEARCH_ENCRYPTED_AT_REST"
]

rule ELASTICSEARCH_ENCRYPTED_AT_REST when %elasticsearch_domains_encrypted !empty {
    %elasticsearch_domains_encrypted.Properties.EncryptionAtRestOptions.Enabled == true
        <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W54    
            Violation: Elasticsearch domains must enforce server side encryption.
            Fix: Set the EncryptionAtRestOptions.Enabled parameter to true.
        >>
}
#
#####################################
##          AWS Solutions          ##
#####################################
#
# Rule Identifier:
#   ELBV2_LISTENER_SSL_POLICY_RULE
#
# Description:
#   Elastic Load Balancer V2 Listener SslPolicy should use TLS 1.2
#
# Reports on:
#   AWS::ElasticLoadBalancingV2::Listener
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   None
#
# CFN_NAG Rule Id:
#   W55
#
# Scenarios:
# a) SKIP: when there are no Elastic Load Balancing V2 Listener Resources
# b) SKIP: when metadata has rule suppression for ELBV2_LISTENER_SSL_POLICY_RULE
# c) FAIL: when sslPolicy in Elastic Load Balancing V2 Listener does not exist or do not use TLS 1.2.
# d) PASS: when sslPolicy in Elastic Load Balancing V2 Listener does exist and use TLS 1.2.

#
# Select all Elastic Load Balancing Resources from incoming template (payload)
#
let elbv2_listener_ssl_policy_rule = Resources.*[ Type == 'AWS::ElasticLoadBalancingV2::Listener'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W55"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELBV2_LISTENER_SSL_POLICY_RULE"
]

rule ELBV2_LISTENER_SSL_POLICY_RULE when %elbv2_listener_ssl_policy_rule !empty {
  let violations = %elbv2_listener_ssl_policy_rule[
    Type == 'AWS::ElasticLoadBalancingV2::Listener'
    Properties.SslPolicy !exists
    OR
    Properties.SslPolicy == /(?i)ELBSecurityPolicy-2016-08/
    OR
    Properties.SslPolicy == /(?i)ELBSecurityPolicy-TLS-1-0-2015-04/
    OR
    Properties.SslPolicy == /(?i)ELBSecurityPolicy-TLS-1-1-2017-01/
    OR
    Properties.SslPolicy == /(?i)ELBSecurityPolicy-FS-2018-06/
    OR
    Properties.SslPolicy == /(?i)ELBSecurityPolicy-FS-1-1-2019-08/
    OR
    Properties.SslPolicy == /(?i)ELBSecurityPolicy-2015/
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W55    
   Violation: Elastic Load Balancer V2 does not have SslPolicy or do not use TLS 1.2.
   Fix: Enable SslPolicy and use TLS 1.2.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
#
# Rule Identifier:
#   ELBV2_LISTENER_PROTOCOL_RULE
#
# Description:
#   Elastic Load Balancer V2 Listener Protocol should use HTTPS for ALBs
#
# Reports on:
#   AWS::ElasticLoadBalancingV2::Listener
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   None
#
# CFN_NAG Rule Id:
#   W56
#
# Scenarios:
# a) SKIP: when there are no Elastic Load Balancing V2 Listener Resources
# b) SKIP: when metadata has rule suppression for ELBV2_LISTENER_PROTOCOL_RULE
# c) FAIL: when Protocol in Elastic Load Balancing V2 Listener uses HTTP.
# d) PASS:  when Protocol in Elastic Load Balancing V2 Listener uses HTTPS.

#
# Select all Elastic Load Balancing Resources from incoming template (payload)
#
let elbv2_listener_protocol_rule = Resources.*[ Type == 'AWS::ElasticLoadBalancingV2::Listener'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W56"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELBV2_LISTENER_PROTOCOL_RULE"
]

rule ELBV2_LISTENER_PROTOCOL_RULE when %elbv2_listener_protocol_rule !empty {
  let violations = %elbv2_listener_protocol_rule[
    Type == 'AWS::ElasticLoadBalancingV2::Listener'
    Properties.Protocol exists
    Properties.Protocol == 'HTTP'
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W56    
   Violation: Elastic Load Balancer V2 do not use HTTPS protocol.
   Fix: use HTTPS protocol for Elastic Load Balancer V2 Listener.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
#
# Rule Identifier:
#   COGNITO_ALLOW_UNAUTHENTICATED_IDENTITIES_RULE
#
# Description:
#   AWS::Cognito::IdentityPool AllowUnauthenticatedIdentities property should be false. But CAN be true if proper restrictive IAM roles and permissions are established for unauthenticated users.
#
# Reports on:
#   AWS::Cognito::IdentityPool
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   None
#
# CFN_NAG Rule Id:
#   W57
#
# Scenarios:
# a) SKIP: when there are no Cognito Identity Pool Resources.
# b) SKIP: when metadata has rule suppression for COGNITO_ALLOW_UNAUTHENTICATED_IDENTITIES_RULE.
# c) FAIL: when AllowUnauthenticatedIdentities in Cognito Identity Pool Resources is set to true.
# d) PASS:  when AllowUnauthenticatedIdentities in Cognito Identity Pool Resources is set to false.

#
# Select all Cognito Identity Pool Resources from incoming template (payload)
#
let cognito_allow_unauthenticated_identities_rule = Resources.*[ Type == 'AWS::Cognito::IdentityPool'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W57"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "COGNITO_ALLOW_UNAUTHENTICATED_IDENTITIES_RULE"
]

rule COGNITO_ALLOW_UNAUTHENTICATED_IDENTITIES_RULE when %cognito_allow_unauthenticated_identities_rule !empty {
  let violations = %cognito_allow_unauthenticated_identities_rule[
    Type == 'AWS::Cognito::IdentityPool'
    Properties.AllowUnauthenticatedIdentities == /(?i)true/
    OR
    Properties.AllowUnauthenticatedIdentities == true
    OR
    Properties.AllowUnauthenticatedIdentities == True
    OR
    Properties.AllowUnauthenticatedIdentities == TRUE
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W57    
   Violation: AllowUnauthenticatedIdentities in Cognito Identity Pool Resources is set to true.
   Fix: set AllowUnauthenticatedIdentities to false in Cognito Identity Pool Resources.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
#
# Rule Identifier:
#   API_GW_METHOD_AUTHORIZATION_TYPE_RULE
#
# Description:
#   AWS::ApiGateway::Method should not have AuthorizationType set to 'NONE' unless it is of HttpMethod: OPTIONS.
#
# Reports on:
#   AWS::ApiGateway::Method
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   None
#
# CFN_NAG Rule Id:
#   W59
#
# Scenarios:
# a) SKIP: when there are no API Gateway Method Resources.
# b) SKIP: when metadata has rule suppression for API_GW_METHOD_AUTHORIZATION_TYPE_RULE.
# c) FAIL: when authorizationType does not exist or is set to none when HttpMethod is not OPTIONS.
# d) PASS: when HTTP Method is set to OPTIONS or AuthorizationType is not set to None.

#
# Select all API Gateway Method Resources from incoming template (payload)
#
let api_gw_method_authorization_type_rule = Resources.*[ Type == 'AWS::ApiGateway::Method'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W59"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "API_GW_METHOD_AUTHORIZATION_TYPE_RULE"
]

rule API_GW_METHOD_AUTHORIZATION_TYPE_RULE when %api_gw_method_authorization_type_rule !empty {
  let violations = %api_gw_method_authorization_type_rule[
    Type == 'AWS::ApiGateway::Method'
    Properties.HttpMethod != /(?i)options/
    Properties.AuthorizationType !exists
    OR
    Properties.AuthorizationType == /(?i)none/
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W59    
   Violation: AuthorizationType set to 'NONE' for API Gateway Method Resources.
   Fix: change value of AuthorizationType for API Gateway Method Resources.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    EMR_SECURITY_CONFIG_ENABLED_AND_CONFIGURED_RULE
#
# Description:
#   EMR SecurityConfiguration should enable and properly configure encryption at rest and in transit.
#
# Reports on:
#    AWS::EMR::SecurityConfiguration
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W61
#
# Scenarios:
# a) SKIP: when there are no EMR SecurityConfiguration resource present
# b) PASS: When all EMR SecurityConfiguration have encryption enabled and configured.
# c) FAIL: When any EMR SecurityConfiguration do not have encryption enabled or configured.
# d) SKIP: when metadata has rule suppression for EMR_SECURITY_CONFIG_ENABLED_AND_CONFIGURED_RULE

#
# Select all EMR SecurityConfiguration resources from incoming template (payload)
#
let emr_security_config_enabled_and_configured_rule = Resources.*[ Type == 'AWS::EMR::SecurityConfiguration'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W61"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EMR_SECURITY_CONFIG_ENABLED_AND_CONFIGURED_RULE"
]

rule EMR_SECURITY_CONFIG_ENABLED_AND_CONFIGURED_RULE when %emr_security_config_enabled_and_configured_rule !empty {
  let violations = %emr_security_config_enabled_and_configured_rule[
    Type == 'AWS::EMR::SecurityConfiguration'
    Properties.SecurityConfiguration.EncryptionConfiguration !exists
    OR
    Properties.SecurityConfiguration.EncryptionConfiguration {
        EnableAtRestEncryption !exists
        OR
        EnableAtRestEncryption == false
        OR
        EnableAtRestEncryption == 'false'
        OR
        EnableInTransitEncryption !exists
        OR
        EnableInTransitEncryption == false
        OR
        EnableInTransitEncryption == 'false'
    }
    OR
    Properties.SecurityConfiguration.EncryptionConfiguration {
        AtRestEncryptionConfiguration !exists
        OR
        AtRestEncryptionConfiguration {
            LocalDiskEncryptionConfiguration !exists
            OR
            LocalDiskEncryptionConfiguration.EncryptionKeyProviderType !exists
            S3EncryptionConfiguration !exists
            OR
            S3EncryptionConfiguration.EncryptionMode !exists
        }
    }
    OR
    Properties.SecurityConfiguration.EncryptionConfiguration {
        InTransitEncryptionConfiguration !exists
        OR
        InTransitEncryptionConfiguration {
            TLSCertificateConfiguration !exists
            OR
            TLSCertificateConfiguration.CertificateProviderType !exists
        }
    }
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W61    
    Violation: EMR SecurityConfiguration resource do not have EncryptionConfiguration properly defined or configured.
    Fix: Define and configure EncryptionConfiguration in all EMR SecurityConfiguration resources.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    API_GW_DOMAIN_DENY_NON_TLS_TRAFFIC
#
# Description:
#   All API GW Domain Name Resources must deny non-TLS traffic
#
# Reports on:
#    AWS::ApiGateway::DomainName
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no API GW Methods present
# b) PASS: when all API GW Domain Names have a security policy configured to deny non-TLS traffic
# c) FAIL: when API GW Domain Names doesn't have a security policy configured to deny non-TLS traffic
# d) SKIP: when metadata includes the suppression for rule API_GW_DOMAIN_DENY_NON_TLS_TRAFFIC

#
# Select all API GW Method resources from incoming template (payload)
#
let aws_apigw_domain_resources_tls_traffic = Resources.*[ Type == 'AWS::ApiGateway::DomainName'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W62"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "API_GW_DOMAIN_DENY_NON_TLS_TRAFFIC"
]

rule API_GW_DOMAIN_DENY_NON_TLS_TRAFFIC when %aws_apigw_domain_resources_tls_traffic !empty {
	%aws_apigw_domain_resources_tls_traffic.Properties.SecurityPolicy == "TLS_1_2"
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W62    
    Violation: API Gateway DomainName - SecurityPolicy must use TLS 1.2
    Fix: Set the SecurityPolicy property parameter to "TLS_1_2".
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    EMR_KERBEROS_ENABLED
#
# Description:
#   Checks if Kerberos is set for EMR cluster.
#
# Reports on:
#    AWS::EMR::Cluster
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when EMR cluster resource not present
# b) SKIP: when metada has rule suppression for EMR_KERBEROS_ENABLED
# c) FAIL: when all EMR cluster resources KerberosAttributes property does not exist
# d) PASS: when all EMR cluster resources KerberosAttributes property is set

#
# Select all EMR Cluster resources from incoming template (payload)
#

let emr_kerberos_enabled = Resources.*[ Type == "AWS::EMR::Cluster"
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "F63"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EMR_KERBEROS_ENABLED"
]

rule EMR_KERBEROS_ENABLED when %emr_kerberos_enabled !empty {
	%emr_kerberos_enabled.Properties.KerberosAttributes exists
	<<
    Guard Rule Set: cfn-nag-equivalent
    Controls: F63    
		Violation: EMR Clusters have Kerberos configured
		Fix: Set the KerberosAttributes property
	>>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    GAMELIFT_FLEET_INBOUND_PORT_RANGE_RULE
#
# Description:
#   GameLift fleet EC2InboundPermissions found with port range instead of just a single port
#
# Reports on:
#    AWS::GameLift::Fleet
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W65
#
# Scenarios:
# a) SKIP: when there is no GameLift Fleet resource present.
# b) PASS: when all GameLift Fleet InboundPermissions resources have single port instead of range.
# c) FAIL: when any GameLift Fleet InboundPermissions resources have range of ports.
# d) SKIP: when metadata has rule suppression for GAMELIFT_FLEET_INBOUND_PORT_RANGE_RULE

#
# Select all GameLift Fleet resources from incoming template (payload)
#
let gamelift_fleet_inbound_port_range_rule = Resources.*[ Type == 'AWS::GameLift::Fleet'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W65"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "GAMELIFT_FLEET_INBOUND_PORT_RANGE_RULE"
]

rule GAMELIFT_FLEET_INBOUND_PORT_RANGE_RULE when %gamelift_fleet_inbound_port_range_rule !empty {
    %gamelift_fleet_inbound_port_range_rule.Properties.EC2InboundPermissions !exists
    OR
    %gamelift_fleet_inbound_port_range_rule.Properties.EC2InboundPermissions[*] {
        FromPort == ToPort
        <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W65    
        Violation: Gamelift fleet inbound permissions has range of ports instead of single port
        Fix: Specify a single port instead of range of ports
        >>
    }
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    EC2_NETWORK_ACL_PROTOCOL_RULE
#
# Description:
#   To avoid opening all ports for Allow rules, EC2 NetworkACL Entry Protocol should be either 6 (for TCP), 17 (for UDP), 1 (for ICMP), or 58 (for ICMPv6, which must include an IPv6 CIDR block, ICMP type, and code).
#
# Reports on:
#    AWS::EC2::NetworkAclEntry
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W66
#
# Scenarios:
# a) SKIP: when there are no EC2 NetworkACLEntry resource present
# b) PASS: When all EC2 NetworkACLEntry resources only uses specific protocol port number 6 (for TCP), 17 (for UDP), 1 (for ICMP), or 58 (for ICMPv6, which must include an IPv6 CIDR block, ICMP type, and code).
# c) FAIL: When any EC2 NetworkACLEntry resources does not use specific protocol port number 6 (for TCP), 17 (for UDP), 1 (for ICMP), or 58 (for ICMPv6, which must include an IPv6 CIDR block, ICMP type, and code).
# d) SKIP: when metadata has rule suppression for EC2_NETWORK_ACL_PROTOCOL_RULE

#
# Select all EC2 NetworkACLEntry resources from incoming template (payload)
#
let ec2_network_acl_protocol_rule = Resources.*[ Type == 'AWS::EC2::NetworkAclEntry'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W66"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EC2_NETWORK_ACL_PROTOCOL_RULE"
]

rule EC2_NETWORK_ACL_PROTOCOL_RULE when %ec2_network_acl_protocol_rule !empty {

  let violations = %ec2_network_acl_protocol_rule[
    Type == 'AWS::EC2::NetworkAclEntry'
    Properties.RuleAction == 'allow'
    Properties {
        Protocol != 1
        Protocol != 6
        Protocol != 17
        Protocol != 58
    }
    OR
    Properties {
        Protocol == 58
        Ipv6CidrBlock !exists
        OR
        Icmp !exists
        OR
        Icmp.Code !exists
        OR
        Icmp.Type !exists
    }
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W66    
    Violation: EC2 NetworkACLEntry resources does not use specific protocol port number 6 (for TCP), 17 (for UDP), 1 (for ICMP), or 58 (for ICMPv6, which must include an IPv6 CIDR block, ICMP type, and code).
    Fix: Use protocol port number 6 (for TCP), 17 (for UDP), 1 (for ICMP), or 58 (for ICMPv6, which must include an IPv6 CIDR block, ICMP type, and code).
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    EC2_NETWORK_ACL_PORT_RANGE_RULE
#
# Description:
#   TCP/UDP protocol NetworkACL entries possibly should not allow all ports.
#
# Reports on:
#    AWS::EC2::NetworkAclEntry
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W67
#
# Scenarios:
# a) SKIP: when there are no EC2 NetworkACLEntry resource present
# b) PASS: When all EC2 NetworkACLEntry resources does not use all ports for TCP/UDP
# c) FAIL: When any EC2 NetworkACLEntry resources does not specify range of ports for TCP/UDP
# d) SKIP: when metadata has rule suppression for EC2_NETWORK_ACL_PORT_RANGE_RULE

#
# Select all EC2 NetworkACLEntry resources from incoming template (payload)
#
let ec2_network_acl_port_range_rule = Resources.*[ Type == 'AWS::EC2::NetworkAclEntry'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W67"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EC2_NETWORK_ACL_PORT_RANGE_RULE"
]

rule EC2_NETWORK_ACL_PORT_RANGE_RULE when %ec2_network_acl_port_range_rule !empty {
  let violations = %ec2_network_acl_port_range_rule[
    Type == 'AWS::EC2::NetworkAclEntry'
    Properties {
        Protocol == 6
        OR
        Protocol == 17
    }
    Properties.PortRange !exists
    OR
    Properties.PortRange.From !exists
    OR
    Properties.PortRange.To !exists
    OR
    Properties {
        PortRange.From == 0
        PortRange.To == 65535
    }
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W67    
    Violation: EC2 NetworkACLEntry resources does not specify a range of ports for TCP/UDP or specifies complete range from 0 to 65535.
    Fix: Specify a range of ports for TCP/UDP for EC2 NetworkACLEntry resources.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
#
# Rule Identifier:
#   API_GW_STAGE_ACCESS_LOGGING_RULE
#
# Description:
#   AWS::ApiGateway::Stage should have the AccessLogSetting property defined.
#
# Reports on:
#   AWS::ApiGateway::Stage
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   None
#
# CFN_NAG Rule Id:
#   W69
#
# Scenarios:
# a) SKIP: when there are no API Gateway Stage Resources.
# b) SKIP: when metadata has rule suppression for API_GW_STAGE_ACCESS_LOGGING_RULE.
# c) FAIL: when accessLogSetting do no exist for APIGateway Stage resources.
# d) PASS: when accessLogSetting exists for APIGateway Stage resources.

#
# Select all API Gateway Stage Resources from incoming template (payload)
#
let api_gw_stage_access_logging_rule = Resources.*[ Type == 'AWS::ApiGateway::Stage'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W69"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "API_GW_STAGE_ACCESS_LOGGING_RULE"
]

rule API_GW_STAGE_ACCESS_LOGGING_RULE when %api_gw_stage_access_logging_rule !empty {

  %api_gw_stage_access_logging_rule.Properties.AccessLogSetting exists
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W69    
    Violation: AuthorizationType set to 'NONE' for API Gateway Method Resources.
    Fix: change value of AuthorizationType for API Gateway Method Resources.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    CLOUDFRONT_MINIMUM_PROTOCOL_VERSION_RULE
#
# Description:
#   Cloudfront should use minimum protocol version TLS 1.2.
#
# Reports on:
#    AWS::CloudFront::Distribution
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W70
#
# Scenarios:
# a) SKIP: when there are CloudFront Distribution resource present
# b) PASS: When all CloudFront Distribution resources uses TLS 1.2
# c) FAIL: When ANY CloudFront Distribution resources do not use TLS 1.2
# d) SKIP: when metadata has rule suppression for CLOUDFRONT_MINIMUM_PROTOCOL_VERSION_RULE

#
# Select all CloudFront Distribution resources from incoming template (payload)
#
let cloudfront_minimum_protocol_version_rule = Resources.*[ Type == 'AWS::CloudFront::Distribution'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W70"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CLOUDFRONT_MINIMUM_PROTOCOL_VERSION_RULE"
]

rule CLOUDFRONT_MINIMUM_PROTOCOL_VERSION_RULE when %cloudfront_minimum_protocol_version_rule !empty {
  let violations = %cloudfront_minimum_protocol_version_rule[
    Properties.DistributionConfig.ViewerCertificate !exists
    OR
    Properties.DistributionConfig {
       ViewerCertificate.MinimumProtocolVersion !exists
       OR
       ViewerCertificate {
        MinimumProtocolVersion is_string
        MinimumProtocolVersion != /(?i)TLSv1.2/
       }
    }
    OR
    Properties.DistributionConfig.ViewerCertificate {
       CloudFrontDefaultCertificate exists
       CloudFrontDefaultCertificate == true
    }
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W70    
    Violation: CloudFront Distribution resource do not use TLS 1.2 or viewerCertificate do no exist
    Fix: Specify viewerCertificate and use TLS 1.2
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    EC2_NETWORK_ACL_ENTRY_INEFFECTIVE_DENY_RULE
#
# Description:
#   NetworkACL Entry Deny rules should affect all CIDR ranges.
#
# Reports on:
#    AWS::EC2::NetworkAclEntry
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W71
#
# Scenarios:
# a) SKIP: when there are no EC2 NetworkACLEntry resource present
# b) PASS: When all EC2 NetworkACLEntry resources deny affects all CIDR ranges.
# c) FAIL: When any EC2 NetworkACLEntry resources deny does not affect all CIDR ranges.
# d) SKIP: when metadata has rule suppression for EC2_NETWORK_ACL_ENTRY_INEFFECTIVE_DENY_RULE

#
# Select all EC2 NetworkACLEntry resources from incoming template (payload)
#
let ec2_network_acl_entry_ineffective_deny_rule = Resources.*[ Type == 'AWS::EC2::NetworkAclEntry'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W71"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EC2_NETWORK_ACL_ENTRY_INEFFECTIVE_DENY_RULE"
]

rule EC2_NETWORK_ACL_ENTRY_INEFFECTIVE_DENY_RULE when %ec2_network_acl_entry_ineffective_deny_rule !empty {
  let violations = %ec2_network_acl_entry_ineffective_deny_rule[
    Type == 'AWS::EC2::NetworkAclEntry'
    Properties.RuleAction == 'deny'
    Properties {
        CidrBlock exists
        CidrBlock != '0.0.0.0/0'
    }
    OR
    Properties {
        Ipv6CidrBlock exists
        Ipv6CidrBlock != '::/0'
        Ipv6CidrBlock != ':/0'
    }
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W71    
    Violation: EC2 NetworkACLEntry resources with ruleAction Deny does not cover all CIDR Ranges.
    Fix: Cover all CIDR ranges for deny RuleAction.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    DYNAMODB_BILLING_MODE_RULE
#
# Description:
#   DynamoDB table should have billing mode set to either PAY_PER_REQUEST or PROVISIONED.
#
# Reports on:
#    AWS::DynamoDB::Table
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W73
#
# Scenarios:
# a) SKIP: when there are no DynamoDb Table resources present
# b) PASS: When all DynamoDb Table resources uses billingMode as PAY_PER_REQUEST or PROVISIONED
# c) FAIL: When any DynamoDb Table resources uses billingMode not as PAY_PER_REQUEST or PROVISIONED or billingMode is not specified.
# d) SKIP: when metadata has rule suppression for DYNAMODB_BILLING_MODE_RULE

#
# Select all DynamoDb Table resources from incoming template (payload)
#
let dynamodb_billing_mode_rule = Resources.*[ Type == 'AWS::DynamoDB::Table'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W73"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "DYNAMODB_BILLING_MODE_RULE"
]

rule DYNAMODB_BILLING_MODE_RULE when %dynamodb_billing_mode_rule !empty {
  let violations = %dynamodb_billing_mode_rule[
    Properties.BillingMode !exists
    OR
    Properties {
        BillingMode != 'PAY_PER_REQUEST'
        BillingMode != 'PROVISIONED'
    }
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W73    
    Violation: DynamoDb Table resources uses billingMode not as PAY_PER_REQUEST or PROVISIONED or billingMode is not specified.
    Fix: Specify billingMode as PAY_PER_REQUEST or PROVISIONED.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    DYNAMODB_TABLE_ENCRYPTED_KMS
#
# Description:
#   Checks if Amazon DynamoDB table is encrypted with AWS Key Management Service (KMS).
#
# Reports on:
#    AWS::DynamoDB::Table
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no DynamoDB Tables present
# b) SKIP: when metadata has rule suppression for DYNAMODB_TABLE_ENCRYPTED_KMS
# c) FAIL: when all DynamoDB Tables are not are encrypted with KMS
# d) PASS: when all DynamoDB Tables are encrypted with KMS

let dynamodb_table_encrypted_kms = Resources.*[ Type == "AWS::DynamoDB::Table"
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W74"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "DYNAMODB_TABLE_ENCRYPTED_KMS"
]

let DYNAMODB_TABLE_ENCRYPTED_KMS_ALLOWED_ALGORITHMS = [ "KMS" ]

rule DYNAMODB_TABLE_ENCRYPTED_KMS when %dynamodb_table_encrypted_kms !empty {
  %dynamodb_table_encrypted_kms.Properties.SSESpecification exists
  %dynamodb_table_encrypted_kms.Properties.SSESpecification.SSEEnabled == true
  %dynamodb_table_encrypted_kms.Properties.SSESpecification.KMSMasterKeyId exists
  %dynamodb_table_encrypted_kms.Properties.SSESpecification.SSEType in %DYNAMODB_TABLE_ENCRYPTED_KMS_ALLOWED_ALGORITHMS
      <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W74    
        Violation: Amazon DynamoDB tables are configured with SSE and a KMS key
        Fix: In SSESpecification, set SSEEnabled to true and set KMSMasterKeyId to the ID of a KMS key
      >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    DB_INSTANCE_BACKUP_ENABLED
#
# Description:
#    Checks if RDS DB instances have backups enabled.
#
# Reports on:
#    AWS::RDS::DBInstance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no RDS instances present
# b) PASS: when all RDS instances have BackupRetentionPeriod set to a positive number
# c) FAIL: when all RDS instances have BackupRetentionPeriod set to 0
# d) FAIL: when there are RDS instances with BackupRetentionPeriod property is not present
# e) SKIP: when metadata includes the suppression for rule DB_INSTANCE_BACKUP_ENABLED

#
# Select all RDS instance resources from incoming template (payload)
#

let aws_rds_instances_db_instance_backup_enabled = Resources.*[ Type == 'AWS::RDS::DBInstance'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W75"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "DB_INSTANCE_BACKUP_ENABLED"
]


rule DB_INSTANCE_BACKUP_ENABLED when %aws_rds_instances_db_instance_backup_enabled !empty {
  let violations = %aws_rds_instances_db_instance_backup_enabled[
    Properties.BackupRetentionPeriod !EXISTS
    or
    Properties.BackupRetentionPeriod < 1
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W75    
    Violation: All RDS instances must have automated backup enabled.
    Fix: Set the BackupRetentionPeriod to values of 1 to 35 to enable backups.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    SECRETSMANAGER_USING_CMK
#
# Description:
#   Checks if all secrets in AWS Secrets Manager are encrypted using a customer managed key that was created in AWS Key Management Service (AWS KMS).
#
# Reports on:
#    AWS::SecretsManager::Secret
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no Secrets Manager Secret resources
# b) PASS: when all Secrets Manager Secrets have an associated customer managed CMK
# c) FAIL: when any Secrets Manager Secrets is missing an associated customer managed CMK
# d) SKIP: when metada has rule suppression for SECRETSMANAGER_USING_CMK

#
# Select all AWS::SageMaker::EndpointConfig resources from incoming template (payload)
#
let aws_secretsmanager_secret_cmk = Resources.*[ Type == "AWS::SecretsManager::Secret"
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W77"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SECRETSMANAGER_USING_CMK"
]



rule SECRETSMANAGER_USING_CMK when %aws_secretsmanager_secret_cmk !empty {
  %aws_secretsmanager_secret_cmk.Properties.KmsKeyId exists
  %aws_secretsmanager_secret_cmk.Properties.KmsKeyId not in ["alias/aws/secretsmanager"]
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W77    
    Violation: AWS Secrets Manager secrets are encrypted using an AWS KMS customer managed key
    Fix: Set the KmsKeyId property
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#  DYNAMODB_PITR_ENABLED
#
# Description:
#  All DynamoDB Tables must have Point-In-Time-Recovery enabled.
#
# Reports on:
#  AWS::DynamoDB::Table
#
# Evaluates:
#  AWS CloudFormation
#
# Rule Parameters:
#  NA
#
# Scenarios:
# a) SKIP: when there are no DynamoDB Tables present
# b) SKIP: when metadata has rule suppression for DYNAMODB_PITR_ENABLED
# c) FAIL: when any DynamoDB Table is missing a PITR configuration
# d) FAIL: when any DynamoDB Table has PointInTimeRecoveryEnabled set to false
# d) PASS: when all DynamoDB Tables have PITR enabled

#
# Select all DynamoDB Table resources from incoming template (payload)
#
let dynamodb_pitr_enabled = Resources.*[ Type == "AWS::DynamoDB::Table" 
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W78"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "DYNAMODB_PITR_ENABLED"
]

rule DYNAMODB_PITR_ENABLED when %dynamodb_pitr_enabled !empty {
    %dynamodb_pitr_enabled.Properties.PointInTimeRecoverySpecification.PointInTimeRecoveryEnabled == true
    <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W78    
      Violation: All DynamoDB Tables must have Point-In-Time-Recovery enabled.
      Fix: Set the dynamodb table property PointInTimeRecoverySpecification.PointInTimeRecoveryEnabled to true.
    >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    ECR_REPO_SCAN_ON_PUSH
#
# Description:
#   ECR Repository should have ScanOnPush enabled.
#
# Reports on:
#    AWS::ECR::Repository
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W79
#
# Scenarios:
# a) SKIP: when there are no ECR Repository resources present
# b) PASS: When all ECR Repository resources have ScanOnPush enabled.
# c) FAIL: When any ECR Repository resources have ScanOnPush disabled or not specified.
# d) SKIP: when metadata has rule suppression for ECR_REPO_SCAN_ON_PUSH

#
# Select all DynamoDb Table resources from incoming template (payload)
#
let ecr_repo_scan_on_push_rule = Resources.*[ Type == 'AWS::ECR::Repository'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W79"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ECR_REPO_SCAN_ON_PUSH"
]

rule ECR_REPO_SCAN_ON_PUSH when %ecr_repo_scan_on_push_rule !empty {
  let violations = %ecr_repo_scan_on_push_rule[
    Properties.ImageScanningConfiguration !exists
    OR
    Properties.ImageScanningConfiguration.ScanOnPush == 'False'
    OR
    Properties.ImageScanningConfiguration.ScanOnPush == false
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W79    
    Violation: ECR Repository resources have ScanOnPush disabled or not specified.
    Fix: Set ScanOnPush in ImageScanningConfiguration to true
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    KENDRA_INDEX_ENCRYPTION_KMS_KEY_ID_RULE
#
# Description:
#   Kendra Index ServerSideEncryptionConfiguration should specify a KmsKeyId value.
#
# Reports on:
#    AWS::Kendra::Index
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W80
#
# Scenarios:
# a) SKIP: when there is no Kendra Index resource present.
# b) PASS: when Kendra Index ServerSideEncryptionConfiguration has a kmsKeyId value.
# c) FAIL: when Kendra Index ServerSideEncryptionConfiguration do not specify a kmsKeyId value.
# d) SKIP: when metadata has rule suppression for KENDRA_INDEX_ENCRYPTION_KMS_KEY_ID_RULE

#
# Select all Kendra Index resources from incoming template (payload)
#
let kendra_index_encryption_kms_key_id_rule = Resources.*[ Type == 'AWS::Kendra::Index'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W80"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "KENDRA_INDEX_ENCRYPTION_KMS_KEY_ID_RULE"
]

rule KENDRA_INDEX_ENCRYPTION_KMS_KEY_ID_RULE when %kendra_index_encryption_kms_key_id_rule !empty {
  let violations = %kendra_index_encryption_kms_key_id_rule[
    Type == 'AWS::Kendra::Index'
    Properties.ServerSideEncryptionConfiguration !exists
    OR
    Properties.ServerSideEncryptionConfiguration.KmsKeyId !exists
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W80    
    Violation: Kendra Index do not have ServerSideEncryptionConfiguration or KmsKeyId for ServerSideEncryptionConfiguration.
    Fix: Specify ServerSideEncryptionConfiguration and KmsKeyId for ServerSideEncryptionConfiguration.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    DLM_LIFECYCLE_POLICY_CROSS_REGION_ENCRYPTION_RULE
#
# Description:
#   DLM LifecyclePolicy PolicyDetails Actions CrossRegionCopy EncryptionConfiguration should enable Encryption.
#
# Reports on:
#    AWS::DLM::LifecyclePolicy
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W81
#
# Scenarios:
# a) SKIP: when there are no DLM LifeCycle Policy resources present.
# b) PASS: When all DLM LifeCycle Policy resources have encryption enabled.
# c) FAIL: When any DLM LifeCycle Policy resources do not have encryption enabled.
# d) SKIP: when metadata has rule suppression for DLM_LIFECYCLE_POLICY_CROSS_REGION_ENCRYPTION_RULE or W81.

#
# Select all DLM LifeCycle Policy resources from incoming template (payload)
#
let dlm_lifecycle_policy_cross_region_encryption_rule = Resources.*[ Type == 'AWS::DLM::LifecyclePolicy'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W81"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "DLM_LIFECYCLE_POLICY_CROSS_REGION_ENCRYPTION_RULE"
]

rule DLM_LIFECYCLE_POLICY_CROSS_REGION_ENCRYPTION_RULE when %dlm_lifecycle_policy_cross_region_encryption_rule !empty {
   let violations = %dlm_lifecycle_policy_cross_region_encryption_rule[
    Type == 'AWS::DLM::LifecyclePolicy'
    Properties.PolicyDetails exists
    Properties.PolicyDetails.Actions exists
    Properties.PolicyDetails.Actions[*].CrossRegionCopy exists
    some Properties.PolicyDetails.Actions[*].CrossRegionCopy[*] {
        EncryptionConfiguration.Encrypted !exists
        OR
        EncryptionConfiguration.Encrypted == false
        OR
        EncryptionConfiguration.Encrypted == 'false'
    }
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W81    
    Violation: DLM LifeCycle Policy resources do not have CrossRegion Encryption enabled.
    Fix: Enable CrossRegion Encryption for DLM LifeCycle Policy resources.
  >>
}

#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    EKS_CLUSTER_ENCRYPTION_RULE
#
# Description:
#   EKS Cluster EncryptionConfig Provider should specify KeyArn to enable Encryption.
#
# Reports on:
#    AWS::EKS::Cluster
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W82
#
# Scenarios:
# a) SKIP: when there are no EKS Cluster resources present.
# b) PASS: when all EKS Cluster resources specifies KeyArn to enable encryption.
# c) FAIL: when any EKS Cluster resources does not specify KeyArn.
# d) SKIP: when metadata has rule suppression for EKS_CLUSTER_ENCRYPTION_RULE

#
# Select all EKS Cluster resources from incoming template (payload)
#
let eks_cluster_encryption_rule = Resources.*[ Type == 'AWS::EKS::Cluster'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W82"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "EKS_CLUSTER_ENCRYPTION_RULE"
]

rule EKS_CLUSTER_ENCRYPTION_RULE when %eks_cluster_encryption_rule !empty {
  let violations = %eks_cluster_encryption_rule[
    Type == 'AWS::EKS::Cluster'
    Properties.EncryptionConfig !exists
    OR
    some Properties.EncryptionConfig[*].Provider !exists
    OR
    some Properties.EncryptionConfig[*].Provider.KeyArn !exists
  ]

  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W82    
    Violation: EKS Cluster resources does not specify KeyArn.
    Fix: specify KeyArn to enable Encryption.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    DAX_ENCRYPTION_ENABLED
#
# Description:
#  Checks whether the GitHub or Bitbucket source repository URL contains either personal access tokens or user name and password.
#
# Reports on:
#    AWS::CodeBuild::Project"
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no AWS::DAX::Cluster resources
# b) SKIP: when metada has rule suppression for DAX_ENCRYPTION_ENABLED
# c) FAIL: when SSESpecification does not exist or SSEEnabled not set to true
# d) PASS: when SSESpecification exist with the attribute SSEEnabled set to true

#
# Select all dax cluster resources from incoming template (payload)
#

let dax_clusters_encryption = Resources.*[ Type == "AWS::DAX::Cluster"
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W83"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "DAX_ENCRYPTION_ENABLED"
]

rule DAX_ENCRYPTION_ENABLED when %dax_clusters_encryption !empty {
	%dax_clusters_encryption.Properties.SSESpecification.SSEEnabled == true
	<<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W83    
		Violation: Amazon DAX clusters are configured with encryption at rest
		Fix: In SSESpecification, set the SSEEnabled property to true
	>>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CLOUDWATCH_LOG_GROUP_ENCRYPTED
#
# Description:
#   Checks if a log group in Amazon CloudWatch Logs is encrypted with a
#   AWS Key Management Service (KMS) managed Customer Master Keys (CMK).
#
# Reports on:
#    AWS::Logs::LogGroup
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no cloudwatch logs log group resources present
# b) PASS: when all cloudwatch logs log group resources property KmsKeyId is set
# c) FAIL: when all cloudwatch logs log group resources property KmsKeyId is not set with valid value
# d) SKIP: when metada has rule suppression for CLOUDWATCH_LOG_GROUP_ENCRYPTED

#
# Select all cloudwatch logs log group resources from incoming template (payload)
#
let cloudwatch_logs = Resources.*[ Type == 'AWS::Logs::LogGroup'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W84"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CLOUDWATCH_LOG_GROUP_ENCRYPTED"
]

rule CLOUDWATCH_LOG_GROUP_ENCRYPTED when %cloudwatch_logs !empty {
  %cloudwatch_logs.Properties.KmsKeyId exists
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W84    
    Violation: CloudWatch Log LogsGroup does not have KmsKeyId set.
    Fix: Set the KmsKeyId parameter to a ARN.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   ELASTICSEARCH_NODE_TO_NODE_ENCRYPTION_CHECK
#
# Description:
#   Elasticsearch domains must enforce Node-to-Node Encryption
#
# Reports on:
#   AWS::Elasticsearch::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there is no elasticsearch domain present
# b) SKIP: when metada has rule suppression for ELASTICSEARCH_NODE_TO_NODE_ENCRYPTION_CHECK
# c) FAIL: when Elasticsearch domain has Node-to-Node encryption property missing
# d) FAIL: when Elasticsearch domain has Node-to-Node encryption set to false
# e) PASS: when Elasticsearch domain has Node-to-Node encryption set to true

#
# Select all elasticsearch domains from incoming template
#
let elasticsearch_node_to_node_encryption_check = Resources.*[ Type == "AWS::Elasticsearch::Domain"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELASTICSEARCH_NODE_TO_NODE_ENCRYPTION_CHECK"
]

rule ELASTICSEARCH_NODE_TO_NODE_ENCRYPTION_CHECK when %elasticsearch_node_to_node_encryption_check !empty {
    %elasticsearch_node_to_node_encryption_check.Properties.NodeToNodeEncryptionOptions.Enabled == true
        <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W85    
            Violation: Elasticsearch domains must enforce Node-to-Node Encryption.
            Fix: Set the NodeToNodeEncryptionOptions.Enabled parameter to true.
        >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    CW_LOGGROUP_RETENTION_PERIOD_CHECK
#
# Description:
#   Checks whether Amazon CloudWatch LogGroup retention
#   period is set to specific number of days.
#
# Reports on:
#    AWS::Logs::LogGroup
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no cloudwatch logs log group resources present
# b) PASS: when all cloudwatch logs log group resources property RetentionInDays is set
# c) FAIL: when all cloudwatch logs log group resources property RetentionInDays is not set with valid value
# d) SKIP: when metada has rule suppression for CW_LOGGROUP_RETENTION_PERIOD_CHECK

#
# Select all cloudwatch logs log group resources from incoming template (payload)
#
let cloudwatch_logs_retention_period = Resources.*[ Type == 'AWS::Logs::LogGroup'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W86"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "CW_LOGGROUP_RETENTION_PERIOD_CHECK"
]

rule CW_LOGGROUP_RETENTION_PERIOD_CHECK when %cloudwatch_logs_retention_period !empty {
  %cloudwatch_logs_retention_period.Properties.RetentionInDays IN [1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, 3653]
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W86    
    Violation: CloudWatch Log LogsGroup does not have RetentionInDays set.
    Fix: Set the RetentionInDays parameter to a value of 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, or 3653.
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    API_GW_CACHE_ENABLED_AND_ENCRYPTED
#
# Description:
#    Checks that all methods in Amazon API Gateway stages have cache enabled and cache encrypted.
#
# Reports on:
#    AWS::ApiGateway::Stage
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there are no API GW Stage Methods present
# b) PASS: when all API Stage Method has caching enabled and encrypted
# c) FAIL: when API Stage Method does not have caching enabled and encrypted
# d) SKIP: when metadata includes the suppression for rule API_GW_CACHE_ENABLED_AND_ENCRYPTED

let api_gw_cache_enabled_encrypted = Resources.*[ Type == 'AWS::ApiGateway::Stage'
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W87"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "API_GW_CACHE_ENABLED_AND_ENCRYPTED"
]

rule API_GW_CACHE_ENABLED_AND_ENCRYPTED when %api_gw_cache_enabled_encrypted !empty {
  when %api_gw_cache_enabled_encrypted.Properties.MethodSettings exists {
    %api_gw_cache_enabled_encrypted.Properties.MethodSettings.*.CacheDataEncrypted == true
    %api_gw_cache_enabled_encrypted.Properties.MethodSettings.*.CachingEnabled == true
    <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W87    
      Violation: API Gateway Stage Method not set with caching and caching encrypted
      Fix: API GW Stage Method property CacheDataEncrypted and CachingEnabled set to true
    >>
  }
}
#
#####################################
##          AWS Solutions          ##
#####################################
# Rule Identifier:
#    KINESIS_FIREHOSE_DELIVERY_STREAM_ENCRYPTION_RULE
#
# Description:
#   Kinesis Firehose DeliveryStream of type DirectPut should specify SSE.
#
# Reports on:
#    AWS::KinesisFirehose::DeliveryStream
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# CFN_NAG Rule Id:
#   W88
#
# Scenarios:
# a) SKIP: when there is no Kinesis Firehose DeliveryStream resource present.
# b) PASS: when all Kinesis Firehose DeliveryStream has SSE specified.
# c) FAIL: when any Kinesis Firehose DeliveryStream resource do not have SSE specified.
# d) SKIP: when metadata has rule suppression for KINESIS_FIREHOSE_DELIVERY_STREAM_ENCRYPTION_RULE

#
# Select all Kinesis Firehose DeliveryStream resources from incoming template (payload)
#
let kinesis_Firehose_delivery_stream_encryption_rule = Resources.*[ Type == 'AWS::KinesisFirehose::DeliveryStream'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W88"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "KINESIS_FIREHOSE_DELIVERY_STREAM_ENCRYPTION_RULE"
]

rule KINESIS_FIREHOSE_DELIVERY_STREAM_ENCRYPTION_RULE when %kinesis_Firehose_delivery_stream_encryption_rule !empty {
  let violations = %kinesis_Firehose_delivery_stream_encryption_rule[
    Properties.DeliveryStreamType !exists
    OR
    Properties.DeliveryStreamType != 'KinesisStreamAsSource'
    Properties.DeliveryStreamEncryptionConfigurationInput !exists
    OR
    Properties.DeliveryStreamEncryptionConfigurationInput.KeyType !exists
  ]
  %violations empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W88    
    Violation: Kinesis Firehose DeliveryStream resource do not have SSE specified.
    Fix: Specify SSE for all Kinesis Firehose DeliveryStream resources.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    LAMBDA_INSIDE_VPC
#
# Description:
#    Checks whether an AWS Lambda function is allowed access to an Amazon Virtual Private Cloud.
#
# Reports on:
#    AWS::Lambda::Function
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when no AWS Lambda functions are present
# b) PASS: when all AWS Lambda functions are VPC enabled
# c) FAIL: when any AWS Lambda functions are not VPC enabled
# d) SKIP: hen metadata includes the suppression for rule LAMBDA_INSIDE_VPC

#
# Select all AWS Lambda Function resources from incoming template (payload)
#
let aws_lambda_functions_inside_vpc = Resources.*[ Type == 'AWS::Lambda::Function' 
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W89"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "LAMBDA_INSIDE_VPC"
]

rule  LAMBDA_INSIDE_VPC when %aws_lambda_functions_inside_vpc !empty {
  %aws_lambda_functions_inside_vpc.Properties.VpcConfig.SecurityGroupIds !empty
  %aws_lambda_functions_inside_vpc.Properties.VpcConfig.SubnetIds !empty
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W89    
    Violation:  All AWS Lambda Functions must be configured with access to a VPC
    Fix: set the VpcConfig.SecurityGroupIds and VpcConfig.SubnetIds parameters with a list of security groups and subnets.
    Lambda creates an elastic network interface for each combination of security group and subnet in the function's VPC configuration.
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#   ELASTICSEARCH_IN_VPC_ONLY
#
# Description:
#   Elasticsearch domains must be in a VPC
#
# Reports on:
#   AWS::Elasticsearch::Domain
#
# Evaluates:
#   AWS CloudFormation
#
# Rule Parameters:
#   NA
#
# Scenarios:
# a) SKIP: when there is no elasticsearch domain present
# b) SKIP: when metada has rule suppression for ELASTICSEARCH_IN_VPC_ONLY
# c) PASS: when elasticsearch domain has VPCOptions or Endpoint properties
# d) FAIL: when elasticsearch domain does not have VPCOptions or Endpoint properties

#
# Select all elasticsearch domains from incoming template
#
let elasticsearch_domains_vpc_required = Resources.*[ Type == "AWS::Elasticsearch::Domain"
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W90"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "ELASTICSEARCH_IN_VPC_ONLY"
]

rule ELASTICSEARCH_IN_VPC_ONLY when %elasticsearch_domains_vpc_required !empty {
    %elasticsearch_domains_vpc_required.Properties.VPCOptions EXISTS
        <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W90    
            Violation: Elasticsearch domains must be in a VPC.
            Fix: Provide VPCOptions object to enable opensearch to function in a VPC.
        >>
}
#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    DMS_REPLICATION_NOT_PUBLIC
#
# Description:
#   Checks whether AWS Database Migration Service replication instances are not set to allow public.
#
# Reports on:
#    AWS::DMS::ReplicationInstance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when there is no DMS Replication Instance present
# b) FAIL: When DMS Replication Instance is present and PubliclyAccessible property is set to true
# c) PASS: When DMS Replication Instance is present and PubliclyAccessible property is set to false
# c) FAIL: When DMS Replication Instance is present and PubliclyAccessible property is not set
# d) SKIP: when metadata has rule suppression for DMS_REPLICATION_NOT_PUBLIC or cfn_nag W91

#
# Select all DMS ReplicationInstance resources from incoming template
#

let dms_replication_instances = Resources.*[ Type == 'AWS::DMS::ReplicationInstance'
  Metadata.cfn_nag.rules_to_suppress not exists or
  Metadata.cfn_nag.rules_to_suppress.*.id != "W91"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "DMS_REPLICATION_NOT_PUBLIC"
]

rule DMS_REPLICATION_NOT_PUBLIC when %dms_replication_instances !empty {
  %dms_replication_instances.Properties.PubliclyAccessible exists
  %dms_replication_instances.Properties.PubliclyAccessible == false
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W91    
    Violation: AWS Database Migration Service replication instances should not be public.
    Fix: Set the DMS Replication Instance property PubliclyAccessible parameter to false.
  >>
}

#
#####################################
##           Gherkin               ##
#####################################
# Rule Identifier:
#    LAMBDA_CONCURRENCY_CHECK
#
# Description:
#    Checks whether the AWS Lambda function is configured with function-level concurrent execution limit.
#
# Reports on:
#    AWS::Lambda::Function
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when no AWS Lambda functions are present
# b) PASS: when all AWS Lambda functions are configured with function-level concurrent execution limits
# c) FAIL: when any AWS Lambda functions are not configured with function-level concurrent execution limits
# d) SKIP: hen metadata includes the suppression for rule LAMBDA_CONCURRENCY_CHECK

#
# Select all AWS Lambda Function resources from incoming template (payload)
#
let aws_lambda_functions_concurrency = Resources.*[ Type == 'AWS::Lambda::Function' 
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W92"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "LAMBDA_CONCURRENCY_CHECK"
]

rule LAMBDA_CONCURRENCY_CHECK when %aws_lambda_functions_concurrency !empty {
  %aws_lambda_functions_concurrency.Properties.ReservedConcurrentExecutions >= 0
  <<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W92    
    Violation: All AWS Lambda Functions must have concurrent execution limits configured
    Fix: Set the ReservedConcurrentExecutions property to an integer greater than or equal to 0
  >>
}
#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    SAGEMAKER_ENDPOINT_CONFIGURATION_KMS_KEY_CONFIGURED
#
# Description:
#   Checks whether AWS Key Management Service (KMS) key is configured for an Amazon SageMaker endpoint configuration.
#
# Reports on:
#    AWS::SageMaker::EndpointConfig
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when Sagemaker EndpointConfig resource not present
# b) SKIP: when metada has rule suppression for SAGEMAKER_ENDPOINT_CONFIGURATION_KMS_KEY_CONFIGURED
# c) FAIL: when all Sagemaker EndpointConfig resources KmsKeyId property does not exist
# d) PASS: when all Sagemaker EndpointConfig resources KmsKeyId property is set

#
# Select all AWS::SageMaker::EndpointConfig resources from incoming template (payload)
#
let sagemaker_endpoint_configuration_kms_key_configured = Resources.*[ Type == "AWS::SageMaker::EndpointConfig"
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W1200"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SAGEMAKER_ENDPOINT_CONFIGURATION_KMS_KEY_CONFIGURED"
]

rule SAGEMAKER_ENDPOINT_CONFIGURATION_KMS_KEY_CONFIGURED when %sagemaker_endpoint_configuration_kms_key_configured !empty {
	%sagemaker_endpoint_configuration_kms_key_configured.Properties.KmsKeyId exists
	<<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W1200    
		Violation: Amazon SageMaker endpoints are configured with a Key Management Service (KMS) key 
		Fix: Set the KmsKeyId property
	>>
}

#
#####################################
##           Gherkin               ##
#####################################
#
# Rule Identifier:
#    SAGEMAKER_NOTEBOOK_INSTANCE_KMS_KEY_CONFIGURED
#
# Description:
#   Checks whether AWS Key Management Service (KMS) key is configured for an Amazon SageMaker notebook instance.
#
# Reports on:
#    AWS::SageMaker::NotebookInstance
#
# Evaluates:
#    AWS CloudFormation
#
# Rule Parameters:
#    NA
#
# Scenarios:
# a) SKIP: when Sagemaker Notebook Instance resource not present
# b) SKIP: when metada has rule suppression for SAGEMAKER_NOTEBOOK_INSTANCE_KMS_KEY_CONFIGURED
# c) FAIL: when all Sagemaker Notebook Instance resources KmsKeyId property does not exist
# d) PASS: when all Sagemaker Notebook Instance resources KmsKeyId property is set

#
# Select all AWS::SageMaker::NotebookInstance resources from incoming template (payload)
#

let sagemaker_notebook_instance_kms_key_configured = Resources.*[ Type == "AWS::SageMaker::NotebookInstance"
  Metadata.cfn_nag.rules_to_suppress not exists or 
  Metadata.cfn_nag.rules_to_suppress.*.id != "W1201"
  Metadata.guard.SuppressedRules not exists or
  Metadata.guard.SuppressedRules.* != "SAGEMAKER_NOTEBOOK_INSTANCE_KMS_KEY_CONFIGURED"
]

rule SAGEMAKER_NOTEBOOK_INSTANCE_KMS_KEY_CONFIGURED when %sagemaker_notebook_instance_kms_key_configured !empty {
	%sagemaker_notebook_instance_kms_key_configured.Properties.KmsKeyId exists
	<<
    Guard Rule Set: cfn-nag-equivalent
    Controls: W1201    
		Violation: Amazon SageMaker Notebook instances are configured with a Key Management Service (KMS) key 
		Fix: Set the KmsKeyId property
	>>
}

