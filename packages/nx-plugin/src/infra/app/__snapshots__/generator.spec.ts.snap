// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`infra generator > should add required dependencies to package.json > dependencies 1`] = `
{
  "aws-cdk": "2.1106.0",
  "aws-cdk-lib": "2.238.0",
  "constructs": "10.5.0",
  "esbuild": "0.27.3",
  "source-map-support": "0.5.21",
}
`;

exports[`infra generator > should add required dependencies to package.json > dev-dependencies 1`] = `
{
  "@eslint/js": "^9.8.0",
  "@nx/eslint": "22.5.1",
  "@nx/eslint-plugin": "22.5.1",
  "@nx/js": "22.5.1",
  "@nx/vitest": "22.5.1",
  "@swc-node/register": "~1.11.1",
  "@swc/core": "~1.15.5",
  "@swc/helpers": "~0.5.18",
  "@types/node": "22.19.11",
  "@vitest/coverage-v8": "^4.0.0",
  "eslint": "^9.8.0",
  "eslint-config-prettier": "^10.0.0",
  "eslint-plugin-prettier": "5.5.5",
  "jsdom": "^27.1.0",
  "jsonc-eslint-parser": "2.4.2",
  "prettier": "3.8.1",
  "tsx": "4.21.0",
  "typescript": "~5.9.2",
  "typescript-eslint": "^8.40.0",
  "vite": "^7.0.0",
  "vitest": "^4.0.8",
}
`;

exports[`infra generator > should add required dependencies to package.json > package-json 1`] = `
{
  "dependencies": {
    "aws-cdk": "2.1106.0",
    "aws-cdk-lib": "2.238.0",
    "constructs": "10.5.0",
    "esbuild": "0.27.3",
    "source-map-support": "0.5.21",
  },
  "devDependencies": {
    "@eslint/js": "^9.8.0",
    "@nx/eslint": "22.5.1",
    "@nx/eslint-plugin": "22.5.1",
    "@nx/js": "22.5.1",
    "@nx/vitest": "22.5.1",
    "@swc-node/register": "~1.11.1",
    "@swc/core": "~1.15.5",
    "@swc/helpers": "~0.5.18",
    "@types/node": "22.19.11",
    "@vitest/coverage-v8": "^4.0.0",
    "eslint": "^9.8.0",
    "eslint-config-prettier": "^10.0.0",
    "eslint-plugin-prettier": "5.5.5",
    "jsdom": "^27.1.0",
    "jsonc-eslint-parser": "2.4.2",
    "prettier": "3.8.1",
    "tsx": "4.21.0",
    "typescript": "~5.9.2",
    "typescript-eslint": "^8.40.0",
    "vite": "^7.0.0",
    "vitest": "^4.0.8",
  },
  "name": "@proj/source",
  "type": "module",
}
`;

exports[`infra generator > should configure Checkov target correctly > checkov-target 1`] = `
{
  "cache": true,
  "dependsOn": [
    "synth",
  ],
  "executor": "nx:run-commands",
  "inputs": [
    "{workspaceRoot}/dist/{projectRoot}/cdk.out",
  ],
  "options": {
    "command": "uvx checkov==3.2.505 --config-file {projectRoot}/checkov.yml --directory dist/{projectRoot}/cdk.out --framework cloudformation",
  },
  "outputs": [
    "{workspaceRoot}/dist/{projectRoot}/checkov",
  ],
}
`;

exports[`infra generator > should configure project.json with correct targets > build-target 1`] = `
{
  "dependsOn": [
    "lint",
    "compile",
    "test",
    "synth",
    "checkov",
  ],
}
`;

exports[`infra generator > should configure project.json with correct targets > deploy-target 1`] = `
{
  "dependsOn": [
    "^build",
    "compile",
  ],
  "executor": "nx:run-commands",
  "options": {
    "command": "cdk deploy --require-approval=never",
    "cwd": "{projectRoot}",
  },
}
`;

exports[`infra generator > should configure project.json with correct targets > destroy-target 1`] = `
{
  "dependsOn": [
    "^build",
    "compile",
  ],
  "executor": "nx:run-commands",
  "options": {
    "command": "cdk destroy --require-approval=never",
    "cwd": "{projectRoot}",
  },
}
`;

exports[`infra generator > should configure project.json with correct targets > project-configuration 1`] = `
{
  "$schema": "../../node_modules/nx/schemas/project-schema.json",
  "metadata": {
    "generator": "ts#infra",
  },
  "name": "@proj/test",
  "projectType": "application",
  "root": "packages/test",
  "sourceRoot": "packages/test/src",
  "tags": [],
  "targets": {
    "bootstrap": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cdk bootstrap",
        "cwd": "{projectRoot}",
      },
    },
    "build": {
      "dependsOn": [
        "lint",
        "compile",
        "test",
        "synth",
        "checkov",
      ],
    },
    "cdk": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cdk",
        "cwd": "{projectRoot}",
      },
    },
    "checkov": {
      "cache": true,
      "dependsOn": [
        "synth",
      ],
      "executor": "nx:run-commands",
      "inputs": [
        "{workspaceRoot}/dist/{projectRoot}/cdk.out",
      ],
      "options": {
        "command": "uvx checkov==3.2.505 --config-file {projectRoot}/checkov.yml --directory dist/{projectRoot}/cdk.out --framework cloudformation",
      },
      "outputs": [
        "{workspaceRoot}/dist/{projectRoot}/checkov",
      ],
    },
    "compile": {
      "executor": "nx:run-commands",
      "options": {
        "command": "tsc --build tsconfig.lib.json",
        "cwd": "{projectRoot}",
      },
      "outputs": [
        "{workspaceRoot}/dist/{projectRoot}/tsc",
      ],
    },
    "deploy": {
      "dependsOn": [
        "^build",
        "compile",
      ],
      "executor": "nx:run-commands",
      "options": {
        "command": "cdk deploy --require-approval=never",
        "cwd": "{projectRoot}",
      },
    },
    "deploy-ci": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cdk deploy --require-approval=never --app ../../dist/{projectRoot}/cdk.out",
        "cwd": "{projectRoot}",
      },
    },
    "destroy": {
      "dependsOn": [
        "^build",
        "compile",
      ],
      "executor": "nx:run-commands",
      "options": {
        "command": "cdk destroy --require-approval=never",
        "cwd": "{projectRoot}",
      },
    },
    "destroy-ci": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cdk destroy --require-approval=never --app ../../dist/{projectRoot}/cdk.out",
        "cwd": "{projectRoot}",
      },
    },
    "lint": {
      "cache": true,
      "configurations": {
        "fix": {
          "fix": true,
        },
        "skip-lint": {
          "force": true,
        },
      },
      "executor": "@nx/eslint:lint",
      "inputs": [
        "eslint",
      ],
    },
    "synth": {
      "cache": true,
      "dependsOn": [
        "^build",
        "compile",
      ],
      "executor": "nx:run-commands",
      "inputs": [
        "default",
      ],
      "options": {
        "command": "cdk synth",
        "cwd": "{projectRoot}",
      },
      "outputs": [
        "{workspaceRoot}/dist/{projectRoot}/cdk.out",
      ],
    },
    "test": {
      "executor": "@nx/vitest:test",
      "options": {
        "reportsDirectory": "{workspaceRoot}/coverage/{projectRoot}",
      },
      "outputs": [
        "{options.reportsDirectory}",
      ],
    },
  },
}
`;

exports[`infra generator > should generate Checkov configuration files > checkov-ts 1`] = `
"import { IConstruct } from 'constructs';
import { CfnResource } from 'aws-cdk-lib';

/**
 * Suppresses a set of rules for a construct tree.
 *
 * @param construct The root construct to suppress the rule for.
 * @param ids The ids of the rules to suppress.
 * @param comment The reason for suppressing the rule
 * @param predicate A predicate function that determines whether the rule should be suppressed for the given construct or any of its descendants.
 *
 * @example
 * The following example suppresses the CKV_AWS_XXX rule for the given construct.
 * suppressRules(construct, ['CKV_AWS_XXX'], 'Not required for this use case')
 *
 * @example
 * The following example suppresses the CKV_AWS_XXX rule for the construct or any of its descendants if it is an instance of Bucket:
 * suppressRules(construct, ['CKV_AWS_XXX'], 'Not required for this use case', (construct) => construct instanceof Bucket)
 */
export const suppressRules = (
  construct: IConstruct,
  ids: string[],
  comment: string,
  predicate?: (construct: IConstruct) => boolean,
) => {
  const resources = (
    predicate ? construct.node.findAll().filter(predicate) : [construct]
  )
    .map((resource) => {
      if (CfnResource.isCfnResource(resource)) {
        return resource;
      } else return resource.node.defaultChild;
    })
    .filter((resource) => CfnResource.isCfnResource(resource));

  resources.forEach((resource) => {
    const metadata = resource.getMetadata('checkov') || {};
    metadata['skip'] = [
      ...(metadata['skip'] ?? []),
      ...ids.map((id) => ({ id, comment })),
    ];
    resource.addMetadata('checkov', metadata);
  });
};
"
`;

exports[`infra generator > should generate Checkov configuration files > checkov-yml 1`] = `
"# Defines the checks to skip entirely. Remove if your requirements differ.
skip-check:
  # Lambda function suppressions
  - CKV_AWS_115 # Concurrent execution limit
  - CKV_AWS_116 # Dead Letter Queue
  - CKV_AWS_117 # Lambda functions in VPC
  - CKV_AWS_173 # Encrypt Lambda environment variables
  - CKV_AWS_272 # Code signing
output:
  - cli
  - json
output-file-path: console,dist/packages/test/checkov/checkov_report.json
"
`;

exports[`infra generator > should generate consistent file content across runs > consistent-files 1`] = `
{
  "cdk.json": "{
  "app": "tsx src/main.ts",
  "output": "../../dist/packages/test/cdk.out",
  "watch": {
    "include": ["**"],
    "exclude": [
      "README.md",
      "cdk*.json",
      "**/*.d.ts",
      "**/*.js",
      "tsconfig.json",
      "package*.json",
      "yarn.lock",
      "node_modules",
      "test"
    ]
  },
  "context": {
    "@aws-cdk/aws-lambda:recognizeLayerVersion": true,
    "@aws-cdk/core:checkSecretUsage": true,
    "@aws-cdk/core:target-partitions": ["aws", "aws-cn"],
    "@aws-cdk-containers/ecs-service-extensions:enableDefaultLogDriver": true,
    "@aws-cdk/aws-ec2:uniqueImdsv2TemplateName": true,
    "@aws-cdk/aws-ecs:arnFormatIncludesClusterName": true,
    "@aws-cdk/aws-iam:minimizePolicies": true,
    "@aws-cdk/core:validateSnapshotRemovalPolicy": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeyAliasStackSafeResourceName": true,
    "@aws-cdk/aws-s3:createDefaultLoggingPolicy": true,
    "@aws-cdk/aws-sns-subscriptions:restrictSqsDescryption": true,
    "@aws-cdk/aws-apigateway:disableCloudWatchRole": true,
    "@aws-cdk/core:enablePartitionLiterals": true,
    "@aws-cdk/aws-events:eventsTargetQueueSameAccount": true,
    "@aws-cdk/aws-ecs:disableExplicitDeploymentControllerForCircuitBreaker": true,
    "@aws-cdk/aws-iam:importedRoleStackSafeDefaultPolicyName": true,
    "@aws-cdk/aws-s3:serverAccessLogsUseBucketPolicy": true,
    "@aws-cdk/aws-route53-patters:useCertificate": true,
    "@aws-cdk/customresources:installLatestAwsSdkDefault": false,
    "@aws-cdk/aws-rds:databaseProxyUniqueResourceName": true,
    "@aws-cdk/aws-codedeploy:removeAlarmsFromDeploymentGroup": true,
    "@aws-cdk/aws-apigateway:authorizerChangeDeploymentLogicalId": true,
    "@aws-cdk/aws-ec2:launchTemplateDefaultUserData": true,
    "@aws-cdk/aws-secretsmanager:useAttachedSecretResourcePolicyForSecretTargetAttachments": true,
    "@aws-cdk/aws-redshift:columnId": true,
    "@aws-cdk/aws-stepfunctions-tasks:enableEmrServicePolicyV2": true,
    "@aws-cdk/aws-ec2:restrictDefaultSecurityGroup": true,
    "@aws-cdk/aws-apigateway:requestValidatorUniqueId": true,
    "@aws-cdk/aws-kms:aliasNameRef": true,
    "@aws-cdk/aws-autoscaling:generateLaunchTemplateInsteadOfLaunchConfig": true,
    "@aws-cdk/core:includePrefixInUniqueNameGeneration": true,
    "@aws-cdk/aws-efs:denyAnonymousAccess": true,
    "@aws-cdk/aws-opensearchservice:enableOpensearchMultiAzWithStandby": true,
    "@aws-cdk/aws-lambda-nodejs:useLatestRuntimeVersion": true,
    "@aws-cdk/aws-efs:mountTargetOrderInsensitiveLogicalId": true,
    "@aws-cdk/aws-rds:auroraClusterChangeScopeOfInstanceParameterGroupWithEachParameters": true,
    "@aws-cdk/aws-appsync:useArnForSourceApiAssociationIdentifier": true,
    "@aws-cdk/aws-rds:preventRenderingDeprecatedCredentials": true,
    "@aws-cdk/aws-codepipeline-actions:useNewDefaultBranchForCodeCommitSource": true,
    "@aws-cdk/aws-cloudwatch-actions:changeLambdaPermissionLogicalIdForLambdaAction": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeysDefaultValueToFalse": true,
    "@aws-cdk/aws-codepipeline:defaultPipelineTypeToV2": true,
    "@aws-cdk/aws-kms:reduceCrossAccountRegionPolicyScope": true,
    "@aws-cdk/aws-eks:nodegroupNameAttribute": true,
    "@aws-cdk/aws-ec2:ebsDefaultGp3Volume": true,
    "@aws-cdk/aws-ecs:removeDefaultDeploymentAlarm": true,
    "@aws-cdk/custom-resources:logApiResponseDataPropertyTrueDefault": false
  }
}
",
  "src/main.ts": "import { ApplicationStage } from './stages/application-stage.js';
import { App } from ':proj/common-constructs';

const app = new App();

// Use this to deploy your own sandbox environment (assumes your CLI credentials)
new ApplicationStage(app, 'proj-test-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
});

app.synth();
",
  "src/stacks/application-stack.ts": "import { Stack, StackProps } from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends Stack {
  constructor(scope: Construct, id: string, props?: StackProps) {
    super(scope, id, props);

    // The code that defines your stack goes here
  }
}
",
  "src/stages/application-stage.ts": "import { Stage, StageProps } from 'aws-cdk-lib';
import { Construct } from 'constructs';
import { ApplicationStack } from '../stacks/application-stack.js';

/**
 * Defines a collection of CDK Stacks which make up your application
 */
export class ApplicationStage extends Stage {
  constructor(scope: Construct, id: string, props?: StageProps) {
    super(scope, id, props);

    new ApplicationStack(this, 'Application', {
      crossRegionReferences: true,
    });
  }
}
",
}
`;

exports[`infra generator > should generate files with correct content > application-stack-ts 1`] = `
"import { Stack, StackProps } from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends Stack {
  constructor(scope: Construct, id: string, props?: StackProps) {
    super(scope, id, props);

    // The code that defines your stack goes here
  }
}
"
`;

exports[`infra generator > should generate files with correct content > application-stage-ts 1`] = `
"import { Stage, StageProps } from 'aws-cdk-lib';
import { Construct } from 'constructs';
import { ApplicationStack } from '../stacks/application-stack.js';

/**
 * Defines a collection of CDK Stacks which make up your application
 */
export class ApplicationStage extends Stage {
  constructor(scope: Construct, id: string, props?: StageProps) {
    super(scope, id, props);

    new ApplicationStack(this, 'Application', {
      crossRegionReferences: true,
    });
  }
}
"
`;

exports[`infra generator > should generate files with correct content > cdk-json 1`] = `
"{
  "app": "tsx src/main.ts",
  "output": "../../dist/packages/test/cdk.out",
  "watch": {
    "include": ["**"],
    "exclude": [
      "README.md",
      "cdk*.json",
      "**/*.d.ts",
      "**/*.js",
      "tsconfig.json",
      "package*.json",
      "yarn.lock",
      "node_modules",
      "test"
    ]
  },
  "context": {
    "@aws-cdk/aws-lambda:recognizeLayerVersion": true,
    "@aws-cdk/core:checkSecretUsage": true,
    "@aws-cdk/core:target-partitions": ["aws", "aws-cn"],
    "@aws-cdk-containers/ecs-service-extensions:enableDefaultLogDriver": true,
    "@aws-cdk/aws-ec2:uniqueImdsv2TemplateName": true,
    "@aws-cdk/aws-ecs:arnFormatIncludesClusterName": true,
    "@aws-cdk/aws-iam:minimizePolicies": true,
    "@aws-cdk/core:validateSnapshotRemovalPolicy": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeyAliasStackSafeResourceName": true,
    "@aws-cdk/aws-s3:createDefaultLoggingPolicy": true,
    "@aws-cdk/aws-sns-subscriptions:restrictSqsDescryption": true,
    "@aws-cdk/aws-apigateway:disableCloudWatchRole": true,
    "@aws-cdk/core:enablePartitionLiterals": true,
    "@aws-cdk/aws-events:eventsTargetQueueSameAccount": true,
    "@aws-cdk/aws-ecs:disableExplicitDeploymentControllerForCircuitBreaker": true,
    "@aws-cdk/aws-iam:importedRoleStackSafeDefaultPolicyName": true,
    "@aws-cdk/aws-s3:serverAccessLogsUseBucketPolicy": true,
    "@aws-cdk/aws-route53-patters:useCertificate": true,
    "@aws-cdk/customresources:installLatestAwsSdkDefault": false,
    "@aws-cdk/aws-rds:databaseProxyUniqueResourceName": true,
    "@aws-cdk/aws-codedeploy:removeAlarmsFromDeploymentGroup": true,
    "@aws-cdk/aws-apigateway:authorizerChangeDeploymentLogicalId": true,
    "@aws-cdk/aws-ec2:launchTemplateDefaultUserData": true,
    "@aws-cdk/aws-secretsmanager:useAttachedSecretResourcePolicyForSecretTargetAttachments": true,
    "@aws-cdk/aws-redshift:columnId": true,
    "@aws-cdk/aws-stepfunctions-tasks:enableEmrServicePolicyV2": true,
    "@aws-cdk/aws-ec2:restrictDefaultSecurityGroup": true,
    "@aws-cdk/aws-apigateway:requestValidatorUniqueId": true,
    "@aws-cdk/aws-kms:aliasNameRef": true,
    "@aws-cdk/aws-autoscaling:generateLaunchTemplateInsteadOfLaunchConfig": true,
    "@aws-cdk/core:includePrefixInUniqueNameGeneration": true,
    "@aws-cdk/aws-efs:denyAnonymousAccess": true,
    "@aws-cdk/aws-opensearchservice:enableOpensearchMultiAzWithStandby": true,
    "@aws-cdk/aws-lambda-nodejs:useLatestRuntimeVersion": true,
    "@aws-cdk/aws-efs:mountTargetOrderInsensitiveLogicalId": true,
    "@aws-cdk/aws-rds:auroraClusterChangeScopeOfInstanceParameterGroupWithEachParameters": true,
    "@aws-cdk/aws-appsync:useArnForSourceApiAssociationIdentifier": true,
    "@aws-cdk/aws-rds:preventRenderingDeprecatedCredentials": true,
    "@aws-cdk/aws-codepipeline-actions:useNewDefaultBranchForCodeCommitSource": true,
    "@aws-cdk/aws-cloudwatch-actions:changeLambdaPermissionLogicalIdForLambdaAction": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeysDefaultValueToFalse": true,
    "@aws-cdk/aws-codepipeline:defaultPipelineTypeToV2": true,
    "@aws-cdk/aws-kms:reduceCrossAccountRegionPolicyScope": true,
    "@aws-cdk/aws-eks:nodegroupNameAttribute": true,
    "@aws-cdk/aws-ec2:ebsDefaultGp3Volume": true,
    "@aws-cdk/aws-ecs:removeDefaultDeploymentAlarm": true,
    "@aws-cdk/custom-resources:logApiResponseDataPropertyTrueDefault": false
  }
}
"
`;

exports[`infra generator > should generate files with correct content > main-ts 1`] = `
"import { ApplicationStage } from './stages/application-stage.js';
import { App } from ':proj/common-constructs';

const app = new App();

// Use this to deploy your own sandbox environment (assumes your CLI credentials)
new ApplicationStage(app, 'proj-test-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
});

app.synth();
"
`;

exports[`infra generator > should handle custom project names correctly > custom-name-files 1`] = `
{
  "cdk.json": "{
  "app": "tsx src/main.ts",
  "output": "../../dist/packages/custom-infra/cdk.out",
  "watch": {
    "include": ["**"],
    "exclude": [
      "README.md",
      "cdk*.json",
      "**/*.d.ts",
      "**/*.js",
      "tsconfig.json",
      "package*.json",
      "yarn.lock",
      "node_modules",
      "test"
    ]
  },
  "context": {
    "@aws-cdk/aws-lambda:recognizeLayerVersion": true,
    "@aws-cdk/core:checkSecretUsage": true,
    "@aws-cdk/core:target-partitions": ["aws", "aws-cn"],
    "@aws-cdk-containers/ecs-service-extensions:enableDefaultLogDriver": true,
    "@aws-cdk/aws-ec2:uniqueImdsv2TemplateName": true,
    "@aws-cdk/aws-ecs:arnFormatIncludesClusterName": true,
    "@aws-cdk/aws-iam:minimizePolicies": true,
    "@aws-cdk/core:validateSnapshotRemovalPolicy": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeyAliasStackSafeResourceName": true,
    "@aws-cdk/aws-s3:createDefaultLoggingPolicy": true,
    "@aws-cdk/aws-sns-subscriptions:restrictSqsDescryption": true,
    "@aws-cdk/aws-apigateway:disableCloudWatchRole": true,
    "@aws-cdk/core:enablePartitionLiterals": true,
    "@aws-cdk/aws-events:eventsTargetQueueSameAccount": true,
    "@aws-cdk/aws-ecs:disableExplicitDeploymentControllerForCircuitBreaker": true,
    "@aws-cdk/aws-iam:importedRoleStackSafeDefaultPolicyName": true,
    "@aws-cdk/aws-s3:serverAccessLogsUseBucketPolicy": true,
    "@aws-cdk/aws-route53-patters:useCertificate": true,
    "@aws-cdk/customresources:installLatestAwsSdkDefault": false,
    "@aws-cdk/aws-rds:databaseProxyUniqueResourceName": true,
    "@aws-cdk/aws-codedeploy:removeAlarmsFromDeploymentGroup": true,
    "@aws-cdk/aws-apigateway:authorizerChangeDeploymentLogicalId": true,
    "@aws-cdk/aws-ec2:launchTemplateDefaultUserData": true,
    "@aws-cdk/aws-secretsmanager:useAttachedSecretResourcePolicyForSecretTargetAttachments": true,
    "@aws-cdk/aws-redshift:columnId": true,
    "@aws-cdk/aws-stepfunctions-tasks:enableEmrServicePolicyV2": true,
    "@aws-cdk/aws-ec2:restrictDefaultSecurityGroup": true,
    "@aws-cdk/aws-apigateway:requestValidatorUniqueId": true,
    "@aws-cdk/aws-kms:aliasNameRef": true,
    "@aws-cdk/aws-autoscaling:generateLaunchTemplateInsteadOfLaunchConfig": true,
    "@aws-cdk/core:includePrefixInUniqueNameGeneration": true,
    "@aws-cdk/aws-efs:denyAnonymousAccess": true,
    "@aws-cdk/aws-opensearchservice:enableOpensearchMultiAzWithStandby": true,
    "@aws-cdk/aws-lambda-nodejs:useLatestRuntimeVersion": true,
    "@aws-cdk/aws-efs:mountTargetOrderInsensitiveLogicalId": true,
    "@aws-cdk/aws-rds:auroraClusterChangeScopeOfInstanceParameterGroupWithEachParameters": true,
    "@aws-cdk/aws-appsync:useArnForSourceApiAssociationIdentifier": true,
    "@aws-cdk/aws-rds:preventRenderingDeprecatedCredentials": true,
    "@aws-cdk/aws-codepipeline-actions:useNewDefaultBranchForCodeCommitSource": true,
    "@aws-cdk/aws-cloudwatch-actions:changeLambdaPermissionLogicalIdForLambdaAction": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeysDefaultValueToFalse": true,
    "@aws-cdk/aws-codepipeline:defaultPipelineTypeToV2": true,
    "@aws-cdk/aws-kms:reduceCrossAccountRegionPolicyScope": true,
    "@aws-cdk/aws-eks:nodegroupNameAttribute": true,
    "@aws-cdk/aws-ec2:ebsDefaultGp3Volume": true,
    "@aws-cdk/aws-ecs:removeDefaultDeploymentAlarm": true,
    "@aws-cdk/custom-resources:logApiResponseDataPropertyTrueDefault": false
  }
}
",
  "src/main.ts": "import { ApplicationStage } from './stages/application-stage.js';
import { App } from ':proj/common-constructs';

const app = new App();

// Use this to deploy your own sandbox environment (assumes your CLI credentials)
new ApplicationStage(app, 'proj-custom-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
});

app.synth();
",
  "src/stacks/application-stack.ts": "import { Stack, StackProps } from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends Stack {
  constructor(scope: Construct, id: string, props?: StackProps) {
    super(scope, id, props);

    // The code that defines your stack goes here
  }
}
",
  "src/stages/application-stage.ts": "import { Stage, StageProps } from 'aws-cdk-lib';
import { Construct } from 'constructs';
import { ApplicationStack } from '../stacks/application-stack.js';

/**
 * Defines a collection of CDK Stacks which make up your application
 */
export class ApplicationStage extends Stage {
  constructor(scope: Construct, id: string, props?: StageProps) {
    super(scope, id, props);

    new ApplicationStack(this, 'Application', {
      crossRegionReferences: true,
    });
  }
}
",
}
`;

exports[`infra generator > should handle custom project names correctly > custom-name-project-config 1`] = `
{
  "$schema": "../../node_modules/nx/schemas/project-schema.json",
  "metadata": {
    "generator": "ts#infra",
  },
  "name": "@proj/custom-infra",
  "projectType": "application",
  "root": "packages/custom-infra",
  "sourceRoot": "packages/custom-infra/src",
  "tags": [],
  "targets": {
    "bootstrap": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cdk bootstrap",
        "cwd": "{projectRoot}",
      },
    },
    "build": {
      "dependsOn": [
        "lint",
        "compile",
        "test",
        "synth",
        "checkov",
      ],
    },
    "cdk": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cdk",
        "cwd": "{projectRoot}",
      },
    },
    "checkov": {
      "cache": true,
      "dependsOn": [
        "synth",
      ],
      "executor": "nx:run-commands",
      "inputs": [
        "{workspaceRoot}/dist/{projectRoot}/cdk.out",
      ],
      "options": {
        "command": "uvx checkov==3.2.505 --config-file {projectRoot}/checkov.yml --directory dist/{projectRoot}/cdk.out --framework cloudformation",
      },
      "outputs": [
        "{workspaceRoot}/dist/{projectRoot}/checkov",
      ],
    },
    "compile": {
      "executor": "nx:run-commands",
      "options": {
        "command": "tsc --build tsconfig.lib.json",
        "cwd": "{projectRoot}",
      },
      "outputs": [
        "{workspaceRoot}/dist/{projectRoot}/tsc",
      ],
    },
    "deploy": {
      "dependsOn": [
        "^build",
        "compile",
      ],
      "executor": "nx:run-commands",
      "options": {
        "command": "cdk deploy --require-approval=never",
        "cwd": "{projectRoot}",
      },
    },
    "deploy-ci": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cdk deploy --require-approval=never --app ../../dist/{projectRoot}/cdk.out",
        "cwd": "{projectRoot}",
      },
    },
    "destroy": {
      "dependsOn": [
        "^build",
        "compile",
      ],
      "executor": "nx:run-commands",
      "options": {
        "command": "cdk destroy --require-approval=never",
        "cwd": "{projectRoot}",
      },
    },
    "destroy-ci": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cdk destroy --require-approval=never --app ../../dist/{projectRoot}/cdk.out",
        "cwd": "{projectRoot}",
      },
    },
    "lint": {
      "cache": true,
      "configurations": {
        "fix": {
          "fix": true,
        },
        "skip-lint": {
          "force": true,
        },
      },
      "executor": "@nx/eslint:lint",
      "inputs": [
        "eslint",
      ],
    },
    "synth": {
      "cache": true,
      "dependsOn": [
        "^build",
        "compile",
      ],
      "executor": "nx:run-commands",
      "inputs": [
        "default",
      ],
      "options": {
        "command": "cdk synth",
        "cwd": "{projectRoot}",
      },
      "outputs": [
        "{workspaceRoot}/dist/{projectRoot}/cdk.out",
      ],
    },
    "test": {
      "executor": "@nx/vitest:test",
      "options": {
        "reportsDirectory": "{workspaceRoot}/coverage/{projectRoot}",
      },
      "outputs": [
        "{options.reportsDirectory}",
      ],
    },
  },
}
`;

exports[`infra generator > with enableStageConfig > should snapshot generated infra-config src directory > packages/common/infra-config/src/index.ts 1`] = `
"export * from './stages.types.js';
export { default } from './stages.config.js';
export { resolveStage } from './resolve-stage.js';
"
`;

exports[`infra generator > with enableStageConfig > should snapshot generated infra-config src directory > packages/common/infra-config/src/resolve-stage.ts 1`] = `
"import type { StageConfig, StagesConfig } from './stages.types.js';
import stagesConfig from './stages.config.js';

// Widen the narrow \`as const\` type to StagesConfig for dynamic key access
const config: StagesConfig = stagesConfig;

/**
 * Resolves stage config for a given project and stage name.
 * Project-specific fields take priority over shared ones.
 *
 * @param projectPath - Project path relative to workspace root (e.g., 'packages/infra')
 * @param stageName - CDK stage name (e.g., 'my-app-dev')
 * @returns Merged StageConfig or undefined if no config exists for this stage
 */
export function resolveStage(
  projectPath: string,
  stageName: string,
): StageConfig | undefined {
  const shared = config.shared?.stages?.[stageName];
  const project = config.projects?.[projectPath]?.stages?.[stageName];
  if (!shared && !project) return undefined;
  return { ...shared, ...project } as StageConfig;
}
"
`;

exports[`infra generator > with enableStageConfig > should snapshot generated infra-config src directory > packages/common/infra-config/src/stages.config.ts 1`] = `
"/**
 * Stage configuration for CDK deployments.
 *
 * This file maps CDK stage names to their deployment settings. When you run
 * \`npx nx run <project>:deploy <stage-name>/*\`, the infra-deploy script
 * automatically resolves and applies the correct credentials.
 *
 * Project keys are the project path relative to the workspace root
 * (e.g., 'packages/infra').
 *
 * Stage names must match the CDK stage identifiers defined in your main.ts —
 * the first argument to \`new ApplicationStage(app, '<stage-name>', ...)\`.
 * For example, if main.ts has \`new ApplicationStage(app, 'my-app-dev', ...)\`
 * then the stage name here is 'my-app-dev'.
 *
 * We recommend committing this file so the team shares a single source of truth.
 * If it contains personal profile names, you can add it to .gitignore instead.
 */
import type { StagesConfig } from './stages.types.js';

export default {
  projects: {
    // Example: map stages for a specific infra project
    // 'packages/infra': {
    //   stages: {
    //     'my-app-dev': {
    //       credentials: { type: 'profile', profile: 'dev-account' },
    //       region: 'us-east-1',
    //       // account is optional — if omitted, CDK infers from the profile
    //     },
    //     'my-app-prod': {
    //       credentials: { type: 'assumeRole', assumeRole: 'arn:aws:iam::123456789012:role/DeployRole' },
    //       region: 'us-west-2',
    //       account: '123456789012',
    //     },
    //   },
    // },
  },
  shared: {
    stages: {
      // Example: shared sandbox stage available to all projects
      // 'sandbox': {
      //   credentials: { type: 'profile', profile: 'sandbox-profile' },
      //   region: 'us-east-1',
      // },
    },
  },
} as const satisfies StagesConfig;
"
`;

exports[`infra generator > with enableStageConfig > should snapshot generated infra-config src directory > packages/common/infra-config/src/stages.types.ts 1`] = `
"/**
 * Type definitions for stage and project configuration.
 *
 * These types are used by both stages.config.ts and the infra-deploy/
 * infra-destroy scripts. They live in a shared package so any
 * project in the workspace can import them.
 */

/** Use an AWS CLI profile from ~/.aws/config */
export type ProfileCredentials = {
  type: 'profile';
  /** AWS CLI profile name */
  profile: string;
};

/** Assume an IAM role via STS, optionally using a profile as the source credentials */
export type AssumeRoleCredentials = {
  type: 'assumeRole';
  /** IAM Role ARN to assume */
  assumeRole: string;
  /** Optional: AWS CLI profile to use as source credentials for the AssumeRole call */
  profile?: string;
  /** Optional: External ID required by the role's trust policy */
  externalId?: string;
  /** Optional: Session duration in seconds (default: 3600). Increase for long deployments. */
  sessionDuration?: number;
};

/**
 * Credentials for deploying to a specific CDK stage.
 * The \`type\` field determines which credential strategy is used.
 */
export type StageCredentials = ProfileCredentials | AssumeRoleCredentials;

/**
 * Configuration for a single CDK stage.
 * Includes credentials, region, and optionally account.
 */
export type StageConfig = {
  /** How to authenticate when deploying this stage */
  credentials: StageCredentials;
  /** AWS region for this stage (e.g., 'us-east-1') */
  region: string;
  /** AWS account ID. If omitted, CDK infers it from the active credentials. */
  account?: string;
};

/**
 * Configuration for a single infrastructure project.
 * The key in the parent map is the project path relative to workspace root
 * (e.g., 'packages/infra').
 */
export type ProjectConfig = {
  /** Map of CDK stage names to their configuration */
  stages: { [stageName: string]: StageConfig };
};

/** Top-level configuration mapping projects and stages to their settings. */
export type StagesConfig = {
  /** Project-specific config. Key is the project path relative to workspace root. */
  projects?: { [projectPath: string]: ProjectConfig };
  /** Shared stage config available to all projects. */
  shared?: {
    stages: { [stageName: string]: StageConfig };
  };
};
"
`;

exports[`infra generator > with enableStageConfig > should snapshot generated scripts src directory > packages/common/scripts/src/index.ts 1`] = `
"// Scripts (infra-deploy, infra-destroy) are the public interface of this package.
"
`;

exports[`infra generator > with enableStageConfig > should snapshot generated scripts src directory > packages/common/scripts/src/infra-deploy.ts 1`] = `
"import { run } from './stage-credentials/run.js';
run('deploy');
"
`;

exports[`infra generator > with enableStageConfig > should snapshot generated scripts src directory > packages/common/scripts/src/infra-destroy.ts 1`] = `
"import { run } from './stage-credentials/run.js';
run('destroy');
"
`;

exports[`infra generator > with enableStageConfig > should snapshot generated scripts src directory > packages/common/scripts/src/stage-credentials/cdk-command.ts 1`] = `
"/**
 * Builds the CDK command as an array of arguments for spawnSync.
 *
 * Defaults to --require-approval=never (standard for local dev deploys).
 * If the user explicitly passes --require-approval with any value, we
 * respect their choice and don't add the default.
 */
export function buildCdkCommand(
  action: string,
  remainingArgs: string[],
): string[] {
  const hasRequireApproval = remainingArgs.some(
    (a) => a === '--require-approval' || a.startsWith('--require-approval='),
  );
  return hasRequireApproval
    ? ['cdk', action, ...remainingArgs]
    : ['cdk', action, '--require-approval=never', ...remainingArgs];
}
"
`;

exports[`infra generator > with enableStageConfig > should snapshot generated scripts src directory > packages/common/scripts/src/stage-credentials/credentials.ts 1`] = `
"import type { StageCredentials, StagesConfig } from ':proj/common-infra-config';

/**
 * Looks up credentials for a given project + stage combination.
 *
 * Lookup order:
 *   1. Project-specific: config.projects[projectPath].stages[stageName].credentials
 *   2. Shared:           config.shared.stages[stageName].credentials
 *   3. No match:         returns undefined — caller falls back to env vars
 */
export function lookupCredentials(
  config: StagesConfig | undefined,
  projectPath: string,
  stageName: string,
): { credentials: StageCredentials | undefined; source: string } {
  const projectCreds =
    config?.projects?.[projectPath]?.stages?.[stageName]?.credentials;
  if (projectCreds) {
    return { credentials: projectCreds, source: 'project-specific' };
  }

  const sharedCreds = config?.shared?.stages?.[stageName]?.credentials;
  if (sharedCreds) {
    return { credentials: sharedCreds, source: 'shared' };
  }

  return { credentials: undefined, source: 'environment fallback' };
}

/**
 * Builds a child process environment with the resolved credentials overlaid.
 * Never modifies process.env — returns a new object.
 */
export async function buildChildEnv(
  credentials: StageCredentials,
  projectPath: string,
): Promise<Record<string, string | undefined>> {
  const env = { ...process.env };

  switch (credentials.type) {
    case 'profile': {
      env.AWS_PROFILE = credentials.profile;
      break;
    }
    case 'assumeRole': {
      let STSClient: typeof import('@aws-sdk/client-sts').STSClient;
      let AssumeRoleCommand: typeof import('@aws-sdk/client-sts').AssumeRoleCommand;
      try {
        ({ STSClient, AssumeRoleCommand } =
          await import('@aws-sdk/client-sts'));
      } catch {
        console.error(
          '[infra-deploy] Error: @aws-sdk/client-sts is required for assumeRole credentials but is not installed.',
        );
        console.error('[infra-deploy] Please install @aws-sdk/client-sts');
        process.exit(1);
      }

      // If a source profile is specified, configure the STS client to use it
      const stsClientOptions: Record<string, unknown> = {};
      if (credentials.profile) {
        const { fromIni } = await import('@aws-sdk/credential-providers');
        stsClientOptions.credentials = fromIni({
          profile: credentials.profile,
        });
      }

      const response = await new STSClient(stsClientOptions).send(
        new AssumeRoleCommand({
          RoleArn: credentials.assumeRole,
          RoleSessionName: \`infra-deploy-\${projectPath.replace(/\\//g, '-')}\`,
          ...(credentials.externalId
            ? { ExternalId: credentials.externalId }
            : {}),
          ...(credentials.sessionDuration
            ? { DurationSeconds: credentials.sessionDuration }
            : {}),
        }),
      );

      env.AWS_ACCESS_KEY_ID = response.Credentials?.AccessKeyId;
      env.AWS_SECRET_ACCESS_KEY = response.Credentials?.SecretAccessKey;
      env.AWS_SESSION_TOKEN = response.Credentials?.SessionToken;
      delete env.AWS_PROFILE;
      break;
    }
  }

  return env;
}

/** Human-readable description of credentials for logging */
export function describeCredentials(creds: StageCredentials): string {
  return creds.type === 'profile'
    ? \`profile '\${creds.profile}'\`
    : \`role '\${creds.assumeRole}'\`;
}
"
`;

exports[`infra generator > with enableStageConfig > should snapshot generated scripts src directory > packages/common/scripts/src/stage-credentials/run.ts 1`] = `
"import { spawnSync } from 'child_process';
import stagesConfig from ':proj/common-infra-config';
import { parseStageName } from './stage-parser.js';
import {
  lookupCredentials,
  buildChildEnv,
  describeCredentials,
} from './credentials.js';
import { buildCdkCommand } from './cdk-command.js';

const log = (msg: string) => console.error(\`[infra-deploy] \${msg}\`);

export async function run(action: 'deploy' | 'destroy'): Promise<void> {
  const [projectPath, ...remainingArgs] = process.argv.slice(2);

  if (!projectPath) {
    log(\`Usage: infra-\${action} <project-path> [stage/*] [cdk-args...]\`);
    process.exit(1);
  }

  const stageName = parseStageName(remainingArgs[0]);
  let childEnv: Record<string, string | undefined> = { ...process.env };

  if (stageName) {
    const { credentials, source } = lookupCredentials(
      stagesConfig,
      projectPath,
      stageName,
    );

    if (credentials) {
      log(
        \`Using \${describeCredentials(credentials)} for '\${stageName}' (\${source})\`,
      );
      childEnv = await buildChildEnv(credentials, projectPath);
    } else {
      log(\`No credentials for '\${stageName}' — using environment\`);
    }
  } else {
    log('No stage specified — using environment credentials');
  }

  // Run CDK from the project directory so it finds cdk.json
  const cmd = buildCdkCommand(action, remainingArgs);
  const { status } = spawnSync(cmd[0], cmd.slice(1), {
    stdio: 'inherit',
    env: childEnv,
    cwd: projectPath,
  });

  process.exit(status ?? 1);
}
"
`;

exports[`infra generator > with enableStageConfig > should snapshot generated scripts src directory > packages/common/scripts/src/stage-credentials/stage-parser.ts 1`] = `
"/**
 * Extracts the CDK stage name from the first positional argument.
 *
 * Examples:
 *   parseStageName('my-app-dev/*')  → 'my-app-dev'
 *   parseStageName('my-app-dev')    → 'my-app-dev'
 *   parseStageName('--verbose')     → undefined (flag, not a stage)
 *   parseStageName(undefined)       → undefined
 */
export function parseStageName(
  firstArg: string | undefined,
): string | undefined {
  if (!firstArg || firstArg.startsWith('-')) return undefined;
  return firstArg.includes('/') ? firstArg.split('/')[0] : firstArg;
}
"
`;
