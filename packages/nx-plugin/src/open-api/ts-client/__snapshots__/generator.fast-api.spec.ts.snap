// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`openApiTsClientGenerator - FastAPI > should generate valid TypeScript for FastAPI echo endpoint with validation errors 1`] = `
"export type EchoOutput = {
  message: string;
};
export type EchoRequestQueryParameters = {
  message: string;
};
export type HTTPValidationError = {
  detail?: Array<ValidationError>;
};
export type InternalServerErrorDetails = {
  detail: string;
};
export type LocationItem = string | number;
export type ValidationError = {
  loc: Array<LocationItem>;
  msg: string;
  type: string;
};

export type EchoRequest = EchoRequestQueryParameters;
export type Echo422Error = {
  status: 422;
  error: HTTPValidationError;
};
export type Echo500Error = {
  status: 500;
  error: InternalServerErrorDetails;
};
export type EchoError = Echo422Error | Echo500Error;
"
`;

exports[`openApiTsClientGenerator - FastAPI > should generate valid TypeScript for FastAPI echo endpoint with validation errors 2`] = `
"import type {
  EchoOutput,
  EchoRequestQueryParameters,
  HTTPValidationError,
  InternalServerErrorDetails,
  LocationItem,
  ValidationError,
  EchoRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static EchoOutput = {
    toJson: (model: EchoOutput): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.message === undefined
          ? {}
          : {
              message: model.message,
            }),
      };
    },
    fromJson: (json: any): EchoOutput => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        message: json['message'],
      };
    },
  };

  public static EchoRequestQueryParameters = {
    toJson: (model: EchoRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.message === undefined
          ? {}
          : {
              message: model.message,
            }),
      };
    },
    fromJson: (json: any): EchoRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        message: json['message'],
      };
    },
  };

  public static HTTPValidationError = {
    toJson: (model: HTTPValidationError): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.detail === undefined
          ? {}
          : {
              detail: model.detail.map($IO.ValidationError.toJson),
            }),
      };
    },
    fromJson: (json: any): HTTPValidationError => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['detail'] === undefined
          ? {}
          : {
              detail: (json['detail'] as Array<any>).map(
                $IO.ValidationError.fromJson,
              ),
            }),
      };
    },
  };

  public static InternalServerErrorDetails = {
    toJson: (model: InternalServerErrorDetails): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.detail === undefined
          ? {}
          : {
              detail: model.detail,
            }),
      };
    },
    fromJson: (json: any): InternalServerErrorDetails => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        detail: json['detail'],
      };
    },
  };

  public static LocationItem = {
    toJson: (model: LocationItem): any => {
      if (model === undefined || model === null) {
        return model;
      }
      if (typeof model === 'string') {
        return model;
      }
      if (typeof model === 'number') {
        return model;
      }
      return model;
    },
    fromJson: (json: any): LocationItem => {
      if (json === undefined || json === null) {
        return json;
      }
      if (typeof json === 'string') {
        return json;
      }
      if (typeof json === 'number') {
        return json;
      }
      return json;
    },
  };

  public static ValidationError = {
    toJson: (model: ValidationError): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.loc === undefined
          ? {}
          : {
              loc: model.loc.map((item0) => item0),
            }),
        ...(model.msg === undefined
          ? {}
          : {
              msg: model.msg,
            }),
        ...(model.type === undefined
          ? {}
          : {
              type: model.type,
            }),
      };
    },
    fromJson: (json: any): ValidationError => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        loc: (json['loc'] as Array<any>).map((item0) => item0),
        msg: json['msg'],
        type: json['type'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.echo = this.echo.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async echo(input: EchoRequest): Promise<EchoOutput> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } =
      $IO.EchoRequestQueryParameters.toJson(input);
    const headerParameters: { [key: string]: any } = {};
    const collectionFormats = {
      message: 'multi',
    } as const;

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/echo', pathParameters, queryParameters, collectionFormats),
      {
        headers: this.$headers(headerParameters, collectionFormats),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.EchoOutput.fromJson(await response.json());
    }
    if (response.status === 422) {
      throw {
        status: response.status,
        error: $IO.HTTPValidationError.fromJson(await response.json()),
      };
    }
    if (response.status === 500) {
      throw {
        status: response.status,
        error: $IO.InternalServerErrorDetails.fromJson(await response.json()),
      };
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - FastAPI > should handle FastAPI validation error schemas with anyOf types 1`] = `
"export type LocationItem = string | number;
export type TestValidation422Response = {
  detail?: Array<ValidationError>;
};
export type TestValidationRequestContent = {
  value: number;
};
export type ValidationError = {
  loc: Array<LocationItem>;
  msg: string;
  type: string;
};

export type TestValidationRequest = TestValidationRequestContent | undefined;
export type TestValidation422Error = {
  status: 422;
  error: TestValidation422Response;
};
export type TestValidationError = TestValidation422Error;
"
`;

exports[`openApiTsClientGenerator - FastAPI > should handle FastAPI validation error schemas with anyOf types 2`] = `
"import type {
  LocationItem,
  TestValidation422Response,
  TestValidationRequestContent,
  ValidationError,
  TestValidationRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static LocationItem = {
    toJson: (model: LocationItem): any => {
      if (model === undefined || model === null) {
        return model;
      }
      if (typeof model === 'string') {
        return model;
      }
      if (typeof model === 'number') {
        return model;
      }
      return model;
    },
    fromJson: (json: any): LocationItem => {
      if (json === undefined || json === null) {
        return json;
      }
      if (typeof json === 'string') {
        return json;
      }
      if (typeof json === 'number') {
        return json;
      }
      return json;
    },
  };

  public static TestValidation422Response = {
    toJson: (model: TestValidation422Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.detail === undefined
          ? {}
          : {
              detail: model.detail.map($IO.ValidationError.toJson),
            }),
      };
    },
    fromJson: (json: any): TestValidation422Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['detail'] === undefined
          ? {}
          : {
              detail: (json['detail'] as Array<any>).map(
                $IO.ValidationError.fromJson,
              ),
            }),
      };
    },
  };

  public static TestValidationRequestContent = {
    toJson: (model: TestValidationRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.value === undefined
          ? {}
          : {
              value: model.value,
            }),
      };
    },
    fromJson: (json: any): TestValidationRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        value: json['value'],
      };
    },
  };

  public static ValidationError = {
    toJson: (model: ValidationError): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.loc === undefined
          ? {}
          : {
              loc: model.loc.map((item0) => item0),
            }),
        ...(model.msg === undefined
          ? {}
          : {
              msg: model.msg,
            }),
        ...(model.type === undefined
          ? {}
          : {
              type: model.type,
            }),
      };
    },
    fromJson: (json: any): ValidationError => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        loc: (json['loc'] as Array<any>).map((item0) => item0),
        msg: json['msg'],
        type: json['type'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.testValidation = this.testValidation.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async testValidation(input?: TestValidationRequest): Promise<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.TestValidationRequestContent.toJson(input))
          : String($IO.TestValidationRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    if (response.status === 422) {
      throw {
        status: response.status,
        error: $IO.TestValidation422Response.fromJson(await response.json()),
      };
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - FastAPI > should handle schemas with hyphens as generated by fastapi >=0.119.0 1`] = `
"export type ContentBlockInput = {
  image?: ContentBlockInputImage;
  text?: Text;
  toolResult?: ContentBlockInputToolResult;
  toolUse?: ContentBlockInputToolUse;
};
export type ContentBlockInputImage = ImageContent | null;
export type ContentBlockInputToolResult = ToolResultInput | null;
export type ContentBlockInputToolUse = ToolUse | null;
export type ContentBlockOutput = {
  image?: ContentBlockOutputImage;
  text?: Text1;
  toolResult?: ContentBlockOutputToolResult;
  toolUse?: ContentBlockOutputToolUse;
};
export type ContentBlockOutputImage = ImageContent | null;
export type ContentBlockOutputToolResult = ToolResultOutput | null;
export type ContentBlockOutputToolUse = ToolUse | null;
export type HTTPValidationError = {
  detail?: Array<ValidationError>;
};
export type ImageContent = {
  format: ImageFormat;
  source: ImageSource;
};
/**
 * Supported image formats.
 */
export type ImageFormat = 'png' | 'jpeg' | 'gif' | 'webp';
export type ImageSource = {
  bytes: Blob;
};
export type InternalServerErrorDetails = {
  detail: string;
};
export type InvokeInput = {
  message: string;
  sessionId: string;
};
export type Json = unknown | null;
export type Json1 = unknown | null;
export type ListMessagesOutput = {
  messages: Array<MessageOutput>;
};
export type ListMessagesRequestQueryParameters = {
  sessionId: string;
};
export type LocationItem = string | number;
export type MessageInput = {
  content: Array<ContentBlockInput>;
  role: Role;
};
export type MessageOutput = {
  content: Array<ContentBlockOutput>;
  role: Role;
};
/**
 * Role of a message sender.

- USER: Messages from the user to the assistant
- ASSISTANT: Messages from the assistant to the user
 */
export type Role = 'user' | 'assistant';
export type Text = string | null;
export type Text1 = string | null;
export type Text2 = string | null;
export type Text3 = string | null;
export type ToolResultContentInput = {
  image?: ToolResultContentInputImage;
  json?: Json;
  text?: Text2;
};
export type ToolResultContentInputImage = ImageContent | null;
/**
 * Content returned by a tool execution.

Attributes:
    image: Image content returned by the tool.
    json: JSON-serializable data returned by the tool.
    text: Text content returned by the tool.
 */
export type ToolResultContentOutput = {
  image?: ToolResultContentOutputImage;
  json?: Json1;
  text?: Text3;
};
export type ToolResultContentOutputImage = ImageContent | null;
export type ToolResultInput = {
  content: Array<ToolResultContentInput>;
  status: ToolResultStatus;
  toolUseId: string;
};
export type ToolResultOutput = {
  content: Array<ToolResultContentOutput>;
  status: ToolResultStatus;
  toolUseId: string;
};
/**
 * Status of a tool execution result.
 */
export type ToolResultStatus = 'success' | 'error';
export type ToolUse = {
  input: unknown;
  name: string;
  toolUseId: string;
};
export type ValidationError = {
  loc: Array<LocationItem>;
  msg: string;
  type: string;
};

export type InvokeRequest = InvokeInput;
export type Invoke422Error = {
  status: 422;
  error: HTTPValidationError;
};
export type Invoke500Error = {
  status: 500;
  error: InternalServerErrorDetails;
};
export type InvokeError = Invoke422Error | Invoke500Error;

export type ListMessagesRequest = ListMessagesRequestQueryParameters;
export type ListMessages422Error = {
  status: 422;
  error: HTTPValidationError;
};
export type ListMessages500Error = {
  status: 500;
  error: InternalServerErrorDetails;
};
export type ListMessagesError = ListMessages422Error | ListMessages500Error;
export type Ping500Error = {
  status: 500;
  error: InternalServerErrorDetails;
};
export type PingError = Ping500Error;
"
`;

exports[`openApiTsClientGenerator - FastAPI > should handle schemas with hyphens as generated by fastapi >=0.119.0 2`] = `
"import type {
  ContentBlockInput,
  ContentBlockInputImage,
  ContentBlockInputToolResult,
  ContentBlockInputToolUse,
  ContentBlockOutput,
  ContentBlockOutputImage,
  ContentBlockOutputToolResult,
  ContentBlockOutputToolUse,
  HTTPValidationError,
  ImageContent,
  ImageSource,
  InternalServerErrorDetails,
  InvokeInput,
  Json,
  Json1,
  ListMessagesOutput,
  ListMessagesRequestQueryParameters,
  LocationItem,
  MessageInput,
  MessageOutput,
  Text,
  Text1,
  Text2,
  Text3,
  ToolResultContentInput,
  ToolResultContentInputImage,
  ToolResultContentOutput,
  ToolResultContentOutputImage,
  ToolResultInput,
  ToolResultOutput,
  ToolUse,
  ValidationError,
  InvokeRequest,
  ListMessagesRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static ContentBlockInput = {
    toJson: (model: ContentBlockInput): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.image === undefined
          ? {}
          : {
              image: $IO.ContentBlockInputImage.toJson(model.image),
            }),
        ...(model.text === undefined
          ? {}
          : {
              text: $IO.Text.toJson(model.text),
            }),
        ...(model.toolResult === undefined
          ? {}
          : {
              toolResult: $IO.ContentBlockInputToolResult.toJson(
                model.toolResult,
              ),
            }),
        ...(model.toolUse === undefined
          ? {}
          : {
              toolUse: $IO.ContentBlockInputToolUse.toJson(model.toolUse),
            }),
      };
    },
    fromJson: (json: any): ContentBlockInput => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['image'] === undefined
          ? {}
          : {
              image: $IO.ContentBlockInputImage.fromJson(json['image']),
            }),
        ...(json['text'] === undefined
          ? {}
          : {
              text: $IO.Text.fromJson(json['text']),
            }),
        ...(json['toolResult'] === undefined
          ? {}
          : {
              toolResult: $IO.ContentBlockInputToolResult.fromJson(
                json['toolResult'],
              ),
            }),
        ...(json['toolUse'] === undefined
          ? {}
          : {
              toolUse: $IO.ContentBlockInputToolUse.fromJson(json['toolUse']),
            }),
      };
    },
  };

  public static ContentBlockInputImage = {
    toJson: (model: ContentBlockInputImage): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.ImageContent.toJson(model as ImageContent),
      };
    },
    fromJson: (json: any): ContentBlockInputImage => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.ImageContent.fromJson(json),
      };
    },
  };

  public static ContentBlockInputToolResult = {
    toJson: (model: ContentBlockInputToolResult): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.ToolResultInput.toJson(model as ToolResultInput),
      };
    },
    fromJson: (json: any): ContentBlockInputToolResult => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.ToolResultInput.fromJson(json),
      };
    },
  };

  public static ContentBlockInputToolUse = {
    toJson: (model: ContentBlockInputToolUse): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.ToolUse.toJson(model as ToolUse),
      };
    },
    fromJson: (json: any): ContentBlockInputToolUse => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.ToolUse.fromJson(json),
      };
    },
  };

  public static ContentBlockOutput = {
    toJson: (model: ContentBlockOutput): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.image === undefined
          ? {}
          : {
              image: $IO.ContentBlockOutputImage.toJson(model.image),
            }),
        ...(model.text === undefined
          ? {}
          : {
              text: $IO.Text1.toJson(model.text),
            }),
        ...(model.toolResult === undefined
          ? {}
          : {
              toolResult: $IO.ContentBlockOutputToolResult.toJson(
                model.toolResult,
              ),
            }),
        ...(model.toolUse === undefined
          ? {}
          : {
              toolUse: $IO.ContentBlockOutputToolUse.toJson(model.toolUse),
            }),
      };
    },
    fromJson: (json: any): ContentBlockOutput => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['image'] === undefined
          ? {}
          : {
              image: $IO.ContentBlockOutputImage.fromJson(json['image']),
            }),
        ...(json['text'] === undefined
          ? {}
          : {
              text: $IO.Text1.fromJson(json['text']),
            }),
        ...(json['toolResult'] === undefined
          ? {}
          : {
              toolResult: $IO.ContentBlockOutputToolResult.fromJson(
                json['toolResult'],
              ),
            }),
        ...(json['toolUse'] === undefined
          ? {}
          : {
              toolUse: $IO.ContentBlockOutputToolUse.fromJson(json['toolUse']),
            }),
      };
    },
  };

  public static ContentBlockOutputImage = {
    toJson: (model: ContentBlockOutputImage): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.ImageContent.toJson(model as ImageContent),
      };
    },
    fromJson: (json: any): ContentBlockOutputImage => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.ImageContent.fromJson(json),
      };
    },
  };

  public static ContentBlockOutputToolResult = {
    toJson: (model: ContentBlockOutputToolResult): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.ToolResultOutput.toJson(model as ToolResultOutput),
      };
    },
    fromJson: (json: any): ContentBlockOutputToolResult => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.ToolResultOutput.fromJson(json),
      };
    },
  };

  public static ContentBlockOutputToolUse = {
    toJson: (model: ContentBlockOutputToolUse): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.ToolUse.toJson(model as ToolUse),
      };
    },
    fromJson: (json: any): ContentBlockOutputToolUse => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.ToolUse.fromJson(json),
      };
    },
  };

  public static HTTPValidationError = {
    toJson: (model: HTTPValidationError): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.detail === undefined
          ? {}
          : {
              detail: model.detail.map($IO.ValidationError.toJson),
            }),
      };
    },
    fromJson: (json: any): HTTPValidationError => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['detail'] === undefined
          ? {}
          : {
              detail: (json['detail'] as Array<any>).map(
                $IO.ValidationError.fromJson,
              ),
            }),
      };
    },
  };

  public static ImageContent = {
    toJson: (model: ImageContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.format === undefined
          ? {}
          : {
              format: model.format,
            }),
        ...(model.source === undefined
          ? {}
          : {
              source: $IO.ImageSource.toJson(model.source),
            }),
      };
    },
    fromJson: (json: any): ImageContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        format: json['format'],
        source: $IO.ImageSource.fromJson(json['source']),
      };
    },
  };

  public static ImageSource = {
    toJson: (model: ImageSource): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.bytes === undefined
          ? {}
          : {
              bytes: model.bytes,
            }),
      };
    },
    fromJson: (json: any): ImageSource => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        bytes: json['bytes'],
      };
    },
  };

  public static InternalServerErrorDetails = {
    toJson: (model: InternalServerErrorDetails): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.detail === undefined
          ? {}
          : {
              detail: model.detail,
            }),
      };
    },
    fromJson: (json: any): InternalServerErrorDetails => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        detail: json['detail'],
      };
    },
  };

  public static InvokeInput = {
    toJson: (model: InvokeInput): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.message === undefined
          ? {}
          : {
              message: model.message,
            }),
        ...(model.sessionId === undefined
          ? {}
          : {
              session_id: model.sessionId,
            }),
      };
    },
    fromJson: (json: any): InvokeInput => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        message: json['message'],
        sessionId: json['session_id'],
      };
    },
  };

  public static Json = {
    toJson: (model: Json): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return model;
    },
    fromJson: (json: any): Json => {
      if (json === undefined || json === null) {
        return json;
      }
      return json;
    },
  };

  public static Json1 = {
    toJson: (model: Json1): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return model;
    },
    fromJson: (json: any): Json1 => {
      if (json === undefined || json === null) {
        return json;
      }
      return json;
    },
  };

  public static ListMessagesOutput = {
    toJson: (model: ListMessagesOutput): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.messages === undefined
          ? {}
          : {
              messages: model.messages.map($IO.MessageOutput.toJson),
            }),
      };
    },
    fromJson: (json: any): ListMessagesOutput => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        messages: (json['messages'] as Array<any>).map(
          $IO.MessageOutput.fromJson,
        ),
      };
    },
  };

  public static ListMessagesRequestQueryParameters = {
    toJson: (model: ListMessagesRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.sessionId === undefined
          ? {}
          : {
              session_id: model.sessionId,
            }),
      };
    },
    fromJson: (json: any): ListMessagesRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        sessionId: json['session_id'],
      };
    },
  };

  public static LocationItem = {
    toJson: (model: LocationItem): any => {
      if (model === undefined || model === null) {
        return model;
      }
      if (typeof model === 'string') {
        return model;
      }
      if (typeof model === 'number') {
        return model;
      }
      return model;
    },
    fromJson: (json: any): LocationItem => {
      if (json === undefined || json === null) {
        return json;
      }
      if (typeof json === 'string') {
        return json;
      }
      if (typeof json === 'number') {
        return json;
      }
      return json;
    },
  };

  public static MessageInput = {
    toJson: (model: MessageInput): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.content === undefined
          ? {}
          : {
              content: model.content.map($IO.ContentBlockInput.toJson),
            }),
        ...(model.role === undefined
          ? {}
          : {
              role: model.role,
            }),
      };
    },
    fromJson: (json: any): MessageInput => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        content: (json['content'] as Array<any>).map(
          $IO.ContentBlockInput.fromJson,
        ),
        role: json['role'],
      };
    },
  };

  public static MessageOutput = {
    toJson: (model: MessageOutput): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.content === undefined
          ? {}
          : {
              content: model.content.map($IO.ContentBlockOutput.toJson),
            }),
        ...(model.role === undefined
          ? {}
          : {
              role: model.role,
            }),
      };
    },
    fromJson: (json: any): MessageOutput => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        content: (json['content'] as Array<any>).map(
          $IO.ContentBlockOutput.fromJson,
        ),
        role: json['role'],
      };
    },
  };

  public static Text = {
    toJson: (model: Text): any => {
      if (model === undefined || model === null) {
        return model;
      }
      if (typeof model === 'string') {
        return model;
      }
      return model;
    },
    fromJson: (json: any): Text => {
      if (json === undefined || json === null) {
        return json;
      }
      if (typeof json === 'string') {
        return json;
      }
      return json;
    },
  };

  public static Text1 = {
    toJson: (model: Text1): any => {
      if (model === undefined || model === null) {
        return model;
      }
      if (typeof model === 'string') {
        return model;
      }
      return model;
    },
    fromJson: (json: any): Text1 => {
      if (json === undefined || json === null) {
        return json;
      }
      if (typeof json === 'string') {
        return json;
      }
      return json;
    },
  };

  public static Text2 = {
    toJson: (model: Text2): any => {
      if (model === undefined || model === null) {
        return model;
      }
      if (typeof model === 'string') {
        return model;
      }
      return model;
    },
    fromJson: (json: any): Text2 => {
      if (json === undefined || json === null) {
        return json;
      }
      if (typeof json === 'string') {
        return json;
      }
      return json;
    },
  };

  public static Text3 = {
    toJson: (model: Text3): any => {
      if (model === undefined || model === null) {
        return model;
      }
      if (typeof model === 'string') {
        return model;
      }
      return model;
    },
    fromJson: (json: any): Text3 => {
      if (json === undefined || json === null) {
        return json;
      }
      if (typeof json === 'string') {
        return json;
      }
      return json;
    },
  };

  public static ToolResultContentInput = {
    toJson: (model: ToolResultContentInput): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.image === undefined
          ? {}
          : {
              image: $IO.ToolResultContentInputImage.toJson(model.image),
            }),
        ...(model.json === undefined
          ? {}
          : {
              json: $IO.Json.toJson(model.json),
            }),
        ...(model.text === undefined
          ? {}
          : {
              text: $IO.Text2.toJson(model.text),
            }),
      };
    },
    fromJson: (json: any): ToolResultContentInput => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['image'] === undefined
          ? {}
          : {
              image: $IO.ToolResultContentInputImage.fromJson(json['image']),
            }),
        ...(json['json'] === undefined
          ? {}
          : {
              json: $IO.Json.fromJson(json['json']),
            }),
        ...(json['text'] === undefined
          ? {}
          : {
              text: $IO.Text2.fromJson(json['text']),
            }),
      };
    },
  };

  public static ToolResultContentInputImage = {
    toJson: (model: ToolResultContentInputImage): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.ImageContent.toJson(model as ImageContent),
      };
    },
    fromJson: (json: any): ToolResultContentInputImage => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.ImageContent.fromJson(json),
      };
    },
  };

  public static ToolResultContentOutput = {
    toJson: (model: ToolResultContentOutput): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.image === undefined
          ? {}
          : {
              image: $IO.ToolResultContentOutputImage.toJson(model.image),
            }),
        ...(model.json === undefined
          ? {}
          : {
              json: $IO.Json1.toJson(model.json),
            }),
        ...(model.text === undefined
          ? {}
          : {
              text: $IO.Text3.toJson(model.text),
            }),
      };
    },
    fromJson: (json: any): ToolResultContentOutput => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['image'] === undefined
          ? {}
          : {
              image: $IO.ToolResultContentOutputImage.fromJson(json['image']),
            }),
        ...(json['json'] === undefined
          ? {}
          : {
              json: $IO.Json1.fromJson(json['json']),
            }),
        ...(json['text'] === undefined
          ? {}
          : {
              text: $IO.Text3.fromJson(json['text']),
            }),
      };
    },
  };

  public static ToolResultContentOutputImage = {
    toJson: (model: ToolResultContentOutputImage): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.ImageContent.toJson(model as ImageContent),
      };
    },
    fromJson: (json: any): ToolResultContentOutputImage => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.ImageContent.fromJson(json),
      };
    },
  };

  public static ToolResultInput = {
    toJson: (model: ToolResultInput): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.content === undefined
          ? {}
          : {
              content: model.content.map($IO.ToolResultContentInput.toJson),
            }),
        ...(model.status === undefined
          ? {}
          : {
              status: model.status,
            }),
        ...(model.toolUseId === undefined
          ? {}
          : {
              toolUseId: model.toolUseId,
            }),
      };
    },
    fromJson: (json: any): ToolResultInput => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        content: (json['content'] as Array<any>).map(
          $IO.ToolResultContentInput.fromJson,
        ),
        status: json['status'],
        toolUseId: json['toolUseId'],
      };
    },
  };

  public static ToolResultOutput = {
    toJson: (model: ToolResultOutput): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.content === undefined
          ? {}
          : {
              content: model.content.map($IO.ToolResultContentOutput.toJson),
            }),
        ...(model.status === undefined
          ? {}
          : {
              status: model.status,
            }),
        ...(model.toolUseId === undefined
          ? {}
          : {
              toolUseId: model.toolUseId,
            }),
      };
    },
    fromJson: (json: any): ToolResultOutput => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        content: (json['content'] as Array<any>).map(
          $IO.ToolResultContentOutput.fromJson,
        ),
        status: json['status'],
        toolUseId: json['toolUseId'],
      };
    },
  };

  public static ToolUse = {
    toJson: (model: ToolUse): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.input === undefined
          ? {}
          : {
              input: model.input,
            }),
        ...(model.name === undefined
          ? {}
          : {
              name: model.name,
            }),
        ...(model.toolUseId === undefined
          ? {}
          : {
              toolUseId: model.toolUseId,
            }),
      };
    },
    fromJson: (json: any): ToolUse => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        input: json['input'],
        name: json['name'],
        toolUseId: json['toolUseId'],
      };
    },
  };

  public static ValidationError = {
    toJson: (model: ValidationError): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.loc === undefined
          ? {}
          : {
              loc: model.loc.map((item0) => item0),
            }),
        ...(model.msg === undefined
          ? {}
          : {
              msg: model.msg,
            }),
        ...(model.type === undefined
          ? {}
          : {
              type: model.type,
            }),
      };
    },
    fromJson: (json: any): ValidationError => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        loc: (json['loc'] as Array<any>).map((item0) => item0),
        msg: json['msg'],
        type: json['type'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.invoke = this.invoke.bind(this);
    this.listMessages = this.listMessages.bind(this);
    this.ping = this.ping.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  /**
   * Handler for agent invocation
   */
  public async *invoke(input: InvokeRequest): AsyncIterableIterator<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      typeof input === 'object'
        ? JSON.stringify($IO.InvokeInput.toJson(input))
        : String($IO.InvokeInput.toJson(input));

    const response = await this.$fetch(
      this.$url('/invocations', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield value;
      }
      return;
    }
    if (response.status === 422) {
      throw {
        status: response.status,
        error: $IO.HTTPValidationError.fromJson(await response.json()),
      };
    }
    if (response.status === 500) {
      throw {
        status: response.status,
        error: $IO.InternalServerErrorDetails.fromJson(await response.json()),
      };
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async listMessages(
    input: ListMessagesRequest,
  ): Promise<ListMessagesOutput> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } =
      $IO.ListMessagesRequestQueryParameters.toJson(input);
    const headerParameters: { [key: string]: any } = {};
    const collectionFormats = {
      session_id: 'multi',
    } as const;

    const body = undefined;

    const response = await this.$fetch(
      this.$url(
        '/messages',
        pathParameters,
        queryParameters,
        collectionFormats,
      ),
      {
        headers: this.$headers(headerParameters, collectionFormats),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.ListMessagesOutput.fromJson(await response.json());
    }
    if (response.status === 422) {
      throw {
        status: response.status,
        error: $IO.HTTPValidationError.fromJson(await response.json()),
      };
    }
    if (response.status === 500) {
      throw {
        status: response.status,
        error: $IO.InternalServerErrorDetails.fromJson(await response.json()),
      };
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async ping(): Promise<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/ping', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    if (response.status === 500) {
      throw {
        status: response.status,
        error: $IO.InternalServerErrorDetails.fromJson(await response.json()),
      };
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;
