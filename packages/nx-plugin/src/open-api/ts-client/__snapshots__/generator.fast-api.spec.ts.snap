// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`openApiTsClientGenerator - FastAPI > should generate valid TypeScript for FastAPI echo endpoint with validation errors 1`] = `
"export type EchoOutput = {
  message: string;
};
export type EchoRequestQueryParameters = {
  message: string;
};
export type HTTPValidationError = {
  detail?: Array<ValidationError>;
};
export type InternalServerErrorDetails = {
  detail: string;
};
export type LocationItem = string | number;
export type ValidationError = {
  loc: Array<LocationItem>;
  msg: string;
  type: string;
};

export type EchoRequest = EchoRequestQueryParameters;
export type Echo422Error = {
  status: 422;
  error: HTTPValidationError;
};
export type Echo500Error = {
  status: 500;
  error: InternalServerErrorDetails;
};
export type EchoError = Echo422Error | Echo500Error;
"
`;

exports[`openApiTsClientGenerator - FastAPI > should generate valid TypeScript for FastAPI echo endpoint with validation errors 2`] = `
"import type {
  EchoOutput,
  EchoRequestQueryParameters,
  HTTPValidationError,
  InternalServerErrorDetails,
  LocationItem,
  ValidationError,
  EchoRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static EchoOutput = {
    toJson: (model: EchoOutput): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.message === undefined
          ? {}
          : {
              message: model.message,
            }),
      };
    },
    fromJson: (json: any): EchoOutput => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        message: json['message'],
      };
    },
  };

  public static EchoRequestQueryParameters = {
    toJson: (model: EchoRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.message === undefined
          ? {}
          : {
              message: model.message,
            }),
      };
    },
    fromJson: (json: any): EchoRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        message: json['message'],
      };
    },
  };

  public static HTTPValidationError = {
    toJson: (model: HTTPValidationError): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.detail === undefined
          ? {}
          : {
              detail: model.detail.map($IO.ValidationError.toJson),
            }),
      };
    },
    fromJson: (json: any): HTTPValidationError => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['detail'] === undefined
          ? {}
          : {
              detail: (json['detail'] as Array<any>).map(
                $IO.ValidationError.fromJson,
              ),
            }),
      };
    },
  };

  public static InternalServerErrorDetails = {
    toJson: (model: InternalServerErrorDetails): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.detail === undefined
          ? {}
          : {
              detail: model.detail,
            }),
      };
    },
    fromJson: (json: any): InternalServerErrorDetails => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        detail: json['detail'],
      };
    },
  };

  public static LocationItem = {
    toJson: (model: LocationItem): any => {
      if (model === undefined || model === null) {
        return model;
      }
      if (typeof model === 'string') {
        return model;
      }
      if (typeof model === 'number') {
        return model;
      }
      return model;
    },
    fromJson: (json: any): LocationItem => {
      if (json === undefined || json === null) {
        return json;
      }
      if (typeof json === 'string') {
        return json;
      }
      if (typeof json === 'number') {
        return json;
      }
      return json;
    },
  };

  public static ValidationError = {
    toJson: (model: ValidationError): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.loc === undefined
          ? {}
          : {
              loc: model.loc.map((item0) => item0),
            }),
        ...(model.msg === undefined
          ? {}
          : {
              msg: model.msg,
            }),
        ...(model.type === undefined
          ? {}
          : {
              type: model.type,
            }),
      };
    },
    fromJson: (json: any): ValidationError => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        loc: (json['loc'] as Array<any>).map((item0) => item0),
        msg: json['msg'],
        type: json['type'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.echo = this.echo.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async echo(input: EchoRequest): Promise<EchoOutput> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } =
      $IO.EchoRequestQueryParameters.toJson(input);
    const headerParameters: { [key: string]: any } = {};
    const collectionFormats = {
      message: 'multi',
    } as const;

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/echo', pathParameters, queryParameters, collectionFormats),
      {
        headers: this.$headers(headerParameters, collectionFormats),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.EchoOutput.fromJson(await response.json());
    }
    if (response.status === 422) {
      throw {
        status: response.status,
        error: $IO.HTTPValidationError.fromJson(await response.json()),
      };
    }
    if (response.status === 500) {
      throw {
        status: response.status,
        error: $IO.InternalServerErrorDetails.fromJson(await response.json()),
      };
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - FastAPI > should handle FastAPI validation error schemas with anyOf types 1`] = `
"export type LocationItem = string | number;
export type TestValidation422Response = {
  detail?: Array<ValidationError>;
};
export type TestValidationRequestContent = {
  value: number;
};
export type ValidationError = {
  loc: Array<LocationItem>;
  msg: string;
  type: string;
};

export type TestValidationRequest = TestValidationRequestContent | undefined;
export type TestValidation422Error = {
  status: 422;
  error: TestValidation422Response;
};
export type TestValidationError = TestValidation422Error;
"
`;

exports[`openApiTsClientGenerator - FastAPI > should handle FastAPI validation error schemas with anyOf types 2`] = `
"import type {
  LocationItem,
  TestValidation422Response,
  TestValidationRequestContent,
  ValidationError,
  TestValidationRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static LocationItem = {
    toJson: (model: LocationItem): any => {
      if (model === undefined || model === null) {
        return model;
      }
      if (typeof model === 'string') {
        return model;
      }
      if (typeof model === 'number') {
        return model;
      }
      return model;
    },
    fromJson: (json: any): LocationItem => {
      if (json === undefined || json === null) {
        return json;
      }
      if (typeof json === 'string') {
        return json;
      }
      if (typeof json === 'number') {
        return json;
      }
      return json;
    },
  };

  public static TestValidation422Response = {
    toJson: (model: TestValidation422Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.detail === undefined
          ? {}
          : {
              detail: model.detail.map($IO.ValidationError.toJson),
            }),
      };
    },
    fromJson: (json: any): TestValidation422Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['detail'] === undefined
          ? {}
          : {
              detail: (json['detail'] as Array<any>).map(
                $IO.ValidationError.fromJson,
              ),
            }),
      };
    },
  };

  public static TestValidationRequestContent = {
    toJson: (model: TestValidationRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.value === undefined
          ? {}
          : {
              value: model.value,
            }),
      };
    },
    fromJson: (json: any): TestValidationRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        value: json['value'],
      };
    },
  };

  public static ValidationError = {
    toJson: (model: ValidationError): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.loc === undefined
          ? {}
          : {
              loc: model.loc.map((item0) => item0),
            }),
        ...(model.msg === undefined
          ? {}
          : {
              msg: model.msg,
            }),
        ...(model.type === undefined
          ? {}
          : {
              type: model.type,
            }),
      };
    },
    fromJson: (json: any): ValidationError => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        loc: (json['loc'] as Array<any>).map((item0) => item0),
        msg: json['msg'],
        type: json['type'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.testValidation = this.testValidation.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async testValidation(input?: TestValidationRequest): Promise<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.TestValidationRequestContent.toJson(input))
          : String($IO.TestValidationRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    if (response.status === 422) {
      throw {
        status: response.status,
        error: $IO.TestValidation422Response.fromJson(await response.json()),
      };
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;
