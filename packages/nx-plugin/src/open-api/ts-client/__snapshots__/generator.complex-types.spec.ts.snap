// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`openApiTsClientGenerator - complex types > should generate valid TypeScript for arrays and dictionaries 1`] = `
"export type PostTest200ResponseItem = {
  id: string;
  tags?: Array<string>;
};
export type PostTestRequestContent = {
  stringArray?: Array<string>;
  numberArray?: Array<number>;
  stringDict?: { [key: string]: string };
  complexDict?: { [key: string]: PostTestRequestContentComplexDictValue };
};
export type PostTestRequestContentComplexDictValue = {
  name: string;
  value: number;
};

export type PostTestRequest = PostTestRequestContent | undefined;
export type PostTestError = never;
"
`;

exports[`openApiTsClientGenerator - complex types > should generate valid TypeScript for arrays and dictionaries 2`] = `
"import type {
  PostTest200ResponseItem,
  PostTestRequestContent,
  PostTestRequestContentComplexDictValue,
  PostTestRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostTest200ResponseItem = {
    toJson: (model: PostTest200ResponseItem): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.id === undefined
          ? {}
          : {
              id: model.id,
            }),
        ...(model.tags === undefined
          ? {}
          : {
              tags: model.tags,
            }),
      };
    },
    fromJson: (json: any): PostTest200ResponseItem => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        id: json['id'],
        ...(json['tags'] === undefined
          ? {}
          : {
              tags: json['tags'],
            }),
      };
    },
  };

  public static PostTestRequestContent = {
    toJson: (model: PostTestRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.stringArray === undefined
          ? {}
          : {
              stringArray: model.stringArray,
            }),
        ...(model.numberArray === undefined
          ? {}
          : {
              numberArray: model.numberArray,
            }),
        ...(model.stringDict === undefined
          ? {}
          : {
              stringDict: model.stringDict,
            }),
        ...(model.complexDict === undefined
          ? {}
          : {
              complexDict: $IO.$mapValues(
                model.complexDict,
                $IO.PostTestRequestContentComplexDictValue.toJson,
              ),
            }),
      };
    },
    fromJson: (json: any): PostTestRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['stringArray'] === undefined
          ? {}
          : {
              stringArray: json['stringArray'],
            }),
        ...(json['numberArray'] === undefined
          ? {}
          : {
              numberArray: json['numberArray'],
            }),
        ...(json['stringDict'] === undefined
          ? {}
          : {
              stringDict: json['stringDict'],
            }),
        ...(json['complexDict'] === undefined
          ? {}
          : {
              complexDict: $IO.$mapValues(
                json['complexDict'],
                $IO.PostTestRequestContentComplexDictValue.fromJson,
              ),
            }),
      };
    },
  };

  public static PostTestRequestContentComplexDictValue = {
    toJson: (model: PostTestRequestContentComplexDictValue): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.name === undefined
          ? {}
          : {
              name: model.name,
            }),
        ...(model.value === undefined
          ? {}
          : {
              value: model.value,
            }),
      };
    },
    fromJson: (json: any): PostTestRequestContentComplexDictValue => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        name: json['name'],
        value: json['value'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.postTest = this.postTest.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async postTest(
    input?: PostTestRequest,
  ): Promise<Array<PostTest200ResponseItem>> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.PostTestRequestContent.toJson(input))
          : String($IO.PostTestRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return ((await response.json()) as Array<any>).map(
        $IO.PostTest200ResponseItem.fromJson,
      );
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - complex types > should handle nullable schemas in various contexts 1`] = `
"export type PostSingleNullableObjectRequestContent = null | {
  key?: string;
};
export type TestNullable200Response = {
  nullableString?: string | null;
  nullableNumber?: number | null;
  nullableInteger?: number | null;
  nullableBoolean?: boolean | null;
  nullableArray?: Array<string> | null;
  nullableObject?: TestNullable200ResponseNullableObject;
};
export type TestNullable200ResponseNullableObject = null | {
  key?: string;
};
export type TestNullableRequestContent = {
  nullableString?: string | null;
  nullableNumber?: number | null;
  nullableInteger?: number | null;
  nullableBoolean?: boolean | null;
  nullableArray?: Array<string> | null;
  nullableObject?: TestNullableRequestContentNullableObject;
  objectWithNullableProps?: TestNullableRequestContentObjectWithNullableProps;
};
export type TestNullableRequestContentNullableObject = null | {
  key?: string;
};
export type TestNullableRequestContentObjectWithNullableProps = {
  nullableString?: string | null;
  nullableNumber?: number | null;
  nullableInteger?: number | null;
  nullableBoolean?: boolean | null;
  nullableArray?: Array<string> | null;
  nullableObject?: TestNullableRequestContentObjectWithNullablePropsNullableObject;
};
export type TestNullableRequestContentObjectWithNullablePropsNullableObject =
  null | {
    key?: string;
  };
export type TestNullableRequestPathParameters = {
  pathParam: string | null;
};
export type TestNullableRequestQueryParameters = {
  queryString?: string | null;
  queryNumber?: number | null;
  queryInteger?: number | null;
  queryBoolean?: boolean | null;
  queryArray?: Array<string> | null;
  queryObject?: unknown | null;
};

export type PostSingleNullableArrayRequest = Array<string> | undefined;
export type PostSingleNullableArrayError = never;

export type PostSingleNullableBooleanRequest = boolean | undefined;
export type PostSingleNullableBooleanError = never;

export type PostSingleNullableNumberRequest = number | undefined;
export type PostSingleNullableNumberError = never;

export type PostSingleNullableObjectRequest =
  | PostSingleNullableObjectRequestContent
  | undefined;
export type PostSingleNullableObjectError = never;

export type PostSingleNullableStringRequest = string | undefined;
export type PostSingleNullableStringError = never;

export type TestNullableRequest = TestNullableRequestPathParameters &
  TestNullableRequestQueryParameters &
  TestNullableRequestContent;
export type TestNullableError = never;
"
`;

exports[`openApiTsClientGenerator - complex types > should handle nullable schemas in various contexts 2`] = `
"import type {
  PostSingleNullableObjectRequestContent,
  TestNullable200Response,
  TestNullable200ResponseNullableObject,
  TestNullableRequestContent,
  TestNullableRequestContentNullableObject,
  TestNullableRequestContentObjectWithNullableProps,
  TestNullableRequestContentObjectWithNullablePropsNullableObject,
  TestNullableRequestPathParameters,
  TestNullableRequestQueryParameters,
  PostSingleNullableArrayRequest,
  PostSingleNullableBooleanRequest,
  PostSingleNullableNumberRequest,
  PostSingleNullableObjectRequest,
  PostSingleNullableStringRequest,
  TestNullableRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostSingleNullableObjectRequestContent = {
    toJson: (model: PostSingleNullableObjectRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.key === undefined
          ? {}
          : {
              key: model.key,
            }),
      };
    },
    fromJson: (json: any): PostSingleNullableObjectRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['key'] === undefined
          ? {}
          : {
              key: json['key'],
            }),
      };
    },
  };

  public static TestNullable200Response = {
    toJson: (model: TestNullable200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.nullableString === undefined
          ? {}
          : {
              nullableString: model.nullableString,
            }),
        ...(model.nullableNumber === undefined
          ? {}
          : {
              nullableNumber: model.nullableNumber,
            }),
        ...(model.nullableInteger === undefined
          ? {}
          : {
              nullableInteger: model.nullableInteger,
            }),
        ...(model.nullableBoolean === undefined
          ? {}
          : {
              nullableBoolean: model.nullableBoolean,
            }),
        ...(model.nullableArray === undefined
          ? {}
          : {
              nullableArray:
                model.nullableArray === null ? null : model.nullableArray,
            }),
        ...(model.nullableObject === undefined
          ? {}
          : {
              nullableObject: $IO.TestNullable200ResponseNullableObject.toJson(
                model.nullableObject,
              ),
            }),
      };
    },
    fromJson: (json: any): TestNullable200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['nullableString'] === undefined
          ? {}
          : {
              nullableString:
                json['nullableString'] === null ? null : json['nullableString'],
            }),
        ...(json['nullableNumber'] === undefined
          ? {}
          : {
              nullableNumber:
                json['nullableNumber'] === null ? null : json['nullableNumber'],
            }),
        ...(json['nullableInteger'] === undefined
          ? {}
          : {
              nullableInteger:
                json['nullableInteger'] === null
                  ? null
                  : json['nullableInteger'],
            }),
        ...(json['nullableBoolean'] === undefined
          ? {}
          : {
              nullableBoolean:
                json['nullableBoolean'] === null
                  ? null
                  : json['nullableBoolean'],
            }),
        ...(json['nullableArray'] === undefined
          ? {}
          : {
              nullableArray:
                json['nullableArray'] === null ? null : json['nullableArray'],
            }),
        ...(json['nullableObject'] === undefined
          ? {}
          : {
              nullableObject:
                $IO.TestNullable200ResponseNullableObject.fromJson(
                  json['nullableObject'],
                ),
            }),
      };
    },
  };

  public static TestNullable200ResponseNullableObject = {
    toJson: (model: TestNullable200ResponseNullableObject): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.key === undefined
          ? {}
          : {
              key: model.key,
            }),
      };
    },
    fromJson: (json: any): TestNullable200ResponseNullableObject => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['key'] === undefined
          ? {}
          : {
              key: json['key'],
            }),
      };
    },
  };

  public static TestNullableRequestContent = {
    toJson: (model: TestNullableRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.nullableString === undefined
          ? {}
          : {
              nullableString: model.nullableString,
            }),
        ...(model.nullableNumber === undefined
          ? {}
          : {
              nullableNumber: model.nullableNumber,
            }),
        ...(model.nullableInteger === undefined
          ? {}
          : {
              nullableInteger: model.nullableInteger,
            }),
        ...(model.nullableBoolean === undefined
          ? {}
          : {
              nullableBoolean: model.nullableBoolean,
            }),
        ...(model.nullableArray === undefined
          ? {}
          : {
              nullableArray:
                model.nullableArray === null ? null : model.nullableArray,
            }),
        ...(model.nullableObject === undefined
          ? {}
          : {
              nullableObject:
                $IO.TestNullableRequestContentNullableObject.toJson(
                  model.nullableObject,
                ),
            }),
        ...(model.objectWithNullableProps === undefined
          ? {}
          : {
              objectWithNullableProps:
                $IO.TestNullableRequestContentObjectWithNullableProps.toJson(
                  model.objectWithNullableProps,
                ),
            }),
      };
    },
    fromJson: (json: any): TestNullableRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['nullableString'] === undefined
          ? {}
          : {
              nullableString:
                json['nullableString'] === null ? null : json['nullableString'],
            }),
        ...(json['nullableNumber'] === undefined
          ? {}
          : {
              nullableNumber:
                json['nullableNumber'] === null ? null : json['nullableNumber'],
            }),
        ...(json['nullableInteger'] === undefined
          ? {}
          : {
              nullableInteger:
                json['nullableInteger'] === null
                  ? null
                  : json['nullableInteger'],
            }),
        ...(json['nullableBoolean'] === undefined
          ? {}
          : {
              nullableBoolean:
                json['nullableBoolean'] === null
                  ? null
                  : json['nullableBoolean'],
            }),
        ...(json['nullableArray'] === undefined
          ? {}
          : {
              nullableArray:
                json['nullableArray'] === null ? null : json['nullableArray'],
            }),
        ...(json['nullableObject'] === undefined
          ? {}
          : {
              nullableObject:
                $IO.TestNullableRequestContentNullableObject.fromJson(
                  json['nullableObject'],
                ),
            }),
        ...(json['objectWithNullableProps'] === undefined
          ? {}
          : {
              objectWithNullableProps:
                $IO.TestNullableRequestContentObjectWithNullableProps.fromJson(
                  json['objectWithNullableProps'],
                ),
            }),
      };
    },
  };

  public static TestNullableRequestContentNullableObject = {
    toJson: (model: TestNullableRequestContentNullableObject): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.key === undefined
          ? {}
          : {
              key: model.key,
            }),
      };
    },
    fromJson: (json: any): TestNullableRequestContentNullableObject => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['key'] === undefined
          ? {}
          : {
              key: json['key'],
            }),
      };
    },
  };

  public static TestNullableRequestContentObjectWithNullableProps = {
    toJson: (model: TestNullableRequestContentObjectWithNullableProps): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.nullableString === undefined
          ? {}
          : {
              nullableString: model.nullableString,
            }),
        ...(model.nullableNumber === undefined
          ? {}
          : {
              nullableNumber: model.nullableNumber,
            }),
        ...(model.nullableInteger === undefined
          ? {}
          : {
              nullableInteger: model.nullableInteger,
            }),
        ...(model.nullableBoolean === undefined
          ? {}
          : {
              nullableBoolean: model.nullableBoolean,
            }),
        ...(model.nullableArray === undefined
          ? {}
          : {
              nullableArray:
                model.nullableArray === null ? null : model.nullableArray,
            }),
        ...(model.nullableObject === undefined
          ? {}
          : {
              nullableObject:
                $IO.TestNullableRequestContentObjectWithNullablePropsNullableObject.toJson(
                  model.nullableObject,
                ),
            }),
      };
    },
    fromJson: (
      json: any,
    ): TestNullableRequestContentObjectWithNullableProps => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['nullableString'] === undefined
          ? {}
          : {
              nullableString:
                json['nullableString'] === null ? null : json['nullableString'],
            }),
        ...(json['nullableNumber'] === undefined
          ? {}
          : {
              nullableNumber:
                json['nullableNumber'] === null ? null : json['nullableNumber'],
            }),
        ...(json['nullableInteger'] === undefined
          ? {}
          : {
              nullableInteger:
                json['nullableInteger'] === null
                  ? null
                  : json['nullableInteger'],
            }),
        ...(json['nullableBoolean'] === undefined
          ? {}
          : {
              nullableBoolean:
                json['nullableBoolean'] === null
                  ? null
                  : json['nullableBoolean'],
            }),
        ...(json['nullableArray'] === undefined
          ? {}
          : {
              nullableArray:
                json['nullableArray'] === null ? null : json['nullableArray'],
            }),
        ...(json['nullableObject'] === undefined
          ? {}
          : {
              nullableObject:
                $IO.TestNullableRequestContentObjectWithNullablePropsNullableObject.fromJson(
                  json['nullableObject'],
                ),
            }),
      };
    },
  };

  public static TestNullableRequestContentObjectWithNullablePropsNullableObject =
    {
      toJson: (
        model: TestNullableRequestContentObjectWithNullablePropsNullableObject,
      ): any => {
        if (model === undefined || model === null) {
          return model;
        }
        return {
          ...(model.key === undefined
            ? {}
            : {
                key: model.key,
              }),
        };
      },
      fromJson: (
        json: any,
      ): TestNullableRequestContentObjectWithNullablePropsNullableObject => {
        if (json === undefined || json === null) {
          return json;
        }
        return {
          ...(json['key'] === undefined
            ? {}
            : {
                key: json['key'],
              }),
        };
      },
    };

  public static TestNullableRequestPathParameters = {
    toJson: (model: TestNullableRequestPathParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.pathParam === undefined
          ? {}
          : {
              pathParam: model.pathParam,
            }),
      };
    },
    fromJson: (json: any): TestNullableRequestPathParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        pathParam: json['pathParam'] === null ? null : json['pathParam'],
      };
    },
  };

  public static TestNullableRequestQueryParameters = {
    toJson: (model: TestNullableRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.queryString === undefined
          ? {}
          : {
              queryString: model.queryString,
            }),
        ...(model.queryNumber === undefined
          ? {}
          : {
              queryNumber: model.queryNumber,
            }),
        ...(model.queryInteger === undefined
          ? {}
          : {
              queryInteger: model.queryInteger,
            }),
        ...(model.queryBoolean === undefined
          ? {}
          : {
              queryBoolean: model.queryBoolean,
            }),
        ...(model.queryArray === undefined
          ? {}
          : {
              queryArray: model.queryArray === null ? null : model.queryArray,
            }),
        ...(model.queryObject === undefined
          ? {}
          : {
              queryObject: model.queryObject,
            }),
      };
    },
    fromJson: (json: any): TestNullableRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['queryString'] === undefined
          ? {}
          : {
              queryString:
                json['queryString'] === null ? null : json['queryString'],
            }),
        ...(json['queryNumber'] === undefined
          ? {}
          : {
              queryNumber:
                json['queryNumber'] === null ? null : json['queryNumber'],
            }),
        ...(json['queryInteger'] === undefined
          ? {}
          : {
              queryInteger:
                json['queryInteger'] === null ? null : json['queryInteger'],
            }),
        ...(json['queryBoolean'] === undefined
          ? {}
          : {
              queryBoolean:
                json['queryBoolean'] === null ? null : json['queryBoolean'],
            }),
        ...(json['queryArray'] === undefined
          ? {}
          : {
              queryArray:
                json['queryArray'] === null ? null : json['queryArray'],
            }),
        ...(json['queryObject'] === undefined
          ? {}
          : {
              queryObject:
                json['queryObject'] === null ? null : json['queryObject'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.postSingleNullableArray = this.postSingleNullableArray.bind(this);
    this.postSingleNullableBoolean = this.postSingleNullableBoolean.bind(this);
    this.postSingleNullableNumber = this.postSingleNullableNumber.bind(this);
    this.postSingleNullableObject = this.postSingleNullableObject.bind(this);
    this.postSingleNullableString = this.postSingleNullableString.bind(this);
    this.testNullable = this.testNullable.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async postSingleNullableArray(
    input?: PostSingleNullableArrayRequest,
  ): Promise<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : JSON.stringify(input === null ? null : input);

    const response = await this.$fetch(
      this.$url('/single-nullable-array', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async postSingleNullableBoolean(
    input?: PostSingleNullableBooleanRequest,
  ): Promise<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body = input === undefined ? undefined : String(input);

    const response = await this.$fetch(
      this.$url('/single-nullable-boolean', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async postSingleNullableNumber(
    input?: PostSingleNullableNumberRequest,
  ): Promise<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body = input === undefined ? undefined : String(input);

    const response = await this.$fetch(
      this.$url('/single-nullable-number', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async postSingleNullableObject(
    input?: PostSingleNullableObjectRequest,
  ): Promise<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify(
              $IO.PostSingleNullableObjectRequestContent.toJson(input),
            )
          : String($IO.PostSingleNullableObjectRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/single-nullable-object', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async postSingleNullableString(
    input?: PostSingleNullableStringRequest,
  ): Promise<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body = input === undefined ? undefined : String(input);

    const response = await this.$fetch(
      this.$url('/single-nullable-string', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async testNullable(
    input: TestNullableRequest,
  ): Promise<TestNullable200Response> {
    const pathParameters: { [key: string]: any } =
      $IO.TestNullableRequestPathParameters.toJson(input);
    const queryParameters: { [key: string]: any } =
      $IO.TestNullableRequestQueryParameters.toJson(input);
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const collectionFormats = {
      queryString: 'multi',
      queryNumber: 'multi',
      queryInteger: 'multi',
      queryBoolean: 'multi',
      queryArray: 'multi',
      queryObject: 'multi',
    } as const;
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.TestNullableRequestContent.toJson(input))
          : String($IO.TestNullableRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url(
        '/test/{pathParam}',
        pathParameters,
        queryParameters,
        collectionFormats,
      ),
      {
        headers: this.$headers(headerParameters, collectionFormats),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.TestNullable200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - complex types > should handle operations with complex map types 1`] = `
"export type PostMapOfArraysOfObjectsRequestContent = {
  [key: string]: Array<PostMapOfArraysOfObjectsRequestContentValueItem>;
};
export type PostMapOfArraysOfObjectsRequestContentValueItem = {
  name: string;
  value: number;
};
export type PostMapOfMapsOfArraysOfNumbersRequestContent = {
  [key: string]: { [key: string]: Array<number> };
};
export type PostMapOfMapsOfNumbersRequestContent = {
  [key: string]: { [key: string]: number };
};
export type PostMapOfNumbersRequestContent = {
  [key: string]: number;
};
export type PostMapOfObjectsRequestContent = {
  [key: string]: PostMapOfObjectsRequestContentValue;
};
export type PostMapOfObjectsRequestContentValue = {
  name: string;
  value: number;
};

export type PostArrayOfMapsOfArraysOfNumbersRequest =
  | Array<{ [key: string]: Array<number> }>
  | undefined;
export type PostArrayOfMapsOfArraysOfNumbersError = never;

export type PostArrayOfMapsOfNumbersRequest =
  | Array<{ [key: string]: number }>
  | undefined;
export type PostArrayOfMapsOfNumbersError = never;

export type PostMapOfArraysOfObjectsRequest =
  | PostMapOfArraysOfObjectsRequestContent
  | undefined;
export type PostMapOfArraysOfObjectsError = never;

export type PostMapOfMapsOfArraysOfNumbersRequest =
  | PostMapOfMapsOfArraysOfNumbersRequestContent
  | undefined;
export type PostMapOfMapsOfArraysOfNumbersError = never;

export type PostMapOfMapsOfNumbersRequest =
  | PostMapOfMapsOfNumbersRequestContent
  | undefined;
export type PostMapOfMapsOfNumbersError = never;

export type PostMapOfNumbersRequest =
  | PostMapOfNumbersRequestContent
  | undefined;
export type PostMapOfNumbersError = never;

export type PostMapOfObjectsRequest =
  | PostMapOfObjectsRequestContent
  | undefined;
export type PostMapOfObjectsError = never;
"
`;

exports[`openApiTsClientGenerator - complex types > should handle operations with complex map types 2`] = `
"import type {
  PostMapOfArraysOfObjectsRequestContent,
  PostMapOfArraysOfObjectsRequestContentValueItem,
  PostMapOfMapsOfArraysOfNumbersRequestContent,
  PostMapOfMapsOfNumbersRequestContent,
  PostMapOfNumbersRequestContent,
  PostMapOfObjectsRequestContent,
  PostMapOfObjectsRequestContentValue,
  PostArrayOfMapsOfArraysOfNumbersRequest,
  PostArrayOfMapsOfNumbersRequest,
  PostMapOfArraysOfObjectsRequest,
  PostMapOfMapsOfArraysOfNumbersRequest,
  PostMapOfMapsOfNumbersRequest,
  PostMapOfNumbersRequest,
  PostMapOfObjectsRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostMapOfArraysOfObjectsRequestContent = {
    toJson: (model: PostMapOfArraysOfObjectsRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.$mapValues(model, (item0) =>
          item0.map($IO.PostMapOfArraysOfObjectsRequestContentValueItem.toJson),
        ),
      };
    },
    fromJson: (json: any): PostMapOfArraysOfObjectsRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.$mapValues(json, (item0) =>
          item0.map(
            $IO.PostMapOfArraysOfObjectsRequestContentValueItem.fromJson,
          ),
        ),
      };
    },
  };

  public static PostMapOfArraysOfObjectsRequestContentValueItem = {
    toJson: (model: PostMapOfArraysOfObjectsRequestContentValueItem): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.name === undefined
          ? {}
          : {
              name: model.name,
            }),
        ...(model.value === undefined
          ? {}
          : {
              value: model.value,
            }),
      };
    },
    fromJson: (json: any): PostMapOfArraysOfObjectsRequestContentValueItem => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        name: json['name'],
        value: json['value'],
      };
    },
  };

  public static PostMapOfMapsOfArraysOfNumbersRequestContent = {
    toJson: (model: PostMapOfMapsOfArraysOfNumbersRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): PostMapOfMapsOfArraysOfNumbersRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static PostMapOfMapsOfNumbersRequestContent = {
    toJson: (model: PostMapOfMapsOfNumbersRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): PostMapOfMapsOfNumbersRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static PostMapOfNumbersRequestContent = {
    toJson: (model: PostMapOfNumbersRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): PostMapOfNumbersRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static PostMapOfObjectsRequestContent = {
    toJson: (model: PostMapOfObjectsRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.$mapValues(
          model,
          $IO.PostMapOfObjectsRequestContentValue.toJson,
        ),
      };
    },
    fromJson: (json: any): PostMapOfObjectsRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.$mapValues(
          json,
          $IO.PostMapOfObjectsRequestContentValue.fromJson,
        ),
      };
    },
  };

  public static PostMapOfObjectsRequestContentValue = {
    toJson: (model: PostMapOfObjectsRequestContentValue): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.name === undefined
          ? {}
          : {
              name: model.name,
            }),
        ...(model.value === undefined
          ? {}
          : {
              value: model.value,
            }),
      };
    },
    fromJson: (json: any): PostMapOfObjectsRequestContentValue => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        name: json['name'],
        value: json['value'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.postArrayOfMapsOfArraysOfNumbers =
      this.postArrayOfMapsOfArraysOfNumbers.bind(this);
    this.postArrayOfMapsOfNumbers = this.postArrayOfMapsOfNumbers.bind(this);
    this.postMapOfArraysOfObjects = this.postMapOfArraysOfObjects.bind(this);
    this.postMapOfMapsOfArraysOfNumbers =
      this.postMapOfMapsOfArraysOfNumbers.bind(this);
    this.postMapOfMapsOfNumbers = this.postMapOfMapsOfNumbers.bind(this);
    this.postMapOfNumbers = this.postMapOfNumbers.bind(this);
    this.postMapOfObjects = this.postMapOfObjects.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async postArrayOfMapsOfArraysOfNumbers(
    input?: PostArrayOfMapsOfArraysOfNumbersRequest,
  ): Promise<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body = input === undefined ? undefined : JSON.stringify(input);

    const response = await this.$fetch(
      this.$url(
        '/array-of-maps-of-arrays-of-numbers',
        pathParameters,
        queryParameters,
      ),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async postArrayOfMapsOfNumbers(
    input?: PostArrayOfMapsOfNumbersRequest,
  ): Promise<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body = input === undefined ? undefined : JSON.stringify(input);

    const response = await this.$fetch(
      this.$url('/array-of-maps-of-numbers', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async postMapOfArraysOfObjects(
    input?: PostMapOfArraysOfObjectsRequest,
  ): Promise<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify(
              $IO.PostMapOfArraysOfObjectsRequestContent.toJson(input),
            )
          : String($IO.PostMapOfArraysOfObjectsRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/map-of-arrays-of-objects', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async postMapOfMapsOfArraysOfNumbers(
    input?: PostMapOfMapsOfArraysOfNumbersRequest,
  ): Promise<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify(
              $IO.PostMapOfMapsOfArraysOfNumbersRequestContent.toJson(input),
            )
          : String(
              $IO.PostMapOfMapsOfArraysOfNumbersRequestContent.toJson(input),
            );

    const response = await this.$fetch(
      this.$url(
        '/map-of-maps-of-arrays-of-numbers',
        pathParameters,
        queryParameters,
      ),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async postMapOfMapsOfNumbers(
    input?: PostMapOfMapsOfNumbersRequest,
  ): Promise<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify(
              $IO.PostMapOfMapsOfNumbersRequestContent.toJson(input),
            )
          : String($IO.PostMapOfMapsOfNumbersRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/map-of-maps-of-numbers', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async postMapOfNumbers(
    input?: PostMapOfNumbersRequest,
  ): Promise<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.PostMapOfNumbersRequestContent.toJson(input))
          : String($IO.PostMapOfNumbersRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/map-of-numbers', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async postMapOfObjects(
    input?: PostMapOfObjectsRequest,
  ): Promise<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.PostMapOfObjectsRequestContent.toJson(input))
          : String($IO.PostMapOfObjectsRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/map-of-objects', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - complex types > should handle recursive schema references 1`] = `
"export type TreeNode = {
  id: string;
  name: string;
  children?: Array<TreeNode>;
};

export type CreateTreeRequest = TreeNode | undefined;
export type CreateTreeError = never;
export type GetTreeError = never;
"
`;

exports[`openApiTsClientGenerator - complex types > should handle recursive schema references 2`] = `
"import type { TreeNode, CreateTreeRequest } from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static TreeNode = {
    toJson: (model: TreeNode): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.id === undefined
          ? {}
          : {
              id: model.id,
            }),
        ...(model.name === undefined
          ? {}
          : {
              name: model.name,
            }),
        ...(model.children === undefined
          ? {}
          : {
              children: model.children.map($IO.TreeNode.toJson),
            }),
      };
    },
    fromJson: (json: any): TreeNode => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        id: json['id'],
        name: json['name'],
        ...(json['children'] === undefined
          ? {}
          : {
              children: (json['children'] as Array<any>).map(
                $IO.TreeNode.fromJson,
              ),
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.createTree = this.createTree.bind(this);
    this.getTree = this.getTree.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async createTree(input?: CreateTreeRequest): Promise<TreeNode> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.TreeNode.toJson(input))
          : String($IO.TreeNode.toJson(input));

    const response = await this.$fetch(
      this.$url('/tree', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 201) {
      return $IO.TreeNode.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async getTree(): Promise<TreeNode> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/tree', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.TreeNode.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - complex types > should handle refs and hoisting of inline schemas 1`] = `
"export type Error = {
  code: string;
  message: string;
};
export type PostTestRequestContent = {
  inline?: PostTestRequestContentInline;
  referenced?: Error;
};
export type PostTestRequestContentInline = {
  name?: string;
  details?: PostTestRequestContentInlineDetails;
};
export type PostTestRequestContentInlineDetails = {
  age?: number;
  active?: boolean;
};

export type PostTestRequest = PostTestRequestContent;
export type PostTest400Error = {
  status: 400;
  error: Error;
};
export type PostTestError = PostTest400Error;
"
`;

exports[`openApiTsClientGenerator - complex types > should handle refs and hoisting of inline schemas 2`] = `
"import type {
  Error,
  PostTestRequestContent,
  PostTestRequestContentInline,
  PostTestRequestContentInlineDetails,
  PostTestRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static Error = {
    toJson: (model: Error): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.code === undefined
          ? {}
          : {
              code: model.code,
            }),
        ...(model.message === undefined
          ? {}
          : {
              message: model.message,
            }),
      };
    },
    fromJson: (json: any): Error => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        code: json['code'],
        message: json['message'],
      };
    },
  };

  public static PostTestRequestContent = {
    toJson: (model: PostTestRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.inline === undefined
          ? {}
          : {
              inline: $IO.PostTestRequestContentInline.toJson(model.inline),
            }),
        ...(model.referenced === undefined
          ? {}
          : {
              referenced: $IO.Error.toJson(model.referenced),
            }),
      };
    },
    fromJson: (json: any): PostTestRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['inline'] === undefined
          ? {}
          : {
              inline: $IO.PostTestRequestContentInline.fromJson(json['inline']),
            }),
        ...(json['referenced'] === undefined
          ? {}
          : {
              referenced: $IO.Error.fromJson(json['referenced']),
            }),
      };
    },
  };

  public static PostTestRequestContentInline = {
    toJson: (model: PostTestRequestContentInline): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.name === undefined
          ? {}
          : {
              name: model.name,
            }),
        ...(model.details === undefined
          ? {}
          : {
              details: $IO.PostTestRequestContentInlineDetails.toJson(
                model.details,
              ),
            }),
      };
    },
    fromJson: (json: any): PostTestRequestContentInline => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['name'] === undefined
          ? {}
          : {
              name: json['name'],
            }),
        ...(json['details'] === undefined
          ? {}
          : {
              details: $IO.PostTestRequestContentInlineDetails.fromJson(
                json['details'],
              ),
            }),
      };
    },
  };

  public static PostTestRequestContentInlineDetails = {
    toJson: (model: PostTestRequestContentInlineDetails): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.age === undefined
          ? {}
          : {
              age: model.age,
            }),
        ...(model.active === undefined
          ? {}
          : {
              active: model.active,
            }),
      };
    },
    fromJson: (json: any): PostTestRequestContentInlineDetails => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['age'] === undefined
          ? {}
          : {
              age: json['age'],
            }),
        ...(json['active'] === undefined
          ? {}
          : {
              active: json['active'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.postTest = this.postTest.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async postTest(input: PostTestRequest): Promise<void> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      typeof input === 'object'
        ? JSON.stringify($IO.PostTestRequestContent.toJson(input))
        : String($IO.PostTestRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return undefined;
    }
    if (response.status === 400) {
      throw {
        status: response.status,
        error: $IO.Error.fromJson(await response.json()),
      };
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;
