// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`openApiTsClientGenerator - arrays > should handle operation which accepts an array of objects 1`] = `
"export type ProcessUsers200Response = {
  processed: number;
  status: string;
};
export type ProcessUsersRequestContentItem = {
  id: string;
  name: string;
  email: string;
  age?: number;
  active?: boolean;
};

export type ProcessUsersRequest = Array<ProcessUsersRequestContentItem>;
export type ProcessUsersError = never;
"
`;

exports[`openApiTsClientGenerator - arrays > should handle operation which accepts an array of objects 2`] = `
"import type {
  ProcessUsers200Response,
  ProcessUsersRequestContentItem,
  ProcessUsersRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static ProcessUsers200Response = {
    toJson: (model: ProcessUsers200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.processed === undefined
          ? {}
          : {
              processed: model.processed,
            }),
        ...(model.status === undefined
          ? {}
          : {
              status: model.status,
            }),
      };
    },
    fromJson: (json: any): ProcessUsers200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        processed: json['processed'],
        status: json['status'],
      };
    },
  };

  public static ProcessUsersRequestContentItem = {
    toJson: (model: ProcessUsersRequestContentItem): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.id === undefined
          ? {}
          : {
              id: model.id,
            }),
        ...(model.name === undefined
          ? {}
          : {
              name: model.name,
            }),
        ...(model.email === undefined
          ? {}
          : {
              email: model.email,
            }),
        ...(model.age === undefined
          ? {}
          : {
              age: model.age,
            }),
        ...(model.active === undefined
          ? {}
          : {
              active: model.active,
            }),
      };
    },
    fromJson: (json: any): ProcessUsersRequestContentItem => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        id: json['id'],
        name: json['name'],
        email: json['email'],
        ...(json['age'] === undefined
          ? {}
          : {
              age: json['age'],
            }),
        ...(json['active'] === undefined
          ? {}
          : {
              active: json['active'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.processUsers = this.processUsers.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  /**
   * Process an array of user objects
   */
  public async processUsers(
    input: ProcessUsersRequest,
  ): Promise<ProcessUsers200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body = JSON.stringify(
      input.map($IO.ProcessUsersRequestContentItem.toJson),
    );

    const response = await this.$fetch(
      this.$url('/process-users', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.ProcessUsers200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - arrays > should handle operation which accepts an array of objects referenced from components 1`] = `
"export type BatchCreateCustomers201Response = {
  created: number;
  customerIds: Array<string>;
};
export type Customer = {
  id: string;
  name: string;
  email: string;
  phone?: string;
  address?: CustomerAddress;
  preferences?: Array<string>;
};
export type CustomerAddress = {
  street: string;
  city: string;
  country: string;
  zipCode?: string;
};

export type BatchCreateCustomersRequest = Array<Customer>;
export type BatchCreateCustomersError = never;
"
`;

exports[`openApiTsClientGenerator - arrays > should handle operation which accepts an array of objects referenced from components 2`] = `
"import type {
  BatchCreateCustomers201Response,
  Customer,
  CustomerAddress,
  BatchCreateCustomersRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static BatchCreateCustomers201Response = {
    toJson: (model: BatchCreateCustomers201Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.created === undefined
          ? {}
          : {
              created: model.created,
            }),
        ...(model.customerIds === undefined
          ? {}
          : {
              customerIds: model.customerIds,
            }),
      };
    },
    fromJson: (json: any): BatchCreateCustomers201Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        created: json['created'],
        customerIds: json['customerIds'],
      };
    },
  };

  public static Customer = {
    toJson: (model: Customer): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.id === undefined
          ? {}
          : {
              id: model.id,
            }),
        ...(model.name === undefined
          ? {}
          : {
              name: model.name,
            }),
        ...(model.email === undefined
          ? {}
          : {
              email: model.email,
            }),
        ...(model.phone === undefined
          ? {}
          : {
              phone: model.phone,
            }),
        ...(model.address === undefined
          ? {}
          : {
              address: $IO.CustomerAddress.toJson(model.address),
            }),
        ...(model.preferences === undefined
          ? {}
          : {
              preferences: model.preferences,
            }),
      };
    },
    fromJson: (json: any): Customer => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        id: json['id'],
        name: json['name'],
        email: json['email'],
        ...(json['phone'] === undefined
          ? {}
          : {
              phone: json['phone'],
            }),
        ...(json['address'] === undefined
          ? {}
          : {
              address: $IO.CustomerAddress.fromJson(json['address']),
            }),
        ...(json['preferences'] === undefined
          ? {}
          : {
              preferences: json['preferences'],
            }),
      };
    },
  };

  public static CustomerAddress = {
    toJson: (model: CustomerAddress): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.street === undefined
          ? {}
          : {
              street: model.street,
            }),
        ...(model.city === undefined
          ? {}
          : {
              city: model.city,
            }),
        ...(model.country === undefined
          ? {}
          : {
              country: model.country,
            }),
        ...(model.zipCode === undefined
          ? {}
          : {
              zipCode: model.zipCode,
            }),
      };
    },
    fromJson: (json: any): CustomerAddress => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        street: json['street'],
        city: json['city'],
        country: json['country'],
        ...(json['zipCode'] === undefined
          ? {}
          : {
              zipCode: json['zipCode'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.batchCreateCustomers = this.batchCreateCustomers.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  /**
   * Create multiple customers from referenced component schema
   */
  public async batchCreateCustomers(
    input: BatchCreateCustomersRequest,
  ): Promise<BatchCreateCustomers201Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body = JSON.stringify(input.map($IO.Customer.toJson));

    const response = await this.$fetch(
      this.$url('/batch-customers', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 201) {
      return $IO.BatchCreateCustomers201Response.fromJson(
        await response.json(),
      );
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - arrays > should handle operation which accepts an array of strings 1`] = `
"export type ProcessTags200Response = {
  processed: number;
  message: string;
};

export type ProcessTagsRequest = Array<string>;
export type ProcessTagsError = never;
"
`;

exports[`openApiTsClientGenerator - arrays > should handle operation which accepts an array of strings 2`] = `
"import type {
  ProcessTags200Response,
  ProcessTagsRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static ProcessTags200Response = {
    toJson: (model: ProcessTags200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.processed === undefined
          ? {}
          : {
              processed: model.processed,
            }),
        ...(model.message === undefined
          ? {}
          : {
              message: model.message,
            }),
      };
    },
    fromJson: (json: any): ProcessTags200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        processed: json['processed'],
        message: json['message'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.processTags = this.processTags.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  /**
   * Process an array of string tags
   */
  public async processTags(
    input: ProcessTagsRequest,
  ): Promise<ProcessTags200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body = JSON.stringify(input);

    const response = await this.$fetch(
      this.$url('/process-tags', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.ProcessTags200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - arrays > should handle operation which returns an array of objects 1`] = `
"export type GetProducts200ResponseItem = {
  id: string;
  name: string;
  price: number;
  description?: string;
  inStock?: boolean;
  tags?: Array<string>;
  metadata?: GetProducts200ResponseItemMetadata;
};
export type GetProducts200ResponseItemMetadata = {
  weight?: number;
  dimensions?: string;
};
/**
 * Get an array of product objects
 */
export type GetProductsRequestQueryParameters = {
  category?: string;
  limit?: number;
};

export type GetProductsRequest = GetProductsRequestQueryParameters;
export type GetProductsError = never;
"
`;

exports[`openApiTsClientGenerator - arrays > should handle operation which returns an array of objects 2`] = `
"import type {
  GetProducts200ResponseItem,
  GetProducts200ResponseItemMetadata,
  GetProductsRequestQueryParameters,
  GetProductsRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static GetProducts200ResponseItem = {
    toJson: (model: GetProducts200ResponseItem): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.id === undefined
          ? {}
          : {
              id: model.id,
            }),
        ...(model.name === undefined
          ? {}
          : {
              name: model.name,
            }),
        ...(model.price === undefined
          ? {}
          : {
              price: model.price,
            }),
        ...(model.description === undefined
          ? {}
          : {
              description: model.description,
            }),
        ...(model.inStock === undefined
          ? {}
          : {
              inStock: model.inStock,
            }),
        ...(model.tags === undefined
          ? {}
          : {
              tags: model.tags,
            }),
        ...(model.metadata === undefined
          ? {}
          : {
              metadata: $IO.GetProducts200ResponseItemMetadata.toJson(
                model.metadata,
              ),
            }),
      };
    },
    fromJson: (json: any): GetProducts200ResponseItem => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        id: json['id'],
        name: json['name'],
        price: json['price'],
        ...(json['description'] === undefined
          ? {}
          : {
              description: json['description'],
            }),
        ...(json['inStock'] === undefined
          ? {}
          : {
              inStock: json['inStock'],
            }),
        ...(json['tags'] === undefined
          ? {}
          : {
              tags: json['tags'],
            }),
        ...(json['metadata'] === undefined
          ? {}
          : {
              metadata: $IO.GetProducts200ResponseItemMetadata.fromJson(
                json['metadata'],
              ),
            }),
      };
    },
  };

  public static GetProducts200ResponseItemMetadata = {
    toJson: (model: GetProducts200ResponseItemMetadata): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.weight === undefined
          ? {}
          : {
              weight: model.weight,
            }),
        ...(model.dimensions === undefined
          ? {}
          : {
              dimensions: model.dimensions,
            }),
      };
    },
    fromJson: (json: any): GetProducts200ResponseItemMetadata => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['weight'] === undefined
          ? {}
          : {
              weight: json['weight'],
            }),
        ...(json['dimensions'] === undefined
          ? {}
          : {
              dimensions: json['dimensions'],
            }),
      };
    },
  };

  public static GetProductsRequestQueryParameters = {
    toJson: (model: GetProductsRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.category === undefined
          ? {}
          : {
              category: model.category,
            }),
        ...(model.limit === undefined
          ? {}
          : {
              limit: model.limit,
            }),
      };
    },
    fromJson: (json: any): GetProductsRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['category'] === undefined
          ? {}
          : {
              category: json['category'],
            }),
        ...(json['limit'] === undefined
          ? {}
          : {
              limit: json['limit'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.getProducts = this.getProducts.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  /**
   * Get an array of product objects
   */
  public async getProducts(
    input: GetProductsRequest,
  ): Promise<Array<GetProducts200ResponseItem>> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } =
      $IO.GetProductsRequestQueryParameters.toJson(input);
    const headerParameters: { [key: string]: any } = {};
    const collectionFormats = {
      category: 'multi',
      limit: 'multi',
    } as const;

    const body = undefined;

    const response = await this.$fetch(
      this.$url(
        '/get-products',
        pathParameters,
        queryParameters,
        collectionFormats,
      ),
      {
        headers: this.$headers(headerParameters, collectionFormats),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return ((await response.json()) as Array<any>).map(
        $IO.GetProducts200ResponseItem.fromJson,
      );
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - arrays > should handle operation which returns an array of objects referenced from components 1`] = `
"/**
 * Get orders using referenced component schema
 */
export type GetOrdersRequestQueryParameters = {
  customerId?: string;
  status?: string;
  limit?: number;
};
export type Order = {
  id: string;
  customerId: string;
  status: OrderStatus;
  items: Array<OrderItemsItem>;
  totalAmount: number;
  shippingAddress?: OrderShippingAddress;
};
export type OrderItemsItem = {
  productId: string;
  quantity: number;
  price: number;
};
export type OrderShippingAddress = {
  street: string;
  city: string;
  country: string;
  zipCode?: string;
};
export type OrderStatus =
  | 'pending'
  | 'processing'
  | 'shipped'
  | 'delivered'
  | 'cancelled';

export type GetOrdersRequest = GetOrdersRequestQueryParameters;
export type GetOrdersError = never;
"
`;

exports[`openApiTsClientGenerator - arrays > should handle operation which returns an array of objects referenced from components 2`] = `
"import type {
  GetOrdersRequestQueryParameters,
  Order,
  OrderItemsItem,
  OrderShippingAddress,
  OrderStatus,
  GetOrdersRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static GetOrdersRequestQueryParameters = {
    toJson: (model: GetOrdersRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.customerId === undefined
          ? {}
          : {
              customerId: model.customerId,
            }),
        ...(model.status === undefined
          ? {}
          : {
              status: model.status,
            }),
        ...(model.limit === undefined
          ? {}
          : {
              limit: model.limit,
            }),
      };
    },
    fromJson: (json: any): GetOrdersRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['customerId'] === undefined
          ? {}
          : {
              customerId: json['customerId'],
            }),
        ...(json['status'] === undefined
          ? {}
          : {
              status: json['status'],
            }),
        ...(json['limit'] === undefined
          ? {}
          : {
              limit: json['limit'],
            }),
      };
    },
  };

  public static Order = {
    toJson: (model: Order): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.id === undefined
          ? {}
          : {
              id: model.id,
            }),
        ...(model.customerId === undefined
          ? {}
          : {
              customerId: model.customerId,
            }),
        ...(model.status === undefined
          ? {}
          : {
              status: model.status,
            }),
        ...(model.items === undefined
          ? {}
          : {
              items: model.items.map($IO.OrderItemsItem.toJson),
            }),
        ...(model.totalAmount === undefined
          ? {}
          : {
              totalAmount: model.totalAmount,
            }),
        ...(model.shippingAddress === undefined
          ? {}
          : {
              shippingAddress: $IO.OrderShippingAddress.toJson(
                model.shippingAddress,
              ),
            }),
      };
    },
    fromJson: (json: any): Order => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        id: json['id'],
        customerId: json['customerId'],
        status: json['status'],
        items: (json['items'] as Array<any>).map($IO.OrderItemsItem.fromJson),
        totalAmount: json['totalAmount'],
        ...(json['shippingAddress'] === undefined
          ? {}
          : {
              shippingAddress: $IO.OrderShippingAddress.fromJson(
                json['shippingAddress'],
              ),
            }),
      };
    },
  };

  public static OrderItemsItem = {
    toJson: (model: OrderItemsItem): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.productId === undefined
          ? {}
          : {
              productId: model.productId,
            }),
        ...(model.quantity === undefined
          ? {}
          : {
              quantity: model.quantity,
            }),
        ...(model.price === undefined
          ? {}
          : {
              price: model.price,
            }),
      };
    },
    fromJson: (json: any): OrderItemsItem => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        productId: json['productId'],
        quantity: json['quantity'],
        price: json['price'],
      };
    },
  };

  public static OrderShippingAddress = {
    toJson: (model: OrderShippingAddress): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.street === undefined
          ? {}
          : {
              street: model.street,
            }),
        ...(model.city === undefined
          ? {}
          : {
              city: model.city,
            }),
        ...(model.country === undefined
          ? {}
          : {
              country: model.country,
            }),
        ...(model.zipCode === undefined
          ? {}
          : {
              zipCode: model.zipCode,
            }),
      };
    },
    fromJson: (json: any): OrderShippingAddress => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        street: json['street'],
        city: json['city'],
        country: json['country'],
        ...(json['zipCode'] === undefined
          ? {}
          : {
              zipCode: json['zipCode'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.getOrders = this.getOrders.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  /**
   * Get orders using referenced component schema
   */
  public async getOrders(input: GetOrdersRequest): Promise<Array<Order>> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } =
      $IO.GetOrdersRequestQueryParameters.toJson(input);
    const headerParameters: { [key: string]: any } = {};
    const collectionFormats = {
      customerId: 'multi',
      status: 'multi',
      limit: 'multi',
    } as const;

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/orders', pathParameters, queryParameters, collectionFormats),
      {
        headers: this.$headers(headerParameters, collectionFormats),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return ((await response.json()) as Array<any>).map($IO.Order.fromJson);
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - arrays > should handle operation which returns an array of strings 1`] = `
"/**
 * Get an array of category names
 */
export type GetCategoriesRequestQueryParameters = {
  filter?: string;
};

export type GetCategoriesRequest = GetCategoriesRequestQueryParameters;
export type GetCategoriesError = never;
"
`;

exports[`openApiTsClientGenerator - arrays > should handle operation which returns an array of strings 2`] = `
"import type {
  GetCategoriesRequestQueryParameters,
  GetCategoriesRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static GetCategoriesRequestQueryParameters = {
    toJson: (model: GetCategoriesRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.filter === undefined
          ? {}
          : {
              filter: model.filter,
            }),
      };
    },
    fromJson: (json: any): GetCategoriesRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['filter'] === undefined
          ? {}
          : {
              filter: json['filter'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.getCategories = this.getCategories.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  /**
   * Get an array of category names
   */
  public async getCategories(
    input: GetCategoriesRequest,
  ): Promise<Array<string>> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } =
      $IO.GetCategoriesRequestQueryParameters.toJson(input);
    const headerParameters: { [key: string]: any } = {};
    const collectionFormats = {
      filter: 'multi',
    } as const;

    const body = undefined;

    const response = await this.$fetch(
      this.$url(
        '/get-categories',
        pathParameters,
        queryParameters,
        collectionFormats,
      ),
      {
        headers: this.$headers(headerParameters, collectionFormats),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return await response.json();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;
