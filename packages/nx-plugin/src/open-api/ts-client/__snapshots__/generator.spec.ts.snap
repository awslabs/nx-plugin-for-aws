// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`openApiTsClientGenerator > should allow duplicate operation ids discriminated by multiple tags 1`] = `
"export type ItemsStockListError = never;
export type UsersPeopleListError = never;
"
`;

exports[`openApiTsClientGenerator > should allow duplicate operation ids discriminated by multiple tags 2`] = `
"/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  private _itemsStockList = async (): Promise<Array<string>> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/items', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return (await response.json()) as Array<string>;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  private _usersPeopleList = async (): Promise<Array<string>> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/users', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return (await response.json()) as Array<string>;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  /**
   * items operations
   */
  public items = {
    list: this._itemsStockList,
  };

  /**
   * stock operations
   */
  public stock = {
    list: this._itemsStockList,
  };

  /**
   * users operations
   */
  public users = {
    list: this._usersPeopleList,
  };

  /**
   * people operations
   */
  public people = {
    list: this._usersPeopleList,
  };
}
"
`;

exports[`openApiTsClientGenerator > should allow duplicate operation ids discriminated by tag 1`] = `
"export type ItemsListError = never;
export type UsersListError = never;
"
`;

exports[`openApiTsClientGenerator > should allow duplicate operation ids discriminated by tag 2`] = `
"/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  private _itemsList = async (): Promise<Array<string>> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/items', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return (await response.json()) as Array<string>;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  private _usersList = async (): Promise<Array<string>> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/users', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return (await response.json()) as Array<string>;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  /**
   * items operations
   */
  public items = {
    list: this._itemsList,
  };

  /**
   * users operations
   */
  public users = {
    list: this._usersList,
  };
}
"
`;

exports[`openApiTsClientGenerator > should generate valid TypeScript for arrays and dictionaries 1`] = `
"export type PostTest200ResponseItem = {
  id: string;
  tags?: Array<string>;
};
export type PostTestRequestContent = {
  stringArray?: Array<string>;
  numberArray?: Array<number>;
  stringDict?: { [key: string]: string };
  complexDict?: { [key: string]: PostTestRequestContentComplexDictValue };
};
export type PostTestRequestContentComplexDictValue = {
  name: string;
  value: number;
};

export type PostTestRequest = PostTestRequestContent | undefined;
export type PostTestError = never;
"
`;

exports[`openApiTsClientGenerator > should generate valid TypeScript for arrays and dictionaries 2`] = `
"import type {
  PostTest200ResponseItem,
  PostTestRequestContent,
  PostTestRequestContentComplexDictValue,
  PostTestRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostTest200ResponseItem = {
    toJson: (model: PostTest200ResponseItem): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.id === undefined
          ? {}
          : {
              id: model.id,
            }),
        ...(model.tags === undefined
          ? {}
          : {
              tags: model.tags,
            }),
      };
    },
    fromJson: (json: any): PostTest200ResponseItem => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        id: json['id'],
        ...(json['tags'] === undefined
          ? {}
          : {
              tags: json['tags'],
            }),
      };
    },
  };

  public static PostTestRequestContent = {
    toJson: (model: PostTestRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.stringArray === undefined
          ? {}
          : {
              stringArray: model.stringArray,
            }),
        ...(model.numberArray === undefined
          ? {}
          : {
              numberArray: model.numberArray,
            }),
        ...(model.stringDict === undefined
          ? {}
          : {
              stringDict: model.stringDict,
            }),
        ...(model.complexDict === undefined
          ? {}
          : {
              complexDict: $IO.mapValues(
                model.complexDict,
                $IO.PostTestRequestContentComplexDictValue.toJson,
              ),
            }),
      };
    },
    fromJson: (json: any): PostTestRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['stringArray'] === undefined
          ? {}
          : {
              stringArray: json['stringArray'],
            }),
        ...(json['numberArray'] === undefined
          ? {}
          : {
              numberArray: json['numberArray'],
            }),
        ...(json['stringDict'] === undefined
          ? {}
          : {
              stringDict: json['stringDict'],
            }),
        ...(json['complexDict'] === undefined
          ? {}
          : {
              complexDict: $IO.mapValues(
                json['complexDict'],
                $IO.PostTestRequestContentComplexDictValue.fromJson,
              ),
            }),
      };
    },
  };

  public static PostTestRequestContentComplexDictValue = {
    toJson: (model: PostTestRequestContentComplexDictValue): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.name === undefined
          ? {}
          : {
              name: model.name,
            }),
        ...(model.value === undefined
          ? {}
          : {
              value: model.value,
            }),
      };
    },
    fromJson: (json: any): PostTestRequestContentComplexDictValue => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        name: json['name'],
        value: json['value'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public postTest = async (
    input?: PostTestRequest,
  ): Promise<Array<PostTest200ResponseItem>> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.PostTestRequestContent.toJson(input))
          : String($IO.PostTestRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return (await response.json()).map($IO.PostTest200ResponseItem.fromJson);
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;

exports[`openApiTsClientGenerator > should generate valid TypeScript for composite types 1`] = `
"export type PutTest200Response = PutTest200ResponseAllOf &
  PutTest200ResponseAllOf1;
export type PutTest200ResponseAllOf = {
  id: string;
};
export type PutTest200ResponseAllOf1 = {
  metadata?: PutTest200ResponseAllOf1Metadata;
};
export type PutTest200ResponseAllOf1Metadata = {
  created?: Date;
};
export type PutTestRequestContent =
  | PutTestRequestContentOneOf
  | PutTestRequestContentOneOf1;
export type PutTestRequestContentOneOf = {
  type: PutTestRequestContentOneOfType;
  valueA: string;
};
export type PutTestRequestContentOneOf1 = {
  type: PutTestRequestContentOneOf1Type;
  valueB: number;
};
export type PutTestRequestContentOneOf1Type = 'b';
export type PutTestRequestContentOneOfType = 'a';

export type PutTestRequest = PutTestRequestContent | undefined;
export type PutTestError = never;
"
`;

exports[`openApiTsClientGenerator > should generate valid TypeScript for composite types 2`] = `
"import type {
  PutTest200Response,
  PutTest200ResponseAllOf,
  PutTest200ResponseAllOf1,
  PutTest200ResponseAllOf1Metadata,
  PutTestRequestContent,
  PutTestRequestContentOneOf,
  PutTestRequestContentOneOf1,
  PutTestRequestContentOneOf1Type,
  PutTestRequestContentOneOfType,
  PutTestRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PutTest200Response = {
    toJson: (model: PutTest200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.PutTest200ResponseAllOf.toJson(model),
        ...$IO.PutTest200ResponseAllOf1.toJson(model),
      };
    },
    fromJson: (json: any): PutTest200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.PutTest200ResponseAllOf.fromJson(json),
        ...$IO.PutTest200ResponseAllOf1.fromJson(json),
      };
    },
  };

  public static PutTest200ResponseAllOf = {
    toJson: (model: PutTest200ResponseAllOf): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.id === undefined
          ? {}
          : {
              id: model.id,
            }),
      };
    },
    fromJson: (json: any): PutTest200ResponseAllOf => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        id: json['id'],
      };
    },
  };

  public static PutTest200ResponseAllOf1 = {
    toJson: (model: PutTest200ResponseAllOf1): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.metadata === undefined
          ? {}
          : {
              metadata: $IO.PutTest200ResponseAllOf1Metadata.toJson(
                model.metadata,
              ),
            }),
      };
    },
    fromJson: (json: any): PutTest200ResponseAllOf1 => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['metadata'] === undefined
          ? {}
          : {
              metadata: $IO.PutTest200ResponseAllOf1Metadata.fromJson(
                json['metadata'],
              ),
            }),
      };
    },
  };

  public static PutTest200ResponseAllOf1Metadata = {
    toJson: (model: PutTest200ResponseAllOf1Metadata): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.created === undefined
          ? {}
          : {
              created: model.created.toISOString(),
            }),
      };
    },
    fromJson: (json: any): PutTest200ResponseAllOf1Metadata => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['created'] === undefined
          ? {}
          : {
              created: new Date(json['created']),
            }),
      };
    },
  };

  public static PutTestRequestContent = {
    toJson: (model: PutTestRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.PutTestRequestContentOneOf.toJson(
          model as PutTestRequestContentOneOf,
        ),
        ...$IO.PutTestRequestContentOneOf1.toJson(
          model as PutTestRequestContentOneOf1,
        ),
      };
    },
    fromJson: (json: any): PutTestRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.PutTestRequestContentOneOf.fromJson(json),
        ...$IO.PutTestRequestContentOneOf1.fromJson(json),
      };
    },
  };

  public static PutTestRequestContentOneOf = {
    toJson: (model: PutTestRequestContentOneOf): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.type === undefined
          ? {}
          : {
              type: model.type,
            }),
        ...(model.valueA === undefined
          ? {}
          : {
              valueA: model.valueA,
            }),
      };
    },
    fromJson: (json: any): PutTestRequestContentOneOf => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        type: json['type'],
        valueA: json['valueA'],
      };
    },
  };

  public static PutTestRequestContentOneOf1 = {
    toJson: (model: PutTestRequestContentOneOf1): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.type === undefined
          ? {}
          : {
              type: model.type,
            }),
        ...(model.valueB === undefined
          ? {}
          : {
              valueB: model.valueB,
            }),
      };
    },
    fromJson: (json: any): PutTestRequestContentOneOf1 => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        type: json['type'],
        valueB: json['valueB'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public putTest = async (
    input?: PutTestRequest,
  ): Promise<PutTest200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.PutTestRequestContent.toJson(input))
          : String($IO.PutTestRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'PUT',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.PutTest200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;

exports[`openApiTsClientGenerator > should generate valid TypeScript for parameters and responses 1`] = `
"export type GetTest200Response = {
  result?: string;
};
export type GetTest400Response = {
  error?: string;
};
export type GetTestRequestHeaderParameters = {
  xApiKey: string;
};
export type GetTestRequestPathParameters = {
  id: string;
};
export type GetTestRequestQueryParameters = {
  filter?: string;
  tags?: Array<string>;
};

export type GetTestRequest = GetTestRequestPathParameters &
  GetTestRequestHeaderParameters &
  GetTestRequestQueryParameters;
export type GetTest400Error = {
  status: 400;
  error: GetTest400Response;
};
export type GetTest404Error = {
  status: 404;
  error: void;
};
export type GetTestError = GetTest400Error | GetTest404Error;
"
`;

exports[`openApiTsClientGenerator > should generate valid TypeScript for parameters and responses 2`] = `
"import type {
  GetTest200Response,
  GetTest400Response,
  GetTestRequestHeaderParameters,
  GetTestRequestPathParameters,
  GetTestRequestQueryParameters,
  GetTestRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static GetTest200Response = {
    toJson: (model: GetTest200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.result === undefined
          ? {}
          : {
              result: model.result,
            }),
      };
    },
    fromJson: (json: any): GetTest200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['result'] === undefined
          ? {}
          : {
              result: json['result'],
            }),
      };
    },
  };

  public static GetTest400Response = {
    toJson: (model: GetTest400Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.error === undefined
          ? {}
          : {
              error: model.error,
            }),
      };
    },
    fromJson: (json: any): GetTest400Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['error'] === undefined
          ? {}
          : {
              error: json['error'],
            }),
      };
    },
  };

  public static GetTestRequestHeaderParameters = {
    toJson: (model: GetTestRequestHeaderParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.xApiKey === undefined
          ? {}
          : {
              'x-api-key': model.xApiKey,
            }),
      };
    },
    fromJson: (json: any): GetTestRequestHeaderParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        xApiKey: json['x-api-key'],
      };
    },
  };

  public static GetTestRequestPathParameters = {
    toJson: (model: GetTestRequestPathParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.id === undefined
          ? {}
          : {
              id: model.id,
            }),
      };
    },
    fromJson: (json: any): GetTestRequestPathParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        id: json['id'],
      };
    },
  };

  public static GetTestRequestQueryParameters = {
    toJson: (model: GetTestRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.filter === undefined
          ? {}
          : {
              filter: model.filter,
            }),
        ...(model.tags === undefined
          ? {}
          : {
              tags: model.tags,
            }),
      };
    },
    fromJson: (json: any): GetTestRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['filter'] === undefined
          ? {}
          : {
              filter: json['filter'],
            }),
        ...(json['tags'] === undefined
          ? {}
          : {
              tags: json['tags'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public getTest = async (
    input: GetTestRequest,
  ): Promise<GetTest200Response> => {
    const pathParameters = $IO.GetTestRequestPathParameters.toJson(input);
    const queryParameters = $IO.GetTestRequestQueryParameters.toJson(input);
    const headerParameters = $IO.GetTestRequestHeaderParameters.toJson(input);
    const collectionFormats = {
      'x-api-key': 'csv',
      filter: 'multi',
      tags: 'multi',
    } as const;

    const body = undefined;

    const response = await this.$fetch(
      this.$url(
        '/test/{id}',
        pathParameters,
        queryParameters,
        collectionFormats,
      ),
      {
        headers: this.$headers(headerParameters, collectionFormats),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.GetTest200Response.fromJson(await response.json());
    }
    if (response.status === 400) {
      throw {
        status: response.status,
        error: $IO.GetTest400Response.fromJson(await response.json()),
      };
    }
    if (response.status === 404) {
      throw {
        status: response.status,
      };
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;

exports[`openApiTsClientGenerator > should generate valid TypeScript for primitive types 1`] = `
"export type GetTest200Response = {
  string: string;
  number: number;
  integer: number;
  boolean: boolean;
  nullableString?: string | null;
  optionalNumber?: number;
};
export type GetTestError = never;
"
`;

exports[`openApiTsClientGenerator > should generate valid TypeScript for primitive types 2`] = `
"import type { GetTest200Response } from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static GetTest200Response = {
    toJson: (model: GetTest200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.string === undefined
          ? {}
          : {
              string: model.string,
            }),
        ...(model.number === undefined
          ? {}
          : {
              number: model.number,
            }),
        ...(model.integer === undefined
          ? {}
          : {
              integer: model.integer,
            }),
        ...(model.boolean === undefined
          ? {}
          : {
              boolean: model.boolean,
            }),
        ...(model.nullableString === undefined
          ? {}
          : {
              'nullable-string': model.nullableString,
            }),
        ...(model.optionalNumber === undefined
          ? {}
          : {
              optionalNumber: model.optionalNumber,
            }),
      };
    },
    fromJson: (json: any): GetTest200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        string: json['string'],
        number: json['number'],
        integer: json['integer'],
        boolean: json['boolean'],
        ...(json['nullable-string'] === undefined
          ? {}
          : {
              nullableString:
                json['nullable-string'] === null
                  ? null
                  : json['nullable-string'],
            }),
        ...(json['optionalNumber'] === undefined
          ? {}
          : {
              optionalNumber: json['optionalNumber'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  /**
   * Sends a test request!
   */
  public getTest = async (): Promise<GetTest200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.GetTest200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle composite primitive and array request bodies 1`] = `
"export type CompositeRequestContent =
  | string
  | number
  | boolean
  | Array<string>
  | Array<CompositeRequestContentOneOf1Item>
  | { [key: string]: number }
  | { [key: string]: CompositeRequestContentOneOf3Value }
  | CompositeRequestContentOneOf4;
export type CompositeRequestContentOneOf1Item = {
  a?: string;
};
export type CompositeRequestContentOneOf3Value = {
  a?: string;
};
export type CompositeRequestContentOneOf4 = null | {
  key?: string;
};

export type CompositeRequest = CompositeRequestContent | undefined;
export type CompositeError = never;
"
`;

exports[`openApiTsClientGenerator > should handle composite primitive and array request bodies 2`] = `
"import type {
  CompositeRequestContent,
  CompositeRequestContentOneOf1Item,
  CompositeRequestContentOneOf3Value,
  CompositeRequestContentOneOf4,
  CompositeRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static CompositeRequestContent = {
    toJson: (model: CompositeRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      if (typeof model === 'string') {
        return model;
      }
      if (typeof model === 'number') {
        return model;
      }
      if (typeof model === 'boolean') {
        return model;
      }
      if (
        Array.isArray(model) &&
        (model.length === 0 || typeof model[0] !== 'object')
      ) {
        return model;
      }
      if (
        Array.isArray(model) &&
        (model.length === 0 || typeof model[0] === 'object')
      ) {
        return model === null
          ? null
          : model.map($IO.CompositeRequestContentOneOf1Item.toJson);
      }
      return {
        ...(model === null ? null : model),
        ...(model === null
          ? null
          : $IO.mapValues(
              model,
              $IO.CompositeRequestContentOneOf3Value.toJson,
            )),
        ...$IO.CompositeRequestContentOneOf4.toJson(
          model as CompositeRequestContentOneOf4,
        ),
      };
    },
    fromJson: (json: any): CompositeRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      if (typeof json === 'string') {
        return json;
      }
      if (typeof json === 'number') {
        return json;
      }
      if (typeof json === 'boolean') {
        return json;
      }
      if (
        Array.isArray(json) &&
        (json.length === 0 || typeof json[0] !== 'object')
      ) {
        return json;
      }
      if (
        Array.isArray(json) &&
        (json.length === 0 || typeof json[0] === 'object')
      ) {
        return json === null
          ? null
          : (json as Array<any>).map(
              $IO.CompositeRequestContentOneOf1Item.fromJson,
            );
      }
      return {
        ...(json === null ? null : json),
        ...(json === null
          ? null
          : $IO.mapValues(
              json,
              $IO.CompositeRequestContentOneOf3Value.fromJson,
            )),
        ...$IO.CompositeRequestContentOneOf4.fromJson(json),
      };
    },
  };

  public static CompositeRequestContentOneOf1Item = {
    toJson: (model: CompositeRequestContentOneOf1Item): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.a === undefined
          ? {}
          : {
              a: model.a,
            }),
      };
    },
    fromJson: (json: any): CompositeRequestContentOneOf1Item => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['a'] === undefined
          ? {}
          : {
              a: json['a'],
            }),
      };
    },
  };

  public static CompositeRequestContentOneOf3Value = {
    toJson: (model: CompositeRequestContentOneOf3Value): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.a === undefined
          ? {}
          : {
              a: model.a,
            }),
      };
    },
    fromJson: (json: any): CompositeRequestContentOneOf3Value => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['a'] === undefined
          ? {}
          : {
              a: json['a'],
            }),
      };
    },
  };

  public static CompositeRequestContentOneOf4 = {
    toJson: (model: CompositeRequestContentOneOf4): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.key === undefined
          ? {}
          : {
              key: model.key,
            }),
      };
    },
    fromJson: (json: any): CompositeRequestContentOneOf4 => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['key'] === undefined
          ? {}
          : {
              key: json['key'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public composite = async (input?: CompositeRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.CompositeRequestContent.toJson(input))
          : String($IO.CompositeRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/composite', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle date and date-time formats 1`] = `
"export type PostDates200Response = {
  processedDate?: Date;
  processedDateTime?: Date;
};
export type PostDatesRequestContent = {
  dateOnly: Date;
  dateTime: Date;
  dateArray?: Array<Date>;
  dateTimeArray?: Array<Date>;
};

export type PostDatesRequest = PostDatesRequestContent | undefined;
export type PostDatesError = never;

export type PostSingleDateRequest = Date;
export type PostSingleDateError = never;
"
`;

exports[`openApiTsClientGenerator > should handle date and date-time formats 2`] = `
"import type {
  PostDates200Response,
  PostDatesRequestContent,
  PostDatesRequest,
  PostSingleDateRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostDates200Response = {
    toJson: (model: PostDates200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.processedDate === undefined
          ? {}
          : {
              processedDate: model.processedDate.toISOString().slice(0, 10),
            }),
        ...(model.processedDateTime === undefined
          ? {}
          : {
              processedDateTime: model.processedDateTime.toISOString(),
            }),
      };
    },
    fromJson: (json: any): PostDates200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['processedDate'] === undefined
          ? {}
          : {
              processedDate: new Date(json['processedDate']),
            }),
        ...(json['processedDateTime'] === undefined
          ? {}
          : {
              processedDateTime: new Date(json['processedDateTime']),
            }),
      };
    },
  };

  public static PostDatesRequestContent = {
    toJson: (model: PostDatesRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.dateOnly === undefined
          ? {}
          : {
              dateOnly: model.dateOnly.toISOString().slice(0, 10),
            }),
        ...(model.dateTime === undefined
          ? {}
          : {
              dateTime: model.dateTime.toISOString(),
            }),
        ...(model.dateArray === undefined
          ? {}
          : {
              dateArray: model.dateArray.map((item0) =>
                item0.toISOString().slice(0, 10),
              ),
            }),
        ...(model.dateTimeArray === undefined
          ? {}
          : {
              dateTimeArray: model.dateTimeArray.map((item0) =>
                item0.toISOString(),
              ),
            }),
      };
    },
    fromJson: (json: any): PostDatesRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        dateOnly: new Date(json['dateOnly']),
        dateTime: new Date(json['dateTime']),
        ...(json['dateArray'] === undefined
          ? {}
          : {
              dateArray: (json['dateArray'] as Array<any>).map(
                (item0) => new Date(item0),
              ),
            }),
        ...(json['dateTimeArray'] === undefined
          ? {}
          : {
              dateTimeArray: (json['dateTimeArray'] as Array<any>).map(
                (item0) => new Date(item0),
              ),
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public postDates = async (
    input?: PostDatesRequest,
  ): Promise<PostDates200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.PostDatesRequestContent.toJson(input))
          : String($IO.PostDatesRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/dates', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.PostDates200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public postSingleDate = async (
    input: PostSingleDateRequest,
  ): Promise<Date> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input.toISOString().slice(0, 10);

    const response = await this.$fetch(
      this.$url('/single-date', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return new Date(await response.text());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle default responses 1`] = `
"export type GetTest200Response = {
  message: string;
};
export type GetTestdefaultResponse = {
  error: string;
};
export type GetTestDefaultError = {
  status: number;
  error: GetTestdefaultResponse;
};
export type GetTestError = GetTestDefaultError;
"
`;

exports[`openApiTsClientGenerator > should handle default responses 2`] = `
"import type {
  GetTest200Response,
  GetTestdefaultResponse,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static GetTest200Response = {
    toJson: (model: GetTest200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.message === undefined
          ? {}
          : {
              message: model.message,
            }),
      };
    },
    fromJson: (json: any): GetTest200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        message: json['message'],
      };
    },
  };

  public static GetTestdefaultResponse = {
    toJson: (model: GetTestdefaultResponse): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.error === undefined
          ? {}
          : {
              error: model.error,
            }),
      };
    },
    fromJson: (json: any): GetTestdefaultResponse => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        error: json['error'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public getTest = async (): Promise<GetTest200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.GetTest200Response.fromJson(await response.json());
    }
    throw {
      status: response.status,
      error: $IO.GetTestdefaultResponse.fromJson(await response.json()),
    };
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle enum request and response bodies 1`] = `
"export type UpdateStatus200Response = 'accepted' | 'rejected';
export type UpdateStatusRequestContent =
  | 'pending'
  | 'in_progress'
  | 'completed'
  | 'failed';

export type UpdateStatusRequest = UpdateStatusRequestContent;
export type UpdateStatusError = never;
"
`;

exports[`openApiTsClientGenerator > should handle enum request and response bodies 2`] = `
"import type {
  UpdateStatus200Response,
  UpdateStatusRequestContent,
  UpdateStatusRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public updateStatus = async (
    input: UpdateStatusRequest,
  ): Promise<UpdateStatus200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input;

    const response = await this.$fetch(
      this.$url('/status', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return (await response.text()) as UpdateStatus200Response;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle inline primitives and composite schemas 1`] = `
"export type TestArrays200Response = {
  [key: string]: number;
};
export type TestArraysWithOtherParameters200Response = {
  [key: string]: number;
};
export type TestArraysWithOtherParametersRequestBodyParameters = {
  body?: Array<string>;
};
export type TestArraysWithOtherParametersRequestQueryParameters = {
  someParameter?: string;
};
export type TestComposites200Response =
  | TestComposites200ResponseAnyOf
  | TestComposites200ResponseAnyOf1;
export type TestComposites200ResponseAnyOf = {
  foo?: string;
};
export type TestComposites200ResponseAnyOf1 = {
  bar?: string;
};
export type TestCompositesRequestContent =
  | TestCompositesRequestContentOneOf
  | string;
export type TestCompositesRequestContentOneOf = 'a' | 'b' | 'c';
export type TestEnums200Response = 'pending' | 'active' | 'completed';

export type TestArraysRequest = Array<string> | undefined;
export type TestArraysError = never;

export type TestArraysWithOtherParametersRequest =
  TestArraysWithOtherParametersRequestQueryParameters &
    TestArraysWithOtherParametersRequestBodyParameters;
export type TestArraysWithOtherParametersError = never;

export type TestCompositesRequest = TestCompositesRequestContent | undefined;
export type TestCompositesError = never;
export type TestEnumsError = never;

export type TestPrimitiveBinaryRequest = Blob;
export type TestPrimitiveBinaryError = never;

export type TestPrimitiveTextRequest = string;
export type TestPrimitiveTextError = never;
"
`;

exports[`openApiTsClientGenerator > should handle inline primitives and composite schemas 2`] = `
"import type {
  TestArrays200Response,
  TestArraysWithOtherParameters200Response,
  TestArraysWithOtherParametersRequestBodyParameters,
  TestArraysWithOtherParametersRequestQueryParameters,
  TestComposites200Response,
  TestComposites200ResponseAnyOf,
  TestComposites200ResponseAnyOf1,
  TestCompositesRequestContent,
  TestCompositesRequestContentOneOf,
  TestEnums200Response,
  TestArraysRequest,
  TestArraysWithOtherParametersRequest,
  TestCompositesRequest,
  TestPrimitiveBinaryRequest,
  TestPrimitiveTextRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static TestArrays200Response = {
    toJson: (model: TestArrays200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): TestArrays200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static TestArraysWithOtherParameters200Response = {
    toJson: (model: TestArraysWithOtherParameters200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): TestArraysWithOtherParameters200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static TestArraysWithOtherParametersRequestBodyParameters = {
    toJson: (
      model: TestArraysWithOtherParametersRequestBodyParameters,
    ): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.body === undefined
          ? {}
          : {
              body: model.body,
            }),
      };
    },
    fromJson: (
      json: any,
    ): TestArraysWithOtherParametersRequestBodyParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['body'] === undefined
          ? {}
          : {
              body: json['body'],
            }),
      };
    },
  };

  public static TestArraysWithOtherParametersRequestQueryParameters = {
    toJson: (
      model: TestArraysWithOtherParametersRequestQueryParameters,
    ): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.someParameter === undefined
          ? {}
          : {
              someParameter: model.someParameter,
            }),
      };
    },
    fromJson: (
      json: any,
    ): TestArraysWithOtherParametersRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['someParameter'] === undefined
          ? {}
          : {
              someParameter: json['someParameter'],
            }),
      };
    },
  };

  public static TestComposites200Response = {
    toJson: (model: TestComposites200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.TestComposites200ResponseAnyOf.toJson(
          model as TestComposites200ResponseAnyOf,
        ),
        ...$IO.TestComposites200ResponseAnyOf1.toJson(
          model as TestComposites200ResponseAnyOf1,
        ),
      };
    },
    fromJson: (json: any): TestComposites200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.TestComposites200ResponseAnyOf.fromJson(json),
        ...$IO.TestComposites200ResponseAnyOf1.fromJson(json),
      };
    },
  };

  public static TestComposites200ResponseAnyOf = {
    toJson: (model: TestComposites200ResponseAnyOf): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.foo === undefined
          ? {}
          : {
              foo: model.foo,
            }),
      };
    },
    fromJson: (json: any): TestComposites200ResponseAnyOf => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['foo'] === undefined
          ? {}
          : {
              foo: json['foo'],
            }),
      };
    },
  };

  public static TestComposites200ResponseAnyOf1 = {
    toJson: (model: TestComposites200ResponseAnyOf1): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.bar === undefined
          ? {}
          : {
              bar: model.bar,
            }),
      };
    },
    fromJson: (json: any): TestComposites200ResponseAnyOf1 => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['bar'] === undefined
          ? {}
          : {
              bar: json['bar'],
            }),
      };
    },
  };

  public static TestCompositesRequestContent = {
    toJson: (model: TestCompositesRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      if (typeof model === 'string') {
        return model;
      }
      if (typeof model === 'string') {
        return model;
      }
      return model;
    },
    fromJson: (json: any): TestCompositesRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      if (typeof json === 'string') {
        return json;
      }
      if (typeof json === 'string') {
        return json;
      }
      return json;
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public testArrays = async (
    input?: TestArraysRequest,
  ): Promise<TestArrays200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify(input)
          : String(input);

    const response = await this.$fetch(
      this.$url('/arrays', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.TestArrays200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public testArraysWithOtherParameters = async (
    input: TestArraysWithOtherParametersRequest,
  ): Promise<TestArraysWithOtherParameters200Response> => {
    const pathParameters = {};
    const queryParameters =
      $IO.TestArraysWithOtherParametersRequestQueryParameters.toJson(input);
    const headerParameters = {};
    const collectionFormats = {
      someParameter: 'multi',
    } as const;
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify(
              $IO.TestArraysWithOtherParametersRequestBodyParameters.toJson(
                input,
              ).body,
            )
          : String(
              $IO.TestArraysWithOtherParametersRequestBodyParameters.toJson(
                input,
              ).body,
            );

    const response = await this.$fetch(
      this.$url(
        '/arrays-with-other-parameters',
        pathParameters,
        queryParameters,
        collectionFormats,
      ),
      {
        headers: this.$headers(headerParameters, collectionFormats),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.TestArraysWithOtherParameters200Response.fromJson(
        await response.json(),
      );
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public testComposites = async (
    input?: TestCompositesRequest,
  ): Promise<TestComposites200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.TestCompositesRequestContent.toJson(input))
          : String($IO.TestCompositesRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/composites', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.TestComposites200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public testEnums = async (): Promise<TestEnums200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/enums', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return (await response.text()) as TestEnums200Response;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public testPrimitiveBinary = async (
    input: TestPrimitiveBinaryRequest,
  ): Promise<Blob> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input;

    const response = await this.$fetch(
      this.$url('/primitives/binary', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.blob();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public testPrimitiveText = async (
    input: TestPrimitiveTextRequest,
  ): Promise<number> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = String(input);

    const response = await this.$fetch(
      this.$url('/primitives/text', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return Number(await response.text());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle multiple response status codes 1`] = `
"export type TestResponses2XXResponse = {
  result?: string;
};
export type TestResponses500Response = {
  reason?: string;
};
export type TestResponses5XXResponse = {
  error?: string;
  trace?: string;
};
export type TestResponsesRequestContent = {
  data?: string;
};

export type TestResponsesRequest = TestResponsesRequestContent | undefined;
export type TestResponses500Error = {
  status: 500;
  error: TestResponses500Response;
};
export type TestResponses5XXError = {
  status: _5XX;
  error: TestResponses5XXResponse;
};
export type TestResponsesError = TestResponses500Error | TestResponses5XXError;
export type _5XX =
  | 500
  | 501
  | 502
  | 503
  | 504
  | 505
  | 506
  | 507
  | 508
  | 509
  | 510
  | 511
  | 512
  | 513
  | 514
  | 515
  | 516
  | 517
  | 518
  | 519
  | 520
  | 521
  | 522
  | 523
  | 524
  | 525
  | 526
  | 527
  | 528
  | 529
  | 530
  | 531
  | 532
  | 533
  | 534
  | 535
  | 536
  | 537
  | 538
  | 539
  | 540
  | 541
  | 542
  | 543
  | 544
  | 545
  | 546
  | 547
  | 548
  | 549
  | 550
  | 551
  | 552
  | 553
  | 554
  | 555
  | 556
  | 557
  | 558
  | 559
  | 560
  | 561
  | 562
  | 563
  | 564
  | 565
  | 566
  | 567
  | 568
  | 569
  | 570
  | 571
  | 572
  | 573
  | 574
  | 575
  | 576
  | 577
  | 578
  | 579
  | 580
  | 581
  | 582
  | 583
  | 584
  | 585
  | 586
  | 587
  | 588
  | 589
  | 590
  | 591
  | 592
  | 593
  | 594
  | 595
  | 596
  | 597
  | 598
  | 599;
"
`;

exports[`openApiTsClientGenerator > should handle multiple response status codes 2`] = `
"import type {
  TestResponses2XXResponse,
  TestResponses500Response,
  TestResponses5XXResponse,
  TestResponsesRequestContent,
  TestResponsesRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static TestResponses2XXResponse = {
    toJson: (model: TestResponses2XXResponse): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.result === undefined
          ? {}
          : {
              result: model.result,
            }),
      };
    },
    fromJson: (json: any): TestResponses2XXResponse => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['result'] === undefined
          ? {}
          : {
              result: json['result'],
            }),
      };
    },
  };

  public static TestResponses500Response = {
    toJson: (model: TestResponses500Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.reason === undefined
          ? {}
          : {
              reason: model.reason,
            }),
      };
    },
    fromJson: (json: any): TestResponses500Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['reason'] === undefined
          ? {}
          : {
              reason: json['reason'],
            }),
      };
    },
  };

  public static TestResponses5XXResponse = {
    toJson: (model: TestResponses5XXResponse): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.error === undefined
          ? {}
          : {
              error: model.error,
            }),
        ...(model.trace === undefined
          ? {}
          : {
              trace: model.trace,
            }),
      };
    },
    fromJson: (json: any): TestResponses5XXResponse => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['error'] === undefined
          ? {}
          : {
              error: json['error'],
            }),
        ...(json['trace'] === undefined
          ? {}
          : {
              trace: json['trace'],
            }),
      };
    },
  };

  public static TestResponsesRequestContent = {
    toJson: (model: TestResponsesRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.data === undefined
          ? {}
          : {
              data: model.data,
            }),
      };
    },
    fromJson: (json: any): TestResponsesRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['data'] === undefined
          ? {}
          : {
              data: json['data'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public testResponses = async (
    input?: TestResponsesRequest,
  ): Promise<TestResponses2XXResponse> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.TestResponsesRequestContent.toJson(input))
          : String($IO.TestResponsesRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 500) {
      throw {
        status: response.status,
        error: $IO.TestResponses500Response.fromJson(await response.json()),
      };
    }
    if (response.status >= 200 && response.status < 300) {
      return $IO.TestResponses2XXResponse.fromJson(await response.json());
    }
    if (response.status >= 500 && response.status < 600) {
      throw {
        status: response.status,
        error: $IO.TestResponses5XXResponse.fromJson(await response.json()),
      };
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle not schema type 1`] = `
"export type TestNot200Response = {
  result?: string;
};
export type TestNotRequestContent = {
  notObject?: unknown;
  notString?: unknown;
};
export type TestNotRequestContentNotObjectNot = {
  foo?: string;
};

export type TestNotRequest = TestNotRequestContent | undefined;
export type TestNotError = never;
"
`;

exports[`openApiTsClientGenerator > should handle not schema type 2`] = `
"import type {
  TestNot200Response,
  TestNotRequestContent,
  TestNotRequestContentNotObjectNot,
  TestNotRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static TestNot200Response = {
    toJson: (model: TestNot200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.result === undefined
          ? {}
          : {
              result: model.result,
            }),
      };
    },
    fromJson: (json: any): TestNot200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['result'] === undefined
          ? {}
          : {
              result: json['result'],
            }),
      };
    },
  };

  public static TestNotRequestContent = {
    toJson: (model: TestNotRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.notObject === undefined
          ? {}
          : {
              notObject: model.notObject,
            }),
        ...(model.notString === undefined
          ? {}
          : {
              notString: model.notString,
            }),
      };
    },
    fromJson: (json: any): TestNotRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['notObject'] === undefined
          ? {}
          : {
              notObject: json['notObject'],
            }),
        ...(json['notString'] === undefined
          ? {}
          : {
              notString: json['notString'],
            }),
      };
    },
  };

  public static TestNotRequestContentNotObjectNot = {
    toJson: (model: TestNotRequestContentNotObjectNot): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.foo === undefined
          ? {}
          : {
              foo: model.foo,
            }),
      };
    },
    fromJson: (json: any): TestNotRequestContentNotObjectNot => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['foo'] === undefined
          ? {}
          : {
              foo: json['foo'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public testNot = async (
    input?: TestNotRequest,
  ): Promise<TestNot200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.TestNotRequestContent.toJson(input))
          : String($IO.TestNotRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/not', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.TestNot200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle nullable schemas in various contexts 1`] = `
"export type PostSingleNullableObjectRequestContent = null | {
  key?: string;
};
export type TestNullable200Response = {
  nullableString?: string | null;
  nullableNumber?: number | null;
  nullableInteger?: number | null;
  nullableBoolean?: boolean | null;
  nullableArray?: Array<string> | null;
  nullableObject?: TestNullable200ResponseNullableObject;
};
export type TestNullable200ResponseNullableObject = null | {
  key?: string;
};
export type TestNullableRequestContent = {
  nullableString?: string | null;
  nullableNumber?: number | null;
  nullableInteger?: number | null;
  nullableBoolean?: boolean | null;
  nullableArray?: Array<string> | null;
  nullableObject?: TestNullableRequestContentNullableObject;
  objectWithNullableProps?: TestNullableRequestContentObjectWithNullableProps;
};
export type TestNullableRequestContentNullableObject = null | {
  key?: string;
};
export type TestNullableRequestContentObjectWithNullableProps = {
  nullableString?: string | null;
  nullableNumber?: number | null;
  nullableInteger?: number | null;
  nullableBoolean?: boolean | null;
  nullableArray?: Array<string> | null;
  nullableObject?: TestNullableRequestContentObjectWithNullablePropsNullableObject;
};
export type TestNullableRequestContentObjectWithNullablePropsNullableObject =
  null | {
    key?: string;
  };
export type TestNullableRequestPathParameters = {
  pathParam: string | null;
};
export type TestNullableRequestQueryParameters = {
  queryString?: string | null;
  queryNumber?: number | null;
  queryInteger?: number | null;
  queryBoolean?: boolean | null;
  queryArray?: Array<string> | null;
  queryObject?: unknown | null;
};

export type PostSingleNullableArrayRequest = Array<string> | undefined;
export type PostSingleNullableArrayError = never;

export type PostSingleNullableBooleanRequest = boolean | undefined;
export type PostSingleNullableBooleanError = never;

export type PostSingleNullableNumberRequest = number | undefined;
export type PostSingleNullableNumberError = never;

export type PostSingleNullableObjectRequest =
  | PostSingleNullableObjectRequestContent
  | undefined;
export type PostSingleNullableObjectError = never;

export type PostSingleNullableStringRequest = string | undefined;
export type PostSingleNullableStringError = never;

export type TestNullableRequest = TestNullableRequestPathParameters &
  TestNullableRequestQueryParameters &
  TestNullableRequestContent;
export type TestNullableError = never;
"
`;

exports[`openApiTsClientGenerator > should handle nullable schemas in various contexts 2`] = `
"import type {
  PostSingleNullableObjectRequestContent,
  TestNullable200Response,
  TestNullable200ResponseNullableObject,
  TestNullableRequestContent,
  TestNullableRequestContentNullableObject,
  TestNullableRequestContentObjectWithNullableProps,
  TestNullableRequestContentObjectWithNullablePropsNullableObject,
  TestNullableRequestPathParameters,
  TestNullableRequestQueryParameters,
  PostSingleNullableArrayRequest,
  PostSingleNullableBooleanRequest,
  PostSingleNullableNumberRequest,
  PostSingleNullableObjectRequest,
  PostSingleNullableStringRequest,
  TestNullableRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostSingleNullableObjectRequestContent = {
    toJson: (model: PostSingleNullableObjectRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.key === undefined
          ? {}
          : {
              key: model.key,
            }),
      };
    },
    fromJson: (json: any): PostSingleNullableObjectRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['key'] === undefined
          ? {}
          : {
              key: json['key'],
            }),
      };
    },
  };

  public static TestNullable200Response = {
    toJson: (model: TestNullable200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.nullableString === undefined
          ? {}
          : {
              nullableString: model.nullableString,
            }),
        ...(model.nullableNumber === undefined
          ? {}
          : {
              nullableNumber: model.nullableNumber,
            }),
        ...(model.nullableInteger === undefined
          ? {}
          : {
              nullableInteger: model.nullableInteger,
            }),
        ...(model.nullableBoolean === undefined
          ? {}
          : {
              nullableBoolean: model.nullableBoolean,
            }),
        ...(model.nullableArray === undefined
          ? {}
          : {
              nullableArray:
                model.nullableArray === null ? null : model.nullableArray,
            }),
        ...(model.nullableObject === undefined
          ? {}
          : {
              nullableObject: $IO.TestNullable200ResponseNullableObject.toJson(
                model.nullableObject,
              ),
            }),
      };
    },
    fromJson: (json: any): TestNullable200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['nullableString'] === undefined
          ? {}
          : {
              nullableString:
                json['nullableString'] === null ? null : json['nullableString'],
            }),
        ...(json['nullableNumber'] === undefined
          ? {}
          : {
              nullableNumber:
                json['nullableNumber'] === null ? null : json['nullableNumber'],
            }),
        ...(json['nullableInteger'] === undefined
          ? {}
          : {
              nullableInteger:
                json['nullableInteger'] === null
                  ? null
                  : json['nullableInteger'],
            }),
        ...(json['nullableBoolean'] === undefined
          ? {}
          : {
              nullableBoolean:
                json['nullableBoolean'] === null
                  ? null
                  : json['nullableBoolean'],
            }),
        ...(json['nullableArray'] === undefined
          ? {}
          : {
              nullableArray:
                json['nullableArray'] === null ? null : json['nullableArray'],
            }),
        ...(json['nullableObject'] === undefined
          ? {}
          : {
              nullableObject:
                $IO.TestNullable200ResponseNullableObject.fromJson(
                  json['nullableObject'],
                ),
            }),
      };
    },
  };

  public static TestNullable200ResponseNullableObject = {
    toJson: (model: TestNullable200ResponseNullableObject): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.key === undefined
          ? {}
          : {
              key: model.key,
            }),
      };
    },
    fromJson: (json: any): TestNullable200ResponseNullableObject => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['key'] === undefined
          ? {}
          : {
              key: json['key'],
            }),
      };
    },
  };

  public static TestNullableRequestContent = {
    toJson: (model: TestNullableRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.nullableString === undefined
          ? {}
          : {
              nullableString: model.nullableString,
            }),
        ...(model.nullableNumber === undefined
          ? {}
          : {
              nullableNumber: model.nullableNumber,
            }),
        ...(model.nullableInteger === undefined
          ? {}
          : {
              nullableInteger: model.nullableInteger,
            }),
        ...(model.nullableBoolean === undefined
          ? {}
          : {
              nullableBoolean: model.nullableBoolean,
            }),
        ...(model.nullableArray === undefined
          ? {}
          : {
              nullableArray:
                model.nullableArray === null ? null : model.nullableArray,
            }),
        ...(model.nullableObject === undefined
          ? {}
          : {
              nullableObject:
                $IO.TestNullableRequestContentNullableObject.toJson(
                  model.nullableObject,
                ),
            }),
        ...(model.objectWithNullableProps === undefined
          ? {}
          : {
              objectWithNullableProps:
                $IO.TestNullableRequestContentObjectWithNullableProps.toJson(
                  model.objectWithNullableProps,
                ),
            }),
      };
    },
    fromJson: (json: any): TestNullableRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['nullableString'] === undefined
          ? {}
          : {
              nullableString:
                json['nullableString'] === null ? null : json['nullableString'],
            }),
        ...(json['nullableNumber'] === undefined
          ? {}
          : {
              nullableNumber:
                json['nullableNumber'] === null ? null : json['nullableNumber'],
            }),
        ...(json['nullableInteger'] === undefined
          ? {}
          : {
              nullableInteger:
                json['nullableInteger'] === null
                  ? null
                  : json['nullableInteger'],
            }),
        ...(json['nullableBoolean'] === undefined
          ? {}
          : {
              nullableBoolean:
                json['nullableBoolean'] === null
                  ? null
                  : json['nullableBoolean'],
            }),
        ...(json['nullableArray'] === undefined
          ? {}
          : {
              nullableArray:
                json['nullableArray'] === null ? null : json['nullableArray'],
            }),
        ...(json['nullableObject'] === undefined
          ? {}
          : {
              nullableObject:
                $IO.TestNullableRequestContentNullableObject.fromJson(
                  json['nullableObject'],
                ),
            }),
        ...(json['objectWithNullableProps'] === undefined
          ? {}
          : {
              objectWithNullableProps:
                $IO.TestNullableRequestContentObjectWithNullableProps.fromJson(
                  json['objectWithNullableProps'],
                ),
            }),
      };
    },
  };

  public static TestNullableRequestContentNullableObject = {
    toJson: (model: TestNullableRequestContentNullableObject): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.key === undefined
          ? {}
          : {
              key: model.key,
            }),
      };
    },
    fromJson: (json: any): TestNullableRequestContentNullableObject => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['key'] === undefined
          ? {}
          : {
              key: json['key'],
            }),
      };
    },
  };

  public static TestNullableRequestContentObjectWithNullableProps = {
    toJson: (model: TestNullableRequestContentObjectWithNullableProps): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.nullableString === undefined
          ? {}
          : {
              nullableString: model.nullableString,
            }),
        ...(model.nullableNumber === undefined
          ? {}
          : {
              nullableNumber: model.nullableNumber,
            }),
        ...(model.nullableInteger === undefined
          ? {}
          : {
              nullableInteger: model.nullableInteger,
            }),
        ...(model.nullableBoolean === undefined
          ? {}
          : {
              nullableBoolean: model.nullableBoolean,
            }),
        ...(model.nullableArray === undefined
          ? {}
          : {
              nullableArray:
                model.nullableArray === null ? null : model.nullableArray,
            }),
        ...(model.nullableObject === undefined
          ? {}
          : {
              nullableObject:
                $IO.TestNullableRequestContentObjectWithNullablePropsNullableObject.toJson(
                  model.nullableObject,
                ),
            }),
      };
    },
    fromJson: (
      json: any,
    ): TestNullableRequestContentObjectWithNullableProps => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['nullableString'] === undefined
          ? {}
          : {
              nullableString:
                json['nullableString'] === null ? null : json['nullableString'],
            }),
        ...(json['nullableNumber'] === undefined
          ? {}
          : {
              nullableNumber:
                json['nullableNumber'] === null ? null : json['nullableNumber'],
            }),
        ...(json['nullableInteger'] === undefined
          ? {}
          : {
              nullableInteger:
                json['nullableInteger'] === null
                  ? null
                  : json['nullableInteger'],
            }),
        ...(json['nullableBoolean'] === undefined
          ? {}
          : {
              nullableBoolean:
                json['nullableBoolean'] === null
                  ? null
                  : json['nullableBoolean'],
            }),
        ...(json['nullableArray'] === undefined
          ? {}
          : {
              nullableArray:
                json['nullableArray'] === null ? null : json['nullableArray'],
            }),
        ...(json['nullableObject'] === undefined
          ? {}
          : {
              nullableObject:
                $IO.TestNullableRequestContentObjectWithNullablePropsNullableObject.fromJson(
                  json['nullableObject'],
                ),
            }),
      };
    },
  };

  public static TestNullableRequestContentObjectWithNullablePropsNullableObject =
    {
      toJson: (
        model: TestNullableRequestContentObjectWithNullablePropsNullableObject,
      ): any => {
        if (model === undefined || model === null) {
          return model;
        }
        return {
          ...(model.key === undefined
            ? {}
            : {
                key: model.key,
              }),
        };
      },
      fromJson: (
        json: any,
      ): TestNullableRequestContentObjectWithNullablePropsNullableObject => {
        if (json === undefined || json === null) {
          return json;
        }
        return {
          ...(json['key'] === undefined
            ? {}
            : {
                key: json['key'],
              }),
        };
      },
    };

  public static TestNullableRequestPathParameters = {
    toJson: (model: TestNullableRequestPathParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.pathParam === undefined
          ? {}
          : {
              pathParam: model.pathParam,
            }),
      };
    },
    fromJson: (json: any): TestNullableRequestPathParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        pathParam: json['pathParam'] === null ? null : json['pathParam'],
      };
    },
  };

  public static TestNullableRequestQueryParameters = {
    toJson: (model: TestNullableRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.queryString === undefined
          ? {}
          : {
              queryString: model.queryString,
            }),
        ...(model.queryNumber === undefined
          ? {}
          : {
              queryNumber: model.queryNumber,
            }),
        ...(model.queryInteger === undefined
          ? {}
          : {
              queryInteger: model.queryInteger,
            }),
        ...(model.queryBoolean === undefined
          ? {}
          : {
              queryBoolean: model.queryBoolean,
            }),
        ...(model.queryArray === undefined
          ? {}
          : {
              queryArray: model.queryArray === null ? null : model.queryArray,
            }),
        ...(model.queryObject === undefined
          ? {}
          : {
              queryObject: model.queryObject,
            }),
      };
    },
    fromJson: (json: any): TestNullableRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['queryString'] === undefined
          ? {}
          : {
              queryString:
                json['queryString'] === null ? null : json['queryString'],
            }),
        ...(json['queryNumber'] === undefined
          ? {}
          : {
              queryNumber:
                json['queryNumber'] === null ? null : json['queryNumber'],
            }),
        ...(json['queryInteger'] === undefined
          ? {}
          : {
              queryInteger:
                json['queryInteger'] === null ? null : json['queryInteger'],
            }),
        ...(json['queryBoolean'] === undefined
          ? {}
          : {
              queryBoolean:
                json['queryBoolean'] === null ? null : json['queryBoolean'],
            }),
        ...(json['queryArray'] === undefined
          ? {}
          : {
              queryArray:
                json['queryArray'] === null ? null : json['queryArray'],
            }),
        ...(json['queryObject'] === undefined
          ? {}
          : {
              queryObject:
                json['queryObject'] === null ? null : json['queryObject'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public postSingleNullableArray = async (
    input?: PostSingleNullableArrayRequest,
  ): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify(input === null ? null : input)
          : String(input === null ? null : input);

    const response = await this.$fetch(
      this.$url('/single-nullable-array', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public postSingleNullableBoolean = async (
    input?: PostSingleNullableBooleanRequest,
  ): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : String(input);

    const response = await this.$fetch(
      this.$url('/single-nullable-boolean', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public postSingleNullableNumber = async (
    input?: PostSingleNullableNumberRequest,
  ): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : String(input);

    const response = await this.$fetch(
      this.$url('/single-nullable-number', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public postSingleNullableObject = async (
    input?: PostSingleNullableObjectRequest,
  ): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify(
              $IO.PostSingleNullableObjectRequestContent.toJson(input),
            )
          : String($IO.PostSingleNullableObjectRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/single-nullable-object', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public postSingleNullableString = async (
    input?: PostSingleNullableStringRequest,
  ): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : String(input);

    const response = await this.$fetch(
      this.$url('/single-nullable-string', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public testNullable = async (
    input: TestNullableRequest,
  ): Promise<TestNullable200Response> => {
    const pathParameters = $IO.TestNullableRequestPathParameters.toJson(input);
    const queryParameters =
      $IO.TestNullableRequestQueryParameters.toJson(input);
    const headerParameters = {};
    const collectionFormats = {
      queryString: 'multi',
      queryNumber: 'multi',
      queryInteger: 'multi',
      queryBoolean: 'multi',
      queryArray: 'multi',
      queryObject: 'multi',
    } as const;
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.TestNullableRequestContent.toJson(input))
          : String($IO.TestNullableRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url(
        '/test/{pathParam}',
        pathParameters,
        queryParameters,
        collectionFormats,
      ),
      {
        headers: this.$headers(headerParameters, collectionFormats),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.TestNullable200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle number and string constraints 1`] = `
"export type TestConstraints200Response = {
  result?: string;
};
export type TestConstraintsRequestContent = {
  constrainedInt: number;
  constrainedString: string;
  hostname?: string;
  ipv4?: string;
  ipv6?: string;
  uri?: string;
};

export type TestConstraintsRequest = TestConstraintsRequestContent | undefined;
export type TestConstraintsError = never;
"
`;

exports[`openApiTsClientGenerator > should handle number and string constraints 2`] = `
"import type {
  TestConstraints200Response,
  TestConstraintsRequestContent,
  TestConstraintsRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static TestConstraints200Response = {
    toJson: (model: TestConstraints200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.result === undefined
          ? {}
          : {
              result: model.result,
            }),
      };
    },
    fromJson: (json: any): TestConstraints200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['result'] === undefined
          ? {}
          : {
              result: json['result'],
            }),
      };
    },
  };

  public static TestConstraintsRequestContent = {
    toJson: (model: TestConstraintsRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.constrainedInt === undefined
          ? {}
          : {
              constrainedInt: model.constrainedInt,
            }),
        ...(model.constrainedString === undefined
          ? {}
          : {
              constrainedString: model.constrainedString,
            }),
        ...(model.hostname === undefined
          ? {}
          : {
              hostname: model.hostname,
            }),
        ...(model.ipv4 === undefined
          ? {}
          : {
              ipv4: model.ipv4,
            }),
        ...(model.ipv6 === undefined
          ? {}
          : {
              ipv6: model.ipv6,
            }),
        ...(model.uri === undefined
          ? {}
          : {
              uri: model.uri,
            }),
      };
    },
    fromJson: (json: any): TestConstraintsRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        constrainedInt: json['constrainedInt'],
        constrainedString: json['constrainedString'],
        ...(json['hostname'] === undefined
          ? {}
          : {
              hostname: json['hostname'],
            }),
        ...(json['ipv4'] === undefined
          ? {}
          : {
              ipv4: json['ipv4'],
            }),
        ...(json['ipv6'] === undefined
          ? {}
          : {
              ipv6: json['ipv6'],
            }),
        ...(json['uri'] === undefined
          ? {}
          : {
              uri: json['uri'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public testConstraints = async (
    input?: TestConstraintsRequest,
  ): Promise<TestConstraints200Response> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.TestConstraintsRequestContent.toJson(input))
          : String($IO.TestConstraintsRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/constraints', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.TestConstraints200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle only default response 1`] = `
"export type GetTestdefaultResponse = {
  message: string;
};
export type GetTestError = never;
"
`;

exports[`openApiTsClientGenerator > should handle only default response 2`] = `
"import type { GetTestdefaultResponse } from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static GetTestdefaultResponse = {
    toJson: (model: GetTestdefaultResponse): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.message === undefined
          ? {}
          : {
              message: model.message,
            }),
      };
    },
    fromJson: (json: any): GetTestdefaultResponse => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        message: json['message'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public getTest = async (): Promise<GetTestdefaultResponse> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    return $IO.GetTestdefaultResponse.fromJson(await response.json());
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle operation tags and multiple services 1`] = `
"export type CreateUserError = never;
export type GetItemsError = never;
export type GetStatusError = never;
export type GetUsersError = never;
"
`;

exports[`openApiTsClientGenerator > should handle operation tags and multiple services 2`] = `
"/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  private _createUser = async (): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/users', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 201) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  /**
   * Returns a list of all the items
   */
  private _getItems = async (): Promise<Array<string>> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/items', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return (await response.json()) as Array<string>;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public getStatus = async (): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/status', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  private _getUsers = async (): Promise<Array<string>> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/users', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return (await response.json()) as Array<string>;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  /**
   * users operations
   */
  public users = {
    createUser: this._createUser,
    getUsers: this._getUsers,
  };

  /**
   * items operations
   */
  public items = {
    /**
     * Returns a list of all the items
     */
    getItems: this._getItems,
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle operations with complex map types 1`] = `
"export type PostMapOfArraysOfObjectsRequestContent = {
  [key: string]: Array<PostMapOfArraysOfObjectsRequestContentValueItem>;
};
export type PostMapOfArraysOfObjectsRequestContentValueItem = {
  name: string;
  value: number;
};
export type PostMapOfMapsOfArraysOfNumbersRequestContent = {
  [key: string]: { [key: string]: Array<number> };
};
export type PostMapOfMapsOfNumbersRequestContent = {
  [key: string]: { [key: string]: number };
};
export type PostMapOfNumbersRequestContent = {
  [key: string]: number;
};
export type PostMapOfObjectsRequestContent = {
  [key: string]: PostMapOfObjectsRequestContentValue;
};
export type PostMapOfObjectsRequestContentValue = {
  name: string;
  value: number;
};

export type PostArrayOfMapsOfArraysOfNumbersRequest =
  | Array<{ [key: string]: Array<number> }>
  | undefined;
export type PostArrayOfMapsOfArraysOfNumbersError = never;

export type PostArrayOfMapsOfNumbersRequest =
  | Array<{ [key: string]: number }>
  | undefined;
export type PostArrayOfMapsOfNumbersError = never;

export type PostMapOfArraysOfObjectsRequest =
  | PostMapOfArraysOfObjectsRequestContent
  | undefined;
export type PostMapOfArraysOfObjectsError = never;

export type PostMapOfMapsOfArraysOfNumbersRequest =
  | PostMapOfMapsOfArraysOfNumbersRequestContent
  | undefined;
export type PostMapOfMapsOfArraysOfNumbersError = never;

export type PostMapOfMapsOfNumbersRequest =
  | PostMapOfMapsOfNumbersRequestContent
  | undefined;
export type PostMapOfMapsOfNumbersError = never;

export type PostMapOfNumbersRequest =
  | PostMapOfNumbersRequestContent
  | undefined;
export type PostMapOfNumbersError = never;

export type PostMapOfObjectsRequest =
  | PostMapOfObjectsRequestContent
  | undefined;
export type PostMapOfObjectsError = never;
"
`;

exports[`openApiTsClientGenerator > should handle operations with complex map types 2`] = `
"import type {
  PostMapOfArraysOfObjectsRequestContent,
  PostMapOfArraysOfObjectsRequestContentValueItem,
  PostMapOfMapsOfArraysOfNumbersRequestContent,
  PostMapOfMapsOfNumbersRequestContent,
  PostMapOfNumbersRequestContent,
  PostMapOfObjectsRequestContent,
  PostMapOfObjectsRequestContentValue,
  PostArrayOfMapsOfArraysOfNumbersRequest,
  PostArrayOfMapsOfNumbersRequest,
  PostMapOfArraysOfObjectsRequest,
  PostMapOfMapsOfArraysOfNumbersRequest,
  PostMapOfMapsOfNumbersRequest,
  PostMapOfNumbersRequest,
  PostMapOfObjectsRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostMapOfArraysOfObjectsRequestContent = {
    toJson: (model: PostMapOfArraysOfObjectsRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.mapValues(model, (item0) =>
          item0.map($IO.PostMapOfArraysOfObjectsRequestContentValueItem.toJson),
        ),
      };
    },
    fromJson: (json: any): PostMapOfArraysOfObjectsRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.mapValues(json, (item0) =>
          item0.map(
            $IO.PostMapOfArraysOfObjectsRequestContentValueItem.fromJson,
          ),
        ),
      };
    },
  };

  public static PostMapOfArraysOfObjectsRequestContentValueItem = {
    toJson: (model: PostMapOfArraysOfObjectsRequestContentValueItem): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.name === undefined
          ? {}
          : {
              name: model.name,
            }),
        ...(model.value === undefined
          ? {}
          : {
              value: model.value,
            }),
      };
    },
    fromJson: (json: any): PostMapOfArraysOfObjectsRequestContentValueItem => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        name: json['name'],
        value: json['value'],
      };
    },
  };

  public static PostMapOfMapsOfArraysOfNumbersRequestContent = {
    toJson: (model: PostMapOfMapsOfArraysOfNumbersRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): PostMapOfMapsOfArraysOfNumbersRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static PostMapOfMapsOfNumbersRequestContent = {
    toJson: (model: PostMapOfMapsOfNumbersRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): PostMapOfMapsOfNumbersRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static PostMapOfNumbersRequestContent = {
    toJson: (model: PostMapOfNumbersRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): PostMapOfNumbersRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static PostMapOfObjectsRequestContent = {
    toJson: (model: PostMapOfObjectsRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.mapValues(model, $IO.PostMapOfObjectsRequestContentValue.toJson),
      };
    },
    fromJson: (json: any): PostMapOfObjectsRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.mapValues(
          json,
          $IO.PostMapOfObjectsRequestContentValue.fromJson,
        ),
      };
    },
  };

  public static PostMapOfObjectsRequestContentValue = {
    toJson: (model: PostMapOfObjectsRequestContentValue): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.name === undefined
          ? {}
          : {
              name: model.name,
            }),
        ...(model.value === undefined
          ? {}
          : {
              value: model.value,
            }),
      };
    },
    fromJson: (json: any): PostMapOfObjectsRequestContentValue => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        name: json['name'],
        value: json['value'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public postArrayOfMapsOfArraysOfNumbers = async (
    input?: PostArrayOfMapsOfArraysOfNumbersRequest,
  ): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify(input)
          : String(input);

    const response = await this.$fetch(
      this.$url(
        '/array-of-maps-of-arrays-of-numbers',
        pathParameters,
        queryParameters,
      ),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public postArrayOfMapsOfNumbers = async (
    input?: PostArrayOfMapsOfNumbersRequest,
  ): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify(input)
          : String(input);

    const response = await this.$fetch(
      this.$url('/array-of-maps-of-numbers', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public postMapOfArraysOfObjects = async (
    input?: PostMapOfArraysOfObjectsRequest,
  ): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify(
              $IO.PostMapOfArraysOfObjectsRequestContent.toJson(input),
            )
          : String($IO.PostMapOfArraysOfObjectsRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/map-of-arrays-of-objects', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public postMapOfMapsOfArraysOfNumbers = async (
    input?: PostMapOfMapsOfArraysOfNumbersRequest,
  ): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify(
              $IO.PostMapOfMapsOfArraysOfNumbersRequestContent.toJson(input),
            )
          : String(
              $IO.PostMapOfMapsOfArraysOfNumbersRequestContent.toJson(input),
            );

    const response = await this.$fetch(
      this.$url(
        '/map-of-maps-of-arrays-of-numbers',
        pathParameters,
        queryParameters,
      ),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public postMapOfMapsOfNumbers = async (
    input?: PostMapOfMapsOfNumbersRequest,
  ): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify(
              $IO.PostMapOfMapsOfNumbersRequestContent.toJson(input),
            )
          : String($IO.PostMapOfMapsOfNumbersRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/map-of-maps-of-numbers', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public postMapOfNumbers = async (
    input?: PostMapOfNumbersRequest,
  ): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.PostMapOfNumbersRequestContent.toJson(input))
          : String($IO.PostMapOfNumbersRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/map-of-numbers', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public postMapOfObjects = async (
    input?: PostMapOfObjectsRequest,
  ): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.PostMapOfObjectsRequestContent.toJson(input))
          : String($IO.PostMapOfObjectsRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/map-of-objects', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle operations with multiple tags 1`] = `
"export type GetMultiTaggedError = never;
export type PostMultiTaggedError = never;
"
`;

exports[`openApiTsClientGenerator > should handle operations with multiple tags 2`] = `
"/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  private _getMultiTagged = async (): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/multi-tagged', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  private _postMultiTagged = async (): Promise<number> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/multi-tagged', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return Number(await response.text());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  /**
   * tag1 operations
   */
  public tag1 = {
    getMultiTagged: this._getMultiTagged,
    postMultiTagged: this._postMultiTagged,
  };

  /**
   * tag2 operations
   */
  public tag2 = {
    getMultiTagged: this._getMultiTagged,
  };

  /**
   * tag3 operations
   */
  public tag3 = {
    getMultiTagged: this._getMultiTagged,
    postMultiTagged: this._postMultiTagged,
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle operations with simple request bodies and query parameters 1`] = `
"export type PostBooleanWithQueryRequestBodyParameters = {
  body?: boolean;
};
export type PostBooleanWithQueryRequestQueryParameters = {
  filter?: string;
};
export type PostNumberWithQueryRequestBodyParameters = {
  body?: number;
};
export type PostNumberWithQueryRequestQueryParameters = {
  filter?: string;
};
export type PostStringWithQueryRequestBodyParameters = {
  body?: string;
};
export type PostStringWithQueryRequestQueryParameters = {
  filter?: string;
};

export type PostBooleanRequest = boolean | undefined;
export type PostBooleanError = never;

export type PostBooleanWithQueryRequest =
  PostBooleanWithQueryRequestQueryParameters &
    PostBooleanWithQueryRequestBodyParameters;
export type PostBooleanWithQueryError = never;

export type PostNumberRequest = number | undefined;
export type PostNumberError = never;

export type PostNumberWithQueryRequest =
  PostNumberWithQueryRequestQueryParameters &
    PostNumberWithQueryRequestBodyParameters;
export type PostNumberWithQueryError = never;

export type PostStringRequest = string | undefined;
export type PostStringError = never;

export type PostStringWithQueryRequest =
  PostStringWithQueryRequestQueryParameters &
    PostStringWithQueryRequestBodyParameters;
export type PostStringWithQueryError = never;
"
`;

exports[`openApiTsClientGenerator > should handle operations with simple request bodies and query parameters 2`] = `
"import type {
  PostBooleanWithQueryRequestBodyParameters,
  PostBooleanWithQueryRequestQueryParameters,
  PostNumberWithQueryRequestBodyParameters,
  PostNumberWithQueryRequestQueryParameters,
  PostStringWithQueryRequestBodyParameters,
  PostStringWithQueryRequestQueryParameters,
  PostBooleanRequest,
  PostBooleanWithQueryRequest,
  PostNumberRequest,
  PostNumberWithQueryRequest,
  PostStringRequest,
  PostStringWithQueryRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostBooleanWithQueryRequestBodyParameters = {
    toJson: (model: PostBooleanWithQueryRequestBodyParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.body === undefined
          ? {}
          : {
              body: model.body,
            }),
      };
    },
    fromJson: (json: any): PostBooleanWithQueryRequestBodyParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['body'] === undefined
          ? {}
          : {
              body: json['body'],
            }),
      };
    },
  };

  public static PostBooleanWithQueryRequestQueryParameters = {
    toJson: (model: PostBooleanWithQueryRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.filter === undefined
          ? {}
          : {
              filter: model.filter,
            }),
      };
    },
    fromJson: (json: any): PostBooleanWithQueryRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['filter'] === undefined
          ? {}
          : {
              filter: json['filter'],
            }),
      };
    },
  };

  public static PostNumberWithQueryRequestBodyParameters = {
    toJson: (model: PostNumberWithQueryRequestBodyParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.body === undefined
          ? {}
          : {
              body: model.body,
            }),
      };
    },
    fromJson: (json: any): PostNumberWithQueryRequestBodyParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['body'] === undefined
          ? {}
          : {
              body: json['body'],
            }),
      };
    },
  };

  public static PostNumberWithQueryRequestQueryParameters = {
    toJson: (model: PostNumberWithQueryRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.filter === undefined
          ? {}
          : {
              filter: model.filter,
            }),
      };
    },
    fromJson: (json: any): PostNumberWithQueryRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['filter'] === undefined
          ? {}
          : {
              filter: json['filter'],
            }),
      };
    },
  };

  public static PostStringWithQueryRequestBodyParameters = {
    toJson: (model: PostStringWithQueryRequestBodyParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.body === undefined
          ? {}
          : {
              body: model.body,
            }),
      };
    },
    fromJson: (json: any): PostStringWithQueryRequestBodyParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['body'] === undefined
          ? {}
          : {
              body: json['body'],
            }),
      };
    },
  };

  public static PostStringWithQueryRequestQueryParameters = {
    toJson: (model: PostStringWithQueryRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.filter === undefined
          ? {}
          : {
              filter: model.filter,
            }),
      };
    },
    fromJson: (json: any): PostStringWithQueryRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['filter'] === undefined
          ? {}
          : {
              filter: json['filter'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public postBoolean = async (input?: PostBooleanRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : String(input);

    const response = await this.$fetch(
      this.$url('/boolean', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public postBooleanWithQuery = async (
    input: PostBooleanWithQueryRequest,
  ): Promise<string> => {
    const pathParameters = {};
    const queryParameters =
      $IO.PostBooleanWithQueryRequestQueryParameters.toJson(input);
    const headerParameters = {};
    const collectionFormats = {
      filter: 'multi',
    } as const;
    const body = input === undefined ? undefined : String(input.body);

    const response = await this.$fetch(
      this.$url(
        '/boolean-with-query',
        pathParameters,
        queryParameters,
        collectionFormats,
      ),
      {
        headers: this.$headers(headerParameters, collectionFormats),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public postNumber = async (input?: PostNumberRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : String(input);

    const response = await this.$fetch(
      this.$url('/number', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public postNumberWithQuery = async (
    input: PostNumberWithQueryRequest,
  ): Promise<string> => {
    const pathParameters = {};
    const queryParameters =
      $IO.PostNumberWithQueryRequestQueryParameters.toJson(input);
    const headerParameters = {};
    const collectionFormats = {
      filter: 'multi',
    } as const;
    const body = input === undefined ? undefined : String(input.body);

    const response = await this.$fetch(
      this.$url(
        '/number-with-query',
        pathParameters,
        queryParameters,
        collectionFormats,
      ),
      {
        headers: this.$headers(headerParameters, collectionFormats),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public postString = async (input?: PostStringRequest): Promise<string> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body = input === undefined ? undefined : String(input);

    const response = await this.$fetch(
      this.$url('/string', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public postStringWithQuery = async (
    input: PostStringWithQueryRequest,
  ): Promise<string> => {
    const pathParameters = {};
    const queryParameters =
      $IO.PostStringWithQueryRequestQueryParameters.toJson(input);
    const headerParameters = {};
    const collectionFormats = {
      filter: 'multi',
    } as const;
    const body = input === undefined ? undefined : String(input.body);

    const response = await this.$fetch(
      this.$url(
        '/string-with-query',
        pathParameters,
        queryParameters,
        collectionFormats,
      ),
      {
        headers: this.$headers(headerParameters, collectionFormats),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle recursive schema references 1`] = `
"export type TreeNode = {
  id: string;
  name: string;
  children?: Array<TreeNode>;
};

export type CreateTreeRequest = TreeNode | undefined;
export type CreateTreeError = never;
export type GetTreeError = never;
"
`;

exports[`openApiTsClientGenerator > should handle recursive schema references 2`] = `
"import type { TreeNode, CreateTreeRequest } from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static TreeNode = {
    toJson: (model: TreeNode): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.id === undefined
          ? {}
          : {
              id: model.id,
            }),
        ...(model.name === undefined
          ? {}
          : {
              name: model.name,
            }),
        ...(model.children === undefined
          ? {}
          : {
              children: model.children.map($IO.TreeNode.toJson),
            }),
      };
    },
    fromJson: (json: any): TreeNode => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        id: json['id'],
        name: json['name'],
        ...(json['children'] === undefined
          ? {}
          : {
              children: (json['children'] as Array<any>).map(
                $IO.TreeNode.fromJson,
              ),
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public createTree = async (input?: CreateTreeRequest): Promise<TreeNode> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.TreeNode.toJson(input))
          : String($IO.TreeNode.toJson(input));

    const response = await this.$fetch(
      this.$url('/tree', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 201) {
      return $IO.TreeNode.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };

  public getTree = async (): Promise<TreeNode> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/tree', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.TreeNode.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle refs and hoisting of inline schemas 1`] = `
"export type Error = {
  code: string;
  message: string;
};
export type PostTestRequestContent = {
  inline?: PostTestRequestContentInline;
  referenced?: Error;
};
export type PostTestRequestContentInline = {
  name?: string;
  details?: PostTestRequestContentInlineDetails;
};
export type PostTestRequestContentInlineDetails = {
  age?: number;
  active?: boolean;
};

export type PostTestRequest = PostTestRequestContent;
export type PostTest400Error = {
  status: 400;
  error: Error;
};
export type PostTestError = PostTest400Error;
"
`;

exports[`openApiTsClientGenerator > should handle refs and hoisting of inline schemas 2`] = `
"import type {
  Error,
  PostTestRequestContent,
  PostTestRequestContentInline,
  PostTestRequestContentInlineDetails,
  PostTestRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static Error = {
    toJson: (model: Error): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.code === undefined
          ? {}
          : {
              code: model.code,
            }),
        ...(model.message === undefined
          ? {}
          : {
              message: model.message,
            }),
      };
    },
    fromJson: (json: any): Error => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        code: json['code'],
        message: json['message'],
      };
    },
  };

  public static PostTestRequestContent = {
    toJson: (model: PostTestRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.inline === undefined
          ? {}
          : {
              inline: $IO.PostTestRequestContentInline.toJson(model.inline),
            }),
        ...(model.referenced === undefined
          ? {}
          : {
              referenced: $IO.Error.toJson(model.referenced),
            }),
      };
    },
    fromJson: (json: any): PostTestRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['inline'] === undefined
          ? {}
          : {
              inline: $IO.PostTestRequestContentInline.fromJson(json['inline']),
            }),
        ...(json['referenced'] === undefined
          ? {}
          : {
              referenced: $IO.Error.fromJson(json['referenced']),
            }),
      };
    },
  };

  public static PostTestRequestContentInline = {
    toJson: (model: PostTestRequestContentInline): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.name === undefined
          ? {}
          : {
              name: model.name,
            }),
        ...(model.details === undefined
          ? {}
          : {
              details: $IO.PostTestRequestContentInlineDetails.toJson(
                model.details,
              ),
            }),
      };
    },
    fromJson: (json: any): PostTestRequestContentInline => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['name'] === undefined
          ? {}
          : {
              name: json['name'],
            }),
        ...(json['details'] === undefined
          ? {}
          : {
              details: $IO.PostTestRequestContentInlineDetails.fromJson(
                json['details'],
              ),
            }),
      };
    },
  };

  public static PostTestRequestContentInlineDetails = {
    toJson: (model: PostTestRequestContentInlineDetails): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.age === undefined
          ? {}
          : {
              age: model.age,
            }),
        ...(model.active === undefined
          ? {}
          : {
              active: model.active,
            }),
      };
    },
    fromJson: (json: any): PostTestRequestContentInlineDetails => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['age'] === undefined
          ? {}
          : {
              age: json['age'],
            }),
        ...(json['active'] === undefined
          ? {}
          : {
              active: json['active'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public postTest = async (input: PostTestRequest): Promise<void> => {
    const pathParameters = {};
    const queryParameters = {};
    const headerParameters = {};
    const body =
      typeof input === 'object'
        ? JSON.stringify($IO.PostTestRequestContent.toJson(input))
        : String($IO.PostTestRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return undefined;
    }
    if (response.status === 400) {
      throw {
        status: response.status,
        error: $IO.Error.fromJson(await response.json()),
      };
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle request body property matching query parameter name 1`] = `
"export type PostTest200Response = {
  result?: string;
};
export type PostTestRequestBodyParameters = {
  body?: PostTestRequestContent;
};
export type PostTestRequestContent = {
  filter: PostTestRequestContentFilter;
  data: string;
};
export type PostTestRequestContentFilter = {
  value?: string;
};
export type PostTestRequestQueryParameters = {
  filter?: string;
};

export type PostTestRequest = PostTestRequestQueryParameters &
  PostTestRequestBodyParameters;
export type PostTestError = never;
"
`;

exports[`openApiTsClientGenerator > should handle request body property matching query parameter name 2`] = `
"import type {
  PostTest200Response,
  PostTestRequestBodyParameters,
  PostTestRequestContent,
  PostTestRequestContentFilter,
  PostTestRequestQueryParameters,
  PostTestRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostTest200Response = {
    toJson: (model: PostTest200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.result === undefined
          ? {}
          : {
              result: model.result,
            }),
      };
    },
    fromJson: (json: any): PostTest200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['result'] === undefined
          ? {}
          : {
              result: json['result'],
            }),
      };
    },
  };

  public static PostTestRequestBodyParameters = {
    toJson: (model: PostTestRequestBodyParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.body === undefined
          ? {}
          : {
              body: $IO.PostTestRequestContent.toJson(model.body),
            }),
      };
    },
    fromJson: (json: any): PostTestRequestBodyParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['body'] === undefined
          ? {}
          : {
              body: $IO.PostTestRequestContent.fromJson(json['body']),
            }),
      };
    },
  };

  public static PostTestRequestContent = {
    toJson: (model: PostTestRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.filter === undefined
          ? {}
          : {
              filter: $IO.PostTestRequestContentFilter.toJson(model.filter),
            }),
        ...(model.data === undefined
          ? {}
          : {
              data: model.data,
            }),
      };
    },
    fromJson: (json: any): PostTestRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        filter: $IO.PostTestRequestContentFilter.fromJson(json['filter']),
        data: json['data'],
      };
    },
  };

  public static PostTestRequestContentFilter = {
    toJson: (model: PostTestRequestContentFilter): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.value === undefined
          ? {}
          : {
              value: model.value,
            }),
      };
    },
    fromJson: (json: any): PostTestRequestContentFilter => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['value'] === undefined
          ? {}
          : {
              value: json['value'],
            }),
      };
    },
  };

  public static PostTestRequestQueryParameters = {
    toJson: (model: PostTestRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.filter === undefined
          ? {}
          : {
              filter: model.filter,
            }),
      };
    },
    fromJson: (json: any): PostTestRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['filter'] === undefined
          ? {}
          : {
              filter: json['filter'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public postTest = async (
    input: PostTestRequest,
  ): Promise<PostTest200Response> => {
    const pathParameters = {};
    const queryParameters = $IO.PostTestRequestQueryParameters.toJson(input);
    const headerParameters = {};
    const collectionFormats = {
      filter: 'multi',
    } as const;
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.PostTestRequestBodyParameters.toJson(input).body)
          : String($IO.PostTestRequestBodyParameters.toJson(input).body);

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters, collectionFormats),
      {
        headers: this.$headers(headerParameters, collectionFormats),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.PostTest200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;

exports[`openApiTsClientGenerator > should handle special formats and vendor extensions 1`] = `
"export type PostTest200Response = {
  createdAt?: Date;
};
export type PostTestRequestContent = {
  int32?: number;
  int64?: number;
  float?: number;
  double?: number;
  binary?: Blob;
  byte?: string;
  uuid?: string;
  email?: string;
};
export type PostTestRequestQueryParameters = {
  date?: Date;
  timestamp?: Date;
};

export type PostTestRequest = PostTestRequestQueryParameters &
  PostTestRequestContent;
export type PostTestError = never;
"
`;

exports[`openApiTsClientGenerator > should handle special formats and vendor extensions 2`] = `
"import type {
  PostTest200Response,
  PostTestRequestContent,
  PostTestRequestQueryParameters,
  PostTestRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  private static mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostTest200Response = {
    toJson: (model: PostTest200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.createdAt === undefined
          ? {}
          : {
              createdAt: model.createdAt.toISOString(),
            }),
      };
    },
    fromJson: (json: any): PostTest200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['createdAt'] === undefined
          ? {}
          : {
              createdAt: new Date(json['createdAt']),
            }),
      };
    },
  };

  public static PostTestRequestContent = {
    toJson: (model: PostTestRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.int32 === undefined
          ? {}
          : {
              int32: model.int32,
            }),
        ...(model.int64 === undefined
          ? {}
          : {
              int64: model.int64,
            }),
        ...(model.float === undefined
          ? {}
          : {
              float: model.float,
            }),
        ...(model.double === undefined
          ? {}
          : {
              double: model.double,
            }),
        ...(model.binary === undefined
          ? {}
          : {
              binary: model.binary,
            }),
        ...(model.byte === undefined
          ? {}
          : {
              byte: model.byte,
            }),
        ...(model.uuid === undefined
          ? {}
          : {
              uuid: model.uuid,
            }),
        ...(model.email === undefined
          ? {}
          : {
              email: model.email,
            }),
      };
    },
    fromJson: (json: any): PostTestRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['int32'] === undefined
          ? {}
          : {
              int32: json['int32'],
            }),
        ...(json['int64'] === undefined
          ? {}
          : {
              int64: json['int64'],
            }),
        ...(json['float'] === undefined
          ? {}
          : {
              float: json['float'],
            }),
        ...(json['double'] === undefined
          ? {}
          : {
              double: json['double'],
            }),
        ...(json['binary'] === undefined
          ? {}
          : {
              binary: json['binary'],
            }),
        ...(json['byte'] === undefined
          ? {}
          : {
              byte: json['byte'],
            }),
        ...(json['uuid'] === undefined
          ? {}
          : {
              uuid: json['uuid'],
            }),
        ...(json['email'] === undefined
          ? {}
          : {
              email: json['email'],
            }),
      };
    },
  };

  public static PostTestRequestQueryParameters = {
    toJson: (model: PostTestRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.date === undefined
          ? {}
          : {
              date: model.date.toISOString().slice(0, 10),
            }),
        ...(model.timestamp === undefined
          ? {}
          : {
              timestamp: model.timestamp.toISOString(),
            }),
      };
    },
    fromJson: (json: any): PostTestRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['date'] === undefined
          ? {}
          : {
              date: new Date(json['date']),
            }),
        ...(json['timestamp'] === undefined
          ? {}
          : {
              timestamp: new Date(json['timestamp']),
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  url: string;
  fetch?: typeof fetch;
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public postTest = async (
    input: PostTestRequest,
  ): Promise<PostTest200Response> => {
    const pathParameters = {};
    const queryParameters = $IO.PostTestRequestQueryParameters.toJson(input);
    const headerParameters = {};
    const collectionFormats = {
      date: 'multi',
      timestamp: 'multi',
    } as const;
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.PostTestRequestContent.toJson(input))
          : String($IO.PostTestRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters, collectionFormats),
      {
        headers: this.$headers(headerParameters, collectionFormats),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.PostTest200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  };
}
"
`;
