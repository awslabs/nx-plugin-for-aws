// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`openApiTsClientGenerator - streaming > should handle error responses for streaming operations 1`] = `
"export type GetStream400Response = {
  code: string;
  message: string;
};
export type GetStream500Response = {
  error: string;
  details?: string;
};
export type GetStream400Error = {
  status: 400;
  error: GetStream400Response;
};
export type GetStream500Error = {
  status: 500;
  error: GetStream500Response;
};
export type GetStreamError = GetStream400Error | GetStream500Error;
"
`;

exports[`openApiTsClientGenerator - streaming > should handle error responses for streaming operations 2`] = `
"import type {
  GetStream400Response,
  GetStream500Response,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static GetStream400Response = {
    toJson: (model: GetStream400Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.code === undefined
          ? {}
          : {
              code: model.code,
            }),
        ...(model.message === undefined
          ? {}
          : {
              message: model.message,
            }),
      };
    },
    fromJson: (json: any): GetStream400Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        code: json['code'],
        message: json['message'],
      };
    },
  };

  public static GetStream500Response = {
    toJson: (model: GetStream500Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.error === undefined
          ? {}
          : {
              error: model.error,
            }),
        ...(model.details === undefined
          ? {}
          : {
              details: model.details,
            }),
      };
    },
    fromJson: (json: any): GetStream500Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        error: json['error'],
        ...(json['details'] === undefined
          ? {}
          : {
              details: json['details'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.getStream = this.getStream.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async *getStream(): AsyncIterableIterator<number> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/stream', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield Number(value);
      }
      return;
    }
    if (response.status === 400) {
      throw {
        status: response.status,
        error: $IO.GetStream400Response.fromJson(await response.json()),
      };
    }
    if (response.status === 500) {
      throw {
        status: response.status,
        error: $IO.GetStream500Response.fromJson(await response.json()),
      };
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - streaming > should return an iterator over a stream of arrays 1`] = `
"export type GetObjectArrays200ResponseItem = {
  id: number;
  name: string;
};
export type GetBooleanArraysError = never;
export type GetDateArraysError = never;
export type GetNumberArraysError = never;
export type GetObjectArraysError = never;
export type GetStringArraysError = never;
"
`;

exports[`openApiTsClientGenerator - streaming > should return an iterator over a stream of arrays 2`] = `
"import type { GetObjectArrays200ResponseItem } from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static GetObjectArrays200ResponseItem = {
    toJson: (model: GetObjectArrays200ResponseItem): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.id === undefined
          ? {}
          : {
              id: model.id,
            }),
        ...(model.name === undefined
          ? {}
          : {
              name: model.name,
            }),
      };
    },
    fromJson: (json: any): GetObjectArrays200ResponseItem => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        id: json['id'],
        name: json['name'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.getBooleanArrays = this.getBooleanArrays.bind(this);
    this.getDateArrays = this.getDateArrays.bind(this);
    this.getNumberArrays = this.getNumberArrays.bind(this);
    this.getObjectArrays = this.getObjectArrays.bind(this);
    this.getStringArrays = this.getStringArrays.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async *getBooleanArrays(): AsyncIterableIterator<Array<boolean>> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test/boolean-arrays', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield JSON.parse(value);
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async *getDateArrays(): AsyncIterableIterator<Array<Date>> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test/date-arrays', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield (JSON.parse(value) as Array<any>).map((item0) => new Date(item0));
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async *getNumberArrays(): AsyncIterableIterator<Array<number>> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test/number-arrays', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield JSON.parse(value);
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async *getObjectArrays(): AsyncIterableIterator<
    Array<GetObjectArrays200ResponseItem>
  > {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test/object-arrays', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield (JSON.parse(value) as Array<any>).map(
          $IO.GetObjectArrays200ResponseItem.fromJson,
        );
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async *getStringArrays(): AsyncIterableIterator<Array<string>> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test/string-arrays', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield JSON.parse(value);
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - streaming > should return an iterator over a stream of dictionaries 1`] = `
"export type GetArrayDict200Response = {
  [key: string]: Array<number>;
};
export type GetBooleanDict200Response = {
  [key: string]: boolean;
};
export type GetDateDict200Response = {
  [key: string]: Date;
};
export type GetEnumDict200Response = {
  [key: string]: string;
};
export type GetEnumDict200ResponseValue = 'RED' | 'GREEN' | 'BLUE';
export type GetNestedDict200Response = {
  [key: string]: { [key: string]: GetNestedDict200ResponseValueValue };
};
export type GetNestedDict200ResponseValueValue = {
  value: number;
  tags: Array<string>;
};
export type GetNumberDict200Response = {
  [key: string]: number;
};
export type GetObjectArrayDict200Response = {
  [key: string]: Array<GetObjectArrayDict200ResponseValueItem>;
};
export type GetObjectArrayDict200ResponseValueItem = {
  id: number;
  name: string;
};
export type GetStringDict200Response = {
  [key: string]: string;
};
export type GetArrayDictError = never;
export type GetBooleanDictError = never;
export type GetDateDictError = never;
export type GetEnumDictError = never;
export type GetNestedDictError = never;
export type GetNumberDictError = never;
export type GetObjectArrayDictError = never;
export type GetStringDictError = never;
"
`;

exports[`openApiTsClientGenerator - streaming > should return an iterator over a stream of dictionaries 2`] = `
"import type {
  GetArrayDict200Response,
  GetBooleanDict200Response,
  GetDateDict200Response,
  GetEnumDict200Response,
  GetEnumDict200ResponseValue,
  GetNestedDict200Response,
  GetNestedDict200ResponseValueValue,
  GetNumberDict200Response,
  GetObjectArrayDict200Response,
  GetObjectArrayDict200ResponseValueItem,
  GetStringDict200Response,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static GetArrayDict200Response = {
    toJson: (model: GetArrayDict200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): GetArrayDict200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static GetBooleanDict200Response = {
    toJson: (model: GetBooleanDict200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): GetBooleanDict200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static GetDateDict200Response = {
    toJson: (model: GetDateDict200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.$mapValues(model, (item0) => item0.toISOString()),
      };
    },
    fromJson: (json: any): GetDateDict200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.$mapValues(json, (item0) => new Date(item0)),
      };
    },
  };

  public static GetEnumDict200Response = {
    toJson: (model: GetEnumDict200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): GetEnumDict200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static GetNestedDict200Response = {
    toJson: (model: GetNestedDict200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.$mapValues(model, (item0) =>
          $IO.$mapValues(item0, $IO.GetNestedDict200ResponseValueValue.toJson),
        ),
      };
    },
    fromJson: (json: any): GetNestedDict200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.$mapValues(json, (item0) =>
          $IO.$mapValues(
            item0,
            $IO.GetNestedDict200ResponseValueValue.fromJson,
          ),
        ),
      };
    },
  };

  public static GetNestedDict200ResponseValueValue = {
    toJson: (model: GetNestedDict200ResponseValueValue): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.value === undefined
          ? {}
          : {
              value: model.value,
            }),
        ...(model.tags === undefined
          ? {}
          : {
              tags: model.tags,
            }),
      };
    },
    fromJson: (json: any): GetNestedDict200ResponseValueValue => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        value: json['value'],
        tags: json['tags'],
      };
    },
  };

  public static GetNumberDict200Response = {
    toJson: (model: GetNumberDict200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): GetNumberDict200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static GetObjectArrayDict200Response = {
    toJson: (model: GetObjectArrayDict200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.$mapValues(model, (item0) =>
          item0.map($IO.GetObjectArrayDict200ResponseValueItem.toJson),
        ),
      };
    },
    fromJson: (json: any): GetObjectArrayDict200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.$mapValues(json, (item0) =>
          item0.map($IO.GetObjectArrayDict200ResponseValueItem.fromJson),
        ),
      };
    },
  };

  public static GetObjectArrayDict200ResponseValueItem = {
    toJson: (model: GetObjectArrayDict200ResponseValueItem): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.id === undefined
          ? {}
          : {
              id: model.id,
            }),
        ...(model.name === undefined
          ? {}
          : {
              name: model.name,
            }),
      };
    },
    fromJson: (json: any): GetObjectArrayDict200ResponseValueItem => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        id: json['id'],
        name: json['name'],
      };
    },
  };

  public static GetStringDict200Response = {
    toJson: (model: GetStringDict200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): GetStringDict200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.getArrayDict = this.getArrayDict.bind(this);
    this.getBooleanDict = this.getBooleanDict.bind(this);
    this.getDateDict = this.getDateDict.bind(this);
    this.getEnumDict = this.getEnumDict.bind(this);
    this.getNestedDict = this.getNestedDict.bind(this);
    this.getNumberDict = this.getNumberDict.bind(this);
    this.getObjectArrayDict = this.getObjectArrayDict.bind(this);
    this.getStringDict = this.getStringDict.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async *getArrayDict(): AsyncIterableIterator<GetArrayDict200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test/array-dict', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield $IO.GetArrayDict200Response.fromJson(JSON.parse(value));
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async *getBooleanDict(): AsyncIterableIterator<GetBooleanDict200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test/boolean-dict', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield $IO.GetBooleanDict200Response.fromJson(JSON.parse(value));
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async *getDateDict(): AsyncIterableIterator<GetDateDict200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test/date-dict', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield $IO.GetDateDict200Response.fromJson(JSON.parse(value));
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async *getEnumDict(): AsyncIterableIterator<GetEnumDict200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test/enum-dict', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield $IO.GetEnumDict200Response.fromJson(JSON.parse(value));
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async *getNestedDict(): AsyncIterableIterator<GetNestedDict200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test/nested-dict', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield $IO.GetNestedDict200Response.fromJson(JSON.parse(value));
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async *getNumberDict(): AsyncIterableIterator<GetNumberDict200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test/number-dict', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield $IO.GetNumberDict200Response.fromJson(JSON.parse(value));
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async *getObjectArrayDict(): AsyncIterableIterator<GetObjectArrayDict200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test/object-array-dict', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield $IO.GetObjectArrayDict200Response.fromJson(JSON.parse(value));
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async *getStringDict(): AsyncIterableIterator<GetStringDict200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test/string-dict', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield $IO.GetStringDict200Response.fromJson(JSON.parse(value));
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - streaming > should return an iterator over a stream of numbers, booleans and dates 1`] = `
"export type GetBooleansError = never;
export type GetDatesError = never;
export type GetNumbersError = never;
"
`;

exports[`openApiTsClientGenerator - streaming > should return an iterator over a stream of numbers, booleans and dates 2`] = `
"/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.getBooleans = this.getBooleans.bind(this);
    this.getDates = this.getDates.bind(this);
    this.getNumbers = this.getNumbers.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async *getBooleans(): AsyncIterableIterator<boolean> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test/booleans', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield value === 'true' ? true : false;
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async *getDates(): AsyncIterableIterator<Date> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test/dates', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield new Date(value);
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async *getNumbers(): AsyncIterableIterator<number> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test/numbers', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield Number(value);
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - streaming > should return an iterator over a stream of objects 1`] = `
"export type GetTest200Response = {
  foo: string;
  bar: number;
};
export type GetTestError = never;
"
`;

exports[`openApiTsClientGenerator - streaming > should return an iterator over a stream of objects 2`] = `
"import type { GetTest200Response } from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static GetTest200Response = {
    toJson: (model: GetTest200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.foo === undefined
          ? {}
          : {
              foo: model.foo,
            }),
        ...(model.bar === undefined
          ? {}
          : {
              bar: model.bar,
            }),
      };
    },
    fromJson: (json: any): GetTest200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        foo: json['foo'],
        bar: json['bar'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.getTest = this.getTest.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async *getTest(): AsyncIterableIterator<GetTest200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield $IO.GetTest200Response.fromJson(JSON.parse(value));
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - streaming > should return an iterator over a stream of strings 1`] = `
"export type GetTestError = never;
"
`;

exports[`openApiTsClientGenerator - streaming > should return an iterator over a stream of strings 2`] = `
"/**
 * Utility for serialisation and deserialisation of API types.
 */
class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.getTest = this.getTest.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async *getTest(): AsyncIterableIterator<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      const reader = response.body
        ?.pipeThrough(new TextDecoderStream())
        .getReader();
      while (reader) {
        const { value, done } = await reader.read();
        if (done) return;
        yield value;
      }
      return;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;
