// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`openApiTsClientGenerator - composite schemas > should generate valid TypeScript for composite types 1`] = `
"export type PutTest200Response = PutTest200ResponseAllOf &
  PutTest200ResponseAllOf1;
export type PutTest200ResponseAllOf = {
  id: string;
};
export type PutTest200ResponseAllOf1 = {
  metadata?: PutTest200ResponseAllOf1Metadata;
};
export type PutTest200ResponseAllOf1Metadata = {
  created?: Date;
};
export type PutTestRequestContent =
  | PutTestRequestContentOneOf
  | PutTestRequestContentOneOf1;
export type PutTestRequestContentOneOf = {
  type: PutTestRequestContentOneOfType;
  valueA: string;
};
export type PutTestRequestContentOneOf1 = {
  type: PutTestRequestContentOneOf1Type;
  valueB: number;
};
export type PutTestRequestContentOneOf1Type = 'b';
export type PutTestRequestContentOneOfType = 'a';

export type PutTestRequest = PutTestRequestContent | undefined;
export type PutTestError = never;
"
`;

exports[`openApiTsClientGenerator - composite schemas > should generate valid TypeScript for composite types 2`] = `
"import type {
  PutTest200Response,
  PutTest200ResponseAllOf,
  PutTest200ResponseAllOf1,
  PutTest200ResponseAllOf1Metadata,
  PutTestRequestContent,
  PutTestRequestContentOneOf,
  PutTestRequestContentOneOf1,
  PutTestRequestContentOneOf1Type,
  PutTestRequestContentOneOfType,
  PutTestRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PutTest200Response = {
    toJson: (model: PutTest200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.PutTest200ResponseAllOf.toJson(model),
        ...$IO.PutTest200ResponseAllOf1.toJson(model),
      };
    },
    fromJson: (json: any): PutTest200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.PutTest200ResponseAllOf.fromJson(json),
        ...$IO.PutTest200ResponseAllOf1.fromJson(json),
      };
    },
  };

  public static PutTest200ResponseAllOf = {
    toJson: (model: PutTest200ResponseAllOf): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.id === undefined
          ? {}
          : {
              id: model.id,
            }),
      };
    },
    fromJson: (json: any): PutTest200ResponseAllOf => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        id: json['id'],
      };
    },
  };

  public static PutTest200ResponseAllOf1 = {
    toJson: (model: PutTest200ResponseAllOf1): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.metadata === undefined
          ? {}
          : {
              metadata: $IO.PutTest200ResponseAllOf1Metadata.toJson(
                model.metadata,
              ),
            }),
      };
    },
    fromJson: (json: any): PutTest200ResponseAllOf1 => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['metadata'] === undefined
          ? {}
          : {
              metadata: $IO.PutTest200ResponseAllOf1Metadata.fromJson(
                json['metadata'],
              ),
            }),
      };
    },
  };

  public static PutTest200ResponseAllOf1Metadata = {
    toJson: (model: PutTest200ResponseAllOf1Metadata): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.created === undefined
          ? {}
          : {
              created: model.created.toISOString(),
            }),
      };
    },
    fromJson: (json: any): PutTest200ResponseAllOf1Metadata => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['created'] === undefined
          ? {}
          : {
              created: new Date(json['created']),
            }),
      };
    },
  };

  public static PutTestRequestContent = {
    toJson: (model: PutTestRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.PutTestRequestContentOneOf.toJson(
          model as PutTestRequestContentOneOf,
        ),
        ...$IO.PutTestRequestContentOneOf1.toJson(
          model as PutTestRequestContentOneOf1,
        ),
      };
    },
    fromJson: (json: any): PutTestRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.PutTestRequestContentOneOf.fromJson(json),
        ...$IO.PutTestRequestContentOneOf1.fromJson(json),
      };
    },
  };

  public static PutTestRequestContentOneOf = {
    toJson: (model: PutTestRequestContentOneOf): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.type === undefined
          ? {}
          : {
              type: model.type,
            }),
        ...(model.valueA === undefined
          ? {}
          : {
              valueA: model.valueA,
            }),
      };
    },
    fromJson: (json: any): PutTestRequestContentOneOf => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        type: json['type'],
        valueA: json['valueA'],
      };
    },
  };

  public static PutTestRequestContentOneOf1 = {
    toJson: (model: PutTestRequestContentOneOf1): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.type === undefined
          ? {}
          : {
              type: model.type,
            }),
        ...(model.valueB === undefined
          ? {}
          : {
              valueB: model.valueB,
            }),
      };
    },
    fromJson: (json: any): PutTestRequestContentOneOf1 => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        type: json['type'],
        valueB: json['valueB'],
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.putTest = this.putTest.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async putTest(input?: PutTestRequest): Promise<PutTest200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.PutTestRequestContent.toJson(input))
          : String($IO.PutTestRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'PUT',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.PutTest200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - composite schemas > should handle composite primitive and array request bodies 1`] = `
"export type CompositeRequestContent =
  | string
  | number
  | boolean
  | Array<string>
  | Array<CompositeRequestContentOneOf1Item>
  | { [key: string]: number }
  | { [key: string]: CompositeRequestContentOneOf3Value }
  | CompositeRequestContentOneOf4;
export type CompositeRequestContentOneOf1Item = {
  a?: string;
};
export type CompositeRequestContentOneOf3Value = {
  a?: string;
};
export type CompositeRequestContentOneOf4 = null | {
  key?: string;
};

export type CompositeRequest = CompositeRequestContent | undefined;
export type CompositeError = never;
"
`;

exports[`openApiTsClientGenerator - composite schemas > should handle composite primitive and array request bodies 2`] = `
"import type {
  CompositeRequestContent,
  CompositeRequestContentOneOf1Item,
  CompositeRequestContentOneOf3Value,
  CompositeRequestContentOneOf4,
  CompositeRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static CompositeRequestContent = {
    toJson: (model: CompositeRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      if (typeof model === 'string') {
        return model;
      }
      if (typeof model === 'number') {
        return model;
      }
      if (typeof model === 'boolean') {
        return model;
      }
      if (
        Array.isArray(model) &&
        (model.length === 0 || typeof model[0] !== 'object')
      ) {
        return model;
      }
      if (
        Array.isArray(model) &&
        (model.length === 0 || typeof model[0] === 'object')
      ) {
        return model === null
          ? null
          : model.map($IO.CompositeRequestContentOneOf1Item.toJson);
      }
      return {
        ...(model === null ? null : model),
        ...(model === null
          ? null
          : $IO.$mapValues(
              model,
              $IO.CompositeRequestContentOneOf3Value.toJson,
            )),
        ...$IO.CompositeRequestContentOneOf4.toJson(
          model as CompositeRequestContentOneOf4,
        ),
      };
    },
    fromJson: (json: any): CompositeRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      if (typeof json === 'string') {
        return json;
      }
      if (typeof json === 'number') {
        return json;
      }
      if (typeof json === 'boolean') {
        return json;
      }
      if (
        Array.isArray(json) &&
        (json.length === 0 || typeof json[0] !== 'object')
      ) {
        return json;
      }
      if (
        Array.isArray(json) &&
        (json.length === 0 || typeof json[0] === 'object')
      ) {
        return json === null
          ? null
          : (json as Array<any>).map(
              $IO.CompositeRequestContentOneOf1Item.fromJson,
            );
      }
      return {
        ...(json === null ? null : json),
        ...(json === null
          ? null
          : $IO.$mapValues(
              json,
              $IO.CompositeRequestContentOneOf3Value.fromJson,
            )),
        ...$IO.CompositeRequestContentOneOf4.fromJson(json),
      };
    },
  };

  public static CompositeRequestContentOneOf1Item = {
    toJson: (model: CompositeRequestContentOneOf1Item): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.a === undefined
          ? {}
          : {
              a: model.a,
            }),
      };
    },
    fromJson: (json: any): CompositeRequestContentOneOf1Item => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['a'] === undefined
          ? {}
          : {
              a: json['a'],
            }),
      };
    },
  };

  public static CompositeRequestContentOneOf3Value = {
    toJson: (model: CompositeRequestContentOneOf3Value): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.a === undefined
          ? {}
          : {
              a: model.a,
            }),
      };
    },
    fromJson: (json: any): CompositeRequestContentOneOf3Value => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['a'] === undefined
          ? {}
          : {
              a: json['a'],
            }),
      };
    },
  };

  public static CompositeRequestContentOneOf4 = {
    toJson: (model: CompositeRequestContentOneOf4): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.key === undefined
          ? {}
          : {
              key: model.key,
            }),
      };
    },
    fromJson: (json: any): CompositeRequestContentOneOf4 => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['key'] === undefined
          ? {}
          : {
              key: json['key'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.composite = this.composite.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async composite(input?: CompositeRequest): Promise<string> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.CompositeRequestContent.toJson(input))
          : String($IO.CompositeRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/composite', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.text();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - composite schemas > should handle inline primitives and composite schemas 1`] = `
"export type TestArrays200Response = {
  [key: string]: number;
};
export type TestArraysWithOtherParameters200Response = {
  [key: string]: number;
};
export type TestArraysWithOtherParametersRequestBodyParameters = {
  body?: Array<string>;
};
export type TestArraysWithOtherParametersRequestQueryParameters = {
  someParameter?: string;
};
export type TestComposites200Response =
  | TestComposites200ResponseAnyOf
  | TestComposites200ResponseAnyOf1;
export type TestComposites200ResponseAnyOf = {
  foo?: string;
};
export type TestComposites200ResponseAnyOf1 = {
  bar?: string;
};
export type TestCompositesRequestContent =
  | TestCompositesRequestContentOneOf
  | string;
export type TestCompositesRequestContentOneOf = 'a' | 'b' | 'c';
export type TestEnums200Response = 'pending' | 'active' | 'completed';

export type TestArraysRequest = Array<string> | undefined;
export type TestArraysError = never;

export type TestArraysWithOtherParametersRequest =
  TestArraysWithOtherParametersRequestQueryParameters &
    TestArraysWithOtherParametersRequestBodyParameters;
export type TestArraysWithOtherParametersError = never;

export type TestCompositesRequest = TestCompositesRequestContent | undefined;
export type TestCompositesError = never;
export type TestEnumsError = never;

export type TestPrimitiveBinaryRequest = Blob;
export type TestPrimitiveBinaryError = never;

export type TestPrimitiveTextRequest = string;
export type TestPrimitiveTextError = never;
"
`;

exports[`openApiTsClientGenerator - composite schemas > should handle inline primitives and composite schemas 2`] = `
"import type {
  TestArrays200Response,
  TestArraysWithOtherParameters200Response,
  TestArraysWithOtherParametersRequestBodyParameters,
  TestArraysWithOtherParametersRequestQueryParameters,
  TestComposites200Response,
  TestComposites200ResponseAnyOf,
  TestComposites200ResponseAnyOf1,
  TestCompositesRequestContent,
  TestCompositesRequestContentOneOf,
  TestEnums200Response,
  TestArraysRequest,
  TestArraysWithOtherParametersRequest,
  TestCompositesRequest,
  TestPrimitiveBinaryRequest,
  TestPrimitiveTextRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static TestArrays200Response = {
    toJson: (model: TestArrays200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): TestArrays200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static TestArraysWithOtherParameters200Response = {
    toJson: (model: TestArraysWithOtherParameters200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): TestArraysWithOtherParameters200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static TestArraysWithOtherParametersRequestBodyParameters = {
    toJson: (
      model: TestArraysWithOtherParametersRequestBodyParameters,
    ): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.body === undefined
          ? {}
          : {
              body: model.body,
            }),
      };
    },
    fromJson: (
      json: any,
    ): TestArraysWithOtherParametersRequestBodyParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['body'] === undefined
          ? {}
          : {
              body: json['body'],
            }),
      };
    },
  };

  public static TestArraysWithOtherParametersRequestQueryParameters = {
    toJson: (
      model: TestArraysWithOtherParametersRequestQueryParameters,
    ): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.someParameter === undefined
          ? {}
          : {
              someParameter: model.someParameter,
            }),
      };
    },
    fromJson: (
      json: any,
    ): TestArraysWithOtherParametersRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['someParameter'] === undefined
          ? {}
          : {
              someParameter: json['someParameter'],
            }),
      };
    },
  };

  public static TestComposites200Response = {
    toJson: (model: TestComposites200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...$IO.TestComposites200ResponseAnyOf.toJson(
          model as TestComposites200ResponseAnyOf,
        ),
        ...$IO.TestComposites200ResponseAnyOf1.toJson(
          model as TestComposites200ResponseAnyOf1,
        ),
      };
    },
    fromJson: (json: any): TestComposites200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...$IO.TestComposites200ResponseAnyOf.fromJson(json),
        ...$IO.TestComposites200ResponseAnyOf1.fromJson(json),
      };
    },
  };

  public static TestComposites200ResponseAnyOf = {
    toJson: (model: TestComposites200ResponseAnyOf): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.foo === undefined
          ? {}
          : {
              foo: model.foo,
            }),
      };
    },
    fromJson: (json: any): TestComposites200ResponseAnyOf => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['foo'] === undefined
          ? {}
          : {
              foo: json['foo'],
            }),
      };
    },
  };

  public static TestComposites200ResponseAnyOf1 = {
    toJson: (model: TestComposites200ResponseAnyOf1): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.bar === undefined
          ? {}
          : {
              bar: model.bar,
            }),
      };
    },
    fromJson: (json: any): TestComposites200ResponseAnyOf1 => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['bar'] === undefined
          ? {}
          : {
              bar: json['bar'],
            }),
      };
    },
  };

  public static TestCompositesRequestContent = {
    toJson: (model: TestCompositesRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      if (typeof model === 'string') {
        return model;
      }
      if (typeof model === 'string') {
        return model;
      }
      return model;
    },
    fromJson: (json: any): TestCompositesRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      if (typeof json === 'string') {
        return json;
      }
      if (typeof json === 'string') {
        return json;
      }
      return json;
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.testArrays = this.testArrays.bind(this);
    this.testArraysWithOtherParameters =
      this.testArraysWithOtherParameters.bind(this);
    this.testComposites = this.testComposites.bind(this);
    this.testEnums = this.testEnums.bind(this);
    this.testPrimitiveBinary = this.testPrimitiveBinary.bind(this);
    this.testPrimitiveText = this.testPrimitiveText.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async testArrays(
    input?: TestArraysRequest,
  ): Promise<TestArrays200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify(input)
          : String(input);

    const response = await this.$fetch(
      this.$url('/arrays', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.TestArrays200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async testArraysWithOtherParameters(
    input: TestArraysWithOtherParametersRequest,
  ): Promise<TestArraysWithOtherParameters200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } =
      $IO.TestArraysWithOtherParametersRequestQueryParameters.toJson(input);
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const collectionFormats = {
      someParameter: 'multi',
    } as const;
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify(
              $IO.TestArraysWithOtherParametersRequestBodyParameters.toJson(
                input,
              ).body,
            )
          : String(
              $IO.TestArraysWithOtherParametersRequestBodyParameters.toJson(
                input,
              ).body,
            );

    const response = await this.$fetch(
      this.$url(
        '/arrays-with-other-parameters',
        pathParameters,
        queryParameters,
        collectionFormats,
      ),
      {
        headers: this.$headers(headerParameters, collectionFormats),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.TestArraysWithOtherParameters200Response.fromJson(
        await response.json(),
      );
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async testComposites(
    input?: TestCompositesRequest,
  ): Promise<TestComposites200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.TestCompositesRequestContent.toJson(input))
          : String($IO.TestCompositesRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/composites', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.TestComposites200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async testEnums(): Promise<TestEnums200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/enums', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return (await response.text()) as TestEnums200Response;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async testPrimitiveBinary(
    input: TestPrimitiveBinaryRequest,
  ): Promise<Blob> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/octet-stream';
    }
    const body = input;

    const response = await this.$fetch(
      this.$url('/primitives/binary', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return await response.blob();
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async testPrimitiveText(
    input: TestPrimitiveTextRequest,
  ): Promise<number> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body = String(input);

    const response = await this.$fetch(
      this.$url('/primitives/text', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return Number(await response.text());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - composite schemas > should handle not schema type 1`] = `
"export type TestNot200Response = {
  result?: string;
};
export type TestNotRequestContent = {
  notObject?: unknown;
  notString?: unknown;
};
export type TestNotRequestContentNotObjectNot = {
  foo?: string;
};

export type TestNotRequest = TestNotRequestContent | undefined;
export type TestNotError = never;
"
`;

exports[`openApiTsClientGenerator - composite schemas > should handle not schema type 2`] = `
"import type {
  TestNot200Response,
  TestNotRequestContent,
  TestNotRequestContentNotObjectNot,
  TestNotRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static TestNot200Response = {
    toJson: (model: TestNot200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.result === undefined
          ? {}
          : {
              result: model.result,
            }),
      };
    },
    fromJson: (json: any): TestNot200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['result'] === undefined
          ? {}
          : {
              result: json['result'],
            }),
      };
    },
  };

  public static TestNotRequestContent = {
    toJson: (model: TestNotRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.notObject === undefined
          ? {}
          : {
              notObject: model.notObject,
            }),
        ...(model.notString === undefined
          ? {}
          : {
              notString: model.notString,
            }),
      };
    },
    fromJson: (json: any): TestNotRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['notObject'] === undefined
          ? {}
          : {
              notObject: json['notObject'],
            }),
        ...(json['notString'] === undefined
          ? {}
          : {
              notString: json['notString'],
            }),
      };
    },
  };

  public static TestNotRequestContentNotObjectNot = {
    toJson: (model: TestNotRequestContentNotObjectNot): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.foo === undefined
          ? {}
          : {
              foo: model.foo,
            }),
      };
    },
    fromJson: (json: any): TestNotRequestContentNotObjectNot => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['foo'] === undefined
          ? {}
          : {
              foo: json['foo'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.testNot = this.testNot.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async testNot(input?: TestNotRequest): Promise<TestNot200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.TestNotRequestContent.toJson(input))
          : String($IO.TestNotRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/not', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.TestNot200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;
