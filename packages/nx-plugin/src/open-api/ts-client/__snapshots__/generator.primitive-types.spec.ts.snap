// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`openApiTsClientGenerator - primitive types > should generate valid TypeScript for primitive types 1`] = `
"export type GetTest200Response = {
  string: string;
  number: number;
  integer: number;
  boolean: boolean;
  nullableString?: string | null;
  optionalNumber?: number;
};
export type GetTestError = never;
"
`;

exports[`openApiTsClientGenerator - primitive types > should generate valid TypeScript for primitive types 2`] = `
"import type { GetTest200Response } from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static GetTest200Response = {
    toJson: (model: GetTest200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.string === undefined
          ? {}
          : {
              string: model.string,
            }),
        ...(model.number === undefined
          ? {}
          : {
              number: model.number,
            }),
        ...(model.integer === undefined
          ? {}
          : {
              integer: model.integer,
            }),
        ...(model.boolean === undefined
          ? {}
          : {
              boolean: model.boolean,
            }),
        ...(model.nullableString === undefined
          ? {}
          : {
              'nullable-string': model.nullableString,
            }),
        ...(model.optionalNumber === undefined
          ? {}
          : {
              optionalNumber: model.optionalNumber,
            }),
      };
    },
    fromJson: (json: any): GetTest200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        string: json['string'],
        number: json['number'],
        integer: json['integer'],
        boolean: json['boolean'],
        ...(json['nullable-string'] === undefined
          ? {}
          : {
              nullableString:
                json['nullable-string'] === null
                  ? null
                  : json['nullable-string'],
            }),
        ...(json['optionalNumber'] === undefined
          ? {}
          : {
              optionalNumber: json['optionalNumber'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.getTest = this.getTest.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  /**
   * Sends a test request!
   */
  public async getTest(): Promise<GetTest200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};

    const body = undefined;

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'GET',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.GetTest200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - primitive types > should generate valid typescript for openapi v3.1 specifications with null types 1`] = `
"export type PostTest200Response = {};
export type PostTestRequestContent = {
  requiredNull: null;
  optionalNull?: null;
  requiredCompositeNull: PostTestRequestContentRequiredCompositeNull;
  optionalCompositeNull?: PostTestRequestContentOptionalCompositeNull;
};
export type PostTestRequestContentOptionalCompositeNull = string | null;
export type PostTestRequestContentRequiredCompositeNull = string | null;

export type PostTestRequest = PostTestRequestContent;
export type PostTestError = never;
"
`;

exports[`openApiTsClientGenerator - primitive types > should generate valid typescript for openapi v3.1 specifications with null types 2`] = `
"import type {
  PostTest200Response,
  PostTestRequestContent,
  PostTestRequestContentOptionalCompositeNull,
  PostTestRequestContentRequiredCompositeNull,
  PostTestRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostTest200Response = {
    toJson: (model: PostTest200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...model,
      };
    },
    fromJson: (json: any): PostTest200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...json,
      };
    },
  };

  public static PostTestRequestContent = {
    toJson: (model: PostTestRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.requiredNull === undefined
          ? {}
          : {
              requiredNull: model.requiredNull,
            }),
        ...(model.optionalNull === undefined
          ? {}
          : {
              optionalNull: model.optionalNull,
            }),
        ...(model.requiredCompositeNull === undefined
          ? {}
          : {
              requiredCompositeNull:
                $IO.PostTestRequestContentRequiredCompositeNull.toJson(
                  model.requiredCompositeNull,
                ),
            }),
        ...(model.optionalCompositeNull === undefined
          ? {}
          : {
              optionalCompositeNull:
                $IO.PostTestRequestContentOptionalCompositeNull.toJson(
                  model.optionalCompositeNull,
                ),
            }),
      };
    },
    fromJson: (json: any): PostTestRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        requiredNull:
          json['requiredNull'] === null ? null : json['requiredNull'],
        ...(json['optionalNull'] === undefined
          ? {}
          : {
              optionalNull:
                json['optionalNull'] === null ? null : json['optionalNull'],
            }),
        requiredCompositeNull:
          $IO.PostTestRequestContentRequiredCompositeNull.fromJson(
            json['requiredCompositeNull'],
          ),
        ...(json['optionalCompositeNull'] === undefined
          ? {}
          : {
              optionalCompositeNull:
                $IO.PostTestRequestContentOptionalCompositeNull.fromJson(
                  json['optionalCompositeNull'],
                ),
            }),
      };
    },
  };

  public static PostTestRequestContentOptionalCompositeNull = {
    toJson: (model: PostTestRequestContentOptionalCompositeNull): any => {
      if (model === undefined || model === null) {
        return model;
      }
      if (typeof model === 'string') {
        return model;
      }
      return model;
    },
    fromJson: (json: any): PostTestRequestContentOptionalCompositeNull => {
      if (json === undefined || json === null) {
        return json;
      }
      if (typeof json === 'string') {
        return json;
      }
      return json;
    },
  };

  public static PostTestRequestContentRequiredCompositeNull = {
    toJson: (model: PostTestRequestContentRequiredCompositeNull): any => {
      if (model === undefined || model === null) {
        return model;
      }
      if (typeof model === 'string') {
        return model;
      }
      return model;
    },
    fromJson: (json: any): PostTestRequestContentRequiredCompositeNull => {
      if (json === undefined || json === null) {
        return json;
      }
      if (typeof json === 'string') {
        return json;
      }
      return json;
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.postTest = this.postTest.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async postTest(input: PostTestRequest): Promise<PostTest200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      typeof input === 'object'
        ? JSON.stringify($IO.PostTestRequestContent.toJson(input))
        : String($IO.PostTestRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.PostTest200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - primitive types > should handle date and date-time formats 1`] = `
"export type PostDates200Response = {
  processedDate?: Date;
  processedDateTime?: Date;
};
export type PostDatesRequestContent = {
  dateOnly: Date;
  dateTime: Date;
  dateArray?: Array<Date>;
  dateTimeArray?: Array<Date>;
};

export type PostDatesRequest = PostDatesRequestContent | undefined;
export type PostDatesError = never;

export type PostSingleDateRequest = Date;
export type PostSingleDateError = never;
"
`;

exports[`openApiTsClientGenerator - primitive types > should handle date and date-time formats 2`] = `
"import type {
  PostDates200Response,
  PostDatesRequestContent,
  PostDatesRequest,
  PostSingleDateRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostDates200Response = {
    toJson: (model: PostDates200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.processedDate === undefined
          ? {}
          : {
              processedDate: model.processedDate.toISOString().slice(0, 10),
            }),
        ...(model.processedDateTime === undefined
          ? {}
          : {
              processedDateTime: model.processedDateTime.toISOString(),
            }),
      };
    },
    fromJson: (json: any): PostDates200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['processedDate'] === undefined
          ? {}
          : {
              processedDate: new Date(json['processedDate']),
            }),
        ...(json['processedDateTime'] === undefined
          ? {}
          : {
              processedDateTime: new Date(json['processedDateTime']),
            }),
      };
    },
  };

  public static PostDatesRequestContent = {
    toJson: (model: PostDatesRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.dateOnly === undefined
          ? {}
          : {
              dateOnly: model.dateOnly.toISOString().slice(0, 10),
            }),
        ...(model.dateTime === undefined
          ? {}
          : {
              dateTime: model.dateTime.toISOString(),
            }),
        ...(model.dateArray === undefined
          ? {}
          : {
              dateArray: model.dateArray.map((item0) =>
                item0.toISOString().slice(0, 10),
              ),
            }),
        ...(model.dateTimeArray === undefined
          ? {}
          : {
              dateTimeArray: model.dateTimeArray.map((item0) =>
                item0.toISOString(),
              ),
            }),
      };
    },
    fromJson: (json: any): PostDatesRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        dateOnly: new Date(json['dateOnly']),
        dateTime: new Date(json['dateTime']),
        ...(json['dateArray'] === undefined
          ? {}
          : {
              dateArray: (json['dateArray'] as Array<any>).map(
                (item0) => new Date(item0),
              ),
            }),
        ...(json['dateTimeArray'] === undefined
          ? {}
          : {
              dateTimeArray: (json['dateTimeArray'] as Array<any>).map(
                (item0) => new Date(item0),
              ),
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.postDates = this.postDates.bind(this);
    this.postSingleDate = this.postSingleDate.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async postDates(
    input?: PostDatesRequest,
  ): Promise<PostDates200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.PostDatesRequestContent.toJson(input))
          : String($IO.PostDatesRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/dates', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.PostDates200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }

  public async postSingleDate(input: PostSingleDateRequest): Promise<Date> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body = input.toISOString().slice(0, 10);

    const response = await this.$fetch(
      this.$url('/single-date', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return new Date(await response.text());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - primitive types > should handle enum request and response bodies 1`] = `
"export type UpdateStatus200Response = 'accepted' | 'rejected';
export type UpdateStatusRequestContent =
  | 'pending'
  | 'in_progress'
  | 'completed'
  | 'failed';

export type UpdateStatusRequest = UpdateStatusRequestContent;
export type UpdateStatusError = never;
"
`;

exports[`openApiTsClientGenerator - primitive types > should handle enum request and response bodies 2`] = `
"import type {
  UpdateStatus200Response,
  UpdateStatusRequestContent,
  UpdateStatusRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.updateStatus = this.updateStatus.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async updateStatus(
    input: UpdateStatusRequest,
  ): Promise<UpdateStatus200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body = input;

    const response = await this.$fetch(
      this.$url('/status', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return (await response.text()) as UpdateStatus200Response;
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - primitive types > should handle number and string constraints 1`] = `
"export type TestConstraints200Response = {
  result?: string;
};
export type TestConstraintsRequestContent = {
  constrainedInt: number;
  constrainedString: string;
  hostname?: string;
  ipv4?: string;
  ipv6?: string;
  uri?: string;
};

export type TestConstraintsRequest = TestConstraintsRequestContent | undefined;
export type TestConstraintsError = never;
"
`;

exports[`openApiTsClientGenerator - primitive types > should handle number and string constraints 2`] = `
"import type {
  TestConstraints200Response,
  TestConstraintsRequestContent,
  TestConstraintsRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static TestConstraints200Response = {
    toJson: (model: TestConstraints200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.result === undefined
          ? {}
          : {
              result: model.result,
            }),
      };
    },
    fromJson: (json: any): TestConstraints200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['result'] === undefined
          ? {}
          : {
              result: json['result'],
            }),
      };
    },
  };

  public static TestConstraintsRequestContent = {
    toJson: (model: TestConstraintsRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.constrainedInt === undefined
          ? {}
          : {
              constrainedInt: model.constrainedInt,
            }),
        ...(model.constrainedString === undefined
          ? {}
          : {
              constrainedString: model.constrainedString,
            }),
        ...(model.hostname === undefined
          ? {}
          : {
              hostname: model.hostname,
            }),
        ...(model.ipv4 === undefined
          ? {}
          : {
              ipv4: model.ipv4,
            }),
        ...(model.ipv6 === undefined
          ? {}
          : {
              ipv6: model.ipv6,
            }),
        ...(model.uri === undefined
          ? {}
          : {
              uri: model.uri,
            }),
      };
    },
    fromJson: (json: any): TestConstraintsRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        constrainedInt: json['constrainedInt'],
        constrainedString: json['constrainedString'],
        ...(json['hostname'] === undefined
          ? {}
          : {
              hostname: json['hostname'],
            }),
        ...(json['ipv4'] === undefined
          ? {}
          : {
              ipv4: json['ipv4'],
            }),
        ...(json['ipv6'] === undefined
          ? {}
          : {
              ipv6: json['ipv6'],
            }),
        ...(json['uri'] === undefined
          ? {}
          : {
              uri: json['uri'],
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.testConstraints = this.testConstraints.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async testConstraints(
    input?: TestConstraintsRequest,
  ): Promise<TestConstraints200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } = {};
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.TestConstraintsRequestContent.toJson(input))
          : String($IO.TestConstraintsRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/constraints', pathParameters, queryParameters),
      {
        headers: this.$headers(headerParameters),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.TestConstraints200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;

exports[`openApiTsClientGenerator - primitive types > should handle special formats and vendor extensions 1`] = `
"export type PostTest200Response = {
  createdAt?: Date;
};
export type PostTestRequestContent = {
  int32?: number;
  int64?: number;
  float?: number;
  double?: number;
  binary?: Blob;
  byte?: string;
  uuid?: string;
  email?: string;
};
export type PostTestRequestQueryParameters = {
  date?: Date;
  timestamp?: Date;
};

export type PostTestRequest = PostTestRequestQueryParameters &
  PostTestRequestContent;
export type PostTestError = never;
"
`;

exports[`openApiTsClientGenerator - primitive types > should handle special formats and vendor extensions 2`] = `
"import type {
  PostTest200Response,
  PostTestRequestContent,
  PostTestRequestQueryParameters,
  PostTestRequest,
} from './types.gen.js';

/**
 * Utility for serialisation and deserialisation of API types.
 */
export class $IO {
  protected static $mapValues = (data: any, fn: (item: any) => any) =>
    Object.fromEntries(Object.entries(data).map(([k, v]) => [k, fn(v)]));

  public static PostTest200Response = {
    toJson: (model: PostTest200Response): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.createdAt === undefined
          ? {}
          : {
              createdAt: model.createdAt.toISOString(),
            }),
      };
    },
    fromJson: (json: any): PostTest200Response => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['createdAt'] === undefined
          ? {}
          : {
              createdAt: new Date(json['createdAt']),
            }),
      };
    },
  };

  public static PostTestRequestContent = {
    toJson: (model: PostTestRequestContent): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.int32 === undefined
          ? {}
          : {
              int32: model.int32,
            }),
        ...(model.int64 === undefined
          ? {}
          : {
              int64: model.int64,
            }),
        ...(model.float === undefined
          ? {}
          : {
              float: model.float,
            }),
        ...(model.double === undefined
          ? {}
          : {
              double: model.double,
            }),
        ...(model.binary === undefined
          ? {}
          : {
              binary: model.binary,
            }),
        ...(model.byte === undefined
          ? {}
          : {
              byte: model.byte,
            }),
        ...(model.uuid === undefined
          ? {}
          : {
              uuid: model.uuid,
            }),
        ...(model.email === undefined
          ? {}
          : {
              email: model.email,
            }),
      };
    },
    fromJson: (json: any): PostTestRequestContent => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['int32'] === undefined
          ? {}
          : {
              int32: json['int32'],
            }),
        ...(json['int64'] === undefined
          ? {}
          : {
              int64: json['int64'],
            }),
        ...(json['float'] === undefined
          ? {}
          : {
              float: json['float'],
            }),
        ...(json['double'] === undefined
          ? {}
          : {
              double: json['double'],
            }),
        ...(json['binary'] === undefined
          ? {}
          : {
              binary: json['binary'],
            }),
        ...(json['byte'] === undefined
          ? {}
          : {
              byte: json['byte'],
            }),
        ...(json['uuid'] === undefined
          ? {}
          : {
              uuid: json['uuid'],
            }),
        ...(json['email'] === undefined
          ? {}
          : {
              email: json['email'],
            }),
      };
    },
  };

  public static PostTestRequestQueryParameters = {
    toJson: (model: PostTestRequestQueryParameters): any => {
      if (model === undefined || model === null) {
        return model;
      }
      return {
        ...(model.date === undefined
          ? {}
          : {
              date: model.date.toISOString().slice(0, 10),
            }),
        ...(model.timestamp === undefined
          ? {}
          : {
              timestamp: model.timestamp.toISOString(),
            }),
      };
    },
    fromJson: (json: any): PostTestRequestQueryParameters => {
      if (json === undefined || json === null) {
        return json;
      }
      return {
        ...(json['date'] === undefined
          ? {}
          : {
              date: new Date(json['date']),
            }),
        ...(json['timestamp'] === undefined
          ? {}
          : {
              timestamp: new Date(json['timestamp']),
            }),
      };
    },
  };
}

/**
 * Client configuration for TestApi
 */
export interface TestApiConfig {
  /**
   * Base URL for the API
   */
  url: string;
  /**
   * Custom instance of fetch. By default the global 'fetch' is used.
   * You can override this to add custom middleware for use cases such as adding authentication headers.
   */
  fetch?: typeof fetch;
  /**
   * Additional configuration
   */
  options?: {
    /**
     * By default, the client will add a Content-Type header, set to the media type defined for
     * the request in the OpenAPI specification.
     * Set this to false to omit this header.
     */
    omitContentTypeHeader?: boolean;
  };
}

/**
 * API Client for TestApi
 */
export class TestApi {
  private $config: TestApiConfig;

  constructor(config: TestApiConfig) {
    this.$config = config;

    this.postTest = this.postTest.bind(this);
  }

  private $url = (
    path: string,
    pathParameters: { [key: string]: any },
    queryParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): string => {
    const baseUrl = this.$config.url.endsWith('/')
      ? this.$config.url.slice(0, -1)
      : this.$config.url;
    const pathWithParameters = Object.entries(pathParameters).reduce(
      (withParams, [key, value]) =>
        withParams.replace(\`{\${key}}\`, encodeURIComponent(\`\${value}\`)),
      path,
    );
    const queryString = Object.entries(queryParameters)
      .map(([key, value]) => {
        if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
          return value
            .map(
              (v) => \`\${encodeURIComponent(key)}=\${encodeURIComponent(\`\${v}\`)}\`,
            )
            .join('&');
        }
        return \`\${encodeURIComponent(key)}=\${encodeURIComponent(Array.isArray(value) ? value.map(String).join(',') : String(value))}\`;
      })
      .join('&');
    return (
      baseUrl + pathWithParameters + (queryString ? \`?\${queryString}\` : '')
    );
  };

  private $headers = (
    headerParameters: { [key: string]: any },
    collectionFormats?: { [key: string]: 'multi' | 'csv' },
  ): [string, string][] => {
    return Object.entries(headerParameters).flatMap(([key, value]) => {
      if (Array.isArray(value) && collectionFormats?.[key] === 'multi') {
        return value.map((v) => [key, String(v)]) as [string, string][];
      }
      return [[key, String(value)]];
    });
  };

  private $fetch: typeof fetch = (...args) =>
    (this.$config.fetch ?? fetch)(...args);

  public async postTest(input: PostTestRequest): Promise<PostTest200Response> {
    const pathParameters: { [key: string]: any } = {};
    const queryParameters: { [key: string]: any } =
      $IO.PostTestRequestQueryParameters.toJson(input);
    const headerParameters: { [key: string]: any } = {};
    if (!this.$config.options?.omitContentTypeHeader) {
      headerParameters['Content-Type'] = 'application/json';
    }
    const collectionFormats = {
      date: 'multi',
      timestamp: 'multi',
    } as const;
    const body =
      input === undefined
        ? undefined
        : typeof input === 'object'
          ? JSON.stringify($IO.PostTestRequestContent.toJson(input))
          : String($IO.PostTestRequestContent.toJson(input));

    const response = await this.$fetch(
      this.$url('/test', pathParameters, queryParameters, collectionFormats),
      {
        headers: this.$headers(headerParameters, collectionFormats),
        method: 'POST',
        body,
      },
    );

    if (response.status === 200) {
      return $IO.PostTest200Response.fromJson(await response.json());
    }
    throw new Error(
      \`Unknown response status \${response.status} returned by API\`,
    );
  }
}
"
`;
