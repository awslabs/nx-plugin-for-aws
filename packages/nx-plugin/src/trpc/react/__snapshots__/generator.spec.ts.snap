// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`trpc react generator > REST API (ServerlessApiGatewayRestApi) > should generate REST API client provider with splitLink for Cognito auth > TestApiClientProvider-REST-Cognito.tsx 1`] = `
"import { AppRouter } from 'backend';
import { useQueryClient } from '@tanstack/react-query';
import { createTRPCOptionsProxy } from '@trpc/tanstack-react-query';
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useRuntimeConfig } from '../hooks/useRuntimeConfig';
import {
  TRPCClient,
  createTRPCClient,
  httpLink,
  httpSubscriptionLink,
  splitLink,
} from '@trpc/client';
import { EventSourcePolyfill } from 'event-source-polyfill';
import { useAuth } from 'react-oidc-context';

interface TestApiTRPCContextValue {
  optionsProxy: ReturnType<typeof createTRPCOptionsProxy<AppRouter>>;
  client: TRPCClient<AppRouter>;
}

export const TestApiTRPCContext = createContext<TestApiTRPCContextValue | null>(
  null,
);

export const TestApiClientProvider: FC<PropsWithChildren> = ({ children }) => {
  const queryClient = useQueryClient();
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.TestApi;
  const auth = useAuth();
  const user = auth?.user;

  const container = useMemo<TestApiTRPCContextValue>(() => {
    const client = createTRPCClient<AppRouter>({
      links: [
        splitLink({
          condition: (op) => op.type === 'subscription',
          true: httpSubscriptionLink({
            url: apiUrl,
            EventSource: EventSourcePolyfill,
            eventSourceOptions: async ({ op }) => {
              const url =
                \`\${apiUrl.replace(/\\/$/, '')}/\${op.path}\` +
                (op.input !== undefined
                  ? \`?input=\${encodeURIComponent(JSON.stringify(op.input))}\`
                  : '');
              return {
                headers: {
                  Authorization: \`Bearer \${user?.id_token}\`,
                },
              };
            },
          }),
          false: httpLink({
            url: apiUrl,
            headers: {
              Authorization: \`Bearer \${user?.id_token}\`,
            },
          }),
        }),
      ],
    });

    const optionsProxy = createTRPCOptionsProxy<AppRouter>({
      client,
      queryClient,
    });

    return { optionsProxy, client };
  }, [apiUrl, queryClient, user]);

  return (
    <TestApiTRPCContext.Provider value={container}>
      {children}
    </TestApiTRPCContext.Provider>
  );
};

export default TestApiClientProvider;
"
`;

exports[`trpc react generator > REST API (ServerlessApiGatewayRestApi) > should generate REST API client provider with splitLink for IAM auth > TestApiClientProvider-REST-IAM.tsx 1`] = `
"import { AppRouter } from 'backend';
import { useQueryClient } from '@tanstack/react-query';
import { createTRPCOptionsProxy } from '@trpc/tanstack-react-query';
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useRuntimeConfig } from '../hooks/useRuntimeConfig';
import {
  TRPCClient,
  createTRPCClient,
  httpLink,
  httpSubscriptionLink,
  splitLink,
} from '@trpc/client';
import { EventSourcePolyfill } from 'event-source-polyfill';
import { useSigV4 } from '../hooks/useSigV4';

interface TestApiTRPCContextValue {
  optionsProxy: ReturnType<typeof createTRPCOptionsProxy<AppRouter>>;
  client: TRPCClient<AppRouter>;
}

export const TestApiTRPCContext = createContext<TestApiTRPCContextValue | null>(
  null,
);

export const TestApiClientProvider: FC<PropsWithChildren> = ({ children }) => {
  const queryClient = useQueryClient();
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.TestApi;
  const sigv4Client = useSigV4();

  const container = useMemo<TestApiTRPCContextValue>(() => {
    const client = createTRPCClient<AppRouter>({
      links: [
        splitLink({
          condition: (op) => op.type === 'subscription',
          true: httpSubscriptionLink({
            url: apiUrl,
            EventSource: EventSourcePolyfill,
            eventSourceOptions: async ({ op }) => {
              const url =
                \`\${apiUrl.replace(/\\/$/, '')}/\${op.path}\` +
                (op.input !== undefined
                  ? \`?input=\${encodeURIComponent(JSON.stringify(op.input))}\`
                  : '');
              const signed = await sigv4Client.sign(url, { method: 'GET' });
              const headers: Record<string, string> = {};
              signed.headers.forEach((v, k) => {
                headers[k] = v;
              });
              return { headers };
            },
          }),
          false: httpLink({
            url: apiUrl,
            fetch: sigv4Client.fetch,
          }),
        }),
      ],
    });

    const optionsProxy = createTRPCOptionsProxy<AppRouter>({
      client,
      queryClient,
    });

    return { optionsProxy, client };
  }, [apiUrl, queryClient, sigv4Client]);

  return (
    <TestApiTRPCContext.Provider value={container}>
      {children}
    </TestApiTRPCContext.Provider>
  );
};

export default TestApiClientProvider;
"
`;

exports[`trpc react generator > REST API (ServerlessApiGatewayRestApi) > should generate REST API client provider with splitLink for None auth > TestApiClientProvider-REST-None.tsx 1`] = `
"import { AppRouter } from 'backend';
import { useQueryClient } from '@tanstack/react-query';
import { createTRPCOptionsProxy } from '@trpc/tanstack-react-query';
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useRuntimeConfig } from '../hooks/useRuntimeConfig';
import {
  TRPCClient,
  createTRPCClient,
  httpLink,
  httpSubscriptionLink,
  splitLink,
} from '@trpc/client';

interface TestApiTRPCContextValue {
  optionsProxy: ReturnType<typeof createTRPCOptionsProxy<AppRouter>>;
  client: TRPCClient<AppRouter>;
}

export const TestApiTRPCContext = createContext<TestApiTRPCContextValue | null>(
  null,
);

export const TestApiClientProvider: FC<PropsWithChildren> = ({ children }) => {
  const queryClient = useQueryClient();
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.TestApi;

  const container = useMemo<TestApiTRPCContextValue>(() => {
    const client = createTRPCClient<AppRouter>({
      links: [
        splitLink({
          condition: (op) => op.type === 'subscription',
          true: httpSubscriptionLink({
            url: apiUrl,
          }),
          false: httpLink({
            url: apiUrl,
          }),
        }),
      ],
    });

    const optionsProxy = createTRPCOptionsProxy<AppRouter>({
      client,
      queryClient,
    });

    return { optionsProxy, client };
  }, [apiUrl, queryClient]);

  return (
    <TestApiTRPCContext.Provider value={container}>
      {children}
    </TestApiTRPCContext.Provider>
  );
};

export default TestApiClientProvider;
"
`;

exports[`trpc react generator > should generate trpc react files > TestApiClientProvider.tsx 1`] = `
"import { AppRouter } from 'backend';
import { useQueryClient } from '@tanstack/react-query';
import { createTRPCOptionsProxy } from '@trpc/tanstack-react-query';
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useRuntimeConfig } from '../hooks/useRuntimeConfig';
import {
  HTTPLinkOptions,
  TRPCClient,
  createTRPCClient,
  httpLink,
} from '@trpc/client';

interface TestApiTRPCContextValue {
  optionsProxy: ReturnType<typeof createTRPCOptionsProxy<AppRouter>>;
  client: TRPCClient<AppRouter>;
}

export const TestApiTRPCContext = createContext<TestApiTRPCContextValue | null>(
  null,
);

export const TestApiClientProvider: FC<PropsWithChildren> = ({ children }) => {
  const queryClient = useQueryClient();
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.TestApi;

  const container = useMemo<TestApiTRPCContextValue>(() => {
    const linkOptions: HTTPLinkOptions<any> = {
      url: apiUrl,
    };

    const client = createTRPCClient<AppRouter>({
      links: [httpLink(linkOptions)],
    });

    const optionsProxy = createTRPCOptionsProxy<AppRouter>({
      client,
      queryClient,
    });

    return { optionsProxy, client };
  }, [apiUrl, queryClient]);

  return (
    <TestApiTRPCContext.Provider value={container}>
      {children}
    </TestApiTRPCContext.Provider>
  );
};

export default TestApiClientProvider;
"
`;

exports[`trpc react generator > should generate trpc react files > useTestApi.tsx 1`] = `
"import { useContext } from 'react';
import { TestApiTRPCContext } from '../components/TestApiClientProvider';

export const useTestApi = () => {
  const container = useContext(TestApiTRPCContext);
  if (!container) {
    throw new Error('useTestApi must be used within TestApiClientProvider');
  }
  return container.optionsProxy;
};

export const useTestApiClient = () => {
  const container = useContext(TestApiTRPCContext);
  if (!container) {
    throw new Error(
      'useTestApiClient must be used within TestApiClientProvider',
    );
  }
  return container.client;
};
"
`;

exports[`trpc react generator > should handle Cognito auth option > TestApiClientProvider-Cognito.tsx 1`] = `
"import { AppRouter } from 'backend';
import { useQueryClient } from '@tanstack/react-query';
import { createTRPCOptionsProxy } from '@trpc/tanstack-react-query';
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useRuntimeConfig } from '../hooks/useRuntimeConfig';
import {
  HTTPLinkOptions,
  TRPCClient,
  createTRPCClient,
  httpLink,
} from '@trpc/client';
import { useAuth } from 'react-oidc-context';

interface TestApiTRPCContextValue {
  optionsProxy: ReturnType<typeof createTRPCOptionsProxy<AppRouter>>;
  client: TRPCClient<AppRouter>;
}

export const TestApiTRPCContext = createContext<TestApiTRPCContextValue | null>(
  null,
);

export const TestApiClientProvider: FC<PropsWithChildren> = ({ children }) => {
  const queryClient = useQueryClient();
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.TestApi;
  const auth = useAuth();
  const user = auth?.user;

  const container = useMemo<TestApiTRPCContextValue>(() => {
    const linkOptions: HTTPLinkOptions<any> = {
      url: apiUrl,
      headers: {
        Authorization: \`Bearer \${user?.id_token}\`,
      },
    };

    const client = createTRPCClient<AppRouter>({
      links: [httpLink(linkOptions)],
    });

    const optionsProxy = createTRPCOptionsProxy<AppRouter>({
      client,
      queryClient,
    });

    return { optionsProxy, client };
  }, [apiUrl, queryClient, user]);

  return (
    <TestApiTRPCContext.Provider value={container}>
      {children}
    </TestApiTRPCContext.Provider>
  );
};

export default TestApiClientProvider;
"
`;

exports[`trpc react generator > should handle IAM auth option > TestApiClientProvider-IAM.tsx 1`] = `
"import { AppRouter } from 'backend';
import { useQueryClient } from '@tanstack/react-query';
import { createTRPCOptionsProxy } from '@trpc/tanstack-react-query';
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useRuntimeConfig } from '../hooks/useRuntimeConfig';
import {
  HTTPLinkOptions,
  TRPCClient,
  createTRPCClient,
  httpLink,
} from '@trpc/client';
import { useSigV4 } from '../hooks/useSigV4';

interface TestApiTRPCContextValue {
  optionsProxy: ReturnType<typeof createTRPCOptionsProxy<AppRouter>>;
  client: TRPCClient<AppRouter>;
}

export const TestApiTRPCContext = createContext<TestApiTRPCContextValue | null>(
  null,
);

export const TestApiClientProvider: FC<PropsWithChildren> = ({ children }) => {
  const queryClient = useQueryClient();
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.TestApi;
  const sigv4Client = useSigV4();

  const container = useMemo<TestApiTRPCContextValue>(() => {
    const linkOptions: HTTPLinkOptions<any> = {
      url: apiUrl,
      fetch: sigv4Client.fetch,
    };

    const client = createTRPCClient<AppRouter>({
      links: [httpLink(linkOptions)],
    });

    const optionsProxy = createTRPCOptionsProxy<AppRouter>({
      client,
      queryClient,
    });

    return { optionsProxy, client };
  }, [apiUrl, queryClient, sigv4Client]);

  return (
    <TestApiTRPCContext.Provider value={container}>
      {children}
    </TestApiTRPCContext.Provider>
  );
};

export default TestApiClientProvider;
"
`;

exports[`trpc react generator > should handle IAM auth option > useSigV4.tsx 1`] = `
"import { AwsClient } from 'aws4fetch';
import { CognitoIdentityClient } from '@aws-sdk/client-cognito-identity';
import { fromCognitoIdentityPool } from '@aws-sdk/credential-provider-cognito-identity';
import { useCallback, useRef } from 'react';
import { useAuth } from 'react-oidc-context';
import { useRuntimeConfig } from './useRuntimeConfig';
import {
  AwsCredentialIdentity,
  AwsCredentialIdentityProvider,
} from '@smithy/types';

// Credential expiration grace time before considering credentials as expired
const CREDENTIAL_EXPIRY_OFFSET_MILLIS = 30 * 1000;

type AwsSignInput = Parameters<AwsClient['sign']>[0];
type AwsSignInit = Parameters<AwsClient['sign']>[1];

export interface SigV4Client {
  /** A SigV4-signing fetch drop-in replacement. */
  fetch: typeof globalThis.fetch;
  /** Signs a request. Same parameters as AwsClient.sign(). Returns an unsigned Request when signing is skipped. */
  sign: AwsClient['sign'];
}

export const useSigV4 = (): SigV4Client => {
  const { cognitoProps } = useRuntimeConfig();
  const auth = useAuth();
  const user = auth?.user;

  const cachedCredentials = useRef<{ [key: string]: AwsCredentialIdentity }>(
    {},
  );

  const skipSigning = !cognitoProps && import.meta.env.MODE === 'serve-local';

  const withCachedCredentials = useCallback(
    async (
      provider: AwsCredentialIdentityProvider,
      ...cacheKeys: string[]
    ): Promise<AwsCredentialIdentity> => {
      const key = \`sigv4/\${cacheKeys.join('/')}\`;
      const cachedCreds = cachedCredentials.current[key];
      if (
        cachedCreds &&
        cachedCreds.expiration &&
        cachedCreds.expiration.getTime() >
          Date.now() + CREDENTIAL_EXPIRY_OFFSET_MILLIS
      ) {
        return cachedCreds;
      }
      const credentials = await provider();
      cachedCredentials.current[key] = credentials;
      return credentials;
    },
    [],
  );

  const getAwsClient = useCallback(async (): Promise<AwsClient> => {
    if (!cognitoProps) {
      throw new Error('cognitoProps is undefined!');
    }
    if (!user?.id_token) {
      throw new Error('user.id_token is undefined!');
    }

    const credentialsFromCognitoIdentityPool = fromCognitoIdentityPool({
      client: new CognitoIdentityClient({ region: cognitoProps.region }),
      identityPoolId: cognitoProps.identityPoolId,
      logins: {
        [\`cognito-idp.\${cognitoProps.region}.amazonaws.com/\${cognitoProps.userPoolId}\`]:
          user.id_token,
      },
    });
    const credential = await withCachedCredentials(
      credentialsFromCognitoIdentityPool,
      cognitoProps.identityPoolId,
      user.profile.sub,
    );
    return new AwsClient(credential);
  }, [cognitoProps, user?.id_token, user?.profile.sub, withCachedCredentials]);

  const sigv4Fetch: typeof globalThis.fetch = useCallback(
    async (input: RequestInfo | URL, init?: RequestInit | undefined) => {
      if (skipSigning) {
        return fetch(input, init);
      }
      const awsClient = await getAwsClient();
      return awsClient.fetch(input, init);
    },
    [skipSigning, getAwsClient],
  );

  const sign = useCallback(
    async (input: AwsSignInput, init?: AwsSignInit): Promise<Request> => {
      if (skipSigning) {
        return new Request(input.toString(), init ?? undefined);
      }
      const awsClient = await getAwsClient();
      return awsClient.sign(input, init);
    },
    [skipSigning, getAwsClient],
  );

  return { fetch: sigv4Fetch, sign };
};
"
`;

exports[`trpc react generator > should modify main.tsx correctly > main.tsx 1`] = `
"import TestApiClientProvider from './components/TestApiClientProvider';
import QueryClientProvider from './components/QueryClientProvider';
import RuntimeConfigProvider from './components/RuntimeConfig';

import { RouterProvider } from '@tanstack/react-router';

const App = () => <RouterProvider router={router} />;

export function Main() {
  return (
    <RuntimeConfigProvider>
      <QueryClientProvider>
        <TestApiClientProvider>
          <App />
        </TestApiClientProvider>
      </QueryClientProvider>
    </RuntimeConfigProvider>
  );
}
"
`;
