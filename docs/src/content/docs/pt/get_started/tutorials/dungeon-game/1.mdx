---
title: "Configurar um monorepo"
description: "Um guia passo a passo de como construir um jogo de aventura de dungeon alimentado por IA ag√™ntica usando o @aws/nx-plugin."
---

import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import PackageManagerShortCommand from '@components/package-manager-short-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Tarefa 1: Criar um monorepo

Para criar um novo monorepo, dentro do diret√≥rio desejado, execute o seguinte comando:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" iacProvider="CDK" />

:::note
Usamos `--iacProvider=CDK` pois usaremos CDK para infraestrutura como c√≥digo neste tutorial. O Nx Plugin para AWS tamb√©m suporta `Terraform`.
:::

Isso configurar√° um monorepo NX dentro do diret√≥rio `dungeon-adventure`. Quando voc√™ abrir o diret√≥rio no VSCode, ver√° esta estrutura de arquivos:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ aqui residir√£o seus subprojetos
- .gitignore
- .prettierignore
- .prettierrc
- nx.json configura o CLI do NX e padr√µes do monorepo
- package.json todas as depend√™ncias Node s√£o definidas aqui
- pnpm-lock.yaml ou bun.lock, yarn.lock, package-lock.json dependendo do gerenciador de pacotes
- pnpm-workspace.yaml se usar pnpm
- README.md
- tsconfig.base.json todos os subprojetos baseados em Node estendem este
- tsconfig.json
- aws-nx-plugin.config.mts configura√ß√£o do Nx Plugin para AWS
</FileTree>

Agora podemos come√ßar a criar nossos diferentes subprojetos usando o `@aws/nx-plugin`.

<Aside type="tip">√â uma melhor pr√°tica garantir que todos os arquivos n√£o stageados estejam commitados no Git antes de executar quaisquer geradores. Isso permite ver o que mudou ap√≥s executar o gerador via `git diff`.</Aside>

## Tarefa 2: Criar uma Game API

Primeiro, vamos criar nossa Game API. Para isso, crie uma API tRPC chamada `GameApi` usando estas etapas:

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

Voc√™ ver√° alguns novos arquivos aparecerem na sua √°rvore de arquivos.

<Aside>
O `package.json` raiz agora est√° configurado com um `type` como `module`, o que significa que ESM √© o tipo de m√≥dulo padr√£o para todos os subprojetos Node fornecidos pelo `@aws/nx-plugin`.
Para mais detalhes sobre projetos TypeScript, consulte o <Link path="guides/typescript-project">guia do gerador ts#project</Link>.
</Aside>

<Drawer title="Arquivos atualizados do ts#trpc-api" trigger="Clique aqui para examinar estes arquivos em mais detalhes.">
Abaixo est√° uma lista de todos os arquivos gerados pelo gerador `ts#trpc-api`. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK espec√≠ficos do aplicativo
          - apis/
            - **game-api.ts** construct CDK para criar sua API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructs CDK gen√©ricos
          - api/
            - rest-api.ts construct CDK base para uma API Gateway Rest API
            - trpc-utils.ts utilit√°rios para constructs CDK de API tRPC
            - utils.ts utilit√°rios para constructs de API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
  - game-api/ API tRPC
    - src/
      - client/ cliente vanilla tipicamente usado para chamadas m√°quina a m√°quina em TS
        - index.ts
      - middleware/ instrumenta√ß√£o com powertools
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ defini√ß√µes de inputs e outputs da API
        - index.ts
        - **echo.ts** schema de input e output de exemplo
        - z-async-iterable.ts schema Zod wrapper para output de subscription tRPC
      - procedures/ implementa√ß√µes espec√≠ficas dos procedimentos/rotas da API
        - **echo.ts** implementa√ß√£o de procedimento de exemplo
      - index.ts
      - init.ts configura contexto e middleware
      - handler.ts ponto de entrada do Lambda handler (usa response streaming para REST APIs)
      - local-server.ts usado ao executar o servidor tRPC localmente
      - **router.ts** define o router tRPC e todos os procedimentos
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Vamos analisar estes arquivos-chave:

```ts {5}
// packages/game-api/src/router.ts
import { echo } from './procedures/echo.js';
import { t } from './init.js';

export const router = t.router;

export const appRouter = router({
  echo,
});

export type AppRouter = typeof appRouter;
```
O router define o router tRPC para sua API e √© onde voc√™ declarar√° todos os m√©todos da API. Como visto acima, temos um m√©todo chamado `echo` com sua implementa√ß√£o no arquivo `./procedures/echo.ts`. O ponto de entrada do Lambda handler est√° em `handler.ts`, que √© configurado automaticamente pelo gerador.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Este arquivo √© a implementa√ß√£o do m√©todo `echo` e como visto √© fortemente tipado declarando suas estruturas de dados de entrada e sa√≠da.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Todas as defini√ß√µes de schema tRPC s√£o definidas usando [Zod](https://zod.dev/) e exportadas como tipos TypeScript via sintaxe `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import { Distribution } from 'aws-cdk-lib/aws-cloudfront';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
  ResponseTransferMode,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AnyPrincipal,
  IGrantable,
  Grant,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// Tipo union de strings para todos os nomes de opera√ß√µes da API
type Operations = Procedures<AppRouter>;

/**
 * Propriedades para criar um construct GameApi
 *
 * @template TIntegrations - Mapa de nomes de opera√ß√£o para suas integra√ß√µes
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mapa de nomes de opera√ß√£o para suas integra√ß√µes no API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Um construct CDK que cria e configura uma AWS API Gateway REST API
 * especificamente para GameApi.
 * @template TIntegrations - Mapa de nomes de opera√ß√£o para suas integra√ß√µes
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Cria integra√ß√µes padr√£o para todas as opera√ß√µes, implementando cada opera√ß√£o como
   * sua pr√≥pria fun√ß√£o lambda individual.
   *
   * @param scope - O escopo do construct CDK
   * @returns Um IntegrationBuilder com integra√ß√µes lambda padr√£o
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return {
          handler,
          integration: new LambdaIntegration(handler, {
            responseTransferMode: ResponseTransferMode.STREAM,
          }),
        };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      deployOptions: {
        tracingEnabled: true,
      },
      policy: new PolicyDocument({
        statements: [
          // Abre OPTIONS para permitir que navegadores fa√ßam requisi√ß√µes preflight n√£o autenticadas
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }

  /**
   * Restringe CORS aos dom√≠nios da distribui√ß√£o CloudFront do website
   *
   * Configura os dom√≠nios da distribui√ß√£o CloudFront como as √∫nicas origens CORS permitidas
   * (al√©m do local host) nas integra√ß√µes AWS Lambda
   *
   * Note que esta restri√ß√£o n√£o √© aplicada ao preflight OPTIONS
   *
   * @param websites - A distribui√ß√£o CloudFront para conceder CORS
   */
  public restrictCorsTo(
    ...websites: { cloudFrontDistribution: Distribution }[]
  ) {
    const allowedOrigins = websites
      .map(
        ({ cloudFrontDistribution }) =>
          `https://${cloudFrontDistribution.distributionDomainName}`,
      )
      .join(',');

    // Define a vari√°vel de ambiente ALLOWED_ORIGINS para todas as integra√ß√µes Lambda
    Object.values(this.integrations).forEach((integration) => {
      if ('handler' in integration && integration.handler instanceof Function) {
        integration.handler.addEnvironment('ALLOWED_ORIGINS', allowedOrigins);
      }
    });
  }

  /**
   * Concede permiss√µes IAM para invocar qualquer m√©todo nesta API.
   *
   * @param grantee - O principal IAM para conceder permiss√µes
   */
  public grantInvokeAccess(grantee: IGrantable) {
    // Aqui concedemos permiss√£o ao grantee para chamar a API.
    // Acesso refinado m√°quina a m√°quina pode ser definido aqui usando principals mais espec√≠ficos (ex: roles ou
    // usu√°rios) e recursos (ex: quais caminhos da API podem ser invocados por qual principal) se necess√°rio.
    this.api.addToResourcePolicy(
      new PolicyStatement({
        effect: Effect.ALLOW,
        principals: [grantee.grantPrincipal],
        actions: ['execute-api:Invoke'],
        resources: ['execute-api:/*'],
      }),
    );

    Grant.addToPrincipal({
      grantee,
      actions: ['execute-api:Invoke'],
      resourceArns: [this.api.arnForExecuteApi('*', '/*', '*')],
    });
  }
}
```

Este √© o construct CDK que define nossa `GameApi`. Ele fornece um m√©todo `defaultIntegrations` que cria automaticamente uma fun√ß√£o Lambda para cada procedimento em nossa API tRPC, apontando para a implementa√ß√£o da API empacotada. Isso significa que no tempo de `cdk synth`, o empacotamento n√£o ocorre (diferente de usar [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) pois j√° o empacotamos como parte do target de build do projeto backend.

</Drawer>

## Tarefa 3: Criar agentes de hist√≥ria

Agora vamos criar nossos Story Agents.

### Agente de hist√≥ria: Projeto Python

Para criar um projeto Python:

<RunGenerator generator="py#project" requiredParameters={{name:"story"}} noInteractive />

Voc√™ ver√° alguns novos arquivos aparecerem na sua √°rvore de arquivos.
<Drawer title="Arquivos atualizados do py#project" trigger="Clique aqui para examinar estes arquivos em mais detalhes.">
O `py#project` gera estes arquivos:

<FileTree>
- .venv/ √∫nico ambiente virtual para o monorepo
- packages/
  - story/
    - dungeon_adventure_story/ m√≥dulo Python
      - hello.py exemplo de arquivo Python (vamos ignorar este)
    - tests/
    - .python-version
    - pyproject.toml
    - project.json
- .python-version vers√£o Python fixada do uv
- pyproject.toml
- uv.lock
</FileTree>

Isso configurou um projeto Python e [UV Workspace](https://docs.astral.sh/uv/concepts/projects/workspaces/) com ambiente virtual compartilhado.

</Drawer>

### Agente de hist√≥ria: Agente Strands

Para adicionar um agente Strands ao projeto com o gerador `py#strands-agent`:

<RunGenerator generator="py#strands-agent" requiredParameters={{project:"story"}} noInteractive />

Voc√™ ver√° alguns novos arquivos aparecerem na sua √°rvore de arquivos.
<Drawer title="Arquivos atualizados do py#strands-agent" trigger="Clique aqui para examinar estes arquivos em mais detalhes.">
O `py#strands-agent` gera estes arquivos:

<FileTree>
- packages/
  - story/
    - dungeon_adventure_story/ m√≥dulo Python
      - agent/
        - init.py configura a aplica√ß√£o FastAPI e middleware
        - main.py ponto de entrada do agente no Bedrock AgentCore Runtime
        - agent.py define um agente e ferramentas de exemplo
        - agentcore_mcp_client.py utilit√°rio para criar clientes para interagir com servidores MCP
        - Dockerfile define a imagem Docker para implanta√ß√£o no AgentCore Runtime
  - common/constructs/
    - src
      - app/agents/story-agent/
        - story-agent.ts construct para implantar seu agente Story no AgentCore Runtime
</FileTree>

Vamos analisar alguns dos arquivos em detalhes:

```python
# agent/agent.py
from contextlib import contextmanager

from strands import Agent, tool
from strands_tools import current_time


# Define uma ferramenta customizada
@tool
def add(a: int, b: int) -> int:
    return a + b


@contextmanager
def get_agent(session_id: str):
    yield Agent(
        system_prompt="""
Voc√™ √© um mago da adi√ß√£o.
Use a ferramenta 'add' para tarefas de adi√ß√£o.
Refira-se √†s ferramentas como seu 'grim√≥rio'.
""",
        tools=[add, current_time],
    )
```

Isso cria um agente Strands de exemplo e define uma ferramenta de adi√ß√£o.

```python
# agent/main.py
import uvicorn
from bedrock_agentcore.runtime.models import PingStatus
from pydantic import BaseModel

from .agent import get_agent
from .init import JsonStreamingResponse, app


class InvokeInput(BaseModel):
    prompt: str
    session_id: str


class StreamChunk(BaseModel):
    content: str


async def handle_invoke(input: InvokeInput):
    """Handler de streaming para invoca√ß√£o do agente"""
    with get_agent(session_id=input.session_id) as agent:
        stream = agent.stream_async(input.prompt)
        async for event in stream:
            print(event)
            text = event.get("event", {}).get("contentBlockDelta", {}).get("delta", {}).get("text")
            if text is not None:
                yield StreamChunk(content=text)
            elif event.get("event", {}).get("messageStop") is not None:
                yield StreamChunk(content="\n")


@app.post(
    "/invocations",
    response_class=JsonStreamingResponse,
    responses={200: JsonStreamingResponse.openapi_response(StreamChunk, "Stream of agent response chunks")},
)
async def invoke(input: InvokeInput) -> JsonStreamingResponse:
    """Ponto de entrada para invoca√ß√£o do agente"""
    return JsonStreamingResponse(handle_invoke(input))


@app.get("/ping")
def ping() -> str:
    # TODO: se executando uma tarefa ass√≠ncrona, retorne PingStatus.HEALTHY_BUSY
    return PingStatus.HEALTHY


if __name__ == "__main__":
    uvicorn.run("dungeon_adventure_story.agent.main:app", port=8080)
```

Este √© o ponto de entrada do agente, configurado como uma aplica√ß√£o FastAPI compat√≠vel com [Amazon Bedrock AgentCore Runtime](https://github.com/aws/bedrock-agentcore-sdk-python). Ele usa o suporte do Strands para streaming e transmite eventos de volta ao cliente conforme ocorrem via JSON Lines.

```ts
// common/constructs/src/app/agents/story-agent.ts
import { Lazy, Names } from 'aws-cdk-lib';
import { Platform } from 'aws-cdk-lib/aws-ecr-assets';
import { Construct } from 'constructs';
import { execSync } from 'child_process';
import * as path from 'path';
import * as url from 'url';
import {
  AgentRuntimeArtifact,
  ProtocolType,
  Runtime,
  RuntimeProps,
} from '@aws-cdk/aws-bedrock-agentcore-alpha';

export type StoryAgentProps = Omit<
  RuntimeProps,
  'runtimeName' | 'protocolConfiguration' | 'agentRuntimeArtifact'
>;

export class StoryAgent extends Construct {
  public readonly dockerImage: AgentRuntimeArtifact;
  public readonly agentCoreRuntime: Runtime;

  constructor(scope: Construct, id: string, props?: StoryAgentProps) {
    super(scope, id);

    this.dockerImage = AgentRuntimeArtifact.fromAsset(
      path.dirname(url.fileURLToPath(new URL(import.meta.url))),
      {
        platform: Platform.LINUX_ARM64,
        extraHash: execSync(
          `docker inspect dungeon-adventure-story-agent:latest --format '{{.Id}}'`,
          { encoding: 'utf-8' },
        ).trim(),
      },
    );

    this.agentCoreRuntime = new Runtime(this, 'StoryAgent', {
      runtimeName: Lazy.string({
        produce: () =>
          Names.uniqueResourceName(this.agentCoreRuntime, { maxLength: 40 }),
      }),
      protocolConfiguration: ProtocolType.HTTP,
      agentRuntimeArtifact: this.dockerImage,
      ...props,
    });
  }
}
```

Isso configura um `AgentRuntimeArtifact` do CDK que envia sua imagem Docker do agente para o ECR e a hospeda usando o AgentCore Runtime.

Voc√™ pode notar um `Dockerfile` extra, que referencia a imagem Docker do projeto `story`, permitindo que co-localizemos o Dockerfile e o c√≥digo-fonte do agente.

</Drawer>

## Tarefa 4: Configurar ferramentas de invent√°rio

### Invent√°rio: Projeto TypeScript

Vamos criar um servidor MCP para fornecer ferramentas para nosso Story Agent gerenciar o invent√°rio de um jogador.

Primeiro, criamos um projeto TypeScript:

<RunGenerator generator="ts#project" requiredParameters={{name:"inventory"}} noInteractive />

Isso criar√° um projeto TypeScript vazio.

<Drawer title="Arquivos atualizados do ts#project" trigger="Clique aqui para examinar estes arquivos em mais detalhes.">
O gerador `ts#project` gera estes arquivos.

<FileTree>
- packages/
  - inventory/
    - src/
      - index.ts ponto de entrada com fun√ß√£o de exemplo
    - project.json configura√ß√£o do projeto
    - eslint.config.mjs configura√ß√£o de lint
    - vite.config.mts configura√ß√£o de testes
    - tsconfig.json configura√ß√£o base TypeScript para o projeto
    - tsconfig.lib.json configura√ß√£o TypeScript para compila√ß√£o e empacotamento
    - tsconfig.spec.json configura√ß√£o TypeScript para testes
- tsconfig.base.json atualizado para configurar um alias para outros projetos referenciarem este
</FileTree>

</Drawer>

### Invent√°rio: Servidor MCP

Em seguida, adicionaremos um servidor MCP ao nosso projeto TypeScript:

<RunGenerator generator="ts#mcp-server" requiredParameters={{project:"inventory"}} noInteractive />

Isso adicionar√° um servidor MCP.
<Drawer title="Arquivos atualizados do ts#mcp-server" trigger="Clique aqui para examinar estes arquivos em mais detalhes.">
O gerador `ts#mcp-server` gera estes arquivos.

<FileTree>
- packages/
  - inventory/
    - src/mcp-server/
      - index.ts barrel export
      - server.ts cria o servidor MCP
      - tools/
        - add.ts ferramenta de exemplo
      - resources/
        - sample-guidance.ts recurso de exemplo
      - stdio.ts ponto de entrada para MCP com transporte STDIO
      - http.ts ponto de entrada para MCP com transporte HTTP streamable
      - Dockerfile constr√≥i a imagem para AgentCore Runtime
    - rolldown.config.ts configura√ß√£o para empacotar o servidor MCP para implanta√ß√£o no AgentCore
  - common/constructs/
    - src
      - app/mcp-servers/inventory-mcp-server/
        - inventory-mcp-server.ts construct para implantar seu servidor MCP de invent√°rio no AgentCore Runtime
</FileTree>

</Drawer>

## Tarefa 5: Criar a Interface do Usu√°rio (UI)

Nesta tarefa, criaremos a UI que permitir√° interagir com o jogo.

### UI do Jogo: Website

Para criar a UI, crie um website chamado `GameUI` usando estas etapas:

<RunGenerator generator="ts#react-website" requiredParameters={{name:"GameUI"}} noInteractive />

Voc√™ ver√° alguns novos arquivos aparecerem na sua √°rvore de arquivos.

<Drawer title="Arquivos atualizados do ts#react-website" trigger="Clique aqui para examinar estes arquivos em mais detalhes.">
O `ts#react-website` gera estes arquivos. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK espec√≠ficos do aplicativo
          - static-websites/
            - **game-ui.ts** construct CDK para criar sua Game UI
        - core/
          - static-website.ts construct gen√©rico para website est√°tico
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.tsx layout geral da p√°gina: cabe√ßalho, rodap√©, sidebar, etc
      - hooks/
        - useAppLayout.tsx permite definir dinamicamente notifica√ß√µes, estilo da p√°gina, etc
      - routes/ rotas baseadas em arquivo do @tanstack/react-router
        - **index.tsx** p√°gina raiz '/'
        - __root.tsx todas as p√°ginas usam este componente como base
      - config.ts
      - **main.tsx** ponto de entrada do React
      - routeTree.gen.ts atualizado automaticamente pelo @tanstack/react-router
      - styles.css
    - index.html
    - project.json
    - vite.config.mts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteName: 'GameUI',
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Este √© o construct CDK que define nossa GameUI. Ele j√° configurou o caminho para o bundle gerado para nossa UI baseada em Vite. Isso significa que no tempo de `build`, o empacotamento ocorre dentro do target de build do projeto game-ui e a sa√≠da √© usada aqui.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import '@cloudscape-design/global-styles/index.css';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export type RouterProviderContext = {};

const router = createRouter({
  routeTree,
  context: {},
});

// Registra a inst√¢ncia do router para type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const App = () => {
  return <RouterProvider router={router} context={{}} />;
};

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <App />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Este √© o ponto de entrada onde o React √© montado. Como mostrado, inicialmente apenas configura um `@tanstack/react-router` em uma configura√ß√£o de [`roteamento baseado em arquivo`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Enquanto o servidor de desenvolvimento estiver em execu√ß√£o, voc√™ pode criar arquivos na pasta `routes` e o `@tanstack/react-router` criar√° a configura√ß√£o de arquivo boilerplate para voc√™, atualizando o arquivo `routeTree.gen.ts`. Este arquivo mant√©m todas as rotas de forma type-safe, o que significa que ao usar `<Link>`, a op√ß√£o `to` s√≥ mostrar√° rotas v√°lidas.
Para mais informa√ß√µes, consulte a [documenta√ß√£o do @tanstack/react-router](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new React website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Um componente ser√° renderizado ao navegar para a rota `/`. O `@tanstack/react-router` gerenciar√° a `Route` para voc√™ sempre que criar/mover este arquivo (desde que o servidor de desenvolvimento esteja em execu√ß√£o).

</Drawer>

### UI do Jogo: Autentica√ß√£o

Vamos configurar nossa Game UI para exigir acesso autenticado via Amazon Cognito usando estas etapas:

<RunGenerator generator="ts#react-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Voc√™ ver√° alguns novos arquivos aparecerem/mudarem na sua √°rvore de arquivos.

<Drawer title="Arquivos atualizados do ts#react-website#auth" trigger="Clique aqui para examinar estes arquivos em mais detalhes.">
O gerador `ts#react-website#auth` atualiza/gera estes arquivos. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts construct CDK para criar pools de usu√°rio/identidade
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx adiciona o usu√°rio logado/logout ao cabe√ßalho
        - CognitoAuth/
          - index.tsx gerencia login no Cognito
        - RuntimeConfig/
          - index.tsx busca o `runtime-config.json` e o fornece aos filhos via contexto
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Atualizado para adicionar Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import { useAuth } from 'react-oidc-context';
+import CognitoAuth from './components/CognitoAuth';
+import { useRuntimeConfig } from './hooks/useRuntimeConfig';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import '@cloudscape-design/global-styles/index.css';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
-export type RouterProviderContext = {};
+export type RouterProviderContext = {
+  runtimeConfig?: ReturnType<typeof useRuntimeConfig>;
+  auth?: ReturnType<typeof useAuth>;
+};
-const router = createRouter({
-  routeTree,
-  context: {},
-});
+const router = createRouter({
+  routeTree,
+  context: {
+    runtimeConfig: undefined,
+    auth: undefined,
+  },
+});
// Registra a inst√¢ncia do router para type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
-const App = () => {
-  return <RouterProvider router={router} context={{}} />;
-};
+const App = () => {
+  const auth = useAuth();
+  const runtimeConfig = useRuntimeConfig();
+  return <RouterProvider router={router} context={{ runtimeConfig, auth }} />;
+};
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <App />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Os componentes `RuntimeConfigProvider` e `CognitoAuth` foram adicionados ao arquivo `main.tsx` via transforma√ß√£o AST. Isso permite que o componente `CognitoAuth` autentique com o Amazon Cognito buscando o `runtime-config.json` que cont√©m a configura√ß√£o de conex√£o do Cognito necess√°ria para fazer chamadas backend para o destino correto.

</Drawer>

### UI do Jogo: Conectar √† Game API

Vamos configurar nossa Game UI para se conectar √† nossa Game API criada anteriormente.

<RunGenerator generator="connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

Voc√™ ver√° alguns novos arquivos aparecerem/mudarem na sua √°rvore de arquivos.

<Drawer title="Arquivos atualizados da conex√£o UI -> tRPC" trigger="Clique aqui para examinar estes arquivos em mais detalhes.">
O gerador `connection` gera/atualiza estes arquivos. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:

<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx configura o cliente GameAPI
      - hooks/
        - **useGameApi.tsx** hooks para chamar a GameApi
      - **main.tsx** injeta os providers do cliente trpc
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { useContext } from 'react';
import { GameApiTRPCContext } from '../components/GameApiClientProvider';

export const useGameApi = () => {
  const container = useContext(GameApiTRPCContext);
  if (!container) {
    throw new Error('useGameApi must be used within GameApiClientProvider');
  }
  return container.optionsProxy;
};

export const useGameApiClient = () => {
  const container = useContext(GameApiTRPCContext);
  if (!container) {
    throw new Error(
      'useGameApiClient must be used within GameApiClientProvider',
    );
  }
  return container.client;
};
```

Este hook fornece acesso ao cliente tRPC para chamar a GameApi. Para exemplos de como chamar APIs tRPC, consulte o <Link path="guides/connection/react-trpc#using-the-generated-code">guia de uso do hook tRPC</Link>.

<Aside>
O hook `useGameApi` √© diferente do `useStoryApi` pois n√£o requer um build para que mudan√ßas sejam refletidas, gra√ßas ao uso de [infer√™ncia de Typescript](https://trpc.io/docs/concepts) pelo tRPC. Isso permite que desenvolvedores fa√ßam mudan√ßas no backend que s√£o instantaneamente refletidas no frontend.
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import { useAuth } from 'react-oidc-context';
import CognitoAuth from './components/CognitoAuth';
import { useRuntimeConfig } from './hooks/useRuntimeConfig';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import '@cloudscape-design/global-styles/index.css';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
...
const App = () => {
  const auth = useAuth();
  const runtimeConfig = useRuntimeConfig();
  return <RouterProvider router={router} context={{ runtimeConfig, auth }} />;
};
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <App />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

O arquivo `main.tsx` foi atualizado via transforma√ß√£o AST para injetar os providers do tRPC.

</Drawer>

### UI do Jogo: Infraestrutura

Vamos criar o subprojeto final para a infraestrutura CDK.

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Voc√™ ver√° alguns novos arquivos aparecerem/mudarem na sua √°rvore de arquivos.

<Drawer title="Arquivos atualizados do ts#infra" trigger="Clique aqui para examinar estes arquivos em mais detalhes.">
O gerador `ts#infra` gera/atualiza estes. Vamos examinar alguns dos arquivos-chave destacados na √°rvore de arquivos:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - checkov.ts
          - index.ts
  - infra
    - src/
      - stages/
        - **application-stage.ts** stacks CDK definidas aqui
      - stacks/
        - **application-stack.ts** recursos CDK definidos aqui
      - **main.ts** ponto de entrada que define todos os stages
    - cdk.json
    - checkov.yml
    - project.json
    - ...
  - package.json
  - tsconfig.json adiciona refer√™ncias
  - tsconfig.base.json adiciona alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStage } from './stages/application-stage.js';
import { App } from ':dungeon-adventure/common-constructs';

const app = new App();

// Use isto para implantar seu pr√≥prio ambiente sandbox (assume suas credenciais CLI)
new ApplicationStage(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
});

app.synth();
```

<Aside type="tip">Se voc√™ est√° vendo um erro de importa√ß√£o em seu IDE, √© porque nosso projeto de infraestrutura ainda n√£o tem uma refer√™ncia TypeScript configurada no `tsconfig.json`. O Nx foi [configurado](https://nx.dev/nx-api/js/generators/typescript-sync) para criar estas refer√™ncias *dinamicamente* sempre que um build/compile √© executado ou se voc√™ executar o comando `nx sync` manualmente. Para mais informa√ß√µes, consulte o <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guia TypeScript</Link>.</Aside>

Este √© o ponto de entrada para sua aplica√ß√£o CDK.

```ts
// packages/infra/src/stacks/application-stack.ts
import { Stack, StackProps } from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends Stack {
  constructor(scope: Construct, id: string, props?: StackProps) {
    super(scope, id, props);

    // O c√≥digo que define sua stack vai aqui
  }
}
```

Vamos instanciar nossos constructs CDK para construir nosso jogo dungeon adventure.

</Drawer>

## Tarefa 6: Atualizar nossa infraestrutura

Vamos atualizar `packages/infra/src/stacks/application-stack.ts` para instanciar alguns de nossos constructs gerados:

<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

:::note
Fornecemos integra√ß√µes padr√£o para nossa Game API. Por padr√£o, cada opera√ß√£o em nossa API √© mapeada para uma fun√ß√£o Lambda individual para lidar com essa opera√ß√£o.
:::

## Tarefa 7: Construir o c√≥digo

<Drawer title="Comandos Nx" trigger="Agora √© hora de construir nosso c√≥digo pela primeira vez">

###### Targets √∫nicos vs m√∫ltiplos

O comando `run-many` executar√° um target em m√∫ltiplos subprojetos listados (`--all` os seleciona todos). Isso garante que depend√™ncias sejam executadas na ordem correta.

Voc√™ tamb√©m pode disparar um build (ou qualquer outra tarefa) para um target de projeto √∫nico executando o target diretamente no projeto. Por exemplo, para buildar o projeto `@dungeon-adventure/infra`, execute o seguinte comando:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />

Voc√™ tamb√©m pode omitir o escopo e usar a sintaxe abreviada do Nx se preferir:

<NxCommands commands={['build infra']} />

###### Visualizando suas depend√™ncias

Para visualizar suas depend√™ncias, execute:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Cache

O Nx depende de [cache](https://nx.dev/concepts/how-caching-works) para reutilizar artefatos de builds anteriores e acelerar o desenvolvimento. √â necess√°ria alguma configura√ß√£o para que isso funcione corretamente e pode haver casos onde voc√™ queira executar um build **sem usar o cache**. Para isso, simplesmente adicione o argumento `--skip-nx-cache` ao seu comando. Por exemplo:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Se por qualquer motivo voc√™ quiser limpar seu cache (armazenado na pasta `.nx`), voc√™ pode executar o seguinte comando:

<NxCommands commands={['reset']} />

</Drawer>

Usando a linha de comando, execute o seguinte comando para corrigir quaisquer problemas de lint primeiro:

<PackageManagerShortCommand commands={["lint"]} />

Em seguida, execute o seguinte comando para um build completo:

<PackageManagerShortCommand commands={["build"]} />

Voc√™ ser√° questionado com o seguinte:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? ‚Ä¶
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Esta mensagem indica que o NX detectou alguns arquivos que podem ser atualizados automaticamente. Neste caso, est√° se referindo aos arquivos `tsconfig.json` que n√£o t√™m refer√™ncias de projeto TypeScript configuradas em projetos dependentes.

Selecione a op√ß√£o **Yes, sync the changes and run the tasks** para prosseguir. Voc√™ deve notar que todos os erros de importa√ß√£o relacionados √† IDE s√£o resolvidos automaticamente, pois o gerador de sincroniza√ß√£o adicionar√° as refer√™ncias TypeScript faltantes automaticamente!

Todos os artefatos constru√≠dos est√£o agora dispon√≠veis dentro da pasta `dist/` na raiz do monorepo. Esta √© uma pr√°tica padr√£o ao usar projetos gerados pelo `@aws/nx-plugin`, pois n√£o polui sua √°rvore de arquivos com arquivos gerados. Caso queira limpar seus arquivos, delete a pasta `dist/` sem se preocupar com artefatos de build espalhados pela √°rvore de arquivos.

Parab√©ns! Voc√™ criou todos os subprojetos necess√°rios para come√ßar a implementar o n√∫cleo do nosso jogo AI Dungeon Adventure.  üéâüéâüéâ