---
title: "Jogo de Dungeons de IA Agêntica"
description: "Um guia passo a passo de como construir um jogo de aventura de dungeon com IA agêntica usando o @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import E2EDiff from '@components/e2e-diff.astro';
import E2ECode from '@components/e2e-code.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

import { getDungeonAdventureElectroDbDependencies } from '../../../../../../../../e2e/src/utils';

## Módulo 2: Implementação da API do Jogo e do Servidor MCP de Inventário

Vamos começar implementando nossa Game API. Para isso, precisamos criar 5 APIs no total:

1. `saveGame` - criar ou atualizar um jogo.
2. `queryGames` - retornar uma lista paginada de jogos salvos anteriormente.
3. `saveAction` - salvar uma ação para um determinado jogo.
4. `queryActions` - retornar uma lista paginada de todas as ações relacionadas a um jogo.
5. `queryInventory` - retornar uma lista paginada de itens no inventário de um jogador.

### Esquema da API

Para definir as entradas e saídas da nossa API, vamos criar nosso esquema usando [Zod](https://zod.dev/) no diretório `packages/game-api/src/schema` da seguinte forma:

<Tabs>
  <TabItem label="action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/action.ts.template" />
  </TabItem>
  <TabItem label="common.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/common.ts.template" />
  </TabItem>
  <TabItem label="game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/game.ts.template" />
  </TabItem>
  <TabItem label="inventory.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/inventory.ts.template" />
  </TabItem>
  <TabItem label="index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/schema/index.ts.old.template" after="dungeon-adventure/2/schema/index.ts.template" />
  </TabItem>
</Tabs>

Você também pode excluir o arquivo `packages/game-api/src/schema/echo.ts` já que não o usaremos neste projeto.

<Aside type="tip">
Como visto acima, para cada esquema definido no Zod, também exportamos uma interface usando a sintaxe `z.TypeOf`. Isso converte nossa definição Zod em uma interface TypeScript sem duplicação de esforço!
</Aside>

### Modelagem de entidades

O diagrama ER para nossa aplicação é o seguinte:

<Image class="centered-image white-bg" src={dungeonAdventureErPng} alt="dungeon-adventure-er.png" width="400" height="300" />

{/* Generated from the following PlantUML: */}
{/*
@startuml Game API Entity Relationship Diagram

!theme plain

skinparam linetype ortho
skinparam roundcorner 10

entity "Game" as game {
  + playerName : string <<PK>>
  --
  genre : string
  lastUpdated : string
}

entity "Action" as action {
  + playerName : string <<PK>>
  + timestamp : string <<SK>>
  --
  role : string
  content : string
}

entity "Item" as item {
  + playerName : string <<PK>>
  + itemName : string
  --
  emoji : string (optional)
  lastUpdated : string
  quantity : number
}

game ||--o{ action
game ||--o{ item

@enduml
*/}

Vamos implementar nosso banco de dados no DynamoDB usando a biblioteca cliente [ElectroDB](https://electrodb.dev/en/core-concepts/introduction/) para simplificar o processo. Para começar, primeiro precisamos instalar o `electrodb` e o DynamoDB Client executando o seguinte comando:

<InstallCommand pkg={getDungeonAdventureElectroDbDependencies()} />

<Aside>
Todas as dependências são adicionadas ao `package.json` raiz pois o `@aws/nx-plugin` segue o princípio de [política de versão única](https://nx.dev/concepts/decisions/dependency-management#single-version-policy). Para mais informações, consulte o <Link path="guides/typescript-project#dependencies">guia ts#project</Link>.
</Aside>

Agora vamos criar os seguintes arquivos na pasta `packages/game-api/src/entities` para definir nossas entidades ElectroDB de acordo com o diagrama ER acima:

<Tabs>
  <TabItem label="action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/action.ts.template" />
  </TabItem>
  <TabItem label="game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/game.ts.template" />
  </TabItem>
  <TabItem label="inventory.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/inventory.ts.template" />
  </TabItem>
</Tabs>

O ElectroDB nos permite não apenas definir nossos tipos, mas também fornecer valores padrão para certos campos como os timestamps acima. Além disso, o ElectroDB segue o [design de tabela única](https://electrodb.dev/en/core-concepts/single-table-relationships/), que é a melhor prática ao usar DynamoDB.

<Aside>
Embora o ElectroDB suporte [coleções](https://electrodb.dev/en/modeling/collections/), optamos por não usá-las neste tutorial para simplificar.
</Aside>

Para preparar o servidor MCP para interagir com o inventário, vamos garantir que exportamos a entidade de inventário em `packages/game-api/src/index.ts`:

<Tabs>
<TabItem label="packages/game-api/src/index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/index.ts.old.template" after="dungeon-adventure/2/index.ts.template" />
</TabItem>
</Tabs>

:::note
A estrutura do pacote seria melhor se refatorássemos as entidades em seu próprio projeto compartilhado, para que o servidor MCP não precise depender da API.
:::

### Adicionando o cliente DynamoDB ao contexto do tRPC

Como precisamos de acesso ao cliente DynamoDB em cada um de nossos procedimentos, queremos criar uma única instância do cliente que possamos passar via contexto. Para isso, faça as seguintes alterações em `packages/game-api/src`:

<Tabs>
  <TabItem label="middleware/dynamodb.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/middleware/dynamodb.ts.template" />

Este é um plugin que instrumentamos para criar o `DynamoDBClient` e injetá-lo no contexto.
  </TabItem>
  <TabItem label="middleware/index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/middleware/index.ts.old.template" after="dungeon-adventure/2/middleware/index.ts.template" />

Aumentamos nosso `IMiddlewareContext` para adicionar o `IDynamoDBContext`.
  </TabItem>
  <TabItem label="init.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/init.ts.old.template" after="dungeon-adventure/2/init.ts.template" />

O plugin DynamoDB é instrumentado.

<Aside>
A API `concat` vincula nosso middleware aos procedimentos que definimos. Para mais detalhes, consulte o [guia concat](https://trpc.io/docs/server/middlewares#concat).
</Aside>
  </TabItem>
</Tabs>

### Definindo nossos procedimentos

Agora é hora de implementar os métodos da API. Para isso, faça as seguintes alterações em `packages/game-api/src/procedures`:

#### Consultas

<Tabs>
  <TabItem label="query-actions.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-actions.ts.template" />
  </TabItem>
  <TabItem label="query-games.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-games.ts.template" />
  </TabItem>
  <TabItem label="query-inventory.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-inventory.ts.template" />
  </TabItem>
</Tabs>

#### Mutations

<Tabs>
  <TabItem label="save-action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/save-action.ts.template" />
  </TabItem>
  <TabItem label="save-game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/save-game.ts.template" />
  </TabItem>
</Tabs>

Você também pode excluir o arquivo `echo.ts` (de `packages/game-api/src/procedures`) já que não o usaremos neste projeto.

### Configuração do roteador

Agora que definimos nossos procedimentos, vamos conectá-los à nossa API. Para isso, atualize o seguinte arquivo:

<Tabs>
  <TabItem label="packages/game-api/src/router.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/router.ts.old.template" after="dungeon-adventure/2/router.ts.template" />
</TabItem>
</Tabs>

### Servidor MCP de Inventário

Agora vamos criar um servidor MCP que permitirá ao nosso agente gerenciar itens no inventário de um jogador.

Definiremos as seguintes ferramentas para nosso Agente:

- `list-inventory-items` para recuperar os itens atuais do inventário do jogador
- `add-to-inventory` para adicionar itens ao inventário do jogador
- `remove-from-inventory` para remover itens do inventário do jogador

Para economizar tempo, definiremos todas as ferramentas inline:

<Tabs>
  <TabItem label="packages/inventory/src/mcp-server/server.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/mcp/server.ts.old.template" after="dungeon-adventure/2/mcp/server.ts.template" />
</TabItem>
</Tabs>

Conforme o número de ferramentas crescer, você pode refatorá-las em arquivos separados se preferir.

Agora você pode excluir os diretórios `tools` e `resources` em `packages/inventory/src/mcp-server` pois não são utilizados.

### Infraestrutura

A etapa final é atualizar nossa infraestrutura para criar a tabela DynamoDB e conceder permissões para operações da Game API. Para isso, atualize o `packages/infra/src` conforme segue:

<Tabs>
  <TabItem label="constructs/electrodb-table.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/constructs/electrodb-table.ts.template" />
  </TabItem>
  <TabItem label="stacks/application-stack.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/1/application-stack.ts.template" after="dungeon-adventure/2/stacks/application-stack.ts.template" />

:::note
Observe que como cada procedimento é atendido por uma função lambda individual, podemos seguir o princípio de menor privilégio e atribuir apenas as permissões de leitura/escrita necessárias com base na implementação do procedimento.
:::
  </TabItem>
</Tabs>

### Implantação e testes

Primeiro, vamos construir a base de código:

<NxCommands commands={['run-many --target build --all']} />

<Aside type="tip">
Se encontrar erros de lint, você pode executar o seguinte comando para corrigi-los automaticamente:

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

Sua aplicação agora pode ser implantada executando o seguinte comando:

<NxCommands commands={['deploy infra dungeon-adventure-infra-sandbox/*']} />

:::caution
Você pode precisar fazer o bootstrap da sua conta AWS primeiro, execute:

<NxCommands commands={['bootstrap infra']} />
:::

Sua primeira implantação levará cerca de 8 minutos para ser concluída. Implantações subsequentes levarão cerca de 2 minutos.

:::tip
Se estiver iterando em alterações de código de funções lambda, você pode implantar com a flag `--hotswap` após construir a base de código para um tempo de implantação muito menor (2-3 segundos).

<NxCommands commands={['run @dungeon-adventure/infra:deploy dungeon-adventure-infra-sandbox/* --hotswap']} />
:::

Uma vez concluída a implantação, você verá algumas saídas semelhantes às seguintes _(alguns valores foram omitidos)_:

```bash
dungeon-adventure-sandbox-Application
dungeon-adventure-sandbox-Application: deploying... [2/2]

 ✅  dungeon-adventure-sandbox-Application

✨  Deployment time: 354s

Outputs:
dungeon-adventure-sandbox-Application.ElectroDbTableTableNameXXX = dungeon-adventure-sandbox-Application-ElectroDbTableXXX-YYY
dungeon-adventure-sandbox-Application.GameApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-sandbox-Application.GameUIDistributionDomainNameXXX = xxx.cloudfront.net
dungeon-adventure-sandbox-Application.StoryApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-sandbox-Application.UserIdentityUserIdentityIdentityPoolIdXXX = region:xxx
dungeon-adventure-sandbox-Application.UserIdentityUserIdentityUserPoolIdXXX = region_xxx
```

Podemos testar nossa API de duas formas:
<ul>
<li>Iniciando uma instância local do backend tRPC e invocando as APIs usando `curl`.</li>
<li>
<Drawer title="curl com Sigv4 habilitado" trigger="Chamando a API implantada usando curl com Sigv4">

<Tabs>
  <TabItem label="Bash/Linux/macOS">
Você pode adicionar o seguinte script ao seu arquivo `.bashrc` (e executar `source` nele) ou simplesmente colar o seguinte no mesmo terminal onde deseja executar o comando.
```bash
// ~/.bashrc
acurl () {
    REGION=$1
    SERVICE=$2
    shift; shift;
    curl --aws-sigv4 "aws:amz:$REGION:$SERVICE" --user "$(aws configure get aws_access_key_id):$(aws configure get aws_secret_access_key)" -H "X-Amz-Security-Token: $(aws configure get aws_session_token)" "$@"
}
```

Para fazer uma requisição curl autenticada com sigv4, você pode invocar `acurl` como nos exemplos abaixo:

###### API Gateway
```bash
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### URL de função Lambda streaming
```bash
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
  </TabItem>
  <TabItem label="Windows PowerShell">
Você pode adicionar a seguinte função ao seu perfil PowerShell ou simplesmente colar o seguinte na mesma sessão PowerShell onde deseja executar o comando.
```powershell
# Perfil PowerShell ou sessão atual
function acurl {
    param(
        [Parameter(Mandatory=$true)][string]$Region,
        [Parameter(Mandatory=$true)][string]$Service,
        [Parameter(ValueFromRemainingArguments=$true)][string[]]$CurlArgs
    )

    $AccessKey = aws configure get aws_access_key_id
    $SecretKey = aws configure get aws_secret_access_key
    $SessionToken = aws configure get aws_session_token

    & curl --aws-sigv4 "aws:amz:$Region`:$Service" --user "$AccessKey`:$SecretKey" -H "X-Amz-Security-Token: $SessionToken" @CurlArgs
}
```

Para fazer uma requisição curl autenticada com sigv4, você pode invocar `acurl` como nos exemplos abaixo:

###### API Gateway
```powershell
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### URL de função Lambda streaming
```powershell
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
  </TabItem>
</Tabs>

</Drawer>
</li>
</ul>


<Tabs>
  <TabItem label="Local">
    Inicie seu servidor local `game-api` executando o seguinte comando:

    <NxCommands highlights={['dungeon-adventure-infra-sandbox-Application-ElectroDbTableXXX-YYY']} env={{TABLE_NAME:"dungeon-adventure-infra-sandbox-Application-ElectroDbTableXXX-YYY"}} commands={["run @dungeon-adventure/game-api:serve"]} />

    <Aside type="caution">
    Use o valor de saída do CDK `dungeon-adventure-infra-sandbox-Application.ElectroDbTableTableNameXXX` para substituir o placeholder destacado.
    </Aside>

    Com o servidor em execução, você pode chamá-lo executando:

    ```bash
    curl -X GET 'http://localhost:2022/games.query?input=%7B%7D'
    ```
  </TabItem>
  <TabItem label="Implantado">
```bash "https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/" "ap-southeast-2"
acurl ap-southeast-2 execute-api -X GET 'https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/games.query?input=%7B%7D'
```
    <Aside type="caution">
    Use o valor de saída do CDK `dungeon-adventure-infra-sandbox-Application.GameApiGameApiEndpointXXX` para substituir o placeholder destacado e defina a região adequadamente.
    </Aside>
  </TabItem>
</Tabs>

:::note
O `%7B%7D` que passamos para testar a API é um objeto JSON vazio codificado em URI (`{}`).
:::

Se o comando for executado com sucesso, você verá uma resposta como:

```json
{"result":{"data":{"items":[],"cursor":null}}}
```

Parabéns, você construiu e implantou sua primeira API usando tRPC! 🎉🎉🎉