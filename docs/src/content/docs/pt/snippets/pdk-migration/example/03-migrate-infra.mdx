---
title: "Migrar a Infraestrutura"
---



import { Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import RunGenerator from '@components/run-generator.astro';
import Link from '@components/link.astro';
import NxCommands from '@components/nx-commands.astro';
import Drawer from '@components/drawer.astro';
import InstallCommand from '@components/install-command.astro';

O último projeto que precisamos migrar para nossa aplicação de lista de compras é o `InfrastructureTsProject`. Este é um projeto TypeScript CDK, para o qual o equivalente no Nx Plugin for AWS é o <Link path="/guides/typescript-infrastructure">gerador `ts#infra`</Link>.

Assim como os projetos Projen, o PDK também fornecia constructs CDK dos quais esses projetos dependem. Migraremos a aplicação de lista de compras desses constructs CDK também, em favor dos gerados pelo Nx Plugin for AWS.

:::tip
Uma grande vantagem do Nx Plugin for AWS sobre o PDK é que os constructs CDK que ele fornece são código-fonte adicionado ao seu projeto em vez de importados via um pacote de terceiros. Isso dá a você controle e flexibilidade para personalizá-los além do que o PDK suportava.
:::

#### Gerar um Projeto de Infraestrutura TypeScript CDK

Execute o <Link path="/guides/typescript-infrastructure">gerador `ts#infra`</Link> para configurar seu projeto de infraestrutura em `packages/infra`:

<RunGenerator generator="ts#infra" noInteractive requiredParameters={{ name: 'infra' }} />

#### Migrar a Infraestrutura CDK

A aplicação de lista de compras PDK instanciava os seguintes constructs dentro da stack de aplicação CDK:

- `DatabaseConstruct` para a tabela DynamoDB que armazena as listas de compras
- `UserIdentity` para recursos Cognito, importado diretamente do PDK
- `MyApi` para implantar a API Smithy, que usava o construct CDK TypeScript gerado com integrações type-safe, dependendo do construct CDK `TypeSafeRestApi` do PDK internamente.
- `Website` para implantar o Website, encapsulando o construct CDK `StaticWebsite` do PDK.

A seguir, migraremos cada um desses para o novo projeto.

##### Copiar a Stack de Aplicação

Copie `packages/infra/src/stacks/application-stack.ts` da aplicação de lista de compras PDK para exatamente o mesmo local em seu novo projeto. Você verá alguns erros TypeScript que abordaremos abaixo.

##### Copiar o Construct de Banco de Dados

A aplicação PDK tinha um construct `Database` em `packages/src/constructs/database.ts`. Copie este arquivo para o mesmo local no novo projeto.

Como o Nx Plugin for AWS usa [Checkov](https://www.checkov.io/) para testes de segurança que é um pouco mais rigoroso que o PDK Nag, precisamos adicionar algumas supressões:

```diff lang="ts"
// constructs/database.ts
+import { suppressRules } from ':shopping-list/common-constructs';
...
+suppressRules(
+  this.shoppingListTable,
+  ['CKV_AWS_28', 'CKV_AWS_119'],
+  'Backup and KMS key not required for this project',
+);
```

Em `application-stack.ts`, atualize a importação do `DatabaseConstruct` para usar sintaxe ESM:

```diff lang="ts"
// stacks/application-stack.ts
-import { DatabaseConstruct } from '../constructs/database';
+import { DatabaseConstruct } from '../constructs/database.js';
```

##### Migrar o Construct UserIdentity

O construct `UserIdentity` geralmente pode ser substituído sem alterações ajustando as importações.

```diff lang="ts"
-import { UserIdentity } from "@aws/pdk/identity";
+import { UserIdentity } from ':shopping-list/common-constructs';
...
const userIdentity = new UserIdentity(this, `${id}UserIdentity`);
```

Note que os constructs subjacentes usados pelo novo construct `UserIdentity` são fornecidos diretamente do `aws-cdk-lib`, enquanto o PDK usava `@aws-cdk/aws-cognito-identitypool-alpha`.

##### Migrar o Construct de API

A aplicação PDK tinha um construct em `constructs/apis/myapi.ts` que instanciava um construct CDK gerado pelo Type Safe API a partir do modelo Smithy.

Além deste construct, como o projeto PDK usava a trait `@handler`, constructs CDK de funções lambda geradas também eram criados.

Assim como o Type Safe API, o Nx Plugin for AWS fornece type-safety para integrações baseadas no modelo Smithy, porém de forma mais simples e flexível. Em vez de gerar um construct CDK inteiro em tempo de build, apenas "metadados" mínimos são gerados, que o `packages/common/constructs/src/app/apis/api.ts` usa de forma genérica. Você pode saber mais no <Link path="/guides/ts-smithy-api">guia do gerador `ts#smithy-api`</Link>.

Siga os passos abaixo:

<Steps>

1. Instancie o construct `Api` em `application-stack.ts`

    ```diff lang="ts"
    // stacks/application-stack.ts
    -import { MyApi } from "../constructs/apis/myapi";
    +import { Api } from ':shopping-list/common-constructs';
    ...
    -const myapi = new MyApi(this, "MyApi", {
    -  databaseConstruct,
    -  userIdentity,
    -});
    +const api = new Api(this, 'MyApi', {
    +  integrations: Api.defaultIntegrations(this).build(),
    +});
    ```

    Observe que usamos `Api.defaultIntegrations(this).build()` - o comportamento padrão é criar uma função lambda para cada operação em nossa API, mesmo comportamento que tínhamos em `myapi.ts`.

1. Conceda permissões para as funções lambda acessarem a tabela DynamoDB.

    Na aplicação PDK, o `DatabaseConstruct` era passado para `MyApi`, que gerenciava a adição das permissões relevantes a cada função gerada. Faremos isso diretamente em `application-stack.ts` acessando a propriedade type-safe `integrations` do construct `Api`:

    ```ts
    // stacks/application-stack.ts
    // Concede acesso escopo às funções lambda para chamar Dynamo
    databaseConstruct.shoppingListTable.grantReadData(
      api.integrations.getShoppingLists.handler,
    );
    [
      api.integrations.putShoppingList.handler,
      api.integrations.deleteShoppingList.handler,
    ].forEach((f) => databaseConstruct.shoppingListTable.grantWriteData(f));
    ```

1. Conceda permissões para usuários autenticados invocarem a API.

    Dentro do `myapi.ts` da aplicação PDK, usuários autenticados também tinham permissões IAM para invocar a API. Faremos o equivalente em `application-stack.ts`:

    ```ts
    // stacks/application-stack.ts
    api.grantInvokeAccess(userIdentity.identityPool.authenticatedRole);
    ```

</Steps>

##### Migrar o Construct Website

Finalmente, adicionamos o construct `Website` de `packages/common/constructs/src/app/static-websites/website.ts` em `application-stack.ts`, pois é o equivalente ao `packages/infra/src/constructs/websites/website.ts` da aplicação PDK.

```diff lang="ts"
-import { Website } from "../constructs/websites/website";
+import { Website } from ':shopping-list/common-constructs';
...
-new Website(this, "Website", {
-  userIdentity,
-  myapi,
-});
+new Website(this, 'Website');
```

Note que não passamos a identidade ou API para o website - o config runtime é gerenciado dentro de cada construct fornecido pelo Nx Plugin for AWS, onde `UserIdentity` e `Api` registram os valores necessários, e `Website` gerencia sua implantação em `/runtime-config.json` no website estático.

Vamos construir o projeto agora que migramos todas as partes relevantes do código para nosso novo projeto.

<NxCommands commands={["run-many --target build"]} />

:::caution
Você pode ver uma falha na build devido a problemas de lint. Estes geralmente podem ser corrigidos automaticamente:

<NxCommands commands={["run-many --target lint --fix"]} />
:::