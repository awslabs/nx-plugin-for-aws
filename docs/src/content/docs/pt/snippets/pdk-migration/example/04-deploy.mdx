---
title: "Implantar"
---



import { Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import RunGenerator from '@components/run-generator.astro';
import Link from '@components/link.astro';
import NxCommands from '@components/nx-commands.astro';
import Drawer from '@components/drawer.astro';
import InstallCommand from '@components/install-command.astro';

Agora que temos nossa base de c√≥digo totalmente migrada, podemos pensar em implant√°-la. Existem dois caminhos que podemos seguir neste momento.

#### Recursos Totalmente Novos (Simples)

A abordagem mais simples √© tratar isso como um aplicativo completamente novo, significando que vamos "come√ßar do zero" com uma nova tabela DynamoDB e um novo User Pool do Cognito - perdendo todos os usu√°rios e suas listas de compras. Para esta abordagem, basta:

<Steps>

1. Exclua a tabela DynamoDB chamada `shopping_list`

1. Implante a nova aplica√ß√£o:

    <NxCommands commands={["deploy infra shopping-list-infra-sandbox/*"]} />

</Steps>

üéâ E pronto! üéâ

#### Migrar Recursos Est√°veis Existentes sem Tempo de Inatividade (Mais Complexo)

Na realidade, √© mais prov√°vel que voc√™ queira migrar os recursos existentes da AWS para que sejam gerenciados pela nova base de c√≥digo, evitando qualquer tempo de inatividade para seus clientes.

:::danger
Esta abordagem √© um pouco mais complexa e cheia de nuances, e como isto √© apenas um exemplo, √© FORTEMENTE recomendado praticar em um ambiente n√£o produtivo (idealmente criando um novo stack sandbox) e documentar os passos exatos para sua aplica√ß√£o. Tamb√©m √© recomendado elaborar planos de conting√™ncia/rollback caso alguma etapa falhe ou produza resultados inesperados.
:::

:::note
Nossa aplica√ß√£o de lista de compras PDK n√£o definiu dom√≠nios personalizados ou DNS. Na pr√°tica, voc√™ provavelmente teria dom√≠nios configurados para seu site e API. Para esta se√ß√£o do guia, assumiremos que configuramos o Route53 com nomes DNS personalizados para o site e API.
:::

Para nossa aplica√ß√£o de lista de compras, os recursos est√°ticos importantes s√£o a tabela DynamoDB que cont√©m as listas de compras dos usu√°rios e o User Pool do Cognito que cont√©m os detalhes de todos os usu√°rios registrados. Nosso plano de alto n√≠vel ser√° manter esses dois recursos-chave e mov√™-los para que sejam gerenciados por nosso novo stack, ent√£o atualizar o DNS para apontar para o novo site (e API, se exposta aos clientes).

<Steps>

1. Atualize sua nova aplica√ß√£o para referenciar os recursos existentes que deseja manter.

    Para a aplica√ß√£o de lista de compras, fazemos isso para a tabela DynamoDB

    ```diff lang="ts"
    // constructs/database.ts
    -this.shoppingListTable = new Table(this, 'ShoppingList', {
    -  ...
    +this.shoppingListTable = Table.fromTableName(
    +  this,
    +  'ShoppingList',
    +  'shopping_list',
    +);
    ```

    E para o User Pool do Cognito

    ```diff lang="ts"
    // packages/common/constructs/src/core/user-identity.ts
    -this.userPool = this.createUserPool();
    +this.userPool = UserPool.fromUserPoolId(
    +  this,
    +  'UserPool',
    +  '<your-user-pool-id>',
    +);
    ```

1. Construa e implante a nova aplica√ß√£o:

    <NxCommands commands={["run-many --target build"]} />

    <NxCommands commands={["deploy infra shopping-list-infra-sandbox/*"]} />

    Agora temos nossa nova aplica√ß√£o implantada referenciando os recursos existentes, mas ainda n√£o recebendo tr√°fego.

1. Realize testes completos de integra√ß√£o para garantir que a nova aplica√ß√£o funciona conforme esperado. Para a aplica√ß√£o de lista de compras, acesse o site e verifique se √© poss√≠vel fazer login, criar, visualizar, editar e excluir listas.

1. Reverta as altera√ß√µes que referenciam os recursos existentes em sua nova aplica√ß√£o, mas n√£o as implante ainda.

    ```diff lang="ts"
    // constructs/database.ts
    +this.shoppingListTable = new Table(this, 'ShoppingList', {
    +  ...
    -this.shoppingListTable = Table.fromTableName(
    -  this,
    -  'ShoppingList',
    -  'shopping_list',
    -);
    ```

    E para o User Pool do Cognito

    ```diff lang="ts"
    // packages/common/constructs/src/core/user-identity.ts
    +this.userPool = this.createUserPool();
    -this.userPool = UserPool.fromUserPoolId(
    -  this,
    -  'UserPool',
    -  '<your-user-pool-id>',
    -);
    ```

    Em seguida, execute uma build

    <NxCommands commands={["run-many --target build"]} />

1. Use `cdk import` na pasta `packages/infra` de sua nova aplica√ß√£o para ver quais recursos ser√£o importados.

    ```bash title="New Application"
    cd packages/infra
    pnpm exec cdk import shopping-list-infra-sandbox/Application --force
    ```

    Siga os prompts pressionando Enter. A importa√ß√£o falhar√° porque os recursos s√£o gerenciados por outro stack - isso √© esperado, fizemos este passo apenas para confirmar quais recursos precisaremos manter. Voc√™ ver√° uma sa√≠da como:

    ```bash wrap
    shopping-list-infra-sandbox/Application/ApplicationUserIdentity/UserPool/smsRole/Resource (AWS::IAM::Role): insira RoleName (vazio para pular)
    shopping-list-infra-sandbox/Application/ApplicationUserIdentity/UserPool/Resource (AWS::Cognito::UserPool): insira UserPoolId (vazio para pular)
    shopping-list-infra-sandbox/Application/Database/ShoppingList/Resource (AWS::DynamoDB::Table): importar com TableName=shopping_list (s/n) s
    ```

    Isso nos diz que h√° 3 recursos que precisaremos importar para nosso novo stack.

1. Atualize seu projeto PDK antigo para definir `RemovalPolicy` como `RETAIN` para os recursos descobertos no passo anterior. Atualmente, este √© o padr√£o para o User Pool e a tabela DynamoDB, mas precisamos atualizar para a SMS Role descoberta:

    ```diff lang="ts"
    // application-stack.ts
    const userIdentity = new UserIdentity(this, `${id}UserIdentity`, {
      userPool,
    });

    +const smsRole = userIdentity.userPool.node.findAll().filter(
    +  c => CfnResource.isCfnResource(c) &&
    +    c.node.path.includes('/smsRole/'))[0] as CfnResource;
    +smsRole.applyRemovalPolicy(RemovalPolicy.RETAIN);
    ```

1. Implante seu projeto PDK para aplicar as pol√≠ticas de remo√ß√£o

    ```bash title="PDK Application"
    cd packages/infra
    npx projen deploy
    ```

1. Acesse o console do CloudFormation e registre os valores solicitados no passo anterior do `cdk import`

    1. O ID do User Pool, ex: `us-west-2_XXXXX`
    2. O Nome da SMS Role, ex: `infra-sandbox-UserIdentityUserPoolsmsRoleXXXXXX`

1. Atualize seu projeto PDK para referenciar os recursos existentes em vez de cri√°-los

    ```diff lang="ts"
    // constructs/database.ts
    -this.shoppingListTable = new Table(this, 'ShoppingList', {
    -  ...
    +this.shoppingListTable = Table.fromTableName(
    +  this,
    +  'ShoppingList',
    +  'shopping_list',
    +);
    ```

    E para o User Pool do Cognito

    ```diff lang="ts"
    // application-stack.ts
    +const userPool = UserPool.fromUserPoolId(
    +  this,
    +  'UserPool',
    +  '<your-user-pool-id>',
    +);
    const userIdentity = new UserIdentity(this, `${id}UserIdentity`, {
    +  // O construct PDK aceita UserPool n√£o IUserPool, mas ainda funciona!
    +  userPool: userPool as any,
    });
    ```

1. Implante seu projeto PDK novamente, isso far√° com que os recursos n√£o sejam mais gerenciados pelo stack CloudFormation do PDK.

    ```bash title="PDK Application"
    cd packages/infra
    npx projen deploy
    ```

1. Agora que os recursos n√£o est√£o mais sendo gerenciados, podemos executar `cdk import` em nossa nova aplica√ß√£o para realizar a importa√ß√£o:

    ```bash title="New Application"
    cd packages/infra
    pnpm exec cdk import shopping-list-infra-sandbox/Application --force
    ```

    Insira os valores quando solicitado, a importa√ß√£o deve ser conclu√≠da com sucesso.

1. Implante a nova aplica√ß√£o novamente para garantir que quaisquer altera√ß√µes nesses recursos existentes (agora gerenciados pelo novo stack) sejam aplicadas:

    <NxCommands commands={["deploy infra shopping-list-infra-sandbox/*"]} />

1. Realize testes completos novamente na nova aplica√ß√£o

1. Atualize os registros DNS para apontar para seu novo Site (e API se necess√°rio).

    Recomendamos uma abordagem gradual usando [Roteamento Ponderado](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-weighted.html) do Route53, onde uma fra√ß√£o das requisi√ß√µes √© direcionada para a nova aplica√ß√£o inicialmente. Monitore suas m√©tricas e aumente gradualmente o peso para a nova aplica√ß√£o at√© que nenhum tr√°fego seja enviado para a aplica√ß√£o PDK antiga.

    Se voc√™ n√£o tiver DNS e usou os dom√≠nios auto-gerados para o site e API, pode considerar o uso de proxy de requisi√ß√µes (ex: via [origem HTTP CloudFront](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_cloudfront_origins-readme.html#from-an-http-endpoint) ou [integra√ß√µes HTTP do API Gateway](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_apigateway.HttpIntegration.html)).

1. Monitore as m√©tricas da aplica√ß√£o PDK para garantir que n√£o h√° tr√°fego e finalmente destrua o stack CloudFormation antigo:

    ```bash
    cd packages/infra
    npx projen destroy
    ```

</Steps>

Isso foi bem mais complexo, mas migramos nossos usu√°rios perfeitamente para a nova aplica√ß√£o! üéâüéâüéâ

Agora temos os benef√≠cios do Nx Plugin para AWS em rela√ß√£o ao PDK:

- Builds mais r√°pidas
- Suporte a desenvolvimento local de API
- Base de c√≥digo amig√°vel para vibe-coding (<Link path="/get_started/building-with-ai">experimente nosso servidor MCP!</Link>)
- C√≥digo type-safe mais intuitivo para cliente/servidor
- E muito mais!