---
title: "Projetos TypeScript"
description: "Documentação de referência para projetos TypeScript"
---

import { FileTree } from '@astrojs/starlight/components';
import RunGenerator from '@components/run-generator.astro';
import InstallCommand from '@components/install-command.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import PackageManagerShortCommand from '@components/package-manager-short-command.astro';
import Link from '@components/link.astro';

O gerador de projetos TypeScript pode ser usado para criar bibliotecas ou aplicações modernas em [TypeScript](https://www.typescriptlang.org/) configuradas com melhores práticas como [ECMAScript Modules (ESM)](https://www.typescriptlang.org/docs/handbook/modules/reference.html), [project references](https://www.typescriptlang.org/docs/handbook/project-references.html) do TypeScript, [Vitest](https://vitest.dev/) para execução de testes e [ESLint](https://eslint.org/) para análise estática.

## Uso

### Gerar um Projeto TypeScript

Você pode gerar um novo projeto TypeScript de duas formas:

<RunGenerator generator="ts#project" />

### Opções

<GeneratorParameters generator="ts#project" />

## Saída do Gerador

O gerador criará a seguinte estrutura de projeto no diretório `<directory>/<name>`:

<FileTree>

  - src Código-fonte TypeScript
    - index.ts
  - project.json Configuração do projeto e targets de build
  - tsconfig.json Configuração base do TypeScript para este projeto (estende o tsconfig.base.json da raiz do workspace)
  - tsconfig.lib.json Configuração do TypeScript para sua biblioteca (código de runtime ou empacotado)
  - tsconfig.spec.json Configuração do TypeScript para seus testes
  - vitest.config.mts Configuração do Vitest
  - eslint.config.mjs Configuração do ESLint

</FileTree>

:::tip
Observe que nenhum arquivo `package.json` é criado para este projeto! Você pode entender o motivo [abaixo](#dependencies).
:::

Você também notará alterações nos seguintes arquivos na raiz do workspace:

<FileTree>

  - nx.json A configuração do Nx é atualizada para configurar o plugin @nx/js/typescript para seu projeto
  - tsconfig.base.json Um alias do TypeScript é configurado para seu projeto permitindo sua importação por outros projetos no workspace
  - tsconfig.json Uma referência de projeto TypeScript é adicionada para seu projeto

</FileTree>

## Escrevendo Código TypeScript

Adicione seu código TypeScript no diretório `src`.

### Sintaxe de Importação ESM

Como seu projeto TypeScript é um ES Module, certifique-se de escrever suas instruções de importação com a sintaxe ESM correta, referenciando explicitamente a extensão do arquivo:

```ts title="index.ts" ".js"
import { sayHello } from './hello.js';
```

:::note
Apesar de estarmos usando TypeScript, e `sayHello` estar definido em `hello.ts`, usamos a extensão `.js` em nossa importação. Você pode ler mais sobre isso [aqui](https://www.typescriptlang.org/docs/handbook/modules/reference.html).
:::

### Exportando para Outros Projetos TypeScript

O ponto de entrada do seu projeto TypeScript é `src/index.ts`. Você pode adicionar exports aqui para qualquer elemento que deseja que outros projetos possam importar:

```ts title="src/index.ts"
export { sayHello } from './hello.js';
export * from './algorithms/index.js';
```

### Importando seu Código em Outros Projetos

[TypeScript aliases](https://www.typescriptlang.org/docs/handbook/modules/reference.html#paths) para seu projeto são configurados no `tsconfig.base.json` do workspace, permitindo que você referencie seu projeto TypeScript de outros projetos TypeScript:

```ts title="packages/my-other-project/src/index.ts"
import { sayHello } from ':my-scope/my-library';
```

:::note
Aliases para projetos TypeScript começam com `:` ao invés do tradicional `@`, evitando possíveis conflitos de nomes entre pacotes locais no workspace e pacotes remotos no [NPM](https://www.npmjs.com/).
:::

Quando você adiciona uma instrução de importação para um novo projeto em seu workspace pela primeira vez, provavelmente verá um erro em seu IDE similar ao abaixo:

<details>
<summary>Erro de importação</summary>

```bash wrap
File '/path/to/my/workspace/packages/my-library/src/index.ts' is not under 'rootDir' '/path/to/my/workspace/packages/my-consumer'. 'rootDir' is expected to contain all source files.
  File is ECMAScript module because '/path/to/my/workspace/package.json' has field "type" with value "module" ts(6059)
File '/path/to/my/workspace/packages/my-library/src/index.ts' is not listed within the file list of project '/path/to/my/workspace/packages/my-consumer/tsconfig.lib.json'. Projects must list all files or use an 'include' pattern.
  File is ECMAScript module because '/path/to/my/workspace/package.json' has field "type" with value "module" ts(6307)
```

</details>

Isso ocorre porque uma [project reference](https://www.typescriptlang.org/docs/handbook/project-references.html) ainda não foi configurada.

Projetos TypeScript são configurados com o gerador Nx TypeScript Sync por padrão, dispensando a necessidade de configurar manualmente as referências de projeto. Basta executar o seguinte comando e o Nx adicionará a configuração necessária:

<NxCommands commands={['sync']} />

Após isso, o erro em seu IDE deve desaparecer e você estará pronto para usar sua biblioteca.

:::tip
Você também pode simplesmente construir seu projeto e será apresentado a uma mensagem como:

```bash wrap
[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date?
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Selecione `Yes` para permitir que o Nx atualize suas referências de projeto.
:::

### Mantendo Aliases de Path Sincronizados

Se você adicionar entradas personalizadas em `compilerOptions.paths` no `tsconfig.json` de um projeto, o TypeScript para de herdar os aliases do workspace definidos em `tsconfig.base.json`. O gerador oculto `ts#sync` é executado antes do target `compile` (configurado em `nx.json`) para copiar quaisquer aliases base ausentes nos arquivos `tsconfig.json`, `tsconfig.lib.json` e `tsconfig.app.json` que já declaram `paths`. Para desativar, remova `@aws/nx-plugin:ts#sync` de `targetDefaults.compile.syncGenerators` em `nx.json`.

### Dependências

Você notará que seu projeto TypeScript não possui um arquivo `package.json`, o que pode ser inesperado se você está acostumado com monorepos TypeScript tradicionais.

Para adicionar uma dependência para qualquer pacote TypeScript em seu monorepo, basta adicionar a dependência ao `package.json` na raiz do workspace. Você pode fazer isso via linha de comando do seu gerenciador de pacotes:

<InstallCommand pkg="some-npm-package" />

A dependência estará então disponível para qualquer projeto TypeScript em seu workspace.

#### Código de Runtime

Ao usar seu projeto TypeScript como código de runtime (por exemplo, como handler de uma função AWS Lambda), recomenda-se usar uma ferramenta como [Rolldown](https://rolldown.rs/) para empacotar seu projeto, pois isso permite [tree-shake](https://rolldown.rs/guide/in-depth/why-bundlers) para incluir apenas as dependências realmente utilizadas.

Você pode alcançar isso adicionando um target como o seguinte em seu arquivo `project.json`:

```json
{
  ...
  "targets": {
    ...
    "bundle": {
      "cache": true,
      "executor": "nx:run-commands",
      "outputs": ["{workspaceRoot}/dist/packages/my-library/bundle"],
      "options": {
        "command": "rolldown -c rolldown.config.ts"
      }
    },
  },
}
```

E adicionando o arquivo `rolldown.config.ts` como segue:

```ts
// rolldown.config.ts
import { defineConfig } from 'rolldown';

export default defineConfig([
  {
    input: 'src/index.ts',
    output: {
      file: '../../dist/packages/my-library/bundle/index.js',
      format: 'cjs',
      inlineDynamicImports: true,
    },
  },
]);
```

:::note
Note que no target acima escolhemos `src/index.ts` como entrypoint do bundle, o que significa que o código exportado deste arquivo será incluído no bundle, junto com todas suas dependências.
:::

:::tip
Se estiver construindo uma função AWS Lambda, confira o gerador <Link path="/guides/ts-lambda-function">`ts#lambda-function`</Link> pois ele configura o empacotamento automaticamente, além de gerar infraestrutura e adicionar observabilidade e type-safety.
:::

#### Publicação no NPM

Se você está publicando seu projeto TypeScript no NPM, deve criar um arquivo `package.json` para ele.

Este deve declarar as dependências que seu projeto referencia. Como em tempo de build seu projeto resolve dependências instaladas via `package.json` da raiz do workspace, recomenda-se configurar o [Nx Dependency Checks ESLint Plugin](https://nx.dev/nx-api/eslint-plugin/documents/dependency-checks) para garantir que o `package.json` do projeto publicado inclua todas dependências usadas.

### Build

Seu projeto TypeScript está configurado com um target `build` (definido em `project.json`), que pode ser executado via:

<NxCommands commands={['run <project-name>:build']} />

Onde `<project-name>` é o nome totalmente qualificado do seu projeto.

O target `build` irá compilar, lintar e testar seu projeto.

A saída do build pode ser encontrada na pasta `dist` da raiz do workspace, dentro de um diretório para seu pacote e target, por exemplo `dist/packages/<my-library>/tsc`

Para construir todos os projetos em seu workspace, execute:

<NxCommands commands={['run-many --target build']} />

Ou use o comando abreviado:

<PackageManagerShortCommand commands={["build"]} />

## Testes

[Vitest](https://vitest.dev/) está configurado para testar seu projeto.

### Escrevendo Testes

Testes devem ser escritos em arquivos `.spec.ts` ou `.test.ts`, colocalizados na pasta `src` do seu projeto.

Por exemplo:

<FileTree>
  - src
    - hello.ts Código-fonte da biblioteca
    - hello.spec.ts Testes para hello.ts
</FileTree>

O Vitest fornece sintaxe similar ao Jest para definir testes, com utilitários como `describe`, `it`, `test` e `expect`.

```ts title="hello.spec.ts"
import { sayHello } from './hello.js';

describe('sayHello', () => {

  it('deve cumprimentar o chamador', () => {
    expect(sayHello('Darth Vader')).toBe('Hello, Darth Vader!');
  });

});
```

Para mais detalhes sobre como escrever testes e funcionalidades como mock de dependências, consulte a [documentação do Vitest](https://vitest.dev/guide/#writing-tests)

### Executando Testes

Testes serão executados como parte do target `build` do seu projeto, mas você também pode executá-los separadamente usando o target `test`:

<NxCommands commands={['run <project-name>:test']} />

Você pode executar um teste individual ou suite de testes usando a flag `-t`:

<NxCommands commands={["run <project-name>:test -t 'sayHello'"]} />

:::tip
Se você usa VSCode, recomendamos instalar a extensão [Vitest Runner for VSCode that actually works](https://marketplace.visualstudio.com/items?itemName=rluvaton.vscode-vitest), que permite executar, monitorar ou debugar testes diretamente da IDE.
:::

## Linting

Projetos TypeScript usam [ESLint](https://eslint.org/) para linting, junto com [Prettier](https://prettier.io/) para formatação.

Recomendamos configurar o ESLint no arquivo `eslint.config.mjs` da raiz do workspace, pois alterações aqui se aplicarão a todos projetos TypeScript no workspace garantindo consistência.

Da mesma forma, você pode configurar o Prettier no arquivo `.prettierrc` da raiz.

### Executando o Linter

Para invocar o linter e verificar seu projeto, execute o target `lint`:

<NxCommands commands={["run <project-name>:lint"]} />

### Corrigindo Problemas de Lint

A maioria dos problemas de lint ou formatação podem ser corrigidos automaticamente. Você pode pedir ao ESLint para corrigir problemas de lint executando com o argumento `--configuration=fix`:

<NxCommands commands={["run <project-name>:lint --configuration=fix"]} />

Similarmente, se desejar corrigir todos problemas de lint em todos pacotes do workspace, execute:

<NxCommands commands={["run-many --target lint --all --configuration=fix"]} />

:::tip
Isto possui um comando abreviado a partir da raiz do seu workspace:

<PackageManagerShortCommand commands={["lint"]} />
:::

### Ignorando Problemas de Lint

Para evitar que problemas de lint atrasem você durante o desenvolvimento (particularmente se você tem problemas não corrigíveis automaticamente em seu projeto), você pode executar um build com a configuração `skip-lint`:

<NxCommands commands={["run-many --target build --configuration=skip-lint"]} />

Isso ainda executará o ESLint como parte do build, mas o target de lint sempre será considerado bem-sucedido.

:::tip
Isto possui um comando abreviado a partir da raiz do seu workspace:

<PackageManagerShortCommand commands={["build:skip-lint"]} />
:::