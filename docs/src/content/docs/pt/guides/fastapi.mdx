---
title: "FastAPI"
description: "Documentação de referência para FastAPI"
---

import { FileTree, AnchorHeading, Tabs, TabItem } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import PackageManagerShortCommand from '@components/package-manager-short-command.astro';
import Infrastructure from '@components/infrastructure.astro';
import Snippet from '@components/snippet.astro';

[FastAPI](https://fastapi.tiangolo.com/) é um framework para construção de APIs em Python.

O gerador FastAPI cria uma nova aplicação FastAPI com configuração de infraestrutura AWS CDK ou Terraform. O backend gerado utiliza AWS Lambda para implantação serverless, exposto via AWS API Gateway. Configura [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/python/latest/) para observabilidade, incluindo registro de logs, rastreamento com AWS X-Ray e métricas no CloudWatch.

## Uso

### Gerar uma API FastAPI

Você pode gerar uma nova API FastAPI de duas formas:

<RunGenerator generator="py#fast-api" />

### Opções

<GeneratorParameters generator="py#fast-api" />

<Snippet name="api/api-choice-note" />

:::tip
Selecione `ServerlessApiGatewayRestApi` (padrão) como seu `computeType` se você pretende construir operações de streaming.
:::

## Saída do Gerador

O gerador criará a seguinte estrutura de projeto no diretório `<directory>/<api-name>`:

<FileTree>

- project.json Configuração do projeto e alvos de build
- pyproject.toml Configuração do projeto Python e dependências
- run.sh Script de bootstrap do Lambda Web Adapter para iniciar o app FastAPI via uvicorn
- \<module_name>
  - \_\_init\_\_.py Inicialização do módulo
  - init.py Configura o app FastAPI e middleware do powertools
  - main.py Implementação da API
- scripts
  - generate_open_api.py Script para gerar schema OpenAPI a partir do app FastAPI

</FileTree>

### Infraestrutura

<Snippet name="shared-constructs" />

<Snippet name="api/shared-constructs" />

## Implementando sua API FastAPI

A implementação principal da API está em `main.py`. É aqui que você define suas rotas e suas implementações. Exemplo:

```python
from pydantic import BaseModel
from .init import app, tracer

class Item(BaseModel):
  name: str

@app.get("/items/{item_id}")
@tracer.capture_method
def get_item(item_id: int) -> Item:
    return Item(name=...)

@app.post("/items")
@tracer.capture_method
def create_item(item: Item):
    return ...
```

O gerador configura automaticamente vários recursos:

1. Integração com AWS Lambda Powertools para observabilidade
2. Middleware de tratamento de erros
3. Correlação de requisições/respostas
4. Coleta de métricas
5. Implantação AWS Lambda via [Lambda Web Adapter](https://github.com/awslabs/aws-lambda-web-adapter) com uvicorn
6. Streaming type-safe (somente REST API)

### Observabilidade com AWS Lambda Powertools

#### Logs

O gerador configura logging estruturado usando AWS Lambda Powertools. Você pode acessar o logger nos handlers:

```python
from .init import app, logger

@app.get("/items/{item_id}")
def read_item(item_id: int):
    logger.info("Fetching item", extra={"item_id": item_id})
    return {"item_id": item_id}
```

O logger inclui automaticamente:

- IDs de correlação para rastreamento
- Caminho e método da requisição
- Informações de contexto do Lambda
- Indicadores de cold start

#### Rastreamento

O rastreamento com AWS X-Ray é configurado automaticamente. Você pode adicionar subsegmentos personalizados:

```python
from .init import app, tracer

@app.get("/items/{item_id}")
@tracer.capture_method
def read_item(item_id: int):
    # Cria um novo subsegmento
    with tracer.provider.in_subsegment("fetch-item-details"):
        # Sua lógica aqui
        return {"item_id": item_id}
```

#### Métricas

Métricas no CloudWatch são coletadas automaticamente. Você pode adicionar métricas personalizadas:

```python
from .init import app, metrics
from aws_lambda_powertools.metrics import MetricUnit

@app.get("/items/{item_id}")
def read_item(item_id: int):
    metrics.add_metric(name="ItemViewed", unit=MetricUnit.Count, value=1)
    return {"item_id": item_id}
```

Métricas padrão incluem:

- Contagem de requisições
- Contagem de sucessos/falhas
- Métricas de cold start
- Métricas por rota

### Tratamento de Erros

O gerador inclui tratamento abrangente de erros:

```python
from fastapi import HTTPException

@app.get("/items/{item_id}")
def read_item(item_id: int):
    if item_id < 0:
        raise HTTPException(status_code=400, detail="Item ID must be positive")
    return {"item_id": item_id}
```

Exceções não tratadas são capturadas pelo middleware e:

1. Registram a exceção completa com stack trace
2. Gravam métrica de falha
3. Retornam resposta 500 segura ao cliente
4. Preservam o ID de correlação

:::tip
Recomenda-se especificar modelos de resposta para operações da API para melhor geração de código ao usar o gerador `connection`. <Link path="guides/connection/react-fastapi#errors">Veja mais detalhes aqui</Link>.
:::

### Streaming

:::caution
Streaming é suportado apenas quando `computeType` é `ServerlessApiGatewayRestApi` (padrão), pois APIs HTTP do API Gateway não suportam streaming de respostas.
:::

A FastAPI gerada suporta respostas em streaming nativamente ao usar REST API. A infraestrutura é configurada para usar o [AWS Lambda Web Adapter](https://github.com/awslabs/aws-lambda-web-adapter) para executar sua FastAPI via uvicorn dentro do Lambda, com `ResponseTransferMode.STREAM` no API Gateway para todas as operações REST API, o que permite que streaming funcione junto com operações não-streaming.

#### Usando `JsonStreamingResponse`

O arquivo `init.py` gerado exporta uma classe `JsonStreamingResponse` que fornece streaming type-safe com geração adequada de schema OpenAPI. Isso garante que o <Link path="guides/connection/react-fastapi">gerador `connection`</Link> possa produzir métodos cliente de streaming corretamente tipados.

```python
from pydantic import BaseModel
from .init import app, JsonStreamingResponse

class Chunk(BaseModel):
    message: str

async def generate_chunks():
    for i in range(100):
        yield Chunk(message=f"This is chunk {i}")

@app.post(
    "/stream",
    response_class=JsonStreamingResponse,
    responses={200: JsonStreamingResponse.openapi_response(Chunk, "Stream of chunks")},
)
async def my_stream() -> JsonStreamingResponse:
    return JsonStreamingResponse(generate_chunks())
```

A classe `JsonStreamingResponse`:

1. Serializa modelos Pydantic para o formato [JSON Lines](https://jsonlines.org/) (`application/jsonl`)
2. Fornece um helper `openapi_response` que gera o schema OpenAPI correto com `itemSchema`, permitindo que o <Link path="guides/connection/react-fastapi#consuming-a-stream">gerador `connection`</Link> produza métodos cliente de streaming type-safe

#### Consumo

Para consumir streams de respostas, utilize o <Link path="guides/connection/react-fastapi#consuming-a-stream">gerador `connection`</Link>, que fornece um método type-safe para iterar sobre os chunks transmitidos.

## Implantando sua API FastAPI

O gerador cria código de infraestrutura CDK ou Terraform baseado no `iacProvider`. Use para implantar:

<Infrastructure>
<Fragment slot="cdk">
O construct CDK para implantação está em `common/constructs`. Use em uma aplicação CDK:

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    // Adicione a API ao seu stack
    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
    });
  }
}
```

Isso configura:

1. Função Lambda para cada operação na aplicação FastAPI
2. API Gateway HTTP/REST como trigger da função
3. Permissões IAM
4. Log group no CloudWatch
5. Configuração de X-Ray
6. Namespace de métricas no CloudWatch

<Snippet name="api/cors-configuration-cdk-note" />

:::note
Se usar `Cognito`, forneça a propriedade `identity`:

```ts {9}
import { MyApi, UserIdentity } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const identity = new UserIdentity(this, 'Identity');

    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
      identity,
    });
  }
}
```

O construct `UserIdentity` pode ser gerado com <Link path="/guides/react-website-auth">gerador `ts#react-website-auth`</Link>
:::
</Fragment>
<Fragment slot="terraform">
Use os módulos Terraform em `common/terraform`:

```hcl {2}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Variáveis de ambiente para a função Lambda
  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  # Políticas IAM adicionais se necessário
  additional_iam_policy_statements = [
    # Adicione permissões adicionais que sua API precisa
  ]

  tags = local.common_tags
}
```

Isso configura:

1. Função Lambda que serve todas as rotas FastAPI
2. API Gateway HTTP/REST como trigger da função
3. Permissões IAM
4. Log group no CloudWatch
5. Configuração de X-Ray
6. Configuração de CORS

<Snippet name="api/cors-configuration-terraform-note" />

:::note
Para `Cognito`, forneça:

```hcl {4-5}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  user_pool_id         = local.user_pool_id
  user_pool_client_ids = [local.client_id]

  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  tags = local.common_tags
}
```

Você pode configurar Cognito User Pool e Client usando recursos ou módulos Terraform apropriados.
:::

Saídas do módulo:

```hcl
# Acessar o endpoint da API
output "api_url" {
  value = module.my_api.stage_invoke_url
}

# Acessar detalhes da função Lambda
output "lambda_function_name" {
  value = module.my_api.lambda_function_name
}

# Acessar role IAM para conceder permissões adicionais
output "lambda_execution_role_arn" {
  value = module.my_api.lambda_execution_role_arn
}
```

Personalize CORS:

```hcl
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Configuração CORS personalizada
  cors_allow_origins = ["https://myapp.com", "https://staging.myapp.com"]
  cors_allow_methods = ["GET", "POST", "PUT", "DELETE"]
  cors_allow_headers = [
    "authorization",
    "content-type",
    "x-custom-header"
  ]

  tags = local.common_tags
}
```

:::caution
Se selecionar `None` para `auth`, Checkov pode reportar falhas:

<Tabs syncKey="http-rest">
<TabItem label="HTTP API">
```
Check: CKV_AWS_309: "Ensure API GatewayV2 routes specify an authorization type"
 FAILED for resource: aws_apigatewayv2_route.proxy_routes["PUT"]
```
</TabItem>
<TabItem label="REST API">
```
Check: CKV_AWS_59: "Ensure there is no open access to back-end resources through API"
 FAILED for resource: aws_api_gateway_method.proxy_method
```
</TabItem>
</Tabs>

Adicione [comentários de supressão](https://www.checkov.io/2.Basics/Suppressing%20and%20Skipping%20Policies.html) se necessário.
:::
</Fragment>
</Infrastructure>

### Integrações

<Snippet name="api/type-safe-api-integrations" parentHeading="Integrações" />

#### Geração de Código

<Infrastructure>
<Fragment slot="cdk">
Como as operações são definidas em Python e a infraestrutura em TypeScript, geramos código para fornecer metadados ao construct CDK.

Um alvo `generate:<ApiName>-metadata` é adicionado ao `project.json` para gerar arquivos como `packages/common/constructs/src/generated/my-api/metadata.gen.ts`.

:::note
Execute um build após alterar a API:

<PackageManagerShortCommand commands={["build"]} />
:::

:::tip
Use [`nx watch`](https://nx.dev/nx-api/nx/documents/watch) para regenerar tipos automaticamente:

<NxCommands
  commands={[
    'watch --projects=<FastAPIProject> -- \\ ',
    'run <InfraProject>:"generate:<ApiName>-metadata"',
  ]}
/>
:::
</Fragment>
<Fragment slot="terraform">
:::note
Não há suporte para integrações type-safe com Terraform.
:::
</Fragment>
</Infrastructure>

### Concedendo Acesso (Somente IAM)

Para autenticação `IAM`, use `grantInvokeAccess`:

<Infrastructure>
<Fragment slot="cdk">
```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```
</Fragment>
<Fragment slot="terraform">
```hcl
# Criar política IAM para permitir invocar a API
resource "aws_iam_policy" "api_invoke_policy" {
  name        = "MyApiInvokePolicy"
  description = "Política para permitir invocar a FastAPI"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = "execute-api:Invoke"
        Resource = "${module.my_api.api_execution_arn}/*/*"
      }
    ]
  })
}

# Anexar a política a uma role IAM (ex: usuários autenticados)
resource "aws_iam_role_policy_attachment" "api_invoke_access" {
  role       = aws_iam_role.authenticated_user_role.name
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}

# Ou anexar a uma role existente pelo nome
resource "aws_iam_role_policy_attachment" "api_invoke_access_existing" {
  role       = "MyExistingRole"
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}
```

Principais saídas:

- `module.my_api.api_execution_arn` - Para permissões execute-api:Invoke
- `module.my_api.api_arn` - ARN do API Gateway
- `module.my_api.lambda_function_arn` - ARN da função Lambda
</Fragment>
</Infrastructure>

## Desenvolvimento Local

Execute o servidor local com:

<NxCommands commands={['run my-api:serve']} />

Isso inicia um servidor FastAPI com:

- Recarregamento automático
- Documentação interativa em `/docs` ou `/redoc`
- Schema OpenAPI em `/openapi.json`

## Invocando sua API FastAPI

Para consumir a API de um site React, use o <Link path="guides/connection/react-fastapi">gerador `connection`</Link>.