---
title: "tRPC"
description: "tRPC에 대한 참조 문서"
---



import { FileTree, Tabs, TabItem } from '@astrojs/starlight/components';
import AnchorHeading from '@astrojs/starlight/components/AnchorHeading.astro';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Snippet from '@components/snippet.astro';

<<<<<<< HEAD
[tRPC](https://trpc.io/)는 엔드투엔드 타입 안전성을 갖춘 TypeScript API 구축 프레임워크입니다. tRPC를 사용하면 API 작업의 입력과 출력 변경사항이 클라이언트 코드에 즉시 반영되며, 프로젝트 재빌드 없이 IDE에서 바로 확인할 수 있습니다.

tRPC API 생성기는 AWS CDK 인프라 설정이 포함된 새로운 tRPC API를 생성합니다. 생성된 백엔드는 서버리스 배포를 위해 AWS Lambda를 사용하며 [Zod](https://zod.dev/)를 통한 스키마 검증을 포함합니다. 또한 로깅, AWS X-Ray 추적, Cloudwatch 메트릭을 위한 [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/)를 설정합니다.
=======
[tRPC](https://trpc.io/)는 엔드투엔드 타입 안전성을 갖춘 TypeScript API 구축 프레임워크입니다. tRPC를 사용하면 API 작업의 입력과 출력 변경사항이 클라이언트 코드에 즉시 반영되며 프로젝트 재빌드 없이 IDE에서 바로 확인할 수 있습니다.

tRPC API 생성기는 AWS CDK 인프라 설정이 완료된 새로운 tRPC API를 생성합니다. 생성된 백엔드는 서버리스 배포를 위해 AWS Lambda를 사용하며 [Zod](https://zod.dev/)를 통한 스키마 검증을 포함합니다. 또한 로깅, AWS X-Ray 추적, Cloudwatch 메트릭을 포함한 관측 가능성을 위해 [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/)를 설정합니다.
>>>>>>> c5375c6 (docs: update translations)

## 사용 방법

### tRPC API 생성하기

새 tRPC API를 두 가지 방법으로 생성할 수 있습니다:

<RunGenerator generator="ts#trpc-api" />

### 옵션

<GeneratorParameters generator="ts#trpc-api" />

<Snippet name="api/api-choice-note" />

## 생성기 출력

생성기는 `<directory>/<api-name>` 디렉토리에 다음 프로젝트 구조를 생성합니다:

<FileTree>
  - src
    - init.ts 백엔드 tRPC 초기화
    - router.ts tRPC 라우터 정의 (Lambda 핸들러 API 진입점)
    - schema Zod를 사용한 스키마 정의
      - echo.ts "echo" 프로시저의 입력/출력 예제 정의
    - procedures API가 노출하는 프로시저(작업)
      - echo.ts 예제 프로시저
    - middleware
      - error.ts 오류 처리 미들웨어
<<<<<<< HEAD
      - logger.ts AWS Powertools 로깅 설정 미들웨어
      - tracer.ts AWS Powertools 추적 설정 미들웨어
      - metrics.ts AWS Powertools 메트릭 설정 미들웨어
=======
      - logger.ts AWS Lambda Powertools 로깅 설정 미들웨어
      - tracer.ts AWS Lambda Powertools 추적 설정 미들웨어
      - metrics.ts AWS Lambda Powertools 메트릭 설정 미들웨어
>>>>>>> c5375c6 (docs: update translations)
    - local-server.ts 로컬 개발 서버용 tRPC 독립 실행형 어댑터 진입점
    - client
      - index.ts 기계 간 API 호출용 타입 안전 클라이언트
  - tsconfig.json TypeScript 설정
  - project.json 프로젝트 설정 및 빌드 타겟

</FileTree>

생성기는 또한 API 배포에 사용할 수 있는 CDK 구성을 `packages/common/constructs` 디렉토리에 생성합니다.

## tRPC API 구현하기

<<<<<<< HEAD
tRPC API는 라우터가 특정 프로시저에 요청을 위임하는 구조로 구성됩니다. 각 프로시저는 Zod 스키마로 정의된 입력과 출력을 가집니다.
=======
개요적으로 tRPC API는 요청을 특정 프로시저에 위임하는 라우터로 구성됩니다. 각 프로시저는 Zod 스키마로 정의된 입력과 출력을 가집니다.
>>>>>>> c5375c6 (docs: update translations)

### 스키마

`src/schema` 디렉토리에는 클라이언트와 서버 코드 간에 공유되는 타입들이 포함되어 있습니다. 이 패키지에서는 TypeScript 우선 스키마 선언 및 검증 라이브러리인 [Zod](https://zod.dev/)를 사용하여 이러한 타입을 정의합니다.

<<<<<<< HEAD
예시 스키마:
=======
:::note
모노레포 루트의 `tsconfig.base.json`에 Zod를 [버전 4.x](https://zod.dev/v4)로 확인하는 별칭이 추가됩니다. 이는 Zod v4가 NPM에 출시되더라도 임포트 경로 변경 없이 업그레이드할 수 있도록 미리 대비하기 위함입니다.
:::

예시 스키마는 다음과 같을 수 있습니다:
>>>>>>> c5375c6 (docs: update translations)

```ts
import { z } from 'zod/v4';

// 스키마 정의
export const UserSchema = z.object({
  name: z.string(),
  height: z.number(),
  dateOfBirth: z.string().datetime(),
});

// 해당 TypeScript 타입
export type User = z.TypeOf<typeof UserSchema>;
```

위 스키마에서 `User` 타입은 다음 TypeScript 인터페이스와 동일합니다:

```ts
interface User {
  name: string;
  height: number;
  dateOfBirth: string;
}
```

<<<<<<< HEAD
스키마 변경 시 API에서 사용되는 구조를 한 곳에서 업데이트할 수 있도록 클라이언트와 서버 코드 모두에서 공유됩니다. Zod는 런타임에 tRPC API에서 자동으로 스키마를 검증하므로 백엔드에서 수동으로 검증 로직을 작성할 필요가 없습니다.

Zod는 `.merge`, `.pick`, `.omit` 등 스키마 결합/파생을 위한 강력한 유틸리티를 제공합니다. 자세한 내용은 [Zod 공식 문서](https://zod.dev/?id=basic-usage)를 참조하세요.
=======
스키마는 서버와 클라이언트 코드 모두에서 공유되므로 API에서 사용하는 구조를 변경할 때 단일 위치에서 업데이트할 수 있습니다.

스키마는 런타임에 tRPC API에 의해 자동으로 검증되므로 백엔드에서 수동으로 검증 로직을 작성할 필요가 없습니다.

Zod는 `.merge`, `.pick`, `.omit` 등 스키마를 결합하거나 파생시키는 강력한 유틸리티를 제공합니다. 자세한 내용은 [Zod 문서 사이트](https://zod.dev/?id=basic-usage)에서 확인할 수 있습니다.
>>>>>>> c5375c6 (docs: update translations)

### 라우터와 프로시저

API 진입점은 `src/router.ts`에 있습니다. 이 파일은 호출되는 작업에 따라 요청을 "프로시저"에 라우팅하는 Lambda 핸들러를 포함합니다. 각 프로시저는 예상 입력, 출력 및 구현을 정의합니다.

생성된 샘플 라우터에는 `echo`라는 단일 작업이 있습니다:

```ts
import { echo } from './procedures/echo.js';

export const appRouter = router({
  echo,
});
```

예시 `echo` 프로시저는 `src/procedures/echo.ts`에 생성됩니다:

```ts
export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

구성 요소 설명:
- `publicProcedure`: `src/middleware`에 설정된 미들웨어를 포함한 공개 API 메서드 정의
- `input`: 작업에 필요한 입력 스키마 정의 (자동 검증)
- `output`: 작업 출력 스키마 정의 (스키마 불일치 시 타입 오류 발생)
- `query`: 비변경 작업 구현 정의 (데이터 조회용). 변경 작업시 `mutation` 사용

<<<<<<< HEAD
새 프로시저 추가 시 `src/router.ts`에 등록해야 합니다.
=======
- `publicProcedure`는 `src/middleware`에 설정된 미들웨어를 포함하여 API의 공개 메서드를 정의합니다. 이 미들웨어에는 로깅, 추적, 메트릭을 위한 AWS Lambda Powertools 통합이 포함됩니다.
- `input`은 작업에 필요한 입력을 정의하는 Zod 스키마를 받습니다. 이 작업에 전송된 요청은 자동으로 이 스키마에 대해 검증됩니다.
- `output`은 작업의 예상 출력을 정의하는 Zod 스키마를 받습니다. 스키마를 준수하지 않는 출력을 반환하면 구현 단계에서 타입 오류가 발생합니다.
- `query`는 API 구현을 정의하는 함수를 받습니다. 이 구현은 `opts`를 수신하며, `opts.input`에는 작업에 전달된 입력이, `opts.ctx`에는 미들웨어에서 설정한 컨텍스트가 포함됩니다. `query`에 전달된 함수는 `output` 스키마를 준수하는 출력을 반환해야 합니다.

`query`를 사용하여 구현을 정의하는 것은 작업이 변경을 유발하지 않음을 나타냅니다. 데이터 조회 메서드를 정의할 때 사용합니다. 변경을 유발하는 작업을 구현하려면 대신 `mutation` 메서드를 사용하세요.

새 프로시저를 추가할 경우 `src/router.ts`의 라우터에 등록해야 합니다.
>>>>>>> c5375c6 (docs: update translations)

## tRPC API 커스터마이징

### 오류 처리

<<<<<<< HEAD
`TRPCError`를 발생시켜 클라이언트에 오류 응답을 반환할 수 있습니다:
=======
구현 단계에서 `TRPCError`를 발생시켜 클라이언트에 오류 응답을 반환할 수 있습니다. 오류 유형을 나타내는 `code`를 받습니다:
>>>>>>> c5375c6 (docs: update translations)

```ts
throw new TRPCError({
  code: 'NOT_FOUND',
  message: '요청한 리소스를 찾을 수 없습니다',
});
```

### 작업 구성

<<<<<<< HEAD
관련 작업을 그룹화하려면 중첩 라우터를 사용합니다:
=======
API가 성장함에 따라 관련 작업을 그룹화하고 싶을 수 있습니다.

중첩 라우터를 사용하여 작업을 그룹화할 수 있습니다:
>>>>>>> c5375c6 (docs: update translations)

```ts
import { getUser } from './procedures/users/get.js';
import { listUsers } from './procedures/users/list.js';

const appRouter = router({
   users: router({
      get: getUser,
      list: listUsers,
   }),
   ...
})
```

<<<<<<< HEAD
클라이언트에서는 `client.users.list.query()` 방식으로 호출합니다.

### 로깅

`src/middleware/logger.ts`에 구성된 AWS Lambda Powertools 로거는 `opts.ctx.logger`로 접근 가능합니다:
=======
클라이언트는 이 작업 그룹화를 받게 되며, 예를 들어 `listUsers` 작업을 호출하는 것은 다음과 같이 표시됩니다:

```ts
client.users.list.query();
```

### 로깅

AWS Lambda Powertools 로거는 `src/middleware/logger.ts`에 구성되며, `opts.ctx.logger`를 통해 API 구현에서 접근할 수 있습니다. 이를 사용하여 CloudWatch Logs에 로깅하거나 모든 구조화된 로그 메시지에 포함할 추가 값을 제어할 수 있습니다:
>>>>>>> c5375c6 (docs: update translations)

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.logger.info('Operation called with input', opts.input);
      return ...;
   });
```

<<<<<<< HEAD
자세한 내용은 [AWS Lambda Powertools Logger 문서](https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/) 참조.

### 메트릭 기록

`src/middleware/metrics.ts`의 메트릭 유틸은 `opts.ctx.metrics`로 접근:
=======
로거에 대한 자세한 내용은 [AWS Lambda Powertools Logger 문서](https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/)를 참조하세요.

### 메트릭 기록

AWS Lambda Powertools 메트릭은 `src/middleware/metrics.ts`에 구성되며, `opts.ctx.metrics`를 통해 API 구현에서 접근할 수 있습니다. 이를 사용하여 AWS SDK를 임포트하거나 사용하지 않고도 CloudWatch에 메트릭을 기록할 수 있습니다:
>>>>>>> c5375c6 (docs: update translations)

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.metrics.addMetric('Invocations', 'Count', 1);
      return ...;
   });
```

<<<<<<< HEAD
자세한 내용은 [AWS Lambda Powertools Metrics 문서](https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/) 참조.
=======
자세한 내용은 [AWS Lambda Powertools Metrics 문서](https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/)를 참조하세요.
>>>>>>> c5375c6 (docs: update translations)

### X-Ray 추적 세부 설정

<<<<<<< HEAD
`src/middleware/tracer.ts`의 추적기는 `opts.ctx.tracer`로 접근:
=======
AWS Lambda Powertools 추적기는 `src/middleware/tracer.ts`에 구성되며, `opts.ctx.tracer`를 통해 API 구현에서 접근할 수 있습니다. 이를 사용하여 API 요청의 성능 및 흐름에 대한 세부 정보를 제공하는 AWS X-Ray 추적을 추가할 수 있습니다:
>>>>>>> c5375c6 (docs: update translations)

```ts {5-7}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      const subSegment = opts.ctx.tracer.getSegment()!.addNewSubsegment('MyAlgorithm');
      // ... 로직 구현
      subSegment.close();
      return ...;
   });
```

<<<<<<< HEAD
자세한 내용은 [AWS Lambda Powertools Tracer 문서](https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/) 참조.

### 커스텀 미들웨어 구현

컨텍스트에 추가 값을 제공하는 미들웨어를 구현할 수 있습니다. 예시 (`src/middleware/identity.ts`):
=======
자세한 내용은 [AWS Lambda Powertools Tracer 문서](https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/)를 참조하세요.

### 커스텀 미들웨어 구현

미들웨어를 구현하여 프로시저에 제공되는 컨텍스트에 추가 값을 추가할 수 있습니다.

예를 들어 API 호출 사용자에 대한 세부 정보를 추출하는 미들웨어를 `src/middleware/identity.ts`에 구현해 보겠습니다.
>>>>>>> c5375c6 (docs: update translations)

:::warning
이 예제는 `auth`가 `IAM`으로 설정되었다고 가정합니다. Cognito 인증시 `event`에서 클레임을 추출하면 더 간단합니다.
:::

컨텍스트 타입 정의:

```ts
export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}
```

<<<<<<< HEAD
미들웨어 구현 예시 (REST/HTTP API 별):
=======
이 컨텍스트에 선택적 추가 속성을 정의합니다. tRPC는 이 미들웨어가 올바르게 구성된 프로시저에서 이 속성이 정의되도록 관리합니다.

다음으로 미들웨어 자체를 구현합니다. 구조는 다음과 같습니다:

```ts
export const createIdentityPlugin = () => {
   const t = initTRPC.context<...>().create();
   return t.procedure.use(async (opts) => {
      // 프로시저 실행 전 로직 추가

      const response = await opts.next(...);

      // 프로시저 실행 후 로직 추가

      return response;
   });
};
```

이 경우 Cognito 호출 사용자의 세부 정보를 추출하려고 합니다. API Gateway 이벤트에서 사용자의 주체 ID("sub")를 추출하고 Cognito에서 사용자 세부 정보를 검색합니다. 구현은 함수가 REST API 또는 HTTP API에 의해 제공되는지에 따라 약간 다릅니다:
>>>>>>> c5375c6 (docs: update translations)

<Tabs>
<TabItem label="REST">
```ts
<<<<<<< HEAD
// ... REST API 구현 코드 (변경 없음) ...
=======
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEvent } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEvent>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoAuthenticationProvider = opts.ctx.event.requestContext?.identity?.cognitoAuthenticationProvider;

    let sub: string | undefined = undefined;
    if (cognitoAuthenticationProvider) {
      const providerParts = cognitoAuthenticationProvider.split(':');
      sub = providerParts[providerParts.length - 1];
    }

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `호출 사용자를 확인할 수 없음`,
      });
    }

    const { Users } = await cognito.listUsers({
      // Lambda 환경에 사용자 풀 ID가 구성되었다고 가정
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `주체 ID ${sub}에 해당하는 사용자를 찾을 수 없음`,
      });
    }

    // 컨텍스트에 ID 정보 제공
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
>>>>>>> c5375c6 (docs: update translations)
```
</TabItem>
<TabItem label="HTTP">
```ts
<<<<<<< HEAD
// ... HTTP API 구현 코드 (변경 없음) ...
=======
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoIdentity = opts.ctx.event.requestContext?.authorizer?.iam
      ?.cognitoIdentity as unknown as
      | {
          amr: string[];
        }
      | undefined;

    const sub = (cognitoIdentity?.amr ?? [])
      .flatMap((s) => (s.includes(':CognitoSignIn:') ? [s] : []))
      .map((s) => {
        const parts = s.split(':');
        return parts[parts.length - 1];
      })?.[0];

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `호출 사용자를 확인할 수 없음`,
      });
    }

    const { Users } = await cognito.listUsers({
      // Lambda 환경에 사용자 풀 ID가 구성되었다고 가정
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `주체 ID ${sub}에 해당하는 사용자를 찾을 수 없음`,
      });
    }

    // 컨텍스트에 ID 정보 제공
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
>>>>>>> c5375c6 (docs: update translations)
```
</TabItem>
</Tabs>

## tRPC API 배포하기

<<<<<<< HEAD
생성된 CDK 구성을 스택에 추가:
=======
tRPC API 생성기는 `common/constructs` 폴더에 API 배포를 위한 CDK 구성을 생성합니다. CDK 애플리케이션에서 이를 사용할 수 있습니다:
>>>>>>> c5375c6 (docs: update translations)

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs`;

export class ExampleStack extends Stack {
   constructor(scope: Construct, id: string) {
      const api = new MyApi(this, 'MyApi', {
        integrations: MyApi.defaultIntegrations(this).build(),
      });
   }
}
```

<<<<<<< HEAD
=======
이 설정은 AWS API Gateway REST/HTTP API, 비즈니스 로직용 AWS Lambda 함수, 선택한 `auth` 메서드 기반 인증을 포함한 API 인프라를 구성합니다.

>>>>>>> c5375c6 (docs: update translations)
:::note
Cognito 인증 사용시 `identity` 속성 제공 필요:

```ts {9}
import { MyApi, UserIdentity } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const identity = new UserIdentity(this, 'Identity');

    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
      identity,
    });
  }
}
```

`UserIdentity` 구성은 <Link path="/guides/react-website-auth">`ts#react-website-auth` 생성기</Link>를 사용하여 생성할 수 있습니다.
:::

### 타입 안전 통합

<Snippet name="api/type-safe-api-integrations" parentHeading="Type-Safe Integrations" />

:::tip
<<<<<<< HEAD
프로시저 추가/제거시 CDK 구성에 자동 반영되며 재빌드 불필요
=======
tRPC API에서 프로시저를 추가하거나 제거할 때 CDK 구성에 즉시 반영되며 재빌드가 필요하지 않습니다.
>>>>>>> c5375c6 (docs: update translations)
:::

### 접근 권한 부여 (IAM 전용)

<<<<<<< HEAD
`grantInvokeAccess` 메서드로 API 접근 권한 부여:
=======
`IAM` 인증을 선택한 경우 `grantInvokeAccess` 메서드를 사용하여 API 접근 권한을 부여할 수 있습니다. 예를 들어 인증된 Cognito 사용자에게 API 접근 권한을 부여할 수 있습니다:
>>>>>>> c5375c6 (docs: update translations)

```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```

## 로컬 tRPC 서버

<<<<<<< HEAD
`serve` 타겟으로 로컬 서버 실행:

<NxCommands commands={['run @my-scope/my-api:serve']} />

변경사항이 자동으로 반영됩니다.
=======
`serve` 타겟을 사용하여 API용 로컬 서버를 실행할 수 있습니다:

<NxCommands commands={['run @my-scope/my-api:serve']} />

로컬 서버의 진입점은 `src/local-server.ts`입니다.
>>>>>>> c5375c6 (docs: update translations)

변경 사항이 발생하면 자동으로 재로드됩니다.

## tRPC API 호출하기

타입 안전 클라이언트 생성 예시:

```ts
import { createMyApiClient } from ':my-scope/my-api';

const client = createMyApiClient({ url: 'https://my-api-url.example.com/' });

await client.echo.query({ message: 'Hello world!' });
```

<<<<<<< HEAD
React 웹사이트에서 호출시 <Link path="guides/api-connection/react-trpc">API Connection</Link> 생성기 사용 권장
=======
React 웹사이트에서 API를 호출하는 경우 <Link path="guides/api-connection/react-trpc">API 연결</Link> 생성기를 사용하여 클라이언트를 구성하는 것이 좋습니다.
>>>>>>> c5375c6 (docs: update translations)

## 추가 정보

[tRPC 공식 문서](https://trpc.io/docs)에서 더 많은 정보를 확인할 수 있습니다.