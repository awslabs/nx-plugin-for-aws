---
title: "tRPC"
description: "tRPC에 대한 참조 문서"
---

import { FileTree } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import schema from '../../../../../../packages/nx-plugin/src/trpc/backend/schema.json';

[tRPC](https://trpc.io/)는 엔드투엔드 타입 안전성을 갖춘 TypeScript API 구축 프레임워크입니다. tRPC를 사용하면 API 작업의 입력 및 출력에 대한 업데이트가 즉시 클라이언트 코드에 반영되며, 프로젝트를 다시 빌드하지 않고도 IDE에서 바로 확인할 수 있습니다.

tRPC API 생성기는 AWS CDK 인프라 설정과 함께 새로운 tRPC API를 생성합니다. 생성된 백엔드는 서버리스 배포를 위해 AWS Lambda를 사용하고 [Zod](https://zod.dev/)를 사용한 스키마 검증을 포함합니다. 로깅, AWS X-Ray 추적 및 Cloudwatch 메트릭을 포함한 관찰성을 위해 [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/)를 설정합니다.

## 사용법

### tRPC API 생성

tRPC API를 생성하는 방법은 두 가지입니다:

<RunGenerator generator="ts#trpc-api" />

### 옵션

<GeneratorParameters schema={schema} />

## 생성기 출력

생성기는 `<directory>/<api-name>` 디렉터리에 다음과 같은 프로젝트 구조를 생성합니다:

<FileTree>
  - schema
    - src
      - index.ts 스키마 진입점
      - procedures
        - echo.ts Zod를 사용한 "echo" 프로시저의 공유 스키마 정의
    - tsconfig.json TypeScript 구성
    - project.json 프로젝트 구성 및 빌드 대상
  - backend
    - src
      - init.ts 백엔드 tRPC 초기화
      - router.ts tRPC 라우터 정의 (Lambda 핸들러 API 진입점)
      - procedures API에서 노출된 프로시저(또는 작업)
        - echo.ts 예시 프로시저
      - middleware
        - error.ts 오류 처리를 위한 미들웨어
        - logger.ts Lambda 로깅을 위한 AWS Powertools 구성 미들웨어
        - tracer.ts Lambda 추적을 위한 AWS Powertools 구성 미들웨어
        - metrics.ts Lambda 메트릭을 위한 AWS Powertools 구성 미들웨어
      - local-server.ts 로컬 개발 서버를 위한 tRPC 독립 어댑터 진입점
      - client
        - index.ts 머신 간 API 호출을 위한 타입 안전 클라이언트
    - tsconfig.json TypeScript 구성
    - project.json 프로젝트 구성 및 빌드 대상

</FileTree>

생성기는 또한 `packages/common/constructs` 디렉터리에 있는 API를 배포하는 데 사용할 수 있는 CDK 구성을 생성합니다.

## tRPC API 구현하기

위에서 볼 수 있듯이, tRPC API의 두 가지 주요 구성 요소는 [`schema`](#schema)와 [`backend`](#backend)로, 작업 공간의 개별 패키지로 정의됩니다.

:::tip
`schema`와 `backend`는 모두 TypeScript 프로젝트이므로, 일반적인 사용법에 대해서는 <Link path="guides/typescript-project">TypeScript 프로젝트 문서</Link>를 참조할 수 있습니다.
:::

### 스키마

스키마 패키지는 클라이언트와 서버 코드 간에 공유되는 타입을 정의합니다. 이 패키지에서 타입은 [Zod](https://zod.dev/)를 사용하여 정의되며, Zod는 TypeScript 우선 스키마 선언 및 검증 라이브러리입니다.

예시 스키마는 다음과 같을 수 있습니다:

```ts
import { z } from 'zod';

// 스키마 정의
export const UserSchema = z.object({
  name: z.string(),
  height: z.number(),
  dateOfBirth: z.string().datetime(),
});

// 해당 TypeScript 타입
export type User = z.TypeOf<typeof UserSchema>;
```

위의 스키마를 고려하면, `User` 타입은 다음 TypeScript와 동일합니다:

```ts
interface User {
  name: string;
  height: number;
  dateOfBirth: string;
}
```

스키마는 서버와 클라이언트 코드 모두에서 공유되어, API에서 사용되는 구조를 변경할 때 단일 장소에서 업데이트할 수 있습니다.

스키마는 tRPC API에 의해 런타임에 자동으로 검증되므로, 백엔드에서 수동으로 사용자 정의 검증 로직을 작성할 필요가 없습니다.

Zod는 `.merge`, `.pick`, `.omit` 등의 스키마를 결합하거나 파생시키는 강력한 유틸리티를 제공합니다. 자세한 내용은 [Zod 문서 웹사이트](https://zod.dev/?id=basic-usage)에서 확인할 수 있습니다.

### 백엔드

중첩된 `backend` 폴더에는 API 구현이 포함되어 있으며, API 작업과 해당 입력, 출력 및 구현을 정의합니다.

`src/router.ts`에서 API의 진입점을 찾을 수 있습니다. 이 파일에는 호출되는 작업에 따라 요청을 "프로시저"로 라우팅하는 람다 핸들러가 포함되어 있습니다. 각 프로시저는 예상되는 입력, 출력 및 구현을 정의합니다.

생성된 샘플 라우터에는 `echo`라는 단일 작업이 있습니다:

```ts
import { echo } from './procedures/echo.js';

export const appRouter = router({
  echo,
});
```

예시 `echo` 프로시저는 `src/procedures/echo.ts`에서 생성됩니다:

```ts
export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

위의 내용을 분석해보면:

- `publicProcedure`는 `src/middleware`에 설정된 미들웨어를 포함하여 API의 공개 메서드를 정의합니다. 이 미들웨어에는 로깅, 추적 및 메트릭을 위한 AWS Lambda Powertools 통합이 포함됩니다.
- `input`은 작업에 대해 예상되는 입력을 정의하는 Zod 스키마를 허용합니다. 이 작업에 대해 전송된 요청은 자동으로 이 스키마에 대해 검증됩니다.
- `output`은 작업에 대해 예상되는 출력을 정의하는 Zod 스키마를 허용합니다. 스키마에 부합하지 않는 출력을 반환하면 타입 오류가 발생합니다.
- `query`는 API 구현을 정의하는 함수를 허용합니다. 이 구현은 작업에 전달된 `input`과 미들웨어에 의해 설정된 기타 컨텍스트(opts.ctx에서 사용 가능)를 포함하는 `opts`를 수신합니다. `query`에 전달된 함수는 `output` 스키마에 부합하는 출력을 반환해야 합니다.

`query`를 사용하여 구현을 정의하는 것은 작업이 변경되지 않음을 나타냅니다. 이를 사용하여 데이터를 검색하는 메서드를 정의하세요. 변경 가능한 작업을 구현하려면 대신 `mutation` 메서드를 사용하세요.

새 작업을 추가하는 경우, `src/router.ts`의 라우터에 등록해야 합니다.

## tRPC API 사용자 정의하기

### 오류

구현에서 `TRPCError`를 던짐으로써 클라이언트에 오류 응답을 반환할 수 있습니다. 이는 오류 유형을 나타내는 `code`를 허용합니다. 예를 들어:

```ts
throw new TRPCError({
  code: 'NOT_FOUND',
  message: '요청된 리소스를 찾을 수 없습니다',
});
```

### 작업 구성하기

API가 성장함에 따라 관련된 작업들을 함께 그룹화하고 싶을 수 있습니다.

중첩된 라우터를 사용하여 작업을 그룹화할 수 있습니다. 예를 들어:

```ts
import { getUser } from './procedures/users/get.js';
import { listUsers } from './procedures/users/list.js';

const appRouter = router({
   users: router({
      get: getUser,
      list: listUsers,
   }),
   ...
})
```

클라이언트는 이러한 작업 그룹화를 받게 되며, 예를 들어 이 경우 `listUsers` 작업을 호출하는 것은 다음과 같을 수 있습니다:

```ts
client.users.list.query();
```

### 로깅

AWS Lambda Powertools 로거는 `src/middleware/logger.ts`에서 구성되며, `opts.ctx.logger`를 통해 API 구현에서 접근할 수 있습니다. 이를 사용하여 CloudWatch Logs에 로그를 기록하고/또는 모든 구조화된 로그 메시지에 포함할 추가 값을 제어할 수 있습니다. 예를 들어:

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.logger.info('입력과 함께 호출된 작업', opts.input);

      return ...;
   });
```

로거에 대한 자세한 정보는 [AWS Lambda Powertools 로거 문서](https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/)를 참조하세요.

### 메트릭 기록

AWS Lambda Powertools 메트릭은 `src/middleware/metrics.ts`에서 구성되며, `opts.ctx.metrics`를 통해 API 구현에서 접근할 수 있습니다. AWS SDK를 가져오고 사용할 필요 없이 CloudWatch에 메트릭을 기록할 수 있습니다. 예를 들어:

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.metrics.addMetric('Invocations', 'Count', 1);

      return ...;
   });
```

자세한 내용은 [AWS Lambda Powertools 메트릭 문서](https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/)를 참조하세요.

### X-Ray 추적 미세 조정

AWS Lambda Powertools 트레이서는 `src/middleware/tracer.ts`에서 구성되며, `opts.ctx.tracer`를 통해 API 구현에서 접근할 수 있습니다. 이를 사용하여 AWS X-Ray로 추적을 추가하여 API 요청의 성능과 흐름에 대한 상세한 인사이트를 제공할 수 있습니다. 예를 들어:

```ts {5-7}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      const subSegment = opts.ctx.tracer.getSegment()!.addNewSubsegment('MyAlgorithm');
      // ... 캡처할 알고리즘 로직
      subSegment.close();

      return ...;
   });
```

자세한 내용은 [AWS Lambda Powertools 트레이서 문서](https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/)를 참조하세요.

### 사용자 정의 미들웨어 구현

미들웨어를 구현하여 프로시저에 제공되는 컨텍스트에 추가 값을 추가할 수 있습니다.

예를 들어, `src/middleware/identity.ts`에서 API의 호출 사용자에 대한 세부 정보를 추출하는 미들웨어를 구현해 보겠습니다.

먼저, 컨텍스트에 추가할 내용을 정의합니다:

```ts
export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}
```

선택적 속성을 컨텍스트에 정의합니다. tRPC는 이 미들웨어를 올바르게 구성한 프로시저에서 이것이 정의되도록 관리합니다.

다음으로, 미들웨어 자체를 구현합니다. 다음과 같은 구조를 가집니다:

```ts
export const createIdentityPlugin = () => {
   const t = initTRPC.context<IIdentityContext>().create();
   return t.procedure.use(async (opts) => {
      // 프로시저 실행 전에 실행할 로직 추가

      const response = await opts.next(...);

      // 프로시저 실행 후에 실행할 로직 추가

      return response;
   });
};
```

이 경우, 호출 Cognito 사용자에 대한 세부 정보를 추출하고 싶습니다. API 게이트웨이 이벤트에서 사용자의 주체 ID(또는 "sub")를 추출하고 Cognito에서 사용자 세부 정보를 검색할 것입니다:

```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoIdentity = opts.ctx.event.requestContext?.authorizer?.iam
      ?.cognitoIdentity as unknown as
      | {
          amr: string[];
        }
      | undefined;

    const sub = (cognitoIdentity?.amr ?? [])
      .flatMap((s) => (s.includes(':CognitoSignIn:') ? [s] : []))
      .map((s) => {
        const parts = s.split(':');
        return parts[parts.length - 1];
      })?.[0];

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `호출 사용자를 확인할 수 없습니다`,
      });
    }

    const { Users } = await cognito.listUsers({
      // Lambda 환경에 구성된 사용자 풀 ID 가정
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `주체 ID ${sub}를 가진 사용자를 찾을 수 없습니다`,
      });
    }

    // 다른 프로시저에서 컨텍스트로 ID 제공
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```

## tRPC API 배포하기

tRPC 백엔드 생성기는 `common/constructs` 폴더에 API를 배포하기 위한 CDK 구조체를 생성합니다. 다음과 같이 CDK 애플리케이션에서 이를 사용할 수 있습니다:

```ts {6}
import { MyApi } from ':my-scope/common-constructs`;

export class ExampleStack extends Stack {
   constructor(scope: Construct, id: string) {
      // 스택에 API 추가
      const api = new MyApi(this, 'MyApi');
   }
}
```

이는 AWS API Gateway HTTP API, 비즈니스 로직을 위한 AWS Lambda 함수, IAM 인증을 포함한 API 인프라를 설정합니다.

### 액세스 권한 부여

`grantInvokeAccess` 메서드를 사용하여 API에 대한 액세스 권한을 부여할 수 있습니다. 예를 들어, 인증된 Cognito 사용자에게 API 액세스 권한을 부여할 수 있습니다:

```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```

## 로컬 tRPC 서버

`serve` 타겟을 사용하여 API의 로컬 서버를 실행할 수 있습니다. 예를 들어:

<NxCommands commands={['run @my-scope/my-api-backend:serve']} />

로컬 서버의 진입점은 `src/local-server.ts`입니다.

## tRPC API 호출하기

타입 안전한 방식으로 API를 호출하기 위해 tRPC 클라이언트를 생성할 수 있습니다. 다른 백엔드에서 tRPC API를 호출하는 경우, 예를 들어 `src/client/index.ts`에서 클라이언트를 사용할 수 있습니다:

```ts
import { createMyApiClient } from ':my-scope/my-api-backend';

const client = createMyApiClient({ url: 'https://my-api-url.example.com/' });

await client.echo.query({ message: 'Hello world!' });
```

React 웹사이트에서 API를 호출하는 경우, 클라이언트를 구성하기 위해 <Link path="guides/api-connection/react-trpc">API 연결</Link> 생성기를 고려해보세요.

## 추가 정보

tRPC에 대한 자세한 내용은 [tRPC 문서](https://trpc.io/docs)를 참조하세요.