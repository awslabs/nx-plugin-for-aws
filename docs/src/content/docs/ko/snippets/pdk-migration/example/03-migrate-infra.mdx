---
title: "인프라스트럭처 마이그레이션"
---



import { Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import RunGenerator from '@components/run-generator.astro';
import Link from '@components/link.astro';
import NxCommands from '@components/nx-commands.astro';
import Drawer from '@components/drawer.astro';
import InstallCommand from '@components/install-command.astro';

쇼핑 목록 애플리케이션을 마이그레이션하기 위해 필요한 마지막 프로젝트는 `InfrastructureTsProject`입니다. 이는 TypeScript CDK 프로젝트로, Nx Plugin for AWS에서 이에 상응하는 것은 <Link path="/guides/typescript-infrastructure">`ts#infra` 생성기</Link>입니다.

Projen 프로젝트뿐만 아니라 PDK는 이러한 프로젝트들이 의존하는 CDK 구문들도 제공했습니다. 우리는 PDK의 CDK 구문 대신 Nx Plugin for AWS가 생성한 구문들을 사용하도록 쇼핑 목록 애플리케이션을 마이그레이션할 것입니다.

:::tip
PDK에 비해 Nx Plugin for AWS의 큰 장점은 타사 패키지를 통해 가져오는 대신 프로젝트에 소스 코드로 추가되는 CDK 구문을 제공한다는 점입니다. 이는 PDK에서 지원했던 것 이상의 유연성과 제어 권한을 부여합니다.
:::

#### TypeScript CDK 인프라 프로젝트 생성

`packages/infra`에 인프라 프로젝트를 설정하려면 <Link path="/guides/typescript-infrastructure">`ts#infra` 생성기</Link>를 실행하세요:

<RunGenerator generator="ts#infra" noInteractive requiredParameters={{ name: 'infra' }} />

#### CDK 인프라 마이그레이션

PDK 쇼핑 목록 애플리케이션은 CDK 애플리케이션 스택 내에서 다음 구문들을 인스턴스화했습니다:

- 쇼핑 목록을 저장하는 DynamoDB 테이블용 `DatabaseConstruct`
- PDK에서 직접 가져온 Cognito 리소스용 `UserIdentity`
- Smithy API 배포용 `MyApi` (PDK의 `TypeSafeRestApi` CDK 구문을 기반으로 타입 안전 통합을 사용하는 생성된 TypeScript CDK 구문)
- PDK의 `StaticWebsite` CDK 구문을 래핑한 웹사이트 배포용 `Website`

이제 각각을 새 프로젝트로 마이그레이션하겠습니다.

##### 애플리케이션 스택 복사

PDK 쇼핑 목록 애플리케이션의 `packages/infra/src/stacks/application-stack.ts`를 새 프로젝트의 동일한 위치에 복사하세요. 아래에서 해결할 TypeScript 오류가 표시될 것입니다.

##### 데이터베이스 구문 복사

PDK 쇼핑 목록 애플리케이션은 `packages/src/constructs/database.ts`에 `Database` 구문을 가지고 있었습니다. 이를 새 프로젝트의 동일한 위치에 복사하세요.

Nx Plugin for AWS는 PDK Nag보다 조금 더 엄격한 [Checkov](https://www.checkov.io/)를 보안 테스트에 사용하므로 다음과 같이 일부 규칙 억제를 추가해야 합니다:

```diff lang="ts"
// constructs/database.ts
+import { suppressRules } from ':shopping-list/common-constructs';
...
+suppressRules(
+  this.shoppingListTable,
+  ['CKV_AWS_28', 'CKV_AWS_119'],
+  'Backup and KMS key not required for this project',
+);
```

`application-stack.ts`에서 `DatabaseConstruct` 임포트를 ESM 구문으로 업데이트하세요:

```diff lang="ts"
// stacks/application-stack.ts
-import { DatabaseConstruct } from '../constructs/database';
+import { DatabaseConstruct } from '../constructs/database.js';
```

##### UserIdentity 구문 마이그레이션

`UserIdentity` 구문은 일반적으로 임포트만 조정하면 변경 없이 교체할 수 있습니다.

```diff lang="ts"
-import { UserIdentity } from "@aws/pdk/identity";
+import { UserIdentity } from ':shopping-list/common-constructs';
...
const userIdentity = new UserIdentity(this, `${id}UserIdentity`);
```

새 `UserIdentity` 구문에서 사용하는 기본 구문들은 PDK가 `@aws-cdk/aws-cognito-identitypool-alpha`를 사용한 반면, 직접 `aws-cdk-lib`에서 제공됩니다.

##### API 구문 마이그레이션

PDK 쇼핑 목록 애플리케이션은 Smithy 모델에서 생성된 타입 안전 CDK 구문을 인스턴스화하는 `constructs/apis/myapi.ts`에 구문을 가지고 있었습니다.

이 구문 외에도 PDK 프로젝트는 `@handler` 트레이트를 사용해 생성된 람다 함수 CDK 구문들도 생성했습니다.

Type Safe API와 마찬가지로 Nx Plugin for AWS는 Smithy 모델 기반의 타입 안전 통합을 제공하지만 훨씬 간단하고 유연한 방식으로 구현됩니다. 빌드 시 전체 CDK 구문을 생성하는 대신 최소한의 "메타데이터"만 생성되며, `packages/common/constructs/src/app/apis/api.ts`에서 일반적인 방식으로 사용합니다. <Link path="/guides/ts-smithy-api">`ts#smithy-api` 생성기 가이드</Link>에서 구문 사용법을 더 알아볼 수 있습니다.

다음 단계를 따르세요:

<Steps>

1. `application-stack.ts`에서 `Api` 구문 인스턴스화

    ```diff lang="ts"
    // stacks/application-stack.ts
    -import { MyApi } from "../constructs/apis/myapi";
    +import { Api } from ':shopping-list/common-constructs';
    ...
    -const myapi = new MyApi(this, "MyApi", {
    -  databaseConstruct,
    -  userIdentity,
    -});
    +const api = new Api(this, 'MyApi', {
    +  integrations: Api.defaultIntegrations(this).build(),
    +});
    ```

    여기서 `Api.defaultIntegrations(this).build()`를 사용합니다 - 기본 동작은 API의 각 작업에 대해 람다 함수를 생성하는 것으로, `myapi.ts`의 동작과 동일합니다.

1. 람다 함수에 DynamoDB 테이블 접근 권한 부여

    PDK 쇼핑 목록 애플리케이션에서는 `DatabaseConsruct`가 `MyApi`에 전달되어 각 생성된 함수 구문에 관련 권한을 추가했습니다. `application-stack.ts` 파일에서 `Api` 구문의 타입 안전 `integrations` 속성에 직접 접근하여 이 작업을 수행합니다:

    ```ts
    // stacks/application-stack.ts
    // 람다 함수에 Dynamo 호출 권한 부여
    databaseConstruct.shoppingListTable.grantReadData(
      api.integrations.getShoppingLists.handler,
    );
    [
      api.integrations.putShoppingList.handler,
      api.integrations.deleteShoppingList.handler,
    ].forEach((f) => databaseConstruct.shoppingListTable.grantWriteData(f));
    ```

1. 인증된 사용자에게 API 호출 권한 부여

    PDK 애플리케이션의 `myapi.ts`에서는 인증된 사용자도 API 호출을 위한 IAM 권한을 부여받았습니다. `application-stack.ts`에서 동등한 작업을 수행합니다:

    ```ts
    // stacks/application-stack.ts
    api.grantInvokeAccess(userIdentity.identityPool.authenticatedRole);
    ```

</Steps>

##### 웹사이트 구문 마이그레이션

마지막으로 PDK 쇼핑 목록 애플리케이션의 `packages/infra/src/constructs/websites/website.ts`에 상응하는 `packages/common/constructs/src/app/static-websites/website.ts`의 `Website` 구문을 `application-stack.ts`에 추가합니다.

```diff lang="ts"
-import { Website } from "../constructs/websites/website";
+import { Website } from ':shopping-list/common-constructs';
...
-new Website(this, "Website", {
-  userIdentity,
-  myapi,
-});
+new Website(this, 'Website');
```

여기서 identity나 API를 웹사이트에 전달하지 않습니다 - Nx Plugin for AWS가 제공하는 각 구문에서 런타임 구성을 관리하며, `UserIdentity`와 `Api`는 필요한 값을 등록하고 `Website`는 정적 웹사이트의 `/runtime-config.json`에 배포합니다.

이제 코드베이스의 모든 관련 부분을 새 프로젝트로 마이그레이션했으므로 프로젝트를 빌드합니다.

<NxCommands commands={["run-many --target build"]} />

:::caution
린트 문제로 빌드 실패가 발생할 수 있습니다. 일반적으로 자동 수정이 가능합니다:

<NxCommands commands={["run-many --target lint --fix"]} />
:::