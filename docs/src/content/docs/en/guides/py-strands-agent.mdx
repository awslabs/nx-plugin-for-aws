---
title: Python Strands Agent
description: Generate a Python Strands Agent for building AI agents with tools and deploy to Amazon Bedrock AgentCore Runtime
---

import { FileTree } from '@astrojs/starlight/components';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import Link from '@components/link.astro';
import Snippet from '@components/snippet.astro';
import Infrastructure from '@components/infrastructure.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import Drawer from '@components/drawer.astro';

Generate a Python [Strands Agent](https://strandsagents.com/) for building AI agents with tools, and optionally deploy it to [Amazon Bedrock AgentCore Runtime](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/).

## What is Strands?

[Strands](https://strandsagents.com/latest/documentation/docs/) is a lightweight, production-ready Python framework for building AI agents. Key features include:

- **Lightweight and customizable**: Simple agent loop that gets out of your way
- **Production ready**: Full observability, tracing, and deployment options for scale
- **Model and provider agnostic**: Supports many different models from various providers
- **Community-driven tools**: Powerful set of community-contributed tools
- **Multi-agent support**: Advanced techniques like agent teams and autonomous agents
- **Flexible interaction modes**: Conversational, streaming, and non-streaming support

## Usage

### Generate a Strands Agent

You can generate a Python Strands Agent in two ways:

<RunGenerator generator="py#strands-agent" />

:::tip
First use the <Link path="/guides/python-project">`py#project`</Link> generator to create a project to add your Strands Agent to.
:::

### Options

<GeneratorParameters generator="py#strands-agent" />

## Generator Output

The generator will add the following files to your existing Python project:

<FileTree>
  - your-project/
    - your_module/
      - agent/ (or custom name if specified)
        - \_\_init\_\_.py Python package initialization
        - agent.py Main agent definition with sample tools
        - main.py Entry point for Bedrock AgentCore Runtime
        - agentcore_mcp_client.py Client factory useful for invoking MCP servers also hosted on Bedrock AgentCore runtime
        - Dockerfile Entry point for hosting your agent (excluded when `computeType` is set to `None`)
    - pyproject.toml Updated with Strands dependencies
    - project.json Updated with agent serve targets
</FileTree>

### Infrastructure

:::note
If you selected `None` for `computeType`, the generator will not vend any infrastructure as code.
:::

<Snippet name="shared-constructs" />

For deploying your Strands Agent, the following files are generated:

<Infrastructure>
<Fragment slot="cdk">
<FileTree>
  - packages/common/constructs/src
    - app
      - agents
        - \<project-name>
          - \<project-name>.ts CDK construct for deploying your agent
          - Dockerfile Passthrough docker file used by the CDK construct
</FileTree>
</Fragment>
<Fragment slot="terraform">
<FileTree>
  - packages/common/terraform/src
    - app
      - agents
        - \<project-name>
          - \<project-name>.tf Module for deploying your agent
    - core
      - agent-core
        - runtime.tf Generic module for deploying to Bedrock AgentCore Runtime
</FileTree>
</Fragment>
</Infrastructure>

## Working with Your Strands Agent

### Adding Tools

Tools are functions that the AI agent can call to perform actions. The Strands framework uses a simple decorator-based approach for defining tools.

You can add new tools in the [`agent.py`](packages/nx-plugin/src/py/strands-agent/files/agent.py.template:6) file:

```python
from strands import Agent, tool

@tool
def calculate_sum(numbers: list[int]) -> int:
    """Calculate the sum of a list of numbers"""
    return sum(numbers)

@tool
def get_weather(city: str) -> str:
    """Get weather information for a city"""
    # Your weather API integration here
    return f"Weather in {city}: Sunny, 25Â°C"

# Add tools to your agent
agent = Agent(
    system_prompt="You are a helpful assistant with access to various tools.",
    tools=[calculate_sum, get_weather],
)
```

The Strands framework automatically handles:
- Type validation based on your function's type hints
- JSON schema generation for tool calling
- Error handling and response formatting

### Using Pre-built Tools

Strands provides a collection of pre-built tools through the `strands-tools` package:

```python
from strands_tools import current_time, http_request, file_read

agent = Agent(
    system_prompt="You are a helpful assistant.",
    tools=[current_time, http_request, file_read],
)
```

### Model Configuration

By default, Strands agents use Claude 4 Sonnet, but you can customize the model provider. See the [Strands documentation on model providers](https://strandsagents.com/latest/documentation/docs/user-guide/quickstart/#model-providers) for configuration options:

```python
from strands import Agent
from strands.models import BedrockModel

# Create a BedrockModel
bedrock_model = BedrockModel(
    model_id="anthropic.claude-sonnet-4-20250514-v1:0",
    region_name="us-west-2",
    temperature=0.3,
)

agent = Agent(model=bedrock_model)
```

### Consuming MCP Servers

You can [add tools from MCP servers](https://strandsagents.com/latest/documentation/docs/user-guide/concepts/tools/mcp-tools/) to your Strands agent.

For consuming MCP Servers which you have created using the <Link path="/guides/py-mcp-server">`py#mcp-server`</Link> or <Link path="/guides/ts-mcp-server">`ts#mcp-server`</Link> generators (or others hosted on Bedrock AgentCore Runtime), a client factory is generated for you in `agentcore_mcp_client.py`.

You can update your `get_agent` method in `agent.py` to create MCP clients and add tools. The following example shows how to perform this with IAM (SigV4) authentication:

```python
# agent.py
import os
from contextlib import contextmanager

import boto3
from strands import Agent

from .agentcore_mcp_client import AgentCoreMCPClient

# Obtain the region an credentials
region = os.environ["AWS_REGION"]
boto_session = boto3.Session(region_name=region)
credentials = boto_session.get_credentials()

@contextmanager
def get_agent(session_id: str):
    mcp_client = AgentCoreMCPClient.with_iam_auth(
        agent_runtime_arn=os.environ["MCP_AGENTCORE_RUNTIME_ARN"],
        credentials=credentials,
        region=region,
        session_id=session_id,
    )

    with mcp_client:
        mcp_tools = mcp_client.list_tools_sync()

        yield Agent(
            system_prompt="..."
            tools=[*mcp_tools],
        )
```

:::tip
If your target MCP server uses JWT authentication, you can use the `AgentCoreMCPClient.with_jwt_auth` method to create the client instead.
:::

With the IAM authentication example above, we need to configure two things in our infrastructure. Firstly, we need to add the environment variable our agent is consuming for our MCP server's AgentCore Runtime ARN, and secondly we need to grant our agent permissions to invoke the MCP server. This can be achieved as follows:

<Infrastructure>
<Fragment slot="cdk">
```ts {9, 13}
import { MyProjectAgent, MyProjectMcpServer } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const mcpServer = new MyProjectMcpServer(this, 'MyProjectMcpServer');

    const agent = new MyProjectAgent(this, 'MyProjectAgent', {
      environmentVariables: {
        MCP_AGENTCORE_RUNTIME_ARN: mcpServer.agentCoreRuntime.agentRuntimeArn,
      },
    });

    mcpServer.agentCoreRuntime.grantInvoke(agent.agentCoreRuntime);
  }
}
```
</Fragment>
<Fragment slot="terraform">
```terraform
# MCP Server
module "my_project_mcp_server" {
  source = "../../common/terraform/src/app/mcp-servers/my-project-mcp-server"
}

# Agent
module "my_project_agent" {
  source = "../../common/terraform/src/app/agents/my-project-agent"

  env = {
    MCP_AGENTCORE_RUNTIME_ARN = module.my_project_mcp_server.agent_core_runtime_arn
  }

  additional_iam_policy_statements = [
    {
      Effect = "Allow"
      Action = [
        "bedrock-agentcore:InvokeAgentRuntime"
      ]
      Resource = [
        module.my_project_mcp_server.agent_core_runtime_arn,
        "${module.my_project_mcp_server.agent_core_runtime_arn}/*"
      ]
    }
  ]
}
```
</Fragment>
</Infrastructure>

### More

For a more in-depth guide to writing Strands agents, refer to the [Strands documentation](https://strandsagents.com/latest/documentation/docs/).

## FastAPI Server

The generator uses [FastAPI](https://fastapi.tiangolo.com/) to create the HTTP server for your Strands Agent. FastAPI provides a modern, fast web framework for building APIs with Python, with automatic API documentation and type validation.

The generated server includes:
- FastAPI application setup with CORS middleware
- Error handling middleware
- OpenAPI schema generation
- Health check endpoint (`/ping`)
- Agent invocation endpoint (`/invocations`)

### Customizing Invoke Inputs and Outputs with Pydantic

The agent's invocation endpoint uses [Pydantic](https://docs.pydantic.dev/) models to define and validate the request and response schemas. You can customize these models in `main.py` to match your agent's requirements.

#### Defining Input Models

The default `InvokeInput` model accepts a prompt and session ID.

```python
from pydantic import BaseModel

class InvokeInput(BaseModel):
    prompt: str
    session_id: str
```

You can extend this model to include any additional fields your agent needs.

:::caution
You will likely want to abstract some or all of the session ID from the caller if users are to invoke your agent directly. For example, you may use the authenticated user ID as part of the session ID.

It is also worth noting that depending on your use case you may need to implement authorization for sessions, for example ensuring that users may only access their own sessions and not those of other users.
:::

#### Defining Output Models

For streaming responses, the return type annotation on your endpoint corresponds to the type of each value yielded by your generator function. By default, the agent yields strings containing the agent's response text as it streams back from Strands:

```python
@app.post("/invocations", openapi_extra={"x-streaming": True})
async def invoke(input: InvokeInput) -> str:
    """Entry point for agent invocation"""
    return StreamingResponse(handle_invoke(input), media_type="text/event-stream")
```

You can define a Pydantic model to yield structured data instead. In order to do this, you will need to serialize the pydantic models yielded by `handle_invoke`:

```python
from pydantic import BaseModel

class StreamChunk(BaseModel):
    content: str
    timestamp: str
    token_count: int

def handle_invoke(...):
    ...
    yield StreamChunk(content="xx", timestamp="yy", token_count=5)

def serialize_stream(generator):
    async for output in generator:
        yield (output.model_dump_json() + "\n").encode("utf-8")

@app.post("/invocations", openapi_extra={"x-streaming": True})
async def invoke(input: InvokeInput) -> StreamChunk:
    return StreamingResponse(serialize_stream(handle_invoke(input)), media_type="application/json")
```

:::caution
Note here that the vended server (and the above `serialize_stream` method) does not currently conform to the Server-Sent Events (SSE) standard, such that if desired the Agent can be invoked by our generated TypeScript client from a frontend, which doesn't currently expect streaming events in SSE format. Please +1 [this GitHub issue](https://github.com/awslabs/nx-plugin-for-aws/issues/369) if this affects you to help us prioritise addressing this.
:::

## Bedrock AgentCore Python SDK

The generator includes a dependency on the [Bedrock AgentCore Python SDK](https://github.com/aws/bedrock-agentcore-sdk-python) for the `PingStatus` constants. If desired, it is straightforward to use `BedrockAgentCoreApp` instead of FastAPI, however note that type-safety is lost.

You can find more details about the SDK's capabilities in the [documentation here](https://aws.github.io/bedrock-agentcore-starter-toolkit/user-guide/runtime/quickstart.html).

:::note
Since the generator vends CDK or Terraform infrastructure which manages deploying your agent, you do not need to utilise the `bedrock-agentcore-starter-toolkit` which the docs mention for deploying your agent.
:::

## Running Your Strands Agent

### Local Development

The generator configures a target named `<your-agent-name>-serve`, which starts your Strands Agent locally for development and testing.

<NxCommands commands={['run your-project:agent-serve']} />

This command uses `uv run` to execute your Strands Agent using the [Bedrock AgentCore Python SDK](https://github.com/aws/bedrock-agentcore-sdk-python).

## Deploying Your Strands Agent to Bedrock AgentCore Runtime

<Snippet name="agent/bedrock-deployment" parentHeading="Deploying Your Strands Agent to Bedrock AgentCore Runtime" />

### Bundle and Docker Targets

In order to build your Strands Agent for Bedrock AgentCore Runtime, a `bundle` target is added to your project, which:

- Exports your Python dependencies to a `requirements.txt` file using `uv export`
- Installs dependencies for the target platform (`aarch64-manylinux2014`) using `uv pip install`

A `docker` target specific to your Strands Agent is also added, which:

- Builds a docker image from the `Dockerfile` which runs your agent, as per the [AgentCore runtime contract](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-service-contract.html)

:::tip
The docker image is built using a tag (for example `my-scope-my-project-agent:latest`), which is referenced by your CDK or Terraform infrastructure, allowing for your `Dockerfile` to be co-located with your Strands Agent project.
:::

### Authentication

#### IAM

By default, your Strands Agent will be secured using IAM authentication, simply deploy it without any arguments:

<Infrastructure>
<Fragment slot="cdk">
```ts {5}
import { MyProjectAgent } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    new MyProjectAgent(this, 'MyProjectAgent');
  }
}
```

You can grant access to invoke your agent on Bedrock AgentCore Runtime using the `grantInvoke` method, for example:

```ts {8}
import { MyProjectAgent } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const agent = new MyProjectAgent(this, 'MyProjectAgent');
    const lambdaFunction = new Function(this, ...);

    agent.agentCoreRuntime.grantInvoke(lambdaFunction);
  }
}
```
</Fragment>
<Fragment slot="terraform">
```terraform
# Agent
module "my_project_agent" {
  # Relative path to the generated module in the common/terraform project
  source = "../../common/terraform/src/app/agents/my-project-agent"
}
```

To grant access to invoke your agent, you will need to add a policy such as the following, referencing the `module.my_project_agent.agent_core_runtime_arn` output:

```terraform
{
  Effect = "Allow"
  Action = [
    "bedrock-agentcore:InvokeAgentRuntime"
  ]
  Resource = [
    module.my_project_agent.agent_core_runtime_arn,
    "${module.my_project_agent.agent_core_runtime_arn}/*"
  ]
}
```
</Fragment>
</Infrastructure>

#### Cognito JWT Authentication

The below demonstrates how to configure Cognito authentication for your agent.

<Infrastructure>
<Fragment slot="cdk">
To configure JWT authentication using Cognito, use the `RuntimeAuthorizerConfiguration.usingCognito()` factory method:

```ts {13-16}
import { MyProjectAgent } from ':my-scope/common-constructs';
import { RuntimeAuthorizerConfiguration } from '@aws-cdk/aws-bedrock-agentcore-alpha';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const userPool = new UserPool(this, 'UserPool');
    const client = userPool.addClient('Client', {
      authFlows: {
        userPassword: true,
      },
    });

    new MyProjectAgent(this, 'MyProjectAgent', {
      authorizerConfiguration: RuntimeAuthorizerConfiguration.usingCognito(
        userPool,
        [client],
      ),
    });
  }
}
```

Alternatively, for custom JWT authentication with your own OIDC provider, use `RuntimeAuthorizerConfiguration.usingJWT()`:

```ts {6-10}
import { MyProjectAgent } from ':my-scope/common-constructs';
import { RuntimeAuthorizerConfiguration } from '@aws-cdk/aws-bedrock-agentcore-alpha';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    new MyProjectAgent(this, 'MyProjectAgent', {
      authorizerConfiguration: RuntimeAuthorizerConfiguration.usingJWT(
        'https://example.com/.well-known/openid-configuration',
        ['client1', 'client2'], // Allowed Client IDs (optional)
        ['audience1'],          // Allowed Audiences (optional)
      ),
    });
  }
}
```
</Fragment>
<Fragment slot="terraform">
To configure JWT authentication, you can edit your agent module to configure the `authorizer_configuration` variable as follows:

```terraform {18-23}
# packages/common/terraform/src/app/agents/my-project-agent/my-project-agent.tf

data "aws_region" "current" {}

locals {
  aws_region = data.aws_region.current.id

  # Replace with your user pool and client ids or expose as variables
  user_pool_id = "xxx"
  user_pool_client_ids = ["yyy"]
}

module "agent_core_runtime" {
  source = "../../../core/agent-core"
  agent_runtime_name = "MyProjectAgent"
  docker_image_tag = "my-scope-my-project-agent:latest"
  server_protocol = "HTTP"
  authorizer_configuration = {
    custom_jwt_authorizer = {
      discovery_url = "https://cognito-idp.${local.aws_region}.amazonaws.com/${local.user_pool_id}/.well-known/openid-configuration"
      allowed_clients = local.user_pool_client_ids
    }
  }
  env = var.env
  additional_iam_policy_statements = var.additional_iam_policy_statements
  tags = var.tags
}
```
</Fragment>
</Infrastructure>

### Observability

Your agent is automatically configured with observability using the [AWS Distro for Open Telemetry](https://aws.amazon.com/otel/) (ADOT), by configuring auto-instrumentation in your `Dockerfile`.

You can find traces in the CloudWatch AWS Console, by selecting "GenAI Observability" in the menu. Note that for traces to be populated you will need to enable [Transaction Search](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Transaction-Search.html).

For more details, refer to the [AgentCore documentation on observability](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/observability-configure.html).

## Invoking your Strands Agent

### Invoke the Local Server

To invoke an Agent running locally via the `<your-agent-name>-serve` target, you can send a simple POST request to `/invocations` on the port your local agent is running on. For example, with `curl`:

```bash
curl -N -X POST http://localhost:8081/invocations \
  -d '{"prompt": "what is 3 + 5?", "session_id": "abcdefghijklmnopqrstuvwxyz0123456789"}' \
  -H "Content-Type: application/json"
```

:::note
The `-N` argument given to `curl` disables buffering the output stream, so you can see the streaming response in real-time.
:::

### Invoke the Deployed Agent

<Snippet name="agent/runtime-arn" parentHeading="Invoke the Deployed Agent" />

#### IAM Authentication

For IAM Authentication, the request must be signed using AWS Signature Version 4 (SigV4).

```bash
acurl <region> bedrock-agentcore -N -X POST \
'https://bedrock
-agentcore.<region>.amazonaws.com/runtimes/<url-encoded-arn>/invocations' \
-d '{"prompt": "what is 3 + 5?", "session_id": "abcdefghijklmnopqrstuvwxyz0123456789"}' \
-H 'Content-Type: application/json'
```

<Drawer title="Sigv4 enabled curl" trigger="Click here for more details on configuring the above acurl command">
<Snippet name="tools/acurl" />
</Drawer>

#### JWT / Cognito Authentication

For Cognito Authentication, pass the Cognito Access Token in the `Authorization` header:

```bash
curl -N -X POST 'https://bedrock
-agentcore.<region>.amazonaws.com/runtimes/<url-encoded-arn>/invocations' \
  -d '{"prompt": "what is 3 + 5?", "session_id": "abcdefghijklmnopqrstuvwxyz0123456789"}' \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <access-token>"
```

You can obtain the access token using the AWS CLI's `cognito-idp admin-initiate-auth` command, for example:

```bash
aws cognito-idp admin-initiate-auth \
  --user-pool-id <user-pool-id> \
  --client-id <user-pool-client-id> \
  --auth-flow ADMIN_NO_SRP_AUTH \
  --auth-parameters USERNAME=<username>,PASSWORD=<password> \
  --region <region> \
  --query 'AuthenticationResult.AccessToken' \
  --output text
```
