---
title: tRPC
description: Reference documentation for tRPC
---
import { FileTree, Tabs, TabItem } from '@astrojs/starlight/components';
import AnchorHeading from '@astrojs/starlight/components/AnchorHeading.astro';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Infrastructure from '@components/infrastructure.astro';
import Snippet from '@components/snippet.astro';

[tRPC](https://trpc.io/) is a framework for building APIs in TypeScript with end-to-end type safety. Using tRPC, updates to API operation inputs and outputs are immediately reflected in client code and are visible in your IDE without the need to rebuild your project.

The tRPC API generator creates a new tRPC API with AWS CDK or Terraform infrastructure setup. The generated backend uses AWS Lambda for serverless deployment, exposed via an AWS API Gateway API, and includes schema validation using [Zod](https://zod.dev/). It sets up [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/) for observability, including logging, AWS X-Ray tracing and Cloudwatch Metrics.

## Usage

### Generate a tRPC API

You can generate a new tRPC API in two ways:

<RunGenerator generator="ts#trpc-api" />

### Options

<GeneratorParameters generator="ts#trpc-api" />

<Snippet name="api/api-choice-note" />

## Generator Output

The generator will create the following project structure in the `<directory>/<api-name>` directory:

<FileTree>
  - src
    - init.ts Backend tRPC initialisation
    - router.ts tRPC router definition (Lambda handler API entrypoint)
    - schema Schema definitions using Zod
      - echo.ts Example definitions for the input and output of the "echo" procedure
    - procedures Procedures (or operations) exposed by your API
      - echo.ts Example procedure
    - middleware
      - error.ts Middleware for error handling
      - logger.ts middleware for configuring AWS Powertools for Lambda logging
      - tracer.ts middleware for configuring AWS Powertools for Lambda tracing
      - metrics.ts middleware for configuring AWS Powertools for Lambda metrics
    - local-server.ts tRPC standalone adapter entrypoint for local development server
    - client
      - index.ts Type-safe client for machine-to-machine API calls
  - tsconfig.json TypeScript configuration
  - project.json Project configuration and build targets

</FileTree>

### Infrastructure

<Snippet name="shared-constructs" />

<Snippet name="api/shared-constructs" />

## Implementing your tRPC API

At a high-level, tRPC APIs consist of a router which delegates requests to specific procedures. Each procedure has an input and output, defined as a Zod schema.

### Schema

The `src/schema` directory contains the types that are shared between your client and server code. In this package, these types are defined using [Zod](https://zod.dev/), a TypeScript-first schema declaration and validation library.

An example schema might look as follows:

```ts
import { z } from 'zod';

// Schema definition
export const UserSchema = z.object({
  name: z.string(),
  height: z.number(),
  dateOfBirth: z.string().datetime(),
});

// Corresponding TypeScript type
export type User = z.TypeOf<typeof UserSchema>;
```

Given the above schema, the `User` type is equivalent to the following TypeScript:

```ts
interface User {
  name: string;
  height: number;
  dateOfBirth: string;
}
```

Schemas are shared by both server and client code, providing a single place to update when making changes to the structures used in your API.

Schemas are automatically validated by your tRPC API at runtime, which saves hand-crafting custom validation logic in your backend.

Zod provides powerful utilities to combine or derive schemas such as `.merge`, `.pick`, `.omit` and more. You can find more information on the [Zod documentation website](https://zod.dev/?id=basic-usage).

### Router and Procedures

You can find the entry point to your api in `src/router.ts`. This file contains the lambda handler which routes requests to "procedures" based on the operation being invoked. Each procedure defines the expected input, output, and implementation.

The sample router generated for you has a single operation, called `echo`:

```ts
import { echo } from './procedures/echo.js';

export const appRouter = router({
  echo,
});
```

The example `echo` procedure is generated for you in `src/procedures/echo.ts`:

```ts
export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

To break down the above:

- `publicProcedure` defines a public method on the API, including the middleware set up in `src/middleware`. This middleware includes AWS Lambda Powertools integration for logging, tracing and metrics.
- `input` accepts a Zod schema which defines the expected input for the operation. Requests sent for this operation are automatically validated against this schema.
- `output` accepts a Zod schema which defines the expected output for the operation. You will see type errors in your implementation if you don't return an output which conforms to the schema.
- `query` accepts a function which defines the implementation for your API. This implementation receives `opts`, which contains the `input` passed to your operation, as well as other context set up by middleware, available in `opts.ctx`. The function passed to `query` must return an output which conforms to the `output` schema.

The use of `query` to define the implementation indicates that the operation is not mutative. Use this to define methods to retrieve data. To implement a mutative operation, use the `mutation` method instead.

If you add a new procedure, make sure you register it by adding it to the router in `src/router.ts`.

## Customising your tRPC API

### Errors

In your implementation, you can return error responses to clients by throwing a `TRPCError`. These accept a `code` which indicates the type of error, for example:

```ts
throw new TRPCError({
  code: 'NOT_FOUND',
  message: 'The requested resource could not be found',
});
```

### Organising Your Operations

As your API grows, you may wish to group related operations together.

You can group operations together using nested routers, for example:

```ts
import { getUser } from './procedures/users/get.js';
import { listUsers } from './procedures/users/list.js';

const appRouter = router({
   users: router({
      get: getUser,
      list: listUsers,
   }),
   ...
})
```

Clients then receive this grouping of operations, for example invoking the `listUsers` operation in this case might look as follows:

```ts
client.users.list.query();
```

### Logging

The AWS Lambda Powertools logger is configured in `src/middleware/logger.ts`, and can be accessed in an API implementation via `opts.ctx.logger`. You can use this to log to CloudWatch Logs, and/or control additional values to include in every structured log message. For example:

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.logger.info('Operation called with input', opts.input);

      return ...;
   });
```

For more information about the logger, please refer to the [AWS Lambda Powertools Logger documentation](https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/).

### Recording Metrics

AWS Lambda Powertools metrics are configured in `src/middleware/metrics.ts`, and can be accessed in an API implementation via `opts.ctx.metrics`. You can use this to record metrics in CloudWatch without the need to import and use the AWS SDK, for example:

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.metrics.addMetric('Invocations', 'Count', 1);

      return ...;
   });
```

For more information, please refer to the [AWS Lambda Powertools Metrics documentation](https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/).

### Fine-tuning X-Ray Tracing

The AWS Lambda Powertools tracer is configured in `src/middleware/tracer.ts`, and can be accessed in an API implementation via `opts.ctx.tracer`. You can use this to add traces with AWS X-Ray to provide detailed insights into the performance and flow of API requests. For example:

```ts {5-7}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      const subSegment = opts.ctx.tracer.getSegment()!.addNewSubsegment('MyAlgorithm');
      // ... my algorithm logic to capture
      subSegment.close();

      return ...;
   });
```

For more information, please refer to the [AWS Lambda Powertools Tracer documentation](https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/).

### Implementing Custom Middleware

You can add additional values to the context provided to procedures by implementing middleware.

As an example, let's implement some middlware to extract some details about the calling user from our API in `src/middleware/identity.ts`.

:::warning
This example assumes `auth` was set to `IAM`. For Cognito authentication, identity middleware is more straightforward, extracting the relevant claims from the `event`.
:::

First, we define what we'll add to the context:

```ts
export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}
```

Note that we define an additional _optional_ property to the context. tRPC manages ensuring that this is defined in procedures which have correctly configured this middleware.

Next, we'll implement the middlware itself. This has the following structure:

```ts
export const createIdentityPlugin = () => {
   const t = initTRPC.context<...>().create();
   return t.procedure.use(async (opts) => {
      // Add logic here to run before the procedure

      const response = await opts.next(...);

      // Add logic here to run after the procedure

      return response;
   });
};
```

In our case, we want to extract details about the calling Cognito user. We'll do that by extracting the user's subject ID (or "sub") from the API Gateway event, and retrieving user details from Cognito. The implementation varies slightly depending on whether the event was provided to our function by a REST API or an HTTP API:

<Tabs>
<TabItem label="REST">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEvent } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEvent>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoAuthenticationProvider = opts.ctx.event.requestContext?.identity?.cognitoAuthenticationProvider;

    let sub: string | undefined = undefined;
    if (cognitoAuthenticationProvider) {
      const providerParts = cognitoAuthenticationProvider.split(':');
      sub = providerParts[providerParts.length - 1];
    }

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `Unable to determine calling user`,
      });
    }

    const { Users } = await cognito.listUsers({
      // Assumes user pool id is configured in lambda environment
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `No user found with subjectId ${sub}`,
      });
    }

    // Provide the identity to other procedures in the context
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
<TabItem label="HTTP">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoIdentity = opts.ctx.event.requestContext?.authorizer?.iam
      ?.cognitoIdentity as unknown as
      | {
          amr: string[];
        }
      | undefined;

    const sub = (cognitoIdentity?.amr ?? [])
      .flatMap((s) => (s.includes(':CognitoSignIn:') ? [s] : []))
      .map((s) => {
        const parts = s.split(':');
        return parts[parts.length - 1];
      })?.[0];

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `Unable to determine calling user`,
      });
    }

    const { Users } = await cognito.listUsers({
      // Assumes user pool id is configured in lambda environment
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `No user found with subjectId ${sub}`,
      });
    }

    // Provide the identity to other procedures in the context
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
</Tabs>

## Deploying your tRPC API

The tRPC API generator creates CDK or Terraform infrastructure as code based on your selected `iacProvider`. You can use this to deploy your tRPC API.

<Infrastructure>
<Fragment slot="cdk">
The CDK construct for deploying your API in the `common/constructs` folder. You can consume this in a CDK application, for example:

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs`;

export class ExampleStack extends Stack {
   constructor(scope: Construct, id: string) {
      // Add the api to your stack
      const api = new MyApi(this, 'MyApi', {
        integrations: MyApi.defaultIntegrations(this).build(),
      });
   }
}
```

This sets up your API infrastructure, including an AWS API Gateway REST or HTTP API, AWS Lambda functions for business logic, and authentication based on your chosen `auth` method.

:::note
If you selected to use `Cognito` authentication, you will need to supply the `identity` property to the API construct:

```ts {9}
import { MyApi, UserIdentity } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const identity = new UserIdentity(this, 'Identity');

    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
      identity,
    });
  }
}
```

The `UserIdentity` construct can be generated using the <Link path="/guides/react-website-auth">`ts#react-website-auth` generator</Link>
:::
</Fragment>
<Fragment slot="terraform">
The Terraform modules for deploying your API are in the `common/terraform` folder. You can use this in a Terraform configuration:

```hcl {6-8}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Environment variables for the Lambda function
  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  # Additional IAM policies if needed
  additional_iam_policy_statements = [
    # Add any additional permissions your API needs
  ]

  tags = local.common_tags
}
```

This sets up:

1. An AWS Lambda function that serves all tRPC procedures
2. API Gateway HTTP/REST API as the function trigger
3. IAM roles and permissions
4. CloudWatch log group
5. X-Ray tracing configuration
6. CORS configuration

:::note
If you selected to use `Cognito` authentication, you will need to supply the Cognito configuration:

```hcl {4-5}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  user_pool_id         = local.user_pool_id
  user_pool_client_ids = [local.client_id]

  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  tags = local.common_tags
}
```

You can set up Cognito User Pool and Client using the appropriate Terraform resources or modules.
:::

The Terraform module provides several outputs you can use:

```hcl
# Access the API endpoint
output "api_url" {
  value = module.my_api.stage_invoke_url
}

# Access Lambda function details
output "lambda_function_name" {
  value = module.my_api.lambda_function_name
}

# Access IAM role for granting additional permissions
output "lambda_execution_role_arn" {
  value = module.my_api.lambda_execution_role_arn
}
```

You can customize CORS settings by passing variables to the module:

```hcl
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Custom CORS configuration
  cors_allow_origins = ["https://myapp.com", "https://staging.myapp.com"]
  cors_allow_methods = ["GET", "POST", "PUT", "DELETE"]
  cors_allow_headers = [
    "authorization",
    "content-type",
    "x-custom-header"
  ]

  tags = local.common_tags
}
```

:::caution
If you selected `None` for `auth` when running the generator, you may see Checkov check failures such as:

<Tabs syncKey="http-rest">
<TabItem label="HTTP API">
```
Check: CKV_AWS_309: "Ensure API GatewayV2 routes specify an authorization type"
 FAILED for resource: aws_apigatewayv2_route.proxy_routes["PUT"]
```
</TabItem>
<TabItem label="REST API">
```
Check: CKV_AWS_59: "Ensure there is no open access to back-end resources through API"
 FAILED for resource: aws_api_gateway_method.proxy_method
```
</TabItem>
</Tabs>

You can [add a suppression comment](https://www.checkov.io/2.Basics/Suppressing%20and%20Skipping%20Policies.html) if you are sure you wish for your API to be public.
:::
</Fragment>
</Infrastructure>

### Integrations

<Snippet name="api/type-safe-api-integrations" parentHeading="Integrations" />

:::tip
If you selected CDK for your `iacProvider`, when you add or remove a procedure in your tRPC API, these changes will be reflected immediately in the CDK construct without the need to rebuild.
:::

### Granting Access (IAM Only)

If you selected to use `IAM` authentication, you can grant access to your API:

<Infrastructure>
<Fragment slot="cdk">
```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```
</Fragment>
<Fragment slot="terraform">
```hcl
# Create an IAM policy to allow invoking the API
resource "aws_iam_policy" "api_invoke_policy" {
  name        = "MyApiInvokePolicy"
  description = "Policy to allow invoking the tRPC API"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = "execute-api:Invoke"
        Resource = "${module.my_api.api_execution_arn}/*/*"
      }
    ]
  })
}

# Attach the policy to an IAM role (e.g., for authenticated users)
resource "aws_iam_role_policy_attachment" "api_invoke_access" {
  role       = aws_iam_role.authenticated_user_role.name
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}

# Or attach to an existing role by name
resource "aws_iam_role_policy_attachment" "api_invoke_access_existing" {
  role       = "MyExistingRole"
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}
```

The key outputs from the API module that you can use for IAM policies are:

- `module.my_api.api_execution_arn` - For granting execute-api:Invoke permissions
- `module.my_api.api_arn` - The API Gateway ARN
- `module.my_api.lambda_function_arn` - The Lambda function ARN
</Fragment>
</Infrastructure>

### Bundle Target

<Snippet name="ts-bundle" />

## Local tRPC Server

You can use the `serve` target to run a local server for your API, for example:

<NxCommands commands={['run @my-scope/my-api:serve']} />

The entry point for the local server is `src/local-server.ts`.

This will automatically reload when you make changes to your API.

## Invoking your tRPC API

You can create a tRPC client to invoke your API in a type-safe manner. If you are calling your tRPC API from another backend, you can use the client in `src/client/index.ts`, for example:

```ts
import { createMyApiClient } from ':my-scope/my-api';

const client = createMyApiClient({ url: 'https://my-api-url.example.com/' });

await client.echo.query({ message: 'Hello world!' });
```

If you are calling your API from a React website, consider using the <Link path="guides/api-connection/react-trpc">API Connection</Link> generator to configure the client.

## More Information

For more information about tRPC, please refer to the [tRPC documentation](https://trpc.io/docs).
