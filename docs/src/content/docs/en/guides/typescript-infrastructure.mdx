---
title: CDK Infrastructure
description: Reference documentation for CDK Infrastructure
---
import { FileTree } from '@astrojs/starlight/components';
import RunGenerator from '@components/run-generator.astro';
import Link from '@components/link.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';

[AWS CDK](https://docs.aws.amazon.com/cdk/v2/guide/home.html) is a framework for defining cloud infrastructure in code and provisioning it through AWS CloudFormation.

The TypeScript infrastructure generator creates an AWS CDK infrastructure application written in TypeScript. The generated application includes security best practices through [Checkov](https://www.checkov.io/) security checks.

## Usage

### Generate an Infrastructure Project

You can generate a new infrastructure project in two ways:

<RunGenerator generator="ts#infra" />

### Options

<GeneratorParameters generator="ts#infra" />

## Generator Output

The generator will create the following project structure in the `<directory>/<name>` directory:

<FileTree>

  - src
    - main.ts Application entry point instantiating CDK stages to deploy
    - stages CDK Stage definitions
      - application-stage.ts Defines a collection of stacks to deploy in a stage
    - stacks CDK Stack definitions
      - application-stack.ts Main application stack
  - cdk.json CDK configuration
  - project.json Project configuration and build targets
  - checkov.yml Checkov configuration file

</FileTree>

The generator also creates two shared packages (if they don't already exist):

<FileTree>

  - packages/common
    - infra-config Stage configuration types and credential mappings
      - src
        - stages.types.ts Type definitions for stage credentials and config
        - stages.config.ts Your stage-to-credential mappings (edit this)
        - index.ts Re-exports for importing from other packages
    - infra-scripts Centralized deploy/destroy scripts
      - src
        - solution-deploy.ts Deploy bin script
        - solution-destroy.ts Destroy bin script
        - lib/ Shared logic (credential lookup, CDK command building)

</FileTree>

:::tip
Your infrastructure is a TypeScript project, so you can refer to the <Link path="guides/typescript-project">TypeScript project documentation</Link> for more details about their general usage.
:::

## Implementing your CDK Infrastructure

You can start writing your CDK infrastructure inside `src/stacks/application-stack.ts`, for example:

```ts title="src/stacks/application-stack.ts" {9-10}
import { Stack, StackProps } from 'aws-cdk-lib';
import { Bucket } from 'aws-cdk-lib/aws-s3'
import { Construct } from 'constructs';

export class ApplicationStack extends Stack {
  constructor(scope: Construct, id: string, props?: StackProps) {
    super(scope, id, props);

    // Declare your infrastructure here
    new Bucket(this, 'MyBucket');
  }
}
```

### Stages and Stacks

You will notice that the top level `src/main.ts` file instantiates a CDK [Stage](https://docs.aws.amazon.com/cdk/v2/guide/stages.html) named `<namespace>-sandbox`. This stage is intended for your own development and testing. It reads account and region from the stage configuration if available, falling back to environment variables.

```ts title="src/main.ts"
import stagesConfig from ':my-scope/common-infra-config';

const projectStages = stagesConfig.projects?.['packages/infra']?.stages ?? {};
const sandboxConfig = projectStages['my-app-sandbox'];

new ApplicationStage(app, 'my-app-sandbox', {
  env: {
    account: sandboxConfig?.account ?? process.env.CDK_DEFAULT_ACCOUNT,
    region: sandboxConfig?.region ?? process.env.CDK_DEFAULT_REGION,
  },
});
```

You can add more stages, for example you may wish to define `beta` and `prod` stages which deploy to separate environments:

```ts title="src/main.ts"
new ApplicationStage(app, 'project-beta', {
  env: {
    account: '123456789012', // beta account
    region: 'us-west-2',
  },
});
new ApplicationStage(app, 'project-prod', {
  env: {
    account: '098765432109', // prod account
    region: 'us-west-2',
  },
});
```

A Stage defines a collection of stacks that should be deployed together to make up your application. You can instantiate as many stacks as you like within a stage, for example:

```ts title="src/stages/application-stage.ts"
import { Stage, StageProps } from 'aws-cdk-lib';
import { Construct } from 'constructs';
import { BackendStack } from '../stacks/backend-stack.js';
import { FrontendStack } from '../stacks/frontend-stack.js';

/**
 * Defines a collection of CDK Stacks which make up your application
 */
export class ApplicationStage extends Stage {
  constructor(scope: Construct, id: string, props?: StageProps) {
    super(scope, id, props);

    new BackendStack(this, 'Backend', {
      crossRegionReferences: true,
    })

    new FrontendStack(this, 'Frontend', {
      crossRegionReferences: true,
    });
  }
}
```

### Stage Credential Configuration

When working with multiple CDK stages (dev, staging, prod), each targeting different AWS accounts and regions, managing credentials becomes a challenge. Without centralized configuration, developers need to manually export `AWS_PROFILE` or assume roles before every deploy, and remember which credentials go with which stage. This is error-prone — deploying to the wrong account with the wrong credentials can have serious consequences.

The generator creates a shared `infra-config` package that serves as a single source of truth for all stage settings across your workspace. This means:

- **One place to configure all stages** — credentials, regions, and accounts for every infra project live in a single file, not scattered across environment variables or shell scripts
- **No accidental cross-account deploys** — the deploy command automatically resolves the right credentials for the target stage
- **Importable from any package** — your CDK `main.ts` reads account and region from the same config, keeping environment definitions consistent between deployment and synthesis
- **Team-shareable** — commit the config for shared team settings, or gitignore it for personal profiles

The generator also creates a shared `infra-scripts` package with `solution-deploy` and `solution-destroy` commands. These wrap CDK with automatic credential resolution, so developers just run `deploy` and the right credentials are applied. This keeps the infra project clean — no deployment scripts or credential logic in your CDK code.

#### Configuring Credentials

Edit `packages/common/infra-config/src/stages.config.ts` to map stage names to AWS credentials:

```ts title="packages/common/infra-config/src/stages.config.ts"
import type { StagesConfig } from './stages.types.js';

const config: StagesConfig = {
  projects: {
    'packages/infra': {
      stages: {
        'my-app-dev': {
          credentials: { type: 'profile', profile: 'dev-account' },
          region: 'us-east-1',
        },
        'my-app-prod': {
          credentials: {
            type: 'assumeRole',
            assumeRole: 'arn:aws:iam::123456789012:role/DeployRole',
          },
          region: 'us-west-2',
          account: '123456789012',
        },
      },
    },
  },
  shared: {
    stages: {
      sandbox: {
        credentials: { type: 'profile', profile: 'personal-sandbox' },
        region: 'us-east-1',
      },
    },
  },
};

export default config;
```

Project keys are the project path relative to the workspace root (e.g., `packages/infra`). This is used instead of the project name because a workspace can have multiple infra projects at different paths, and the path is unambiguous — it's the same value you see in `project.json`'s location and in the deploy command.

Stage names (e.g., `my-app-dev`, `my-app-prod`) must match the CDK stage identifiers you define in `main.ts` — the first argument to `new ApplicationStage(app, 'my-app-dev', ...)`. This is the same string you use in deploy commands like `pnpm nx run infra:deploy my-app-dev/*`.

Shared stages are available to all projects — project-specific entries take priority. Shared stages don't need a project path because they apply to any infra project in the workspace. When you run `pnpm nx run infra:deploy sandbox/*`, the deploy script first checks for a project-specific entry under `packages/infra`, and if none is found, falls back to the shared `sandbox` entry. This is useful when multiple infra projects deploy to the same sandbox account — you define the credentials once instead of repeating them for each project.

#### Credential Types

- **`profile`** — Uses an AWS CLI profile from `~/.aws/config`
- **`assumeRole`** — Assumes an IAM role via STS. Optionally specify a `profile` as the source identity, `externalId`, and `sessionDuration`

#### Account and Region

Each stage config includes a required `region` and an optional `account`. If `account` is omitted, CDK infers it from the active credentials. The generated `main.ts` reads these values from the config:

```ts title="src/main.ts"
import stagesConfig from ':my-scope/common-infra-config';

const projectStages = stagesConfig.projects?.['packages/infra']?.stages ?? {};
const sandboxConfig = projectStages['my-app-sandbox'];

new ApplicationStage(app, 'my-app-sandbox', {
  env: {
    account: sandboxConfig?.account ?? process.env.CDK_DEFAULT_ACCOUNT,
    region: sandboxConfig?.region ?? process.env.CDK_DEFAULT_REGION,
  },
});
```

#### How Deployment Works

When you run `deploy`, the `solution-deploy` script handles credential resolution automatically:

1. Reads the stage name from the command arguments
2. Looks up credentials in `stages.config.ts` (project-specific → shared → environment fallback)
3. Sets the appropriate AWS environment variables for the CDK child process only (your shell environment is never modified)
4. Runs `cdk deploy` with the resolved credentials

If no matching stage config is found, the script falls back to whatever AWS credentials are already in your environment — so existing workflows continue to work without any configuration.

:::tip
You can commit `stages.config.ts` for shared team configuration, or add it to `.gitignore` if it contains personal profile names.
:::

### API Infrastructure

If you have used the <Link path="guides/trpc">tRPC API</Link> or <Link path="guides/fastapi">FastAPI</Link> generators to create APIs, you will notice you already have some constructs available in `packages/common/constructs` to deploy them.

If, for example, you created a tRPC API called `my-api`, you can simply import and instantiate the construct to add all necessary infrastructure to deploy it:

```ts title="src/stacks/application-stack.ts" {3, 9-12}
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import { MyApi } from ':my-scope/common-constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Add infrastructure for your API
    new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
    });
  }
}
```

### Website Infrastructure

If you have used the <Link path="guides/react-website">CloudScape website</Link> generator, you will notice you already have a construct in `packages/common/constructs` to deploy it. For example:

```ts title="src/stacks/application-stack.ts" {3, 9-10}
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import { MyWebsite } from ':my-scope/common-constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Add infrastructure for your website
    new MyWebsite(this, 'MyWebsite');
  }
}
```

:::warning
It is important to ensure that the website is declared _after_ any API constructs in order for the website <Link path="guides/react-website#runtime-configuration">Runtime Config</Link> to include all API config.
:::

## Synthesizing your Infrastructure

As part of your `build` target, as well as running the <Link path="guides/typescript-project#building">default compile, lint and test targets</Link>, your infrastructure project is _synthesized_ to CloudFormation. This can also be executed in a standalone fashion, by running the `synth` target:

<NxCommands commands={['run <my-infra>:synth']} />

You will find your synthesized cloud assembly in the root `dist` folder, under `dist/packages/<my-infra-project>/cdk.out`.

## Security Testing

A `checkov` target is added to your project which runs security checks are run on your infrastructure using [Checkov](https://www.checkov.io/).

<NxCommands commands={['run <my-infra>:checkov']} />

You will find your security test results in the root `dist` folder, under `dist/packages/<my-infra-project>/checkov`.

:::note
Checkov is run using `uvx`, so you will need to [install `uv` if you haven't already](https://docs.astral.sh/uv/getting-started/installation/).
:::

:::caution
Some Checkov rules are suppressed by default via the `checkov.yml` file. It is recommended that you review these based on your use case.
:::

### Suppressing Checkov Checks

There may be instances where you want to suppress certain rules on resources. You can do this in two ways:

#### Supress a rule on a given construct

```typescript
import { suppressRules } from ':my-scope/common-constructs';

// suppresses the CKV_AWS_XXX for the given construct.
suppressRules(construct, ['CKV_AWS_XXX'], 'Reason');
```

#### Supress a rule on a descendant construct

```typescript
import { suppressRules } from ':my-scope/common-constructs';

// Supresses the CKV_AWS_XXX for the construct or any of its descendants if it is an instance of Bucket
suppressRules(construct, ['CKV_AWS_XXX'], 'Reason', (construct) => construct instanceof Bucket);
```

## Bootstrapping your AWS Account(s)

If you are deploying a CDK application to an AWS Account for the first time, it will need to be bootstrapped first.

First, ensure that you have [configured credentials for your AWS account](https://docs.aws.amazon.com/sdkref/latest/guide/access.html).

Next, you can use the `cdk bootstrap` command:

```bash
npx cdk bootstrap aws://<account-id>/<region>
```

For more details, please refer to the [CDK documentation](https://docs.aws.amazon.com/cdk/v2/guide/bootstrapping-env.html).

## Deploying to AWS

After a build, you can deploy your infrastructure to AWS using the `deploy` target.

:::caution
Use the `deploy-ci` target if deploying in a CI/CD pipeline. See below for more details.
:::

If you have configured stage credentials in `packages/common/infra-config/src/stages.config.ts`, the deploy command will automatically resolve and apply the correct AWS credentials for the target stage. Otherwise, it uses whatever AWS credentials are in your environment.

Next, run the deploy target:

<NxCommands commands={['run <my-infra>:deploy <my-infra>-sandbox/*']} />

:::tip
The above command deploys _all_ stacks for the `<my-infra>-sandbox` stage. You can specify other stages so long as they are defined in `main.ts`.

You can also deploy individual stacks by specifying the full stack name, for example:

<NxCommands commands={['run <my-infra>:deploy <my-infra>-sandbox/Application']} />
:::

## Deploying to AWS in a CI/CD Pipeline

Use the `deploy-ci` target if you are deploying to AWS as part of a CI/CD pipeline.

<NxCommands commands={['run <my-infra>:deploy-ci my-stage/*']} />

This target differs slightly from the regular `deploy` target in that it ensures pre-synthesized cloud-assembly is deployed, rather than synthesizing on the fly. This helps to avoid potential issues with non-determinism due to changes package versions, ensuring that every pipeline stage deploys using the same cloud-assembly.

## Tearing Down AWS Infrastructure

Use the `destroy` target to tear down your resources:

<NxCommands commands={['run <my-infra>:destroy <my-infra>-sandbox/*']} />

## More Information

For more information about CDK, please refer to the [CDK Developer Guide](https://docs.aws.amazon.com/cdk/v2/guide/core_concepts.html) and [API Reference](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-construct-library.html).
