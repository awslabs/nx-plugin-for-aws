---
title: Set up a monorepo
description: A walkthrough of how to build an agentic AI-powered dungeon adventure game using the @aws/nx-plugin.
---

import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Task 1: Create a monorepo

To create a new monorepo, from within your desired directory, run the following command:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" iacProvider="CDK" />

:::note
We use `--iacProvider=CDK` as we will use CDK for infrastructure as code in this tutorial. The Nx Plugin for AWS also supports `Terraform`.
:::

This will set up a NX monorepo within the `dungeon-adventure` directory. When you open the directory in VSCode, you will see this file structure:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ this is where your sub-projects will reside
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configures the Nx CLI and monorepo defaults
- package.json all node dependencies are defined here
- pnpm-lock.yaml or bun.lock, yarn.lock, package-lock.json depending on package manager
- pnpm-workspace.yaml if using pnpm
- README.md
- tsconfig.base.json all node based sub-projects extend this
- tsconfig.json
- aws-nx-plugin.config.mts configuraton for the Nx Plugin for AWS
</FileTree>

We can now start creating our different sub-projects using the `@aws/nx-plugin`.

<Aside type="tip">It is best practice to ensure all your unstaged files are committed in Git before running any generators. This allows you to see what has changed after running your generator via `git diff`.</Aside>

## Task 2: Create a Game API

First, let's create our Game API. To do this, create a tRPC API called `GameApi` using these steps:

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

You will see some new files appear in your file tree.

<Aside>
The root `package.json` is now configured with a `type` of `module`, which means ESM is the default module type for all node based sub-projects vended by the `@aws/nx-plugin`. For more details on working with TypeScript projects, refer to the <Link path="guides/typescript-project">ts#project component guide</Link>.
</Aside>

<Drawer title="ts#trpc-api updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated by the `ts#trpc-api` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ app specific cdk constructs
          - apis/
            - **game-api.ts** cdk construct to create your tRPC API
            - index.ts
            - ...
          - index.ts
        - core/ generic cdk constructs
          - api/
            - rest-api.ts base cdk construct for an API Gateway Rest API
            - trpc-utils.ts utilities for trpc API CDK constructs
            - utils.ts utilities for API constructs
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ shared types
      - src/
        - index.ts
        - runtime-config.ts interface definition used by both CDK and website
      - project.json
      - ...
  - game-api/ tRPC API
    - src/
      - client/ vanilla client typically used for ts machine to machine calls
        - index.ts
        - sigv4.ts
      - middleware/ powertools instrumentation
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ definitions of inputs and outputs for your API
        - **echo.ts**
      - procedures/ specific implementations for your API procedures/routes
        - **echo.ts**
      - index.ts
      - init.ts sets up context and middleware
      - local-server.ts used when running the tRPC server locally
      - **router.ts** entrypoint for your lambda handler which defines all procedures
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Let us look at these key files:

```ts {5,12}
// packages/game-api/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
The router defines the entrypoint for your tRPC API and is the place where you will declare all of your API methods. As you can see above, we have a method called `echo` with it's implementation in the `./procedures/echo.ts` file.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

This file is the implementation of the `echo` method and as you can see is strongly typed by declaring its input and output data structures.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

All tRPC schema definitions are defined using [Zod](https://zod.dev/) and are exported as typescript types via the `z.TypeOf` syntax.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// String union type for all API operation names
type Operations = Procedures<AppRouter>;

/**
 * Properties for creating a GameApi construct
 *
 * @template TIntegrations - Map of operation names to their integrations
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Map of operation names to their API Gateway integrations
   */
  integrations: TIntegrations;
}

/**
 * A CDK construct that creates and configures an AWS API Gateway REST API
 * specifically for GameApi.
 * @template TIntegrations - Map of operation names to their integrations
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Creates default integrations for all operations, which implement each operation as
   * its own individual lambda function.
   *
   * @param scope - The CDK construct scope
   * @returns An IntegrationBuilder with default lambda integrations
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Here we grant any AWS credentials from the account that the project is deployed in to call the api.
          // Machine to machine fine-grained access can be defined here using more specific principals (eg roles or
          // users) and resources (eg which api paths may be invoked by which principal) if required.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Open up OPTIONS to allow browsers to make unauthenticated preflight requests
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

This is the CDK construct that defines our `GameApi`. It provides a `defaultIntegrations` method which automatically creates a Lambda function for each procedure in our tRPC API, pointing to the bundled API implementation. This means that at `cdk synth` time, bundling does not occur (opposed to using [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) as we have already bundled it as part of the backend project's build target.

</Drawer>

## Task 3: Create Story agents

Now let's create our Story Agents. 

### Story agent: Python project

To create a Python project:

<RunGenerator generator="py#project" requiredParameters={{name:"story"}} noInteractive />

You will see some new files appear in your file tree.
<Drawer title="py#project updated files" trigger="Click here to examine these files in more detail.">
The `py#project` generates these files:

<FileTree>
- .venv/ single virtual env for monorepo
- packages/
  - story/
    - dungeon_adventure_story/ python module
      - hello.py example python file (we'll ignore this)
    - tests/
    - .python-version
    - pyproject.toml
    - project.json
- .python-version pinned uv python version
- pyproject.toml
- uv.lock
</FileTree>

This has configured a Python project and [UV Workspace](https://docs.astral.sh/uv/concepts/projects/workspaces/) with shared virtual environment.

</Drawer>

### Story agent: Strands Agent

To add a Strands agent to the project with the `py#strands-agent` generator:

<RunGenerator generator="py#strands-agent" requiredParameters={{project:"story"}} noInteractive />

You will see some new files appear in your file tree.
<Drawer title="py#strands-agent updated files" trigger="Click here to examine these files in more detail.">
The `py#strands-agent` generates these files:

<FileTree>
- packages/
  - story/
    - dungeon_adventure_story/ python module
      - agent/
        - main.py entrypoint for your agent in Bedrock AgentCore Runtime
        - agent.py defines an example agent and tools
        - agentcore_mcp_client.py utility for creating clients to interact with MCP servers
        - Dockerfile defines the docker image for deployment to AgentCore Runtime
  - common/constructs/
    - src
      - core/agent-core/
        - runtime.ts generic construct for deploying to AgentCore Runtime
      - app/agents/story-agent/
        - story-agent.ts construct for deploying your Story agent to AgentCore Runtime
</FileTree>

Let's take a look at some of the files in detail:

```python
# agent/agent.py
from contextlib import contextmanager

from strands import Agent, tool
from strands_tools import current_time


# Define a custom tool
@tool
def add(a: int, b: int) -> int:
    return a + b


@contextmanager
def get_agent(session_id: str):
    yield Agent(
        system_prompt="""
You are an addition wizard.
Use the 'add' tool for addition tasks.
Refer to tools as your 'spellbook'.
""",
        tools=[add, current_time],
    )
```

This creates an example Strands agent and defines an addition tool.

```python
# agent/main.py
from bedrock_agentcore.runtime import BedrockAgentCoreApp

from .agent import get_agent

app = BedrockAgentCoreApp()


@app.entrypoint
async def invoke(payload, context):
    """Handler for agent invocation"""
    prompt = payload.get(
        "prompt", "No prompt found in input, please guide the user "
        "to create a json payload with prompt key"
    )

    with get_agent(session_id=context.session_id) as agent:
        stream = agent.stream_async(prompt)
        async for event in stream:
            print(event)
            yield (event)


if __name__ == "__main__":
    app.run()
```

This is the entrypoint for the agent, configured using the [Amazon Bedrock AgentCore SDK](https://github.com/aws/bedrock-agentcore-sdk-python). It uses Strands support for streaming and streams events back to the client as they occur.

```ts
// common/constructs/src/app/agents/story-agent.ts
import { Lazy, Names } from 'aws-cdk-lib';
import { DockerImageAsset, Platform } from 'aws-cdk-lib/aws-ecr-assets';
import { Construct } from 'constructs';
import { execSync } from 'child_process';
import * as path from 'path';
import * as url from 'url';
import {
  AgentCoreRuntime,
  AgentCoreRuntimeProps,
} from '../../../core/agent-core/runtime.js';

export type StoryAgentProps = Omit<
  AgentCoreRuntimeProps,
  'runtimeName' | 'serverProtocol' | 'containerUri'
>;

export class StoryAgent extends Construct {
  public readonly dockerImage: DockerImageAsset;
  public readonly agentCoreRuntime: AgentCoreRuntime;

  constructor(scope: Construct, id: string, props?: StoryAgentProps) {
    super(scope, id);

    this.dockerImage = new DockerImageAsset(this, 'DockerImage', {
      platform: Platform.LINUX_ARM64,
      directory: path.dirname(url.fileURLToPath(new URL(import.meta.url))),
      extraHash: execSync(
        `docker inspect dungeon-adventure-story-agent:latest --format '{{.Id}}'`,
        { encoding: 'utf-8' },
      ).trim(),
    });

    this.agentCoreRuntime = new AgentCoreRuntime(this, 'StoryAgent', {
      runtimeName: Lazy.string({
        produce: () =>
          Names.uniqueResourceName(this.agentCoreRuntime, { maxLength: 40 }),
      }),
      serverProtocol: 'HTTP',
      containerUri: this.dockerImage.imageUri,
      ...props,
    });
  }
}
```

This configures a CDK `DockerImageAsset` which uploads your agent Docker image to ECR, and hosts it using AgentCore Runtime.

You may notice an extra `Dockerfile`, that references the Docker image from the `story` project, allowing us to co-locate the Dockerfile and agent source code.

</Drawer>

## Task 4: Set up inventory tools

### Inventory: TypeScript project

Let us create an MCP server to provide tools for our Story Agent to manage a player's inventory.

First, we create a TypeScript project:

<RunGenerator generator="ts#project" requiredParameters={{name:"inventory"}} noInteractive />

This will create an empty TypeScript project.

<Drawer title="ts#project updated files" trigger="Click here to examine these files in more detail.">
The `ts#project` generator generates these files. 

<FileTree>
- packages/
  - inventory/
    - src/
      - index.ts entry point with example function
    - project.json project configuration
    - eslint.config.mjs lint configuration
    - vite.config.ts test configuration
    - tsconfig.json base typescript configuration for the project
    - tsconfig.lib.json typescript configuration for the project targeted for compilation and bundling
    - tsconfig.spec.json typescript configuration for tests
- tsconfig.base.json updated to configure an alias for other projects to reference this
</FileTree>

</Drawer>

### Inventory: MCP server

Next, we'll add an MCP server to our TypeScript project:

<RunGenerator generator="ts#mcp-server" requiredParameters={{project:"inventory"}} noInteractive />

This will add an MCP server.
<Drawer title="ts#mcp-server updated files" trigger="Click here to examine these files in more detail.">
The `ts#mcp-server` generator generates these files.

<FileTree>
- packages/
  - inventory/
    - src/mcp-server/
      - server.ts creates the MCP server
      - tools/
        - add.ts example tool
      - resources/
        - sample-guidance.ts example resource
      - stdio.ts entry point for MCP with STDIO transport
      - http.ts entry point for MCP with Streamable HTTP transport
      - Dockerfile builds the image for AgentCore Runtime
    - rolldown.config.ts configuration for bundling the MCP server for deployment to AgentCore
  - common/constructs/
    - src
      - app/mcp-servers/inventory-mcp-server/
        - inventory-mcp-server.ts construct for deploying your inventory MCP server to AgentCore Runtime
</FileTree>

</Drawer>

## Task 5: Create the User Interface (UI)

In this task, we will create the UI which will allow you to interact with the game.

### Game UI: Website

To create the UI, create a website called `GameUI` using these steps:

<RunGenerator generator="ts#react-website" requiredParameters={{name:"GameUI"}} noInteractive />

You will see some new files appear in your file tree.

<Drawer title="ts#react-website updated files" trigger="Click here to examine these files in more detail.">
The `ts#react-website` generates these files. Let us examine some of the key files highlighted in the file tree:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ app specific cdk constructs
          - static-websites/
            - **game-ui.ts** cdk construct to create your Game UI
        - core/
          - static-website.ts generic static website construct
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts overall page layout: header, footer, sidebar, etc
          - navitems.ts sidebar nav items
      - hooks/
        - useAppLayout.tsx allows you to dynamically set things like notifications, page style, etc
      - routes/ @tanstack/react-router file based routes
        - index.tsx root '/' page redirects to '/welcome'
        - __root.tsx all pages use this component as a base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** React entrypoint
        - routeTree.gen.ts this is automatically updated by @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteName: 'GameUI',
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

This is the CDK construct that defines our GameUI. It has already configured the file path to the generated bundle for our Vite based UI. This means that at `build` time, bundling occurs within the game-ui project's build target and the output is used here.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Register the router instance for type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

This is the entry point where React is mounted. As shown, it initially just configures a `@tanstack/react-router` in a [`file-based-routing`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing) configuration. As long as your development server is running, you can create files within the `routes` folder and `@tanstack/react-router` will create the boilerplate file setup for you, along with updating the `routeTree.gen.ts` file. This file maintains all routes in a type-safe manner, which means when you use `<Link>`, the `to` option will only show valid routes. 
For more information, refer to the [`@tanstack/react-router` docs](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

A component will be rendered when navigating to the `/welcome` route. `@tanstack/react-router` will manage the `Route` for you whenever you create/move this file (as long as the dev server is running).

</Drawer>

### Game UI: Auth

Let us configure our Game UI to require authenticated access via Amazon Cognito using these steps:

<RunGenerator generator="ts#react-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

You will see some new files appear/change in your file tree.

<Drawer title="ts#react-website#auth updated files" trigger="Click here to examine these files in more detail.">
The `ts#react-website#auth` generator updates/generates these files. Let us examine some of the key files highlighted in the file tree:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts cdk construct for creating user/identity pools
    - types/
      - src/
        - runtime-config.ts updated to add the cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx adds the logged in user/logout to the header
        - CognitoAuth/
          - index.ts manages logging into Cognito
        - RuntimeConfig/
          - index.tsx fetches the `runtime-config.json` and provides it to children via context
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Updated to add Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Register the router instance for type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

The `RuntimeConfigProvider` and `CognitoAuth` components have been added to the `main.tsx` file via an AST transform. This allows the `CognitoAuth` component to authenticate with Amazon Cognito by fetching the `runtime-config.json` which contains the required cognito connection configuration in order to make the backend calls to the correct destination.

</Drawer>

### Game UI: Connect to Game API

Let us configure our Game UI to connect to our previously created Game API.

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

You will see some new files have appear/change in your file tree.

<Drawer title="UI -> tRPC api-connection updated files" trigger="Click here to examine these files in more detail.">
The `api-connection` generator generates/updates these files. Let us examine some of the key files highlighted in the file tree:

<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx sets up the GameAPI client
      - hooks/
        - **useGameApi.tsx** hooks to call the GameApi
      - **main.tsx** injects the trpc client providers
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { GameApiTRCPContext } from '../components/GameApiClientProvider';

export const useGameApi = GameApiTRCPContext.useTRPC;
```

This hook uses tRPC's latest [React Query integration](https://trpc.io/blog/introducing-tanstack-react-query-client) allowing users to interact with `@tanstack/react-query` directly without any additional layers of abstraction. For examples on how to call tRPC APIs, refer to the <Link path="guides/api-connection/react-trpc#using-the-generated-code">using the tRPC hook guide</Link>.

<Aside>
The `useGameApi` hook is different to the `useStoryApi` hook as it does not require a build in order for changes to be reflected courtesy of tRPC's usage of [Typescript inference](https://trpc.io/docs/concepts). This allows developers to make changes to their backend which instantly are reflected in their frontend.
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Register the router instance for type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <RouterProvider router={router} />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

The `main.tsx` file has been updated via an AST transform to inject the tRPC providers.

</Drawer>

### Game UI: Infrastructure

Let us create the final sub-project for the CDK infrastructure.

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

You will see some new files have appear/change in your file tree.

<Drawer title="ts#infra updated files" trigger="Click here to examine these files in more detail.">
The `ts#infra` generator generates/updates these. Let us examine some of the key files highlighted in the file tree:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - checkov.ts
          - index.ts
  - infra
    - src/
      - stages/
        - **application-stage.ts** cdk stacks defined here
      - stacks/
        - **application-stack.ts** cdk resources defined here
      - index.ts
      - **main.ts** entrypoint which defines all stages
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json add references
  - tsconfig.base.json add alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStage } from './stacks/application-stage.js';
import { App } from ':dungeon-adventure/common-constructs';

const app = new App();

// Use this to deploy your own sandbox environment (assumes your CLI credentials)
new ApplicationStage(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
});

app.synth();
```

<Aside type="tip">If you see an import error within your IDE, this is because our infrastructure project does not have a typescript reference set up yet in the `tsconfig.json`. Nx has been [configured](https://nx.dev/nx-api/js/generators/typescript-sync) to create these references *dynamically* whenever a build/compile is run or if you run the `nx sync` command manually. For more information refer to the <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">Typescript guide</Link>.</Aside>

This is the entry point for your CDK application.

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // The code that defines your stack goes here
  }
}
```

Let us instantiate our CDK constructs to build our dungeon adventure game.

</Drawer>

## Task 6: Update our infrastructure

Let's update `packages/infra/src/stacks/application-stack.ts` to instantiate some of our generated constructs:

<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

:::note 
We supply default integrations for our Game API. By default, each operation in our API is mapped to an individual Lambda function to handle that operation.
:::

## Task 7: Build the code

<Drawer title="Nx commands" trigger="Now it's time for us to build our code for the first time">

###### Single vs Multiple targets

The `run-many` command will run a target on multiple listed subprojects (`--all` will target them all). This ensures dependencies are executed in the correct order.

You can also trigger a build (or any other task) for a single project target by running the target on the project directly. For example, to build the `@dungeon-adventure/infra` project, run the following command:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />

You can also omit the scope, and use the Nx shorthand syntax if you prefer:

<NxCommands commands={['build infra']} />

###### Visualizing your dependencies

To visualize your dependencies, run:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Caching

Nx relies on [caching](https://nx.dev/concepts/how-caching-works) so that you can re-use artifacts from previous builds in order to speed up development. There is some configuration required to get this to work correctly and there may be cases where you want to perform a build **without using the cache**. To do that, simply append the `--skip-nx-cache` argument to your command. For example:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
If for whatever reason you ever wanted to clear your cache (stored in the `.nx` folder), you can run the following command:

<NxCommands commands={['reset']} />

</Drawer>

Using the command line, run: 

<NxCommands commands={['run-many --target build --all']} />

You will be prompted with the following:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? …
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

This message indicates that NX has detected some files which can be updated automatically for you. In this case, it is referring to the `tsconfig.json` files which do not have Typescript references set up on references projects. 

Select the **Yes, sync the changes and run the tasks** option to proceed. You should notice all of you IDE related import errors get automatically resolved as the sync generator will add the missing typescript references automatically!

<Aside type="tip">
If you encounter any lint errors, run the following command to automatically fix them.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>
All built artifacts are now available within the `dist/ folder` located at the root of the monorepo. This is a standard pactice when using projects generated by the `@aws/nx-plugin` as it does not pollute your file-tree with generated files. In the event you want to clean your files, delete the `dist/` folder without worrying about generated files being littered throughout the file tree.

Congratulations! You’ve created all of the required sub-projects required to start implementing the core of our AI Dungeon Adventure game.  🎉🎉🎉