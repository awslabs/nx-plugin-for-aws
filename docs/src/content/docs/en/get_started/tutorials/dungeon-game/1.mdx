---
title: Set up a monorepo
description: A walkthrough of how to build an agentic AI-powered dungeon adventure game using the @aws/nx-plugin.
---

import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import PackageManagerShortCommand from '@components/package-manager-short-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Task 1: Create a monorepo

To create a new monorepo, from within your desired directory, run the following command:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" iacProvider="CDK" />

:::note
We use `--iacProvider=CDK` as we will use CDK for infrastructure as code in this tutorial. The Nx Plugin for AWS also supports `Terraform`.
:::

This will set up a NX monorepo within the `dungeon-adventure` directory. When you open the directory in VSCode, you will see this file structure:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ this is where your sub-projects will reside
- .gitignore
- .prettierignore
- .prettierrc
- nx.json configures the Nx CLI and monorepo defaults
- package.json all node dependencies are defined here
- pnpm-lock.yaml or bun.lock, yarn.lock, package-lock.json depending on package manager
- pnpm-workspace.yaml if using pnpm
- README.md
- tsconfig.base.json all node based sub-projects extend this
- tsconfig.json
- aws-nx-plugin.config.mts configuraton for the Nx Plugin for AWS
</FileTree>

We can now start creating our different sub-projects using the `@aws/nx-plugin`.

<Aside type="tip">It is best practice to ensure all your unstaged files are committed in Git before running any generators. This allows you to see what has changed after running your generator via `git diff`.</Aside>

## Task 2: Create a Game API

First, let's create our Game API. To do this, create a tRPC API called `GameApi` using these steps:

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

You will see some new files appear in your file tree.

<Aside>
The root `package.json` is now configured with a `type` of `module`, which means ESM is the default module type for all node based sub-projects vended by the `@aws/nx-plugin`.
For more details on working with TypeScript projects, refer to the <Link path="guides/typescript-project">ts#project generator guide</Link>.
</Aside>

<Drawer title="ts#trpc-api updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated by the `ts#trpc-api` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ app specific cdk constructs
          - apis/
            - **game-api.ts** cdk construct to create your tRPC API
            - index.ts
            - ...
          - index.ts
        - core/ generic cdk constructs
          - api/
            - rest-api.ts base cdk construct for an API Gateway Rest API
            - trpc-utils.ts utilities for trpc API CDK constructs
            - utils.ts utilities for API constructs
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
  - game-api/ tRPC API
    - src/
      - client/ vanilla client typically used for ts machine to machine calls
        - index.ts
      - middleware/ powertools instrumentation
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ definitions of inputs and outputs for your API
        - index.ts
        - **echo.ts** sample input and output schema
        - z-async-iterable.ts wrapper Zod schema for tRPC subscription output
      - procedures/ specific implementations for your API procedures/routes
        - **echo.ts** sample procedure implementation
      - index.ts
      - init.ts sets up context and middleware
      - handler.ts Lambda handler entrypoint (uses response streaming for REST APIs)
      - local-server.ts used when running the tRPC server locally
      - **router.ts** defines the tRPC router and all procedures
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Let us look at these key files:

```ts {5}
// packages/game-api/src/router.ts
import { echo } from './procedures/echo.js';
import { t } from './init.js';

export const router = t.router;

export const appRouter = router({
  echo,
});

export type AppRouter = typeof appRouter;
```
The router defines the tRPC router for your API and is the place where you will declare all of your API methods. As you can see above, we have a method called `echo` with it's implementation in the `./procedures/echo.ts` file. The Lambda handler entrypoint is in `handler.ts`, which is configured automatically by the generator.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

This file is the implementation of the `echo` method and as you can see is strongly typed by declaring its input and output data structures.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

All tRPC schema definitions are defined using [Zod](https://zod.dev/) and are exported as typescript types via the `z.TypeOf` syntax.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import { Distribution } from 'aws-cdk-lib/aws-cloudfront';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
  ResponseTransferMode,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AnyPrincipal,
  IGrantable,
  Grant,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// String union type for all API operation names
type Operations = Procedures<AppRouter>;

/**
 * Properties for creating a GameApi construct
 *
 * @template TIntegrations - Map of operation names to their integrations
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Map of operation names to their API Gateway integrations
   */
  integrations: TIntegrations;
}

/**
 * A CDK construct that creates and configures an AWS API Gateway REST API
 * specifically for GameApi.
 * @template TIntegrations - Map of operation names to their integrations
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Creates default integrations for all operations, which implement each operation as
   * its own individual lambda function.
   *
   * @param scope - The CDK construct scope
   * @returns An IntegrationBuilder with default lambda integrations
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return {
          handler,
          integration: new LambdaIntegration(handler, {
            responseTransferMode: ResponseTransferMode.STREAM,
          }),
        };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      deployOptions: {
        tracingEnabled: true,
      },
      policy: new PolicyDocument({
        statements: [
          // Open up OPTIONS to allow browsers to make unauthenticated preflight requests
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }

  /**
   * Restricts CORS to the website CloudFront distribution domains
   *
   * Configures the CloudFront distribution domains as the only permitted CORS origins
   * (other than local host) in the AWS Lambda integrations
   *
   * Note that this restriction is not applied to preflight OPTIONS
   *
   * @param websites - The CloudFront distribution to grant CORS from
   */
  public restrictCorsTo(
    ...websites: { cloudFrontDistribution: Distribution }[]
  ) {
    const allowedOrigins = websites
      .map(
        ({ cloudFrontDistribution }) =>
          `https://${cloudFrontDistribution.distributionDomainName}`,
      )
      .join(',');

    // Set ALLOWED_ORIGINS environment variable for all Lambda integrations
    Object.values(this.integrations).forEach((integration) => {
      if ('handler' in integration && integration.handler instanceof Function) {
        integration.handler.addEnvironment('ALLOWED_ORIGINS', allowedOrigins);
      }
    });
  }

  /**
   * Grants IAM permissions to invoke any method on this API.
   *
   * @param grantee - The IAM principal to grant permissions to
   */
  public grantInvokeAccess(grantee: IGrantable) {
    // Here we grant grantee permission to call the api.
    // Machine to machine fine-grained access can be defined here using more specific principals (eg roles or
    // users) and resources (eg which api paths may be invoked by which principal) if required.
    this.api.addToResourcePolicy(
      new PolicyStatement({
        effect: Effect.ALLOW,
        principals: [grantee.grantPrincipal],
        actions: ['execute-api:Invoke'],
        resources: ['execute-api:/*'],
      }),
    );

    Grant.addToPrincipal({
      grantee,
      actions: ['execute-api:Invoke'],
      resourceArns: [this.api.arnForExecuteApi('*', '/*', '*')],
    });
  }
}
```

This is the CDK construct that defines our `GameApi`. It provides a `defaultIntegrations` method which automatically creates a Lambda function for each procedure in our tRPC API, pointing to the bundled API implementation. This means that at `cdk synth` time, bundling does not occur (opposed to using [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) as we have already bundled it as part of the backend project's build target.

</Drawer>

## Task 3: Create Story agents

Now let's create our Story Agents.

### Story agent: Python project

To create a Python project:

<RunGenerator generator="py#project" requiredParameters={{name:"story"}} noInteractive />

You will see some new files appear in your file tree.
<Drawer title="py#project updated files" trigger="Click here to examine these files in more detail.">
The `py#project` generates these files:

<FileTree>
- .venv/ single virtual env for monorepo
- packages/
  - story/
    - dungeon_adventure_story/ python module
      - hello.py example python file (we'll ignore this)
    - tests/
    - .python-version
    - pyproject.toml
    - project.json
- .python-version pinned uv python version
- pyproject.toml
- uv.lock
</FileTree>

This has configured a Python project and [UV Workspace](https://docs.astral.sh/uv/concepts/projects/workspaces/) with shared virtual environment.

</Drawer>

### Story agent: Strands Agent

To add a Strands agent to the project with the `py#strands-agent` generator:

<RunGenerator generator="py#strands-agent" requiredParameters={{project:"story"}} noInteractive />

You will see some new files appear in your file tree.
<Drawer title="py#strands-agent updated files" trigger="Click here to examine these files in more detail.">
The `py#strands-agent` generates these files:

<FileTree>
- packages/
  - story/
    - dungeon_adventure_story/ python module
      - agent/
        - init.py sets up the FastAPI app and middleware
        - main.py entrypoint for your agent in Bedrock AgentCore Runtime
        - agent.py defines an example agent and tools
        - agentcore_mcp_client.py utility for creating clients to interact with MCP servers
        - Dockerfile defines the docker image for deployment to AgentCore Runtime
  - common/constructs/
    - src
      - app/agents/story-agent/
        - story-agent.ts construct for deploying your Story agent to AgentCore Runtime
</FileTree>

Let's take a look at some of the files in detail:

```python
# agent/agent.py
from contextlib import contextmanager

from strands import Agent, tool
from strands_tools import current_time


# Define a custom tool
@tool
def add(a: int, b: int) -> int:
    return a + b


@contextmanager
def get_agent(session_id: str):
    yield Agent(
        system_prompt="""
You are an addition wizard.
Use the 'add' tool for addition tasks.
Refer to tools as your 'spellbook'.
""",
        tools=[add, current_time],
    )
```

This creates an example Strands agent and defines an addition tool.

```python
# agent/main.py
import uvicorn
from bedrock_agentcore.runtime.models import PingStatus
from pydantic import BaseModel

from .agent import get_agent
from .init import JsonStreamingResponse, app


class InvokeInput(BaseModel):
    prompt: str
    session_id: str


class StreamChunk(BaseModel):
    content: str


async def handle_invoke(input: InvokeInput):
    """Streaming handler for agent invocation"""
    with get_agent(session_id=input.session_id) as agent:
        stream = agent.stream_async(input.prompt)
        async for event in stream:
            print(event)
            text = event.get("event", {}).get("contentBlockDelta", {}).get("delta", {}).get("text")
            if text is not None:
                yield StreamChunk(content=text)
            elif event.get("event", {}).get("messageStop") is not None:
                yield StreamChunk(content="\n")


@app.post(
    "/invocations",
    response_class=JsonStreamingResponse,
    responses={200: JsonStreamingResponse.openapi_response(StreamChunk, "Stream of agent response chunks")},
)
async def invoke(input: InvokeInput) -> JsonStreamingResponse:
    """Entry point for agent invocation"""
    return JsonStreamingResponse(handle_invoke(input))


@app.get("/ping")
def ping() -> str:
    # TODO: if running an async task, return PingStatus.HEALTHY_BUSY
    return PingStatus.HEALTHY


if __name__ == "__main__":
    uvicorn.run("dungeon_adventure_story.agent.main:app", port=8080)
```

This is the entrypoint for the agent, configured as a FastAPI application compatible with [Amazon Bedrock AgentCore Runtime](https://github.com/aws/bedrock-agentcore-sdk-python). It uses Strands support for streaming and streams events back to the client as they occur via JSON Lines.

```ts
// common/constructs/src/app/agents/story-agent.ts
import { Lazy, Names } from 'aws-cdk-lib';
import { Platform } from 'aws-cdk-lib/aws-ecr-assets';
import { Construct } from 'constructs';
import { execSync } from 'child_process';
import * as path from 'path';
import * as url from 'url';
import {
  AgentRuntimeArtifact,
  ProtocolType,
  Runtime,
  RuntimeProps,
} from '@aws-cdk/aws-bedrock-agentcore-alpha';

export type StoryAgentProps = Omit<
  RuntimeProps,
  'runtimeName' | 'protocolConfiguration' | 'agentRuntimeArtifact'
>;

export class StoryAgent extends Construct {
  public readonly dockerImage: AgentRuntimeArtifact;
  public readonly agentCoreRuntime: Runtime;

  constructor(scope: Construct, id: string, props?: StoryAgentProps) {
    super(scope, id);

    this.dockerImage = AgentRuntimeArtifact.fromAsset(
      path.dirname(url.fileURLToPath(new URL(import.meta.url))),
      {
        platform: Platform.LINUX_ARM64,
        extraHash: execSync(
          `docker inspect dungeon-adventure-story-agent:latest --format '{{.Id}}'`,
          { encoding: 'utf-8' },
        ).trim(),
      },
    );

    this.agentCoreRuntime = new Runtime(this, 'StoryAgent', {
      runtimeName: Lazy.string({
        produce: () =>
          Names.uniqueResourceName(this.agentCoreRuntime, { maxLength: 40 }),
      }),
      protocolConfiguration: ProtocolType.HTTP,
      agentRuntimeArtifact: this.dockerImage,
      ...props,
    });
  }
}
```

This configures a CDK `AgentRuntimeArtifact` which uploads your agent Docker image to ECR, and hosts it using AgentCore Runtime.

You may notice an extra `Dockerfile`, that references the Docker image from the `story` project, allowing us to co-locate the Dockerfile and agent source code.

</Drawer>

## Task 4: Set up inventory tools

### Inventory: TypeScript project

Let us create an MCP server to provide tools for our Story Agent to manage a player's inventory.

First, we create a TypeScript project:

<RunGenerator generator="ts#project" requiredParameters={{name:"inventory"}} noInteractive />

This will create an empty TypeScript project.

<Drawer title="ts#project updated files" trigger="Click here to examine these files in more detail.">
The `ts#project` generator generates these files.

<FileTree>
- packages/
  - inventory/
    - src/
      - index.ts entry point with example function
    - project.json project configuration
    - eslint.config.mjs lint configuration
    - vitest.config.mts test configuration
    - tsconfig.json base typescript configuration for the project
    - tsconfig.lib.json typescript configuration for the project targeted for compilation and bundling
    - tsconfig.spec.json typescript configuration for tests
- tsconfig.base.json updated to configure an alias for other projects to reference this
</FileTree>

</Drawer>

### Inventory: MCP server

Next, we'll add an MCP server to our TypeScript project:

<RunGenerator generator="ts#mcp-server" requiredParameters={{project:"inventory"}} noInteractive />

This will add an MCP server.
<Drawer title="ts#mcp-server updated files" trigger="Click here to examine these files in more detail.">
The `ts#mcp-server` generator generates these files.

<FileTree>
- packages/
  - inventory/
    - src/mcp-server/
      - index.ts barrel export
      - server.ts creates the MCP server
      - tools/
        - add.ts example tool
      - resources/
        - sample-guidance.ts example resource
      - stdio.ts entry point for MCP with STDIO transport
      - http.ts entry point for MCP with Streamable HTTP transport
      - Dockerfile builds the image for AgentCore Runtime
    - rolldown.config.ts configuration for bundling the MCP server for deployment to AgentCore
  - common/constructs/
    - src
      - app/mcp-servers/inventory-mcp-server/
        - inventory-mcp-server.ts construct for deploying your inventory MCP server to AgentCore Runtime
</FileTree>

</Drawer>

## Task 5: Create the User Interface (UI)

In this task, we will create the UI which will allow you to interact with the game.

### Game UI: Website

To create the UI, create a website called `GameUI` using these steps:

<RunGenerator generator="ts#react-website" requiredParameters={{name:"GameUI"}} noInteractive />

You will see some new files appear in your file tree.

<Drawer title="ts#react-website updated files" trigger="Click here to examine these files in more detail.">
The `ts#react-website` generates these files. Let us examine some of the key files highlighted in the file tree:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ app specific cdk constructs
          - static-websites/
            - **game-ui.ts** cdk construct to create your Game UI
        - core/
          - static-website.ts generic static website construct
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.tsx overall page layout: header, footer, sidebar, etc
      - hooks/
        - useAppLayout.tsx allows you to dynamically set things like notifications, page style, etc
      - routes/ @tanstack/react-router file based routes
        - **index.tsx** root '/' page
        - __root.tsx all pages use this component as a base
      - config.ts
      - **main.tsx** React entrypoint
      - routeTree.gen.ts this is automatically updated by @tanstack/react-router
      - styles.css
    - index.html
    - project.json
    - vite.config.mts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteName: 'GameUI',
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

This is the CDK construct that defines our GameUI. It has already configured the file path to the generated bundle for our Vite based UI. This means that at `build` time, bundling occurs within the game-ui project's build target and the output is used here.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import '@cloudscape-design/global-styles/index.css';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export type RouterProviderContext = {};

const router = createRouter({
  routeTree,
  context: {},
});

// Register the router instance for type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const App = () => {
  return <RouterProvider router={router} context={{}} />;
};

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <App />
      </I18nProvider>
    </React.StrictMode>,
  );
```

This is the entry point where React is mounted. As shown, it initially just configures a `@tanstack/react-router` in a [`file-based-routing`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing) configuration. As long as your development server is running, you can create files within the `routes` folder and `@tanstack/react-router` will create the boilerplate file setup for you, along with updating the `routeTree.gen.ts` file. This file maintains all routes in a type-safe manner, which means when you use `<Link>`, the `to` option will only show valid routes.
For more information, refer to the [`@tanstack/react-router` docs](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new React website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

A component will be rendered when navigating to the `/` route. `@tanstack/react-router` will manage the `Route` for you whenever you create/move this file (as long as the dev server is running).

</Drawer>

### Game UI: Auth

Let us configure our Game UI to require authenticated access via Amazon Cognito using these steps:

<RunGenerator generator="ts#react-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

You will see some new files appear/change in your file tree.

<Drawer title="ts#react-website#auth updated files" trigger="Click here to examine these files in more detail.">
The `ts#react-website#auth` generator updates/generates these files. Let us examine some of the key files highlighted in the file tree:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts cdk construct for creating user/identity pools
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx adds the logged in user/logout to the header
        - CognitoAuth/
          - index.tsx manages logging into Cognito
        - RuntimeConfig/
          - index.tsx fetches the `runtime-config.json` and provides it to children via context
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Updated to add Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import { useAuth } from 'react-oidc-context';
+import CognitoAuth from './components/CognitoAuth';
+import { useRuntimeConfig } from './hooks/useRuntimeConfig';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import '@cloudscape-design/global-styles/index.css';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
-export type RouterProviderContext = {};
+export type RouterProviderContext = {
+  runtimeConfig?: ReturnType<typeof useRuntimeConfig>;
+  auth?: ReturnType<typeof useAuth>;
+};
-const router = createRouter({
-  routeTree,
-  context: {},
-});
+const router = createRouter({
+  routeTree,
+  context: {
+    runtimeConfig: undefined,
+    auth: undefined,
+  },
+});
// Register the router instance for type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
-const App = () => {
-  return <RouterProvider router={router} context={{}} />;
-};
+const App = () => {
+  const auth = useAuth();
+  const runtimeConfig = useRuntimeConfig();
+  return <RouterProvider router={router} context={{ runtimeConfig, auth }} />;
+};
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <App />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

The `RuntimeConfigProvider` and `CognitoAuth` components have been added to the `main.tsx` file via an AST transform. This allows the `CognitoAuth` component to authenticate with Amazon Cognito by fetching the `runtime-config.json` which contains the required cognito connection configuration in order to make the backend calls to the correct destination.

</Drawer>

### Game UI: Connect to Game API

Let us configure our Game UI to connect to our previously created Game API.

<RunGenerator generator="connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

You will see some new files have appear/change in your file tree.

<Drawer title="UI -> tRPC connection updated files" trigger="Click here to examine these files in more detail.">
The `connection` generator generates/updates these files. Let us examine some of the key files highlighted in the file tree:

<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx sets up the GameAPI client
      - hooks/
        - **useGameApi.tsx** hooks to call the GameApi
      - **main.tsx** injects the trpc client providers
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { useContext } from 'react';
import { GameApiTRPCContext } from '../components/GameApiClientProvider';

export const useGameApi = () => {
  const container = useContext(GameApiTRPCContext);
  if (!container) {
    throw new Error('useGameApi must be used within GameApiClientProvider');
  }
  return container.optionsProxy;
};

export const useGameApiClient = () => {
  const container = useContext(GameApiTRPCContext);
  if (!container) {
    throw new Error(
      'useGameApiClient must be used within GameApiClientProvider',
    );
  }
  return container.client;
};
```

This hook provides access to the tRPC client for calling the GameApi. For examples on how to call tRPC APIs, refer to the <Link path="guides/connection/react-trpc#using-the-generated-code">using the tRPC hook guide</Link>.

<Aside>
The `useGameApi` hook is different to the `useStoryApi` hook as it does not require a build in order for changes to be reflected courtesy of tRPC's usage of [Typescript inference](https://trpc.io/docs/concepts). This allows developers to make changes to their backend which instantly are reflected in their frontend.
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import { useAuth } from 'react-oidc-context';
import CognitoAuth from './components/CognitoAuth';
import { useRuntimeConfig } from './hooks/useRuntimeConfig';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import '@cloudscape-design/global-styles/index.css';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
...
const App = () => {
  const auth = useAuth();
  const runtimeConfig = useRuntimeConfig();
  return <RouterProvider router={router} context={{ runtimeConfig, auth }} />;
};
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <App />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

The `main.tsx` file has been updated via an AST transform to inject the tRPC providers.

</Drawer>

### Game UI: Infrastructure

Let us create the final sub-project for the CDK infrastructure.

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

You will see some new files have appear/change in your file tree.

<Drawer title="ts#infra updated files" trigger="Click here to examine these files in more detail.">
The `ts#infra` generator generates/updates these. Let us examine some of the key files highlighted in the file tree:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - checkov.ts
          - index.ts
  - infra
    - src/
      - stages/
        - **application-stage.ts** cdk stacks defined here
      - stacks/
        - **application-stack.ts** cdk resources defined here
      - **main.ts** entrypoint which defines all stages
    - cdk.json
    - checkov.yml
    - project.json
    - ...
  - package.json
  - tsconfig.json add references
  - tsconfig.base.json add alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStage } from './stages/application-stage.js';
import { App } from ':dungeon-adventure/common-constructs';

const app = new App();

// Use this to deploy your own sandbox environment (assumes your CLI credentials)
new ApplicationStage(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
});

app.synth();
```

<Aside type="tip">If you see an import error within your IDE, this is because our infrastructure project does not have a typescript reference set up yet in the `tsconfig.json`. Nx has been [configured](https://nx.dev/nx-api/js/generators/typescript-sync) to create these references *dynamically* whenever a build/compile is run or if you run the `nx sync` command manually. For more information refer to the <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">Typescript guide</Link>.</Aside>

This is the entry point for your CDK application.

```ts
// packages/infra/src/stacks/application-stack.ts
import { Stack, StackProps } from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends Stack {
  constructor(scope: Construct, id: string, props?: StackProps) {
    super(scope, id, props);

    // The code that defines your stack goes here
  }
}
```

Let us instantiate our CDK constructs to build our dungeon adventure game.

</Drawer>

## Task 6: Update our infrastructure

Let's update `packages/infra/src/stacks/application-stack.ts` to instantiate some of our generated constructs:

<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

:::note
We supply default integrations for our Game API. By default, each operation in our API is mapped to an individual Lambda function to handle that operation.
:::

## Task 7: Build the code

<Drawer title="Nx commands" trigger="Now it's time for us to build our code for the first time">

###### Single vs Multiple targets

The `run-many` command will run a target on multiple listed subprojects (`--all` will target them all). This ensures dependencies are executed in the correct order.

You can also trigger a build (or any other task) for a single project target by running the target on the project directly. For example, to build the `@dungeon-adventure/infra` project, run the following command:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />

You can also omit the scope, and use the Nx shorthand syntax if you prefer:

<NxCommands commands={['build infra']} />

###### Visualizing your dependencies

To visualize your dependencies, run:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Caching

Nx relies on [caching](https://nx.dev/concepts/how-caching-works) so that you can re-use artifacts from previous builds in order to speed up development. There is some configuration required to get this to work correctly and there may be cases where you want to perform a build **without using the cache**. To do that, simply append the `--skip-nx-cache` argument to your command. For example:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
If for whatever reason you ever wanted to clear your cache (stored in the `.nx` folder), you can run the following command:

<NxCommands commands={['reset']} />

</Drawer>

Using the command line, run the following command to fix any lint issues first:

<PackageManagerShortCommand commands={["lint"]} />

Then, run the following command for a full build:

<PackageManagerShortCommand commands={["build"]} />

You will be prompted with the following:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? â€¦
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

This message indicates that NX has detected some files which can be updated automatically for you. In this case, it is referring to the `tsconfig.json` files which do not have Typescript references set up on references projects.

Select the **Yes, sync the changes and run the tasks** option to proceed. You should notice all of you IDE related import errors get automatically resolved as the sync generator will add the missing typescript references automatically!

All built artifacts are now available within the `dist/ folder` located at the root of the monorepo. This is a standard pactice when using projects generated by the `@aws/nx-plugin` as it does not pollute your file-tree with generated files. In the event you want to clean your files, delete the `dist/` folder without worrying about build artifacts being littered throughout the file tree.

Congratulations! You've created all of the required sub-projects required to start implementing the core of our AI Dungeon Adventure game.  ðŸŽ‰ðŸŽ‰ðŸŽ‰