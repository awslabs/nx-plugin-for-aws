---
title: Implement the Game API and Inventory MCP server
description: A walkthrough of how to build an agentic AI-powered dungeon adventure game using the @aws/nx-plugin.
---

import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import E2EDiff from '@components/e2e-diff.astro';
import E2ECode from '@components/e2e-code.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

import { getDungeonAdventureElectroDbDependencies } from '../../../../../../../../e2e/src/utils';

## Task 1: Implement the Game API

We will implement the following APIs in this section:

1. `saveGame` - create or update a game.
2. `queryGames` - return a paginated list of previously saved games.
3. `saveAction` - save an action for a given game.
4. `queryActions` - return a paginated list of all actions related to a game.
5. `queryInventory` - return a paginated list of items in a player's inventory.

### API schema

To define our API inputs and outputs, let's create our schema using [Zod](https://zod.dev/) within the `packages/game-api/src/schema/index.ts` file as follows:

<E2EDiff lang="typescript" before="dungeon-adventure/2/schema/index.ts.old.template" after="dungeon-adventure/2/schema/index.ts.template" />

Delete the `packages/game-api/src/schema/echo.ts` file as we will not be using it in this project.

<Aside type="tip">
For each of the schemas we define in Zod, we also export an interface using the `z.TypeOf` syntax. This converts our Zod definition into a Typescript interface without having to duplicate effort.
</Aside>

### Entity modelling

This is the ER diagram for our application.

<Image class="centered-image white-bg" src={dungeonAdventureErPng} alt="dungeon-adventure-er.png" width="400" height="300" />

{/* Generated from the following PlantUML: */}
{/*
@startuml Game API Entity Relationship Diagram

!theme plain

skinparam linetype ortho
skinparam roundcorner 10

entity "Game" as game {
  + playerName : string <<PK>>
  --
  genre : string
  lastUpdated : string
}

entity "Action" as action {
  + playerName : string <<PK>>
  + timestamp : string <<SK>>
  --
  role : string
  content : string
}

entity "Item" as item {
  + playerName : string <<PK>>
  + itemName : string
  --
  emoji : string (optional)
  lastUpdated : string
  quantity : number
}

game ||--o{ action
game ||--o{ item

@enduml
*/}

We will implement our database in DynamoDB, and will use the [ElectroDB](https://electrodb.dev/en/core-concepts/introduction/) DynamoDB client library to simplify things. To install `electrodb` and the DynamoDB Client, run this command:

<InstallCommand pkg={getDungeonAdventureElectroDbDependencies()} />

<Aside>
All dependencies are added to the root `package.json` as the `@aws/nx-plugin` follows the [single version policy](https://nx.dev/concepts/decisions/dependency-management#single-version-policy) principle. For more information, refer to the <Link path="guides/typescript-project#dependencies">ts#project guide</Link>.
</Aside>

To define our ElectroDB entities from the ER Diagram, let's create the `packages/game-api/src/entities/index.ts` file:

<E2ECode lang="typescript" path="dungeon-adventure/2/entities/index.ts.template" />

ElectroDB allows us to not only define our types, but can also provide defaults for certain values like timestamps. In addition, ElectroDB follows [single-table design](https://electrodb.dev/en/core-concepts/single-table-relationships/) which is the best practice when using DynamoDB.

<Aside>
Whilst ElectroDB does support [collections](https://electrodb.dev/en/modeling/collections/), we have chosen not to use them in this tutorial for simplicity.
</Aside>

To prepare for the MCP server to interact with the inventory, let's ensure we export the inventory entity in `packages/game-api/src/index.ts`:

<Tabs>
<TabItem label="packages/game-api/src/index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/index.ts.old.template" after="dungeon-adventure/2/index.ts.template" />
</TabItem>
</Tabs>

:::note
The package structure would be better if we refactored entities into their own shared project so that the MCP server does not need to depend on the API.
:::

### Defining our procedures

To implement the API methods, make the following changes within `packages/game-api/src/procedures`:

<Tabs>
  <TabItem label="actions.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/actions.ts.template" />
  </TabItem>
  <TabItem label="games.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/games.ts.template" />
  </TabItem>
  <TabItem label="inventory.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/inventory.ts.template" />
  </TabItem>
</Tabs>

Delete the `echo.ts` file (from `packages/game-api/src/procedures`) as we will not be using it in this project.

### Router setup

After we define our procedures, to wire them into our API, update the following file:

<Tabs>
  <TabItem label="packages/game-api/src/router.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/router.ts.old.template" after="dungeon-adventure/2/router.ts.template" />
</TabItem>
</Tabs>

## Task 2: Create an Inventory MCP server

Let us create an MCP server which will allow our agent to manage items in a player's inventory.

We'll define the following tools for our agent:

- `list-inventory-items` for retrieving the player's current inventory items
- `add-to-inventory` for adding items to the player's inventory
- `remove-from-inventory` for removing items from the player's inventory

To save time, we will define all the tools inline:

<Tabs>
  <TabItem label="packages/inventory/src/mcp-server/server.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/mcp/server.ts.old.template" after="dungeon-adventure/2/mcp/server.ts.template" />
</TabItem>
</Tabs>

As the number of tools grow, you can refactor them out into separate files if you like.

Delete the `tools` and `resources` directories in `packages/inventory/src/mcp-server` as these will not be used.

## Task 3: Update the infrastructure

The final step is to update our infrastructure to create the DynamoDB table and grant permissions to perform operations from the Game API.
To do so, update the `packages/infra/src` as follows:

<Tabs>
  <TabItem label="constructs/electrodb-table.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/constructs/electrodb-table.ts.template" />
  </TabItem>
  <TabItem label="stacks/application-stack.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/1/application-stack.ts.template" after="dungeon-adventure/2/stacks/application-stack.ts.template" />

:::note
Notice here that since each procedure is served by an individual lambda function, we can follow the principle of least privilege and assign only the required read/write permissions based on the procedure's implementation.
:::
  </TabItem>
</Tabs>

## Task 4: Deployment and testing

First, fix any lint issues:

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />

Then build the codebase:

<NxCommands commands={['run-many --target build --all']} />

### Deploy your application
To deploy your application, run the following command:

<NxCommands commands={['deploy infra "dungeon-adventure-infra-sandbox/*"']} />

:::caution
To bootstrap your AWS Account first, run:

<NxCommands commands={['bootstrap infra']} />
:::

Your first deployment will take around 8 minutes to complete. Subsequent deployments will take around 2 minutes.

:::tip
If you're iterating on Lambda function code changes, you can deploy with the `--hotswap` flag after building the codebase for a much shorter (2-3 second) deployment time.

<NxCommands commands={['run @dungeon-adventure/infra:deploy "dungeon-adventure-infra-sandbox/*" --hotswap']} />
:::

Once the deployment completes, you will see outputs similar to the following _(some values have been redacted)_:

```bash
dungeon-adventure-sandbox-Application
dungeon-adventure-sandbox-Application: deploying... [2/2]

 âœ…  dungeon-adventure-sandbox-Application

âœ¨  Deployment time: 354s

Outputs:
dungeon-adventure-sandbox-Application.ElectroDbTableTableNameXXX = dungeon-adventure-sandbox-Application-ElectroDbTableXXX-YYY
dungeon-adventure-sandbox-Application.GameApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-sandbox-Application.GameUIDistributionDomainNameXXX = xxx.cloudfront.net
dungeon-adventure-sandbox-Application.StoryApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-sandbox-Application.UserIdentityUserIdentityIdentityPoolIdXXX = region:xxx
dungeon-adventure-sandbox-Application.UserIdentityUserIdentityUserPoolIdXXX = region_xxx
```
### Test the API
You can test the API by either:
<ul>
<li>Starting a local instance of the tRPC backend and invoke the APIs using `curl`.</li>
<li>
<Drawer title="Sigv4 enabled curl" trigger="Calling the deployed API using sigv4 enabled curl">
<Snippet name="tools/acurl" />
</Drawer>
</li>
</ul>


<Tabs>
  <TabItem label="Local">
    To start your local `game-api` server, run the following command:

    <NxCommands highlights={['dungeon-adventure-infra-sandbox-Application-ElectroDbTableXXX-YYY']} env={{TABLE_NAME:"dungeon-adventure-infra-sandbox-Application-ElectroDbTableXXX-YYY"}} commands={["run @dungeon-adventure/game-api:serve"]} />

    <Aside type="caution">
    Use the CDK deploy output value of `dungeon-adventure-infra-sandbox-Application.ElectroDbTableTableNameXXX` to replace the highlighted placeholder.
    </Aside>

    Once your server is up and running, you can call it by running the following command:

    ```bash
    curl -X GET 'http://localhost:2022/games.query?input=%7B%7D'
    ```
  </TabItem>
  <TabItem label="Deployed">
```bash "https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/" "ap-southeast-2"
acurl ap-southeast-2 execute-api -X GET 'https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/games.query?input=%7B%7D'
```
    <Aside type="caution">
    Use the CDK deploy output value of `dungeon-adventure-infra-sandbox-Application.GameApiGameApiEndpointXXX` to replace the highlighted placeholder and set the region accordingly.
    </Aside>
  </TabItem>
</Tabs>

:::note
The `%7B%7D` we pass to test the API is a URI encoded empty JSON object (`{}`).
:::

If the command runs successfully, you will see a response as follows:

```json
{"result":{"data":{"items":[],"cursor":null}}}
```

Congratulations, you have built and deployed your first API using tRPC!  ðŸŽ‰ðŸŽ‰ðŸŽ‰
