---
title: "Distribuisci"
---



import { Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import RunGenerator from '@components/run-generator.astro';
import Link from '@components/link.astro';
import NxCommands from '@components/nx-commands.astro';
import Drawer from '@components/drawer.astro';
import InstallCommand from '@components/install-command.astro';

Ora che abbiamo la nostra codebase completamente migrata, possiamo procedere con la distribuzione. A questo punto abbiamo due strade percorribili.

#### Risorse Completamente Nuove (Semplice)

L'approccio piÃ¹ semplice Ã¨ trattare questa come un'applicazione completamente nuova, il che significa che "ricominceremo" con una nuova tabella DynamoDB e un nuovo User Pool Cognito - perdendo tutti gli utenti e le loro liste della spesa. Per questo approccio, basta:

<Steps>

1. Elimina la tabella DynamoDB denominata `shopping_list`

1. Distribuisci la nuova applicazione:

    <NxCommands commands={["deploy infra shopping-list-infra-sandbox/*"]} />

</Steps>

ðŸŽ‰ E abbiamo finito! ðŸŽ‰

#### Migrare le Risorse Esistenti con Stato Senza Interruzioni (PiÃ¹ Complesso)

Nella realtÃ , Ã¨ piÃ¹ probabile che tu voglia migrare le risorse AWS esistenti in modo che siano gestite dalla nuova codebase, evitando nel contempo qualsiasi interruzione del servizio per i clienti.

:::danger
Questo approccio Ã¨ piÃ¹ articolato e complesso, e trattandosi solo di un esempio, Ã¨ FORTEMENTE consigliato esercitarsi in un ambiente non di produzione (idealmente creando un nuovo stack sandbox) e documentare i passaggi esatti per la tua applicazione. Si raccomanda inoltre di preparare piani di contingenza/rollback nel caso in cui i passaggi falliscano o producano risultati imprevisti.
:::

:::note
La nostra applicazione PDK per le liste della spesa non definiva domini personalizzati o DNS. Nella pratica Ã¨ probabile che tu abbia domini configurati per il sito web e l'API. Ai fini di questa sezione della guida, supporremo di aver configurato Route53 con nomi DNS personalizzati per il sito web e l'API.
:::

Per la nostra applicazione delle liste della spesa, le risorse con stato che ci interessano sono la tabella DynamoDB che contiene le liste della spesa degli utenti e l'User Pool che contiene i dettagli di tutti gli utenti registrati. Il nostro piano ad alto livello sarÃ  mantenere queste due risorse chiave e spostarle in modo che siano gestite dal nuovo stack, per poi aggiornare il DNS per puntare al nuovo sito web (e all'API se esposta ai clienti).

<Steps>

1. Aggiorna la nuova applicazione per riferirsi alle risorse esistenti che desideri mantenere.

    Per l'applicazione delle liste della spesa, facciamo questo per la tabella DynamoDB

    ```diff lang="ts"
    // constructs/database.ts
    -this.shoppingListTable = new Table(this, 'ShoppingList', {
    -  ...
    +this.shoppingListTable = Table.fromTableName(
    +  this,
    +  'ShoppingList',
    +  'shopping_list',
    +);
    ```

    E per l'User Pool Cognito

    ```diff lang="ts"
    // packages/common/constructs/src/core/user-identity.ts
    -this.userPool = this.createUserPool();
    +this.userPool = UserPool.fromUserPoolId(
    +  this,
    +  'UserPool',
    +  '<your-user-pool-id>',
    +);
    ```

1. Compila e distribuisci la nuova applicazione:

    <NxCommands commands={["run-many --target build"]} />

    <NxCommands commands={["deploy infra shopping-list-infra-sandbox/*"]} />

    Ora abbiamo la nuova applicazione attiva che fa riferimento alle risorse esistenti, ma non ancora in produzione.

1. Esegui test di integrazione completi per verificare che la nuova applicazione funzioni come previsto. Per l'applicazione delle liste della spesa, carica il sito web e verifica di poter accedere, creare, visualizzare, modificare ed eliminare liste.

1. Ripristina le modifiche che fanno riferimento alle risorse esistenti nella nuova applicazione, ma non distribuirle ancora.

    ```diff lang="ts"
    // constructs/database.ts
    +this.shoppingListTable = new Table(this, 'ShoppingList', {
    +  ...
    -this.shoppingListTable = Table.fromTableName(
    -  this,
    -  'ShoppingList',
    -  'shopping_list',
    -);
    ```

    E per l'User Pool Cognito

    ```diff lang="ts"
    // packages/common/constructs/src/core/user-identity.ts
    +this.userPool = this.createUserPool();
    -this.userPool = UserPool.fromUserPoolId(
    -  this,
    -  'UserPool',
    -  '<your-user-pool-id>',
    -);
    ```

    E poi esegui una compilazione

    <NxCommands commands={["run-many --target build"]} />

1. Usa `cdk import` nella cartella `packages/infra` della nuova applicazione per vedere quali risorse verranno proposte per l'importazione.

    ```bash title="Nuova Applicazione"
    cd packages/infra
    pnpm exec cdk import shopping-list-infra-sandbox/Application --force
    ```

    Procedi attraverso le richieste premendo invio. L'importazione fallirÃ  perchÃ© le risorse sono gestite da un altro stack - Ã¨ previsto, abbiamo fatto questo passaggio solo per confermare quali risorse dovremo mantenere. Vedrai un output simile a questo:

    ```bash wrap
    shopping-list-infra-sandbox/Application/ApplicationUserIdentity/UserPool/smsRole/Resource (AWS::IAM::Role): inserisci RoleName (vuoto per saltare)
    shopping-list-infra-sandbox/Application/ApplicationUserIdentity/UserPool/Resource (AWS::Cognito::UserPool): inserisci UserPoolId (vuoto per saltare)
    shopping-list-infra-sandbox/Application/Database/ShoppingList/Resource (AWS::DynamoDB::Table): importa con TableName=shopping_list (y/n) y
    ```

    Questo ci dice che in realtÃ  ci sono 3 risorse da importare nel nuovo stack.

1. Aggiorna il tuo vecchio progetto PDK per impostare `RemovalPolicy` su `RETAIN` per le risorse individuate nel passaggio precedente. Al momento della stesura questa Ã¨ l'impostazione predefinita sia per l'User Pool che per la tabella DynamoDB, ma dobbiamo aggiornarla per il ruolo SMS individuato sopra:

    ```diff lang="ts"
    // application-stack.ts
    const userIdentity = new UserIdentity(this, `${id}UserIdentity`, {
      userPool,
    });

    +const smsRole = userIdentity.userPool.node.findAll().filter(
    +  c => CfnResource.isCfnResource(c) &&
    +    c.node.path.includes('/smsRole/'))[0] as CfnResource;
    +smsRole.applyRemovalPolicy(RemovalPolicy.RETAIN);
    ```

1. Distribuisci il progetto PDK per applicare le politiche di rimozione

    ```bash title="Applicazione PDK"
    cd packages/infra
    npx projen deploy
    ```

1. Controlla la console CloudFormation e registra i valori richiesti nel passaggio `cdk import` precedente

    1. L'ID dell'User Pool, es. `us-west-2_XXXXX`
    2. Il nome del ruolo SMS, es. `infra-sandbox-UserIdentityUserPoolsmsRoleXXXXXX`

1. Aggiorna il progetto PDK per riferirsi alle risorse esistenti invece di crearne di nuove

    ```diff lang="ts"
    // constructs/database.ts
    -this.shoppingListTable = new Table(this, 'ShoppingList', {
    -  ...
    +this.shoppingListTable = Table.fromTableName(
    +  this,
    +  'ShoppingList',
    +  'shopping_list',
    +);
    ```

    E per l'User Pool Cognito

    ```diff lang="ts"
    // application-stack.ts
    +const userPool = UserPool.fromUserPoolId(
    +  this,
    +  'UserPool',
    +  '<your-user-pool-id>',
    +);
    const userIdentity = new UserIdentity(this, `${id}UserIdentity`, {
    +  // Il costrutto PDK accetta UserPool non IUserPool, ma funziona comunque!
    +  userPool: userPool as any,
    });
    ```

1. Distribuisci nuovamente il progetto PDK, questo significa che le risorse non saranno piÃ¹ gestite dallo stack CloudFormation del progetto PDK.

    ```bash title="Applicazione PDK"
    cd packages/infra
    npx projen deploy
    ```

1. Ora che le risorse non sono gestite, possiamo eseguire `cdk import` nella nuova applicazione per completare l'importazione:

    ```bash title="Nuova Applicazione"
    cd packages/infra
    pnpm exec cdk import shopping-list-infra-sandbox/Application --force
    ```

    Inserisci i valori quando richiesto, l'importazione dovrebbe completarsi con successo.

1. Distribuisci nuovamente la nuova applicazione per assicurarti che eventuali modifiche a queste risorse esistenti (ora gestite dal nuovo stack) vengano applicate:

    <NxCommands commands={["deploy infra shopping-list-infra-sandbox/*"]} />

1. Esegui nuovamente un test completo della nuova applicazione

1. Aggiorna i record DNS per puntare al nuovo sito web (e all'API se necessario).

    Raccomandiamo un approccio graduale usando il [Routing Ponderato](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-weighted.html) di Route53, dove inizialmente una frazione delle richieste viene indirizzata alla nuova applicazione. Monitorando le metriche, puoi aumentare gradualmente il peso per la nuova applicazione finchÃ© tutto il traffico non viene indirizzato lÃ¬.

    Se non hai DNS e hai usato i domini auto-generati per sito web e API, puoi considerare il proxy delle richieste (es. tramite un [origine HTTP CloudFront](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_cloudfront_origins-readme.html#from-an-http-endpoint) o [integrazioni HTTP API Gateway](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_apigateway.HttpIntegration.html)).

1. Monitora le metriche dell'applicazione PDK per assicurarti che non ci sia traffico residuo, infine elimina il vecchio stack CloudFormation:

    ```bash
    cd packages/infra
    npx projen destroy
    ```

</Steps>

Ãˆ stato piuttosto articolato, ma abbiamo migrato gli utenti in modo trasparente alla nuova applicazione! ðŸŽ‰ðŸŽ‰ðŸŽ‰

Ora abbiamo i nuovi vantaggi di Nx Plugin for AWS rispetto a PDK:

- Build piÃ¹ veloci
- Supporto allo sviluppo locale delle API
- Una codebase amichevole per il vibe-coding (<Link path="/get_started/building-with-ai">prova il nostro server MCP!</Link>)
- Codice client/server type-safe piÃ¹ intuitivo
- E altro ancora!