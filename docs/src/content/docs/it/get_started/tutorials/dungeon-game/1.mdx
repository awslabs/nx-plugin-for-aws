---
title: "Configurare un monorepo"
description: "Una guida dettagliata su come costruire un gioco di avventura in dungeon alimentato da IA agentiva utilizzando @aws/nx-plugin."
---

import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import PackageManagerShortCommand from '@components/package-manager-short-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Task 1: Creare un monorepo

Per creare un nuovo monorepo, esegui il seguente comando dalla directory desiderata:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" iacProvider="CDK" />

:::note
Utilizziamo `--iacProvider=CDK` poich√© useremo CDK per l'infrastructure as code in questo tutorial. Il Plugin Nx per AWS supporta anche `Terraform`.
:::

Questo configurer√† un monorepo NX all'interno della directory `dungeon-adventure`. Quando apri la directory in VSCode, vedrai questa struttura di file:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ qui risiederanno i tuoi sotto-progetti
- .gitignore
- .prettierignore
- .prettierrc
- nx.json configura la CLI NX e le impostazioni predefinite del monorepo
- package.json tutte le dipendenze Node sono definite qui
- pnpm-lock.yaml o bun.lock, yarn.lock, package-lock.json in base al package manager
- pnpm-workspace.yaml se si utilizza pnpm
- README.md
- tsconfig.base.json esteso da tutti i sotto-progetti basati su Node
- tsconfig.json
- aws-nx-plugin.config.mts configurazione per il Plugin Nx per AWS
</FileTree>

Ora possiamo iniziare a creare i diversi sotto-progetti utilizzando `@aws/nx-plugin`.

<Aside type="tip">√à una best practice assicurarsi che tutti i file non staged siano committati in Git prima di eseguire qualsiasi generatore. Questo permette di visualizzare le modifiche dopo l'esecuzione tramite `git diff`.</Aside>

## Task 2: Creare una Game API

Per prima cosa, creiamo la nostra Game API. Per farlo, creiamo un'API tRPC chiamata `GameApi` seguendo questi passaggi:

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

Vedrai alcuni nuovi file apparire nella struttura delle cartelle.

<Aside>
Il `package.json` principale √® ora configurato con `type` impostato a `module`, il che significa che ESM √® il tipo di modulo predefinito per tutti i sotto-progetti Node generati da `@aws/nx-plugin`.
Per maggiori dettagli sui progetti TypeScript, consulta la <Link path="guides/typescript-project">guida del generatore ts#project</Link>.
</Aside>

<Drawer title="File aggiornati da ts#trpc-api" trigger="Clicca qui per esaminare questi file in dettaglio.">
Di seguito l'elenco dei file generati dal generatore `ts#trpc-api`. Esamineremo alcuni file chiave evidenziati nella struttura:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ CDK constructs specifici per l'applicazione
          - apis/
            - **game-api.ts** CDK construct per creare l'API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ CDK constructs generici
          - api/
            - rest-api.ts CDK construct base per API Gateway Rest API
            - trpc-utils.ts utility per CDK constructs di API tRPC
            - utils.ts utility per i constructs API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
  - game-api/ API tRPC
    - src/
      - client/ client vanilla tipicamente usato per chiamate machine-to-machine in TS
        - index.ts
      - middleware/ strumentazione Powertools
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ definizioni di input e output per l'API
        - index.ts
        - **echo.ts** schema di input e output di esempio
        - z-async-iterable.ts schema Zod wrapper per output subscription tRPC
      - procedures/ implementazioni specifiche delle procedure/route dell'API
        - **echo.ts** implementazione procedura di esempio
      - index.ts
      - init.ts configura contesto e middleware
      - handler.ts entrypoint del Lambda handler (usa response streaming per REST APIs)
      - local-server.ts usato per eseguire il server tRPC localmente
      - **router.ts** definisce il router tRPC e tutte le procedure
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Esaminiamo questi file chiave:

```ts {5}
// packages/game-api/src/router.ts
import { echo } from './procedures/echo.js';
import { t } from './init.js';

export const router = t.router;

export const appRouter = router({
  echo,
});

export type AppRouter = typeof appRouter;
```
Il router definisce il router tRPC per l'API ed √® dove dichiarerai tutti i metodi dell'API. Come visibile sopra, abbiamo un metodo chiamato `echo` con l'implementazione nel file `./procedures/echo.ts`. L'entrypoint del Lambda handler si trova in `handler.ts`, che √® configurato automaticamente dal generatore.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Questo file implementa il metodo `echo` ed √® fortemente tipizzato dichiarando le strutture dati di input e output.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Tutte le definizioni degli schema tRPC sono create con [Zod](https://zod.dev/) ed esportate come tipi TypeScript tramite la sintassi `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import { Distribution } from 'aws-cdk-lib/aws-cloudfront';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
  ResponseTransferMode,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AnyPrincipal,
  IGrantable,
  Grant,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// Tipo union per tutti i nomi delle operazioni API
type Operations = Procedures<AppRouter>;

/**
 * Propriet√† per creare un construct GameApi
 *
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mappa dei nomi delle operazioni alle integrazioni API Gateway
   */
  integrations: TIntegrations;
}

/**
 * CDK construct che crea e configura un'API REST API Gateway AWS
 * specifica per GameApi.
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integrazioni predefinite per tutte le operazioni, implementando ciascuna operazione
   * come singola funzione lambda.
   *
   * @param scope - Scope del construct CDK
   * @returns IntegrationBuilder con integrazioni lambda predefinite
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return {
          handler,
          integration: new LambdaIntegration(handler, {
            responseTransferMode: ResponseTransferMode.STREAM,
          }),
        };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      deployOptions: {
        tracingEnabled: true,
      },
      policy: new PolicyDocument({
        statements: [
          // Apriamo OPTIONS per permettere ai browser richieste preflight non autenticate
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }

  /**
   * Limita CORS ai domini della distribuzione CloudFront del sito web
   *
   * Configura i domini della distribuzione CloudFront come uniche origini CORS permesse
   * (oltre a local host) nelle integrazioni AWS Lambda
   *
   * Nota che questa restrizione non viene applicata al preflight OPTIONS
   *
   * @param websites - La distribuzione CloudFront da cui concedere CORS
   */
  public restrictCorsTo(
    ...websites: { cloudFrontDistribution: Distribution }[]
  ) {
    const allowedOrigins = websites
      .map(
        ({ cloudFrontDistribution }) =>
          `https://${cloudFrontDistribution.distributionDomainName}`,
      )
      .join(',');

    // Imposta la variabile d'ambiente ALLOWED_ORIGINS per tutte le integrazioni Lambda
    Object.values(this.integrations).forEach((integration) => {
      if ('handler' in integration && integration.handler instanceof Function) {
        integration.handler.addEnvironment('ALLOWED_ORIGINS', allowedOrigins);
      }
    });
  }

  /**
   * Concede permessi IAM per invocare qualsiasi metodo su questa API.
   *
   * @param grantee - Il principal IAM a cui concedere i permessi
   */
  public grantInvokeAccess(grantee: IGrantable) {
    // Qui concediamo al grantee il permesso di chiamare l'API.
    // √à possibile definire qui accessi granulari machine-to-machine usando principal specifici
    this.api.addToResourcePolicy(
      new PolicyStatement({
        effect: Effect.ALLOW,
        principals: [grantee.grantPrincipal],
        actions: ['execute-api:Invoke'],
        resources: ['execute-api:/*'],
      }),
    );

    Grant.addToPrincipal({
      grantee,
      actions: ['execute-api:Invoke'],
      resourceArns: [this.api.arnForExecuteApi('*', '/*', '*')],
    });
  }
}
```

Questo √® il CDK construct che definisce la nostra `GameApi`. Fornisce un metodo `defaultIntegrations` che crea automaticamente una funzione Lambda per ogni procedura nell'API tRPC, puntando all'implementazione bundled. Ci√≤ significa che al momento di `cdk synth` non avviene il bundling (a differenza di [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) poich√© √® gi√† stato eseguito come parte del target di build del progetto backend.

</Drawer>

## Task 3: Creare gli Story agents

Ora creiamo i nostri Story Agents.

### Story agent: Progetto Python

Per creare un progetto Python:

<RunGenerator generator="py#project" requiredParameters={{name:"story"}} noInteractive />

Vedrai alcuni nuovi file apparire nella struttura delle cartelle.
<Drawer title="File aggiornati da py#project" trigger="Clicca qui per esaminare questi file in dettaglio.">
Il generatore `py#project` genera questi file:

<FileTree>
- .venv/ virtual env condiviso per il monorepo
- packages/
  - story/
    - dungeon_adventure_story/ modulo Python
      - hello.py file Python di esempio (ignorabile)
    - tests/
    - .python-version
    - pyproject.toml
    - project.json
- .python-version versione Python bloccata per UV
- pyproject.toml
- uv.lock
</FileTree>

Questo ha configurato un progetto Python e un [UV Workspace](https://docs.astral.sh/uv/concepts/projects/workspaces/) con ambiente virtuale condiviso.

</Drawer>

### Story agent: Agente Strands

Per aggiungere un agente Strands al progetto con il generatore `py#strands-agent`:

<RunGenerator generator="py#strands-agent" requiredParameters={{project:"story"}} noInteractive />

Vedrai alcuni nuovi file apparire nella struttura delle cartelle.
<Drawer title="File aggiornati da py#strands-agent" trigger="Clicca qui per esaminare questi file in dettaglio.">
Il generatore `py#strands-agent` genera questi file:

<FileTree>
- packages/
  - story/
    - dungeon_adventure_story/ modulo Python
      - agent/
        - init.py configura l'app FastAPI e il middleware
        - main.py entrypoint per l'agente in Bedrock AgentCore Runtime
        - agent.py definisce un agente e strumenti di esempio
        - agentcore_mcp_client.py utility per client MCP
        - Dockerfile definisce l'immagine Docker per il deployment in AgentCore Runtime
  - common/constructs/
    - src
      - app/agents/story-agent/
        - story-agent.ts construct per deployare lo Story agent in AgentCore Runtime
</FileTree>

Esaminiamo alcuni file in dettaglio:

```python
# agent/agent.py
from contextlib import contextmanager

from strands import Agent, tool
from strands_tools import current_time


# Definisci uno strumento personalizzato
@tool
def add(a: int, b: int) -> int:
    return a + b


@contextmanager
def get_agent(session_id: str):
    yield Agent(
        system_prompt="""
Sei un mago delle addizioni.
Usa lo strumento 'add' per le operazioni di addizione.
Riferisciti agli strumenti come al tuo 'grimorio'.
""",
        tools=[add, current_time],
    )
```

Questo crea un agente Strands di esempio e definisce uno strumento di addizione.

```python
# agent/main.py
import uvicorn
from bedrock_agentcore.runtime.models import PingStatus
from pydantic import BaseModel

from .agent import get_agent
from .init import JsonStreamingResponse, app


class InvokeInput(BaseModel):
    prompt: str
    session_id: str


class StreamChunk(BaseModel):
    content: str


async def handle_invoke(input: InvokeInput):
    """Handler di streaming per l'invocazione dell'agente"""
    with get_agent(session_id=input.session_id) as agent:
        stream = agent.stream_async(input.prompt)
        async for event in stream:
            print(event)
            text = event.get("event", {}).get("contentBlockDelta", {}).get("delta", {}).get("text")
            if text is not None:
                yield StreamChunk(content=text)
            elif event.get("event", {}).get("messageStop") is not None:
                yield StreamChunk(content="\n")


@app.post(
    "/invocations",
    response_class=JsonStreamingResponse,
    responses={200: JsonStreamingResponse.openapi_response(StreamChunk, "Stream of agent response chunks")},
)
async def invoke(input: InvokeInput) -> JsonStreamingResponse:
    """Entry point per l'invocazione dell'agente"""
    return JsonStreamingResponse(handle_invoke(input))


@app.get("/ping")
def ping() -> str:
    # TODO: se si esegue un task asincrono, restituire PingStatus.HEALTHY_BUSY
    return PingStatus.HEALTHY


if __name__ == "__main__":
    uvicorn.run("dungeon_adventure_story.agent.main:app", port=8080)
```

Questo √® l'entrypoint dell'agente, configurato come applicazione FastAPI compatibile con [Amazon Bedrock AgentCore Runtime](https://github.com/aws/bedrock-agentcore-sdk-python). Utilizza il supporto streaming di Strands per inviare eventi al client in tempo reale tramite JSON Lines.

```ts
// common/constructs/src/app/agents/story-agent.ts
import { Lazy, Names } from 'aws-cdk-lib';
import { Platform } from 'aws-cdk-lib/aws-ecr-assets';
import { Construct } from 'constructs';
import { execSync } from 'child_process';
import * as path from 'path';
import * as url from 'url';
import {
  AgentRuntimeArtifact,
  ProtocolType,
  Runtime,
  RuntimeProps,
} from '@aws-cdk/aws-bedrock-agentcore-alpha';

export type StoryAgentProps = Omit<
  RuntimeProps,
  'runtimeName' | 'protocolConfiguration' | 'agentRuntimeArtifact'
>;

export class StoryAgent extends Construct {
  public readonly dockerImage: AgentRuntimeArtifact;
  public readonly agentCoreRuntime: Runtime;

  constructor(scope: Construct, id: string, props?: StoryAgentProps) {
    super(scope, id);

    this.dockerImage = AgentRuntimeArtifact.fromAsset(
      path.dirname(url.fileURLToPath(new URL(import.meta.url))),
      {
        platform: Platform.LINUX_ARM64,
        extraHash: execSync(
          `docker inspect dungeon-adventure-story-agent:latest --format '{{.Id}}'`,
          { encoding: 'utf-8' },
        ).trim(),
      },
    );

    this.agentCoreRuntime = new Runtime(this, 'StoryAgent', {
      runtimeName: Lazy.string({
        produce: () =>
          Names.uniqueResourceName(this.agentCoreRuntime, { maxLength: 40 }),
      }),
      protocolConfiguration: ProtocolType.HTTP,
      agentRuntimeArtifact: this.dockerImage,
      ...props,
    });
  }
}
```

Questo configura un `AgentRuntimeArtifact` CDK che carica l'immagine Docker dell'agente su ECR e la ospita usando AgentCore Runtime.

Potresti notare un `Dockerfile` aggiuntivo che referenzia l'immagine Docker dal progetto `story`, permettendo di collocare Dockerfile e codice sorgente insieme.

</Drawer>

## Task 4: Configurare gli strumenti di inventario

### Inventory: Progetto TypeScript

Creiamo un server MCP che fornir√† strumenti allo Story Agent per gestire l'inventario del giocatore.

Iniziamo creando un progetto TypeScript:

<RunGenerator generator="ts#project" requiredParameters={{name:"inventory"}} noInteractive />

Questo creer√† un progetto TypeScript vuoto.

<Drawer title="File aggiornati da ts#project" trigger="Clicca qui per esaminare questi file in dettaglio.">
Il generatore `ts#project` genera questi file.

<FileTree>
- packages/
  - inventory/
    - src/
      - index.ts entry point con funzione di esempio
    - project.json configurazione del progetto
    - eslint.config.mjs configurazione lint
    - vite.config.mts configurazione test
    - tsconfig.json configurazione TypeScript base
    - tsconfig.lib.json configurazione per compilazione e bundling
    - tsconfig.spec.json configurazione per i test
- tsconfig.base.json aggiornato con alias per riferire questo progetto
</FileTree>

</Drawer>

### Inventory: Server MCP

Aggiungiamo un server MCP al progetto TypeScript:

<RunGenerator generator="ts#mcp-server" requiredParameters={{project:"inventory"}} noInteractive />

Questo aggiunger√† un server MCP.
<Drawer title="File aggiornati da ts#mcp-server" trigger="Clicca qui per esaminare questi file in dettaglio.">
Il generatore `ts#mcp-server` genera questi file.

<FileTree>
- packages/
  - inventory/
    - src/mcp-server/
      - index.ts barrel export
      - server.ts crea il server MCP
      - tools/
        - add.ts strumento di esempio
      - resources/
        - sample-guidance.ts risorsa di esempio
      - stdio.ts entry point per MCP con trasporto STDIO
      - http.ts entry point per MCP con trasporto HTTP streamable
      - Dockerfile builda l'immagine per AgentCore Runtime
    - rolldown.config.ts configurazione per il bundling del server MCP
  - common/constructs/
    - src
      - app/mcp-servers/inventory-mcp-server/
        - inventory-mcp-server.ts construct per deployare il server MCP in AgentCore Runtime
</FileTree>

</Drawer>

## Task 5: Creare l'interfaccia utente (UI)

In questo task, creeremo l'interfaccia utente che ti permetter√† di interagire con il gioco.

### Game UI: Sito Web

Per creare l'interfaccia utente, creiamo un sito web chiamato `GameUI` seguendo questi passaggi:

<RunGenerator generator="ts#react-website" requiredParameters={{name:"GameUI"}} noInteractive />

Vedrai alcuni nuovi file apparire nella struttura delle cartelle.

<Drawer title="File aggiornati da ts#react-website" trigger="Clicca qui per esaminare questi file in dettaglio.">
Il generatore `ts#react-website` genera questi file. Esaminiamo alcuni file chiave evidenziati nella struttura:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ CDK constructs specifici per l'applicazione
          - static-websites/
            - **game-ui.ts** CDK construct per creare la Game UI
        - core/
          - static-website.ts construct generico per siti statici
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.tsx layout generale della pagina: header, footer, sidebar, ecc
      - hooks/
        - useAppLayout.tsx permette di impostare notifiche, stile pagina, ecc
      - routes/ routing basato su file @tanstack/react-router
        - **index.tsx** root '/' page
        - __root.tsx componente base per tutte le pagine
      - config.ts
      - **main.tsx** entrypoint React
      - routeTree.gen.ts generato automaticamente da @tanstack/react-router
      - styles.css
    - index.html
    - project.json
    - vite.config.mts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteName: 'GameUI',
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Questo √® il CDK construct che definisce la nostra GameUI. Ha gi√† configurato il percorso del bundle generato per la nostra UI basata su Vite. Ci√≤ significa che al momento della `build`, il bundling avviene all'interno del target di build del progetto game-ui e l'output viene utilizzato qui.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import '@cloudscape-design/global-styles/index.css';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export type RouterProviderContext = {};

const router = createRouter({
  routeTree,
  context: {},
});

// Registra l'istanza del router per type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const App = () => {
  return <RouterProvider router={router} context={{}} />;
};

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <App />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Questo √® l'entry point dove React viene montato. Come mostrato, inizialmente configura solo un `@tanstack/react-router` in una configurazione [`file-based-routing`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Finch√© il server di sviluppo √® in esecuzione, puoi creare file nella cartella `routes` e `@tanstack/react-router` creer√† automaticamente la configurazione boilerplate per te, aggiornando anche il file `routeTree.gen.ts`. Questo file mantiene tutte le route in modo type-safe, il che significa che quando usi `<Link>`, l'opzione `to` mostrer√† solo route valide.
Per maggiori informazioni, consulta la [documentazione di `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Benvenuto nel tuo nuovo sito React!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un componente verr√† renderizzato quando si naviga verso la route `/`. `@tanstack/react-router` gestir√† la `Route` per te ogni volta che crei/sposti questo file (finch√© il server dev √® in esecuzione).

</Drawer>

### Game UI: Autenticazione

Configuriamo la nostra Game UI per richiedere autenticazione tramite Amazon Cognito seguendo questi passaggi:

<RunGenerator generator="ts#react-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Vedrai alcuni nuovi file apparire/cambiare nella struttura delle cartelle.

<Drawer title="File aggiornati da ts#react-website#auth" trigger="Clicca qui per esaminare questi file in dettaglio.">
Il generatore `ts#react-website#auth` aggiorna/genera questi file. Esaminiamo alcuni file chiave evidenziati nella struttura:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts CDK construct per pool utenti/identit√†
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx aggiunge utente/logout nell'header
        - CognitoAuth/
          - index.tsx gestisce il login a Cognito
        - RuntimeConfig/
          - index.tsx recupera `runtime-config.json` e lo fornisce via context
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Aggiornato con Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import { useAuth } from 'react-oidc-context';
+import CognitoAuth from './components/CognitoAuth';
+import { useRuntimeConfig } from './hooks/useRuntimeConfig';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import '@cloudscape-design/global-styles/index.css';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
-export type RouterProviderContext = {};
+export type RouterProviderContext = {
+  runtimeConfig?: ReturnType<typeof useRuntimeConfig>;
+  auth?: ReturnType<typeof useAuth>;
+};
-const router = createRouter({
-  routeTree,
-  context: {},
-});
+const router = createRouter({
+  routeTree,
+  context: {
+    runtimeConfig: undefined,
+    auth: undefined,
+  },
+});
// Registra l'istanza del router per type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
-const App = () => {
-  return <RouterProvider router={router} context={{}} />;
-};
+const App = () => {
+  const auth = useAuth();
+  const runtimeConfig = useRuntimeConfig();
+  return <RouterProvider router={router} context={{ runtimeConfig, auth }} />;
+};
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <App />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

I componenti `RuntimeConfigProvider` e `CognitoAuth` sono stati aggiunti al file `main.tsx` tramite una trasformazione AST. Questo permette al componente `CognitoAuth` di autenticarsi con Amazon Cognito recuperando il `runtime-config.json` che contiene la configurazione necessaria per effettuare le chiamate backend alla destinazione corretta.

</Drawer>

### Game UI: Connessione alla Game API

Configuriamo la nostra Game UI per connettersi alla Game API creata precedentemente.

<RunGenerator generator="connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

Vedrai alcuni nuovi file apparire/cambiare nella struttura delle cartelle.

<Drawer title="File aggiornati da UI -> tRPC connection" trigger="Clicca qui per esaminare questi file in dettaglio.">
Il generatore `connection` genera/aggiorna questi file. Esaminiamo alcuni file chiave evidenziati nella struttura:

<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx configura il client GameAPI
      - hooks/
        - **useGameApi.tsx** hook per chiamare la GameApi
      - **main.tsx** inietta i provider trpc client
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { useContext } from 'react';
import { GameApiTRPCContext } from '../components/GameApiClientProvider';

export const useGameApi = () => {
  const container = useContext(GameApiTRPCContext);
  if (!container) {
    throw new Error('useGameApi must be used within GameApiClientProvider');
  }
  return container.optionsProxy;
};

export const useGameApiClient = () => {
  const container = useContext(GameApiTRPCContext);
  if (!container) {
    throw new Error(
      'useGameApiClient must be used within GameApiClientProvider',
    );
  }
  return container.client;
};
```

Questo hook fornisce accesso al client tRPC per chiamare la GameApi. Per esempi su come chiamare le API tRPC, consulta la <Link path="guides/connection/react-trpc#using-the-generated-code">guida all'utilizzo dell'hook tRPC</Link>.

<Aside>
L'hook `useGameApi` √® diverso dall'hook `useStoryApi` poich√© non richiede una build per riflettere le modifiche grazie all'utilizzo dell'[inferenza TypeScript](https://trpc.io/docs/concepts) di tRPC. Questo permette agli sviluppatori di apportare modifiche al backend che si riflettono istantaneamente nel frontend.
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import { useAuth } from 'react-oidc-context';
import CognitoAuth from './components/CognitoAuth';
import { useRuntimeConfig } from './hooks/useRuntimeConfig';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import '@cloudscape-design/global-styles/index.css';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
...
const App = () => {
  const auth = useAuth();
  const runtimeConfig = useRuntimeConfig();
  return <RouterProvider router={router} context={{ runtimeConfig, auth }} />;
};
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <App />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Il file `main.tsx` √® stato aggiornato tramite una trasformazione AST per iniettare i provider tRPC.

</Drawer>

### Game UI: Infrastruttura

Creiamo il progetto finale per l'infrastruttura CDK.

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Vedrai alcuni nuovi file apparire/cambiare nella struttura delle cartelle.

<Drawer title="File aggiornati da ts#infra" trigger="Clicca qui per esaminare questi file in dettaglio.">
Il generatore `ts#infra` genera/aggiorna questi file. Esaminiamo alcuni file chiave evidenziati nella struttura:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - checkov.ts
          - index.ts
  - infra
    - src/
      - stages/
        - **application-stage.ts** stack CDK definiti qui
      - stacks/
        - **application-stack.ts** risorse CDK definite qui
      - **main.ts** entrypoint che definisce tutti gli stage
    - cdk.json
    - checkov.yml
    - project.json
    - ...
  - package.json
  - tsconfig.json aggiunti riferimenti
  - tsconfig.base.json aggiunto alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStage } from './stages/application-stage.js';
import { App } from ':dungeon-adventure/common-constructs';

const app = new App();

// Deploya un ambiente sandbox personale (richiede credenziali CLI)
new ApplicationStage(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
});

app.synth();
```

<Aside type="tip">Se vedi un errore di import nel tuo IDE, √® perch√© il progetto infrastruttura non ha ancora un riferimento TypeScript configurato nel `tsconfig.json`. Nx √® stato [configurato](https://nx.dev/nx-api/js/generators/typescript-sync) per creare questi riferimenti *dinamicamente* ogni volta che viene eseguita una build/compilazione o se esegui manualmente il comando `nx sync`. Per maggiori informazioni consulta la <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guida TypeScript</Link>.</Aside>

Questo √® l'entry point per l'applicazione CDK.

```ts
// packages/infra/src/stacks/application-stack.ts
import { Stack, StackProps } from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends Stack {
  constructor(scope: Construct, id: string, props?: StackProps) {
    super(scope, id, props);

    // Il codice che definisce lo stack va qui
  }
}
```

Istanzieremo i nostri CDK constructs per costruire il gioco dungeon adventure.

</Drawer>

## Task 6: Aggiornare l'infrastruttura

Aggiorniamo `packages/infra/src/stacks/application-stack.ts` per istanziare alcuni dei nostri constructs generati:

<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

:::note
Forniamo integrazioni predefinite per la nostra Game API. Per impostazione predefinita, ogni operazione nell'API √® mappata a una singola funzione Lambda per gestire quell'operazione.
:::

## Task 7: Compilare il codice

<Drawer title="Comandi Nx" trigger="Ora √® il momento di compilare il codice per la prima volta">

###### Target singoli vs multipli

Il comando `run-many` esegue un target su pi√π sotto-progetti elencati (`--all` li seleziona tutti). Questo garantisce che le dipendenze vengano eseguite nell'ordine corretto.

Puoi anche attivare una build (o qualsiasi altro task) per un singolo target di progetto eseguendo il target direttamente sul progetto. Ad esempio, per compilare il progetto `@dungeon-adventure/infra`, esegui il seguente comando:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />

Puoi anche omettere lo scope e usare la sintassi abbreviata di Nx se preferisci:

<NxCommands commands={['build infra']} />

###### Visualizzare le dipendenze

Per visualizzare le dipendenze, esegui:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Caching

Nx si basa sul [caching](https://nx.dev/concepts/how-caching-works) per riutilizzare gli artefatti delle build precedenti e velocizzare lo sviluppo. √à necessaria una certa configurazione per farlo funzionare correttamente e potrebbero esserci casi in cui vuoi eseguire una build **senza usare la cache**. Per farlo, aggiungi semplicemente l'argomento `--skip-nx-cache` al comando. Ad esempio:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Se per qualsiasi motivo volessi pulire la cache (memorizzata nella cartella `.nx`), puoi eseguire il seguente comando:

<NxCommands commands={['reset']} />

</Drawer>

Dalla riga di comando, esegui il seguente comando per correggere prima eventuali problemi di lint:

<PackageManagerShortCommand commands={["lint"]} />

Quindi, esegui il seguente comando per una build completa:

<PackageManagerShortCommand commands={["build"]} />

Vedrai il seguente prompt:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Alcuni file di configurazione TypeScript mancano di riferimenti ai progetti dipendenti o contengono riferimenti obsoleti.

Questo causer√† un errore in CI.

? Vuoi sincronizzare le modifiche identificate per aggiornare il workspace? ‚Ä¶
S√¨, sincronizza le modifiche ed esegui i task
No, esegui i task senza sincronizzare le modifiche
```

Questo messaggio indica che NX ha rilevato alcuni file che possono essere aggiornati automaticamente. In questo caso, si riferisce ai file `tsconfig.json` che non hanno riferimenti TypeScript configurati sui progetti referenziati.

Seleziona l'opzione **S√¨, sincronizza le modifiche ed esegui i task** per procedere. Dovresti notare che tutti gli errori di import dell'IDE vengono risolti automaticamente poich√© il generatore sync aggiunger√† automaticamente i riferimenti TypeScript mancanti!

Tutti gli artefatti compilati sono ora disponibili nella cartella `dist/` situata alla radice del monorepo. Questa √® una pratica standard quando si utilizzano progetti generati da `@aws/nx-plugin` poich√© non inquina la struttura dei file con file generati. Nel caso in cui tu voglia pulire i file, elimina la cartella `dist/` senza preoccuparti degli artefatti di build sparsi nella struttura dei file.

Congratulazioni! Hai creato tutti i sotto-progetti necessari per iniziare a implementare il core del nostro gioco AI Dungeon Adventure.  üéâüéâüéâ