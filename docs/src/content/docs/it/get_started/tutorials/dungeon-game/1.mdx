---
title: "Gioco di Dungeon con IA"
description: "Una guida dettagliata su come costruire un gioco di avventura dungeon alimentato da IA utilizzando il plugin @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Modulo 1: Configurazione del monorepo

Inizieremo creando un nuovo monorepo. Esegui il seguente comando dalla directory desiderata:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

Questo configurerà un monorepo NX all'interno della directory `dungeon-adventure` che potrai aprire in vscode. Dovrebbe apparire come segue:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ qui risiederanno i tuoi sotto-progetti
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura la CLI NX e le impostazioni predefinite del monorepo
- package.json tutte le dipendenze node sono definite qui
- pnpm-lock.yaml o bun.lock, yarn.lock, package-lock.json in base al package manager
- pnpm-workspace.yaml se si utilizza pnpm
- README.md
- tsconfig.base.json esteso da tutti i sotto-progetti basati su node
- tsconfig.json
</FileTree>

Ora siamo pronti per iniziare a creare i diversi sotto-progetti utilizzando il plugin `@aws/nx-plugin`.

<Aside type="tip">È una best practice assicurarsi che tutti i file non committati siano salvati in Git prima di eseguire qualsiasi generatore. Ciò consente di visualizzare le modifiche dopo l'esecuzione del generatore tramite `git diff`</Aside>

### Game API

Iniziamo creando la nostra Game API. Per farlo, creiamo un'API tRPC chiamata `GameApi` seguendo questi passaggi:

<RunGenerator generator="ts#trpc-api" requiredParameters={{apiName:"GameApi"}} noInteractive />

<br />

Dovresti vedere alcuni nuovi file nel tuo albero delle directory.

<Aside>
Il `package.json` principale è ora configurato con un `type` impostato su `module`, il che significa che ESM è il tipo di modulo predefinito per tutti i sotto-progetti node gestiti dal plugin `@aws/nx-plugin`. Per maggiori dettagli su come lavorare con progetti TypeScript, consulta la <Link path="guides/typescript-project">guida ts#project</Link>.
</Aside>

<Drawer title="File aggiornati da ts#trpc-api" trigger="Clicca qui per esaminare questi file nel dettaglio.">
Di seguito è riportato l'elenco di tutti i file generati dal generatore `ts#trpc-api`. Esamineremo alcuni file chiave evidenziati nell'albero delle directory:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ costrutti CDK specifici per l'applicazione
          - apis/
            - **game-api.ts** costrutto CDK per creare l'API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ costrutti CDK generici
          - api/
            - rest-api.ts costrutto base CDK per un'API Gateway Rest API
            - trpc-utils.ts utility per i costrutti CDK delle API tRPC
            - utils.ts utility per i costrutti delle API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipi condivisi
      - src/
        - index.ts
        - runtime-config.ts definizione dell'interfaccia utilizzata sia da CDK che dal sito web
      - project.json
      - ...
  - game-api/
    - backend/ codice di implementazione tRPC
      - src/
        - client/ client vanilla tipicamente utilizzato per chiamate machine-to-machine
          - index.ts
          - sigv4.ts
        - middleware/ strumentazione Powertools
          - error.ts
          - index.ts
          - logger.ts
          - metrics.ts
          - tracer.ts
        - procedures/ implementazioni specifiche per le procedure/route dell'API
          - **echo.ts**
        - index.ts
        - init.ts configura il contesto e i middleware
        - local-server.ts utilizzato per eseguire il server tRPC localmente
        - **router.ts** punto di ingresso per l'handler lambda che definisce tutte le procedure
      - project.json
      - ...
    - schema/
      - src/
        - procedures/
          - **echo.ts**
        - index.ts
      - project.json
      - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Analizziamo alcuni file chiave:

```ts {5,12}
// packages/game-api/backend/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>,
  ) => ctx,
});

export type AppRouter = typeof appRouter;
```
Il router definisce il punto di ingresso per la tua API tRPC ed è il luogo dove dichiarerai tutti i metodi dell'API. Come puoi vedere sopra, abbiamo un metodo chiamato `echo` con la sua implementazione nel file `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/backend/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from ':dungeon-adventure/game-api-schema';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Questo file contiene l'implementazione del metodo `echo` ed è fortemente tipizzato dichiarando le strutture di dati di input e output. Importa queste definizioni dal progetto `:dungeon-adventure/game-api-schema`, che è un [alias](https://www.typescriptlang.org/tsconfig/paths.html) per il progetto schema.

<Aside type="tip">Se vedi un errore di importazione nel tuo IDE, è perché il nostro backend non ha ancora un riferimento TypeScript configurato nel suo tsconfig.json. Nx è stato [configurato](https://nx.dev/nx-api/js/generators/typescript-sync) per creare questi riferimenti *dinamicamente* quando viene eseguito un build/compile o se esegui manualmente il comando `nx sync`. Per maggiori informazioni, consulta la <Link path="guides/typescript-project#importing-your-library-code-inother-projects">guida TypeScript</Link>.</Aside>

```ts
// packages/game-api/schema/src/procedures/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Tutte le definizioni dello schema tRPC sono definite utilizzando [Zod](https://zod.dev/) ed esportate come tipi TypeScript tramite la sintassi `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api-backend';

// Tipo union per tutti i nomi delle operazioni API
type Operations = Procedures<AppRouter>;

/**
 * Proprietà per creare un costrutto GameApi
 *
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mappa dei nomi delle operazioni alle loro integrazioni API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un costrutto CDK che crea e configura un'API Gateway REST API di AWS
 * specificamente per GameApi.
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integrazioni predefinite per tutte le operazioni, implementando ciascuna operazione come
   * una singola funzione lambda.
   *
   * @param scope - Il costrutto CDK scope
   * @returns Un IntegrationBuilder con integrazioni lambda predefinite
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/backend/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Qui concediamo a qualsiasi credenziale AWS dell'account in cui il progetto è deployato di chiamare l'API.
          // È possibile definire qui accessi machine-to-machine granulari utilizzando principal più specifici (es. ruoli o
          // utenti) e risorse (es. quali percorsi API possono essere invocati da quale principal) se necessario.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Apriamo OPTIONS per consentire ai browser di effettuare richieste preflight non autenticate
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

Questo è il costrutto CDK che definisce la nostra GameApi. Come puoi vedere, fornisce un metodo `defaultIntegrations` che crea automaticamente una funzione lambda per ogni procedura nella nostra API tRPC, puntando all'implementazione dell'API già bundled. Ciò significa che al momento di `cdk synth`, il bundling non avviene (a differenza dell'uso di [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) poiché è già stato eseguito come parte del target di build del progetto backend.

</Drawer>

### Story API

Ora creiamo la nostra Story API. Per farlo, creiamo un'API Fast chiamata `StoryApi` seguendo questi passaggi:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi"}} noInteractive />

Dovresti vedere alcuni nuovi file nel tuo albero delle directory.
<Drawer title="File aggiornati da py#fast-api" trigger="Clicca qui per esaminare questi file nel dettaglio.">
Di seguito è riportato l'elenco di tutti i file generati dal generatore `py#fast-api`. Esamineremo alcuni file chiave evidenziati nell'albero delle directory:
<FileTree>
- .venv/ singolo virtual env per il monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ costrutti CDK specifici per l'applicazione
          - apis/
            - **story-api.ts** costrutto CDK per creare la tua Fast API
            - index.ts aggiornato per esportare la nuova story-api
      - project.json aggiornato per aggiungere una dipendenza di build su story_api
    - types/ tipi condivisi
      - src/
        - **runtime-config.ts** aggiornato per aggiungere la StoryApi
  - story_api/
    - story_api/ modulo Python
      - init.py configura Powertools, FastAPI e middleware
      - **main.py** punto di ingresso per la lambda contenente tutte le route
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version versione Python bloccata per uv
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import {
  OPERATION_DETAILS,
  Operations,
} from '../../generated/story-api/metadata.gen.js';

/**
 * Proprietà per creare un costrutto StoryApi
 *
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export interface StoryApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mappa dei nomi delle operazioni alle loro integrazioni API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un costrutto CDK che crea e configura un'API Gateway REST API di AWS
 * specificamente per StoryApi.
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export class StoryApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integrazioni predefinite per tutte le operazioni, implementando ciascuna operazione come
   * una singola funzione lambda.
   *
   * @param scope - Il costrutto CDK scope
   * @returns Un IntegrationBuilder con integrazioni lambda predefinite
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: OPERATION_DETAILS,
      defaultIntegrationOptions: {
        runtime: Runtime.PYTHON_3_12,
        handler: 'story_api.main.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/story_api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `StoryApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: StoryApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'StoryApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Qui concediamo a qualsiasi credenziale AWS dell'account in cui il progetto è deployato di chiamare l'API.
          // È possibile definire qui accessi machine-to-machine granulari utilizzando principal più specifici (es. ruoli o
          // utenti) e risorse (es. quali percorsi API possono essere invocati da quale principal) se necessario.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Apriamo OPTIONS per consentire ai browser di effettuare richieste preflight non autenticate
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: OPERATION_DETAILS,
      ...props,
    });
  }
}

```

Questo è il costrutto CDK che definisce la nostra StoryApi. Come puoi vedere, fornisce un metodo `defaultIntegrations` che crea automaticamente una funzione lambda per ogni operazione definita nella nostra FastAPI, puntando all'implementazione dell'API già bundled. Ciò significa che al momento di `cdk synth`, il bundling non avviene (a differenza di [PythonFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/@aws-cdk_aws-lambda-python-alpha.PythonFunction.html)) poiché è già stato eseguito come parte del target di build del progetto backend.

```diff lang="ts"
// packages/common/types/src/runtime-config.ts
export type ApiUrl = string;
// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-empty-interface
export interface IRuntimeConfig {
  apis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

Ecco un esempio del generatore che esegue una trasformazione AST preservando tutto il codice esistente e aggiungendo un aggiornamento. Qui puoi vedere che `StoryApi` è stata aggiunta alla definizione di `IRuntimeConfig`, il che significa che quando verrà utilizzata dal frontend, garantirà la type safety!

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

Questo è dove verranno definiti tutti i metodi della tua API. Come puoi vedere qui, abbiamo un metodo `read_root` mappato alla route `GET /`. Puoi utilizzare [Pydantic](https://docs.pydantic.dev/latest/) per dichiarare input e output dei metodi e garantire la type safety.

</Drawer>

### Game UI: Sito web

Ora creiamo l'interfaccia utente che ti permetterà di interagire con il gioco. Per farlo, creiamo un sito web chiamato `GameUI` seguendo questi passaggi:

<RunGenerator generator="ts#cloudscape-website" requiredParameters={{name:"GameUI"}} noInteractive />

Dovresti vedere alcuni nuovi file nel tuo albero delle directory.

<Drawer title="File aggiornati da ts#cloudscape-website" trigger="Clicca qui per esaminare questi file nel dettaglio.">
Di seguito è riportato l'elenco di tutti i file generati dal generatore `ts#cloudscape-website`. Esamineremo alcuni file chiave evidenziati nell'albero delle directory:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ costrutti CDK specifici per l'applicazione
          - static-websites/
            - **game-ui.ts** costrutto CDK per creare la tua Game UI
        - core/
          - static-website.ts costrutto generico per siti web statici
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts layout complessivo della pagina: header, footer, sidebar, ecc
          - navitems.ts elementi di navigazione della sidebar
      - hooks/
        - useAppLayout.tsx permette di impostare dinamicamente elementi come notifiche, stile della pagina, ecc
      - routes/ route basate su file di @tanstack/react-router
        - index.tsx pagina root '/' che reindirizza a '/welcome'
        - __root.tsx tutte le pagine utilizzano questo componente come base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** entrypoint React
        - routeTree.gen.ts questo file viene aggiornato automaticamente da @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Questo è il costrutto CDK che definisce la nostra GameUI. Come puoi vedere, ha già configurato il percorso del file al bundle generato per l'interfaccia basata su Vite. Ciò significa che al momento del `build`, il bundling avviene all'interno del target di build del progetto game-ui e il suo output viene utilizzato qui.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Registra l'istanza del router per la type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Questo è il punto di ingresso dove viene montato React. Come mostrato, inizialmente configura un `@tanstack/react-router` in una configurazione [`file-based-routing`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Ciò significa che, finché il server di sviluppo è in esecuzione, puoi semplicemente creare file nella cartella `routes` e `@tanstack/react-router` creerà automaticamente il boilerplate necessario, aggiornando il file `routeTree.gen.ts`. Questo file mantiene tutte le route in modo type-safe, quindi quando usi `<Link>`, l'opzione `to` mostrerà solo route valide. Per maggiori informazioni, consulta la [documentazione di `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un componente che verrà renderizzato quando si naviga alla route `/welcome`. `@tanstack/react-router` gestirà la `Route` per te ogni volta che crei/sposti questo file (finché il dev server è in esecuzione). Questo verrà mostrato in una sezione successiva di questo tutorial.

</Drawer>

### Game UI: Autenticazione

Ora configuriamo la nostra Game UI per richiedere l'accesso autenticato tramite Amazon Cognito seguendo questi passaggi:

<RunGenerator generator="ts#cloudscape-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Dovresti vedere alcuni nuovi file/modifiche nel tuo albero delle directory.

<Drawer title="File aggiornati da ts#cloudscape-website#auth" trigger="Clicca qui per esaminare questi file nel dettaglio.">
Di seguito è riportato l'elenco di tutti i file generati/modificati dal generatore `ts#cloudscape-website#auth`. Esamineremo alcuni file chiave evidenziati nell'albero delle directory:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts costrutto CDK per creare pool di utenti/identità
    - types/
      - src/
        - runtime-config.ts aggiornato per aggiungere cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx aggiunge l'utente loggato/logout all'header
        - CognitoAuth/
          - index.ts gestisce il login in Cognito
        - RuntimeConfig/
          - index.tsx recupera il `runtime-config.json` e lo fornisce ai figli via contesto
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Aggiornato per aggiungere Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra l'istanza del router per la type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

I componenti `RuntimeConfigProvider` e `CognitoAuth` sono stati aggiunti al file `main.tsx` tramite una trasformazione AST. Ciò permette al componente `CognitoAuth` di autenticarsi con Amazon Cognito recuperando il `runtime-config.json` che contiene la configurazione di connessione Cognito necessaria per effettuare chiamate al backend verso la destinazione corretta.

</Drawer>

### Game UI: Connessione alla Story API

Ora configuriamo la nostra Game UI per connettersi alla Story API creata precedentemente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

Dovresti vedere alcuni nuovi file/modifiche nel tuo albero delle directory.

<Drawer title="File aggiornati da UI -> FastAPI api-connection" trigger="Clicca qui per esaminare questi file nel dettaglio.">
Di seguito è riportato l'elenco di tutti i file generati/modificati dal generatore `api-connection`. Esamineremo alcuni file chiave evidenziati nell'albero delle directory:
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx utilizzato da StoryApi per firmare le richieste
        - useStoryApiClient.tsx hook per costruire un client StoryApi
        - useStoryApi.tsx hook per interagire con StoryApi utilizzando TanStack Query
      - components/
        - QueryClientProvider.tsx provider del client TanStack Query
        - StoryApiProvider.tsx Provider per l'hook TanStack Query di StoryApi
      - main.tsx Inietta il QueryClientProvider e StoryApiProvider
    - .gitignore ignora i file client generati
    - project.json aggiornato per aggiungere target per la generazione di hook openapi
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json aggiornato per emettere un file openapi.json

</FileTree>

```tsx {1,12-15}
// packages/game-ui/src/hooks/useStoryApiClient.tsx
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

Questo hook può essere utilizzato per effettuare richieste API autenticate alla `StoryApi`. Come puoi vedere nell'implementazione, utilizza `StoryApi` che viene generato al momento del build, quindi vedrai un errore nel tuo IDE finché non eseguiremo il build del codice. Per maggiori dettagli su come viene generato il client o su come consumare l'API, consulta la <Link path="guides/api-connection/react-fastapi">guida React to FastAPI</Link>.

```tsx
// packages/game-ui/src/components/StoryApiProvider.tsx
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useStoryApiClient } from '../hooks/useStoryApiClient';
import { StoryApiOptionsProxy } from '../generated/story-api/options-proxy.gen';

export const StoryApiContext = createContext<StoryApiOptionsProxy | undefined>(
  undefined,
);

export const StoryApiProvider: FC<PropsWithChildren> = ({ children }) => {
  const client = useStoryApiClient();
  const optionsProxy = useMemo(
    () => new StoryApiOptionsProxy({ client }),
    [client],
  );

  return (
    <StoryApiContext.Provider value={optionsProxy}>
      {children}
    </StoryApiContext.Provider>
  );
};

export default StoryApiProvider;
```

Il componente provider sopra utilizza l'hook `useStoryApiClient` e istanzia `StoryApiOptionsProxy`, utilizzato per costruire opzioni per gli hook TanStack Query. Puoi utilizzare l'hook corrispondente `useStoryApi` per accedere a questo options proxy, che fornisce un modo per interagire con la tua FastAPI in modo coerente con la tua API tRPC.

Poiché `useStoryApiClient` ci fornisce un async iterator per la nostra streaming API, in questo tutorial utilizzeremo direttamente il client vanilla.

<Aside type="caution">
I file `src/generated/story-api/*.gen.ts` non devono mai essere modificati manualmente poiché verranno rigenerati ogni volta che esegui il build della tua API.
</Aside>

</Drawer>

### Game UI: Connessione alla Game API

Ora configuriamo la nostra Game UI per connettersi alla Game API creata precedentemente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api-backend"}} noInteractive />

Dovresti vedere alcuni nuovi file/modifiche nel tuo albero delle directory.

<Drawer title="File aggiornati da UI -> tRPC api-connection" trigger="Clicca qui per esaminare questi file nel dettaglio.">
Di seguito è riportato l'elenco di tutti i file generati/modificati dal generatore `api-connection`. Esamineremo alcuni file chiave evidenziati nell'albero delle directory:
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - TrpcClients/
          - index.tsx
          - TrpcApis.tsx tutte le API tRPC configurate
          - TrpcClientProviders.tsx crea un client provider per ogni API tRPC
          - TrpcProvider.tsx
      - hooks/
        - **useGameApi.tsx** hook per chiamare la GameApi
      - **main.tsx** inietta i provider client trpc
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { TrpcApis } from '../components/TrpcClients';

export const useGameApi = () => TrpcApis.GameApi.useTRPC();
```

Questo hook utilizza l'ultima [integrazione React Query di tRPC](https://trpc.io/blog/introducing-tanstack-react-query-client), permettendo agli utenti di interagire direttamente con `@tanstack/react-query` senza ulteriori livelli di astrazione. Per esempi su come chiamare API tRPC, consulta la <Link path="guides/api-connection/react-trpc#using-the-generated-code">guida sull'utilizzo dell'hook tRPC</Link>.

<Aside>
L'hook `useGameApi` è diverso dall'hook `useStoryApi` perché non richiede un build per riflettere le modifiche grazie all'uso di [TypeScript inference](https://trpc.io/docs/concepts) da parte di tRPC. Ciò consente agli sviluppatori di apportare modifiche al backend che vengono immediatamente riflesse nel frontend!
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import TrpcClientProviders from './components/TrpcClients';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra l'istanza del router per la type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <TrpcClientProviders>
                <RouterProvider router={router} />
+              </TrpcClientProviders>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Il file `main.tsx` è stato aggiornato tramite una trasformazione AST per iniettare i provider tRPC.

</Drawer>

### Game UI: Infrastruttura

Ora l'ultimo sotto-progetto che dobbiamo creare è per l'infrastruttura CDK. Per crearlo, segui questi passaggi:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Dovresti vedere alcuni nuovi file/modifiche nel tuo albero delle directory.

<Drawer title="File aggiornati da ts#infra" trigger="Clicca qui per esaminare questi file nel dettaglio.">
Di seguito è riportato l'elenco di tutti i file generati/modificati dal generatore `ts#infra`. Esamineremo alcuni file chiave evidenziati nell'albero delle directory:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts** risorse CDK definite qui
      - index.ts
      - **main.ts** entrypoint che definisce tutti gli stack
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json aggiunge riferimenti
  - tsconfig.base.json aggiunge alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
  App,
  CfnGuardValidator,
  RuleSet,
} from ':dungeon-adventure/common-constructs';

const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

// Utilizza questo per deployare il tuo ambiente sandbox (presuppone le credenziali CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

Questo è l'entrypoint per la tua applicazione CDK.

È configurato per utilizzare [`cfn-guard`](https://github.com/cdklabs/cdk-validator-cfnguard) per eseguire la validazione dell'infrastruttura basata sul set di regole configurato. Questo viene strumentato post-sintesi.

<Aside type="tip">
Potrebbero esserci casi in cui desideri sopprimere determinate regole su risorse specifiche. Puoi farlo in due modi:

###### Sopprimi una regola su un costrutto specifico

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// sopprime la RULE_NAME per il costrutto specificato.
suppressRule(construct, 'RULE_NAME');
```

###### Sopprimi una regola su un costrutto discendente

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// Sopprime la RULE_NAME per il costrutto o qualsiasi suo discendente se è un'istanza di Bucket
suppressRule(construct, 'RULE_NAME', (construct) => construct instanceof Bucket);
```
</Aside>

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Il codice che definisce il tuo stack va qui
  }
}
```

Questo è dove istanzieremo i nostri costrutti CDK per costruire il nostro gioco dungeon adventure.

</Drawer>

#### Aggiornare l'infrastruttura

Apportiamo un aggiornamento al file `packages/infra/src/stacks/application-stack.ts` per istanziare alcuni dei costrutti già generati:

```diff lang="ts"
+import {
+  GameApi,
+  GameUI,
+  StoryApi,
+  UserIdentity,
+} from ':dungeon-adventure/common-constructs';
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

-    // Il codice che definisce il tuo stack va qui
+    const userIdentity = new UserIdentity(this, 'UserIdentity');
+
+    const gameApi = new GameApi(this, 'GameApi', {
+      integrations: GameApi.defaultIntegrations(this).build(),
+    });
+    const storyApi = new StoryApi(this, 'StoryApi', {
+      integrations: StoryApi.defaultIntegrations(this).build(),
+    });
+
+    // concede al nostro ruolo autenticato l'accesso per invocare le nostre API
+    [storyApi, gameApi].forEach((api) =>
+      api.grantInvokeAccess(userIdentity.identityPool.authenticatedRole),
+    );
+
+    // Assicurati che questo sia istanziato per ultimo così il runtime-config.json può essere configurato automaticamente
+    new GameUI(this, 'GameUI');
  }
}

```

Nota che forniamo integrazioni predefinite per le nostre due API. Di default, ogni operazione nelle nostre API è mappata a una singola funzione lambda per gestire quell'operazione.

### Compilare il codice

<Drawer title="Comandi Nx" trigger="Ora è il momento di compilare il nostro codice per la prima volta">
###### Target singolo vs multipli

Il comando `run-many` eseguirà un target su più sotto-progetti elencati (`--all` li selezionerà tutti). Garantirà che le dipendenze siano eseguite nell'ordine corretto.

Puoi anche attivare un build (o qualsiasi altro task) per un target di progetto singolo eseguendo il target direttamente sul progetto. Ad esempio, se vogliamo compilare il progetto `@dungeon-adventure/infra`, puoi eseguire il seguente comando:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualizzare le dipendenze

Puoi anche visualizzare le tue dipendenze tramite:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Cache

Nx si affida alla [cache](https://nx.dev/concepts/how-caching-works) per riutilizzare artefatti da build precedenti e velocizzare lo sviluppo. È necessaria una configurazione per farlo funzionare correttamente e potrebbero esserci casi in cui vuoi eseguire un build **senza utilizzare la cache**. Per farlo, aggiungi semplicemente l'argomento `--skip-nx-cache` al tuo comando. Ad esempio:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Se per qualsiasi motivo desideri cancellare la tua cache (memorizzata nella cartella `.nx`), puoi eseguire il seguente comando:

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

Dovresti visualizzare il seguente prompt:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? …
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Questo messaggio indica che NX ha rilevato alcuni file che possono essere aggiornati automaticamente. In questo caso, si riferisce ai file `tsconfig.json` che non hanno riferimenti TypeScript configurati sui progetti dipendenti. Seleziona l'opzione **Yes, sync the changes and run the tasks** per procedere. Noterai che tutti gli errori di importazione nel tuo IDE verranno automaticamente risolti poiché il generatore di sync aggiungerà i riferimenti TypeScript mancanti automaticamente!

<Aside type="tip">
Se incontri errori di lint, puoi eseguire il seguente comando per correggerli automaticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

<Aside type="caution" title="Errore di build su Windows">
<Drawer trigger="Se sei su Windows e incontri un errore di build/synth, clicca qui." title="Errore di build su Windows">
Se incontri un errore di build/synth per il progetto `@dungeon-adventure/infra`, questo è atteso poiché la libreria che strumenta `cfn-guard` attualmente non supporta Windows. C'è una richiesta di funzionalità che lo tiene traccia, ma nel frattempo possiamo disabilitare `cfn-guard` modificando il file `packages/infra/src/main.ts` come segue:

```diff lang="ts"
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
   App,
-  CfnGuardValidator,
-  RuleSet,
} from ':dungeon-adventure/common-constructs';
-
-const app = new App({
-  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
-});
+const app = new App();

// Utilizza questo per deployare il tuo ambiente sandbox (presuppone le credenziali CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```
</Drawer>
</Aside>

Tutti gli artefatti compilati sono ora disponibili nella cartella `dist/` alla radice del monorepo. Questa è una pratica standard quando si utilizzano progetti generati dal plugin `@aws/nx-plugin`, poiché non inquina l'albero delle directory con file generati. Se desideri pulire i tuoi file, puoi semplicemente eliminare la cartella `dist/` senza preoccuparti di file generati sparsi nell'albero delle directory.

Complimenti! Hai creato tutti i sotto-progetti necessari per iniziare a implementare il cuore del nostro gioco Dunegeon Adventure.  🎉🎉🎉