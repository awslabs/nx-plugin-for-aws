---
title: "Configurare un monorepo"
description: "Una guida dettagliata su come costruire un gioco di avventura in dungeon alimentato da IA agentiva utilizzando @aws/nx-plugin."
---

import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Task 1: Creare un monorepo

Per creare un nuovo monorepo, esegui il seguente comando dalla directory desiderata:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" iacProvider="CDK" />

:::note
Utilizziamo `--iacProvider=CDK` poiché useremo CDK per l'infrastructure as code in questo tutorial. Il Plugin Nx per AWS supporta anche `Terraform`.
:::

Questo configurerà un monorepo NX all'interno della directory `dungeon-adventure`. Quando apri la directory in VSCode, vedrai questa struttura di file:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ qui risiederanno i tuoi sotto-progetti
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura la CLI NX e le impostazioni predefinite del monorepo
- package.json tutte le dipendenze Node sono definite qui
- pnpm-lock.yaml o bun.lock, yarn.lock, package-lock.json in base al package manager
- pnpm-workspace.yaml se si utilizza pnpm
- README.md
- tsconfig.base.json esteso da tutti i sotto-progetti basati su Node
- tsconfig.json
- aws-nx-plugin.config.mts configurazione per il Plugin Nx per AWS
</FileTree>

Ora possiamo iniziare a creare i diversi sotto-progetti utilizzando `@aws/nx-plugin`.

<Aside type="tip">È una best practice assicurarsi che tutti i file non staged siano committati in Git prima di eseguire qualsiasi generatore. Questo permette di visualizzare le modifiche dopo l'esecuzione tramite `git diff`.</Aside>

## Task 2: Creare una Game API

Per prima cosa, creiamo la nostra Game API. Per farlo, creiamo un'API tRPC chiamata `GameApi` seguendo questi passaggi:

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

Vedrai alcuni nuovi file apparire nella struttura delle cartelle.

<Aside>
Il `package.json` principale è ora configurato con `type` impostato a `module`, il che significa che ESM è il tipo di modulo predefinito per tutti i sotto-progetti Node generati da `@aws/nx-plugin`. 
Per maggiori dettagli sui progetti TypeScript, consulta la <Link path="guides/typescript-project">guida del generatore ts#project</Link>.
</Aside>

<Drawer title="File aggiornati da ts#trpc-api" trigger="Clicca qui per esaminare questi file in dettaglio.">
Di seguito l'elenco dei file generati dal generatore `ts#trpc-api`. Esamineremo alcuni file chiave evidenziati nella struttura:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ CDK constructs specifici per l'applicazione
          - apis/
            - **game-api.ts** CDK construct per creare l'API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ CDK constructs generici
          - api/
            - rest-api.ts CDK construct base per API Gateway Rest API
            - trpc-utils.ts utility per CDK constructs di API tRPC
            - utils.ts utility per i constructs API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipi condivisi
      - src/
        - index.ts
        - runtime-config.ts definizione dell'interfaccia usata sia da CDK che dal sito web
      - project.json
      - ...
  - game-api/ API tRPC
    - src/
      - client/ client vanilla tipicamente usato per chiamate machine-to-machine in TS
        - index.ts
        - sigv4.ts
      - middleware/ strumentazione Powertools
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ definizioni di input e output per l'API
        - **echo.ts**
      - procedures/ implementazioni specifiche delle procedure/route dell'API
        - **echo.ts**
      - index.ts
      - init.ts configura contesto e middleware
      - local-server.ts usato per eseguire il server tRPC localmente
      - **router.ts** entrypoint per il lambda handler che definisce tutte le procedure
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Esaminiamo questi file chiave:

```ts {5,12}
// packages/game-api/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
Il router definisce l'entrypoint per l'API tRPC ed è dove dichiarerai tutti i metodi dell'API. Come visibile sopra, abbiamo un metodo chiamato `echo` con l'implementazione nel file `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Questo file implementa il metodo `echo` ed è fortemente tipizzato dichiarando le strutture dati di input e output.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Tutte le definizioni degli schema tRPC sono create con [Zod](https://zod.dev/) ed esportate come tipi TypeScript tramite la sintassi `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// Tipo union per tutti i nomi delle operazioni API
type Operations = Procedures<AppRouter>;

/**
 * Proprietà per creare un construct GameApi
 *
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mappa dei nomi delle operazioni alle integrazioni API Gateway
   */
  integrations: TIntegrations;
}

/**
 * CDK construct che crea e configura un'API REST API Gateway AWS
 * specifica per GameApi.
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integrazioni predefinite per tutte le operazioni, implementando ciascuna operazione
   * come singola funzione lambda.
   *
   * @param scope - Scope del construct CDK
   * @returns IntegrationBuilder con integrazioni lambda predefinite
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Concediamo a qualsiasi credenziale AWS dell'account di deployment di chiamare l'API.
          // È possibile definire qui accessi granulari machine-to-machine usando principal specifici
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Apriamo OPTIONS per permettere ai browser richieste preflight non autenticate
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

Questo è il CDK construct che definisce la nostra `GameApi`. Fornisce un metodo `defaultIntegrations` che crea automaticamente una funzione Lambda per ogni procedura nell'API tRPC, puntando all'implementazione bundled. Ciò significa che al momento di `cdk synth` non avviene il bundling (a differenza di [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) poiché è già stato eseguito come parte del target di build del progetto backend.

</Drawer>

## Task 3: Creare gli Story agents

Ora creiamo i nostri Story Agents. 

### Story agent: Progetto Python

Per creare un progetto Python:

<RunGenerator generator="py#project" requiredParameters={{name:"story"}} noInteractive />

Vedrai alcuni nuovi file apparire nella struttura delle cartelle.
<Drawer title="File aggiornati da py#project" trigger="Clicca qui per esaminare questi file in dettaglio.">
Il generatore `py#project` genera questi file:

<FileTree>
- .venv/ virtual env condiviso per il monorepo
- packages/
  - story/
    - dungeon_adventure_story/ modulo Python
      - hello.py file Python di esempio (ignorabile)
    - tests/
    - .python-version
    - pyproject.toml
    - project.json
- .python-version versione Python bloccata per UV
- pyproject.toml
- uv.lock
</FileTree>

Questo ha configurato un progetto Python e un [UV Workspace](https://docs.astral.sh/uv/concepts/projects/workspaces/) con ambiente virtuale condiviso.

</Drawer>

### Story agent: Agente Strands

Per aggiungere un agente Strands al progetto con il generatore `py#strands-agent`:

<RunGenerator generator="py#strands-agent" requiredParameters={{project:"story"}} noInteractive />

Vedrai alcuni nuovi file apparire nella struttura delle cartelle.
<Drawer title="File aggiornati da py#strands-agent" trigger="Clicca qui per esaminare questi file in dettaglio.">
Il generatore `py#strands-agent` genera questi file:

<FileTree>
- packages/
  - story/
    - dungeon_adventure_story/ modulo Python
      - agent/
        - main.py entrypoint per l'agente in Bedrock AgentCore Runtime
        - agent.py definisce un agente e strumenti di esempio
        - agentcore_mcp_client.py utility per client MCP
        - Dockerfile definisce l'immagine Docker per il deployment in AgentCore Runtime
  - common/constructs/
    - src
      - core/agent-core/
        - runtime.ts construct generico per deployment in AgentCore Runtime
      - app/agents/story-agent/
        - story-agent.ts construct per deployare lo Story agent in AgentCore Runtime
</FileTree>

Esaminiamo alcuni file in dettaglio:

```python
# agent/agent.py
from contextlib import contextmanager

from strands import Agent, tool
from strands_tools import current_time


# Definisci uno strumento personalizzato
@tool
def add(a: int, b: int) -> int:
    return a + b


@contextmanager
def get_agent(session_id: str):
    yield Agent(
        system_prompt="""
Sei un mago delle addizioni.
Usa lo strumento 'add' per le operazioni di addizione.
Riferisciti agli strumenti come al tuo 'grimorio'.
""",
        tools=[add, current_time],
    )
```

Questo crea un agente Strands di esempio e definisce uno strumento di addizione.

```python
# agent/main.py
from bedrock_agentcore.runtime import BedrockAgentCoreApp

from .agent import get_agent

app = BedrockAgentCoreApp()


@app.entrypoint
async def invoke(payload, context):
    """Handler per l'invocazione dell'agente"""
    prompt = payload.get(
        "prompt", "Nessun prompt trovato nell'input, guida l'utente "
        "a creare un payload JSON con chiave prompt"
    )

    with get_agent(session_id=context.session_id) as agent:
        stream = agent.stream_async(prompt)
        async for event in stream:
            print(event)
            yield (event)


if __name__ == "__main__":
    app.run()
```

Questo è l'entrypoint dell'agente, configurato con [Amazon Bedrock AgentCore SDK](https://github.com/aws/bedrock-agentcore-sdk-python). Utilizza il supporto streaming di Strands per inviare eventi al client in tempo reale.

```ts
// common/constructs/src/app/agents/story-agent.ts
import { Lazy, Names } from 'aws-cdk-lib';
import { DockerImageAsset, Platform } from 'aws-cdk-lib/aws-ecr-assets';
import { Construct } from 'constructs';
import { execSync } from 'child_process';
import * as path from 'path';
import * as url from 'url';
import {
  AgentCoreRuntime,
  AgentCoreRuntimeProps,
} from '../../../core/agent-core/runtime.js';

export type StoryAgentProps = Omit<
  AgentCoreRuntimeProps,
  'runtimeName' | 'serverProtocol' | 'containerUri'
>;

export class StoryAgent extends Construct {
  public readonly dockerImage: DockerImageAsset;
  public readonly agentCoreRuntime: AgentCoreRuntime;

  constructor(scope: Construct, id: string, props?: StoryAgentProps) {
    super(scope, id);

    this.dockerImage = new DockerImageAsset(this, 'DockerImage', {
      platform: Platform.LINUX_ARM64,
      directory: path.dirname(url.fileURLToPath(new URL(import.meta.url))),
      extraHash: execSync(
        `docker inspect dungeon-adventure-story-agent:latest --format '{{.Id}}'`,
        { encoding: 'utf-8' },
      ).trim(),
    });

    this.agentCoreRuntime = new AgentCoreRuntime(this, 'StoryAgent', {
      runtimeName: Lazy.string({
        produce: () =>
          Names.uniqueResourceName(this.agentCoreRuntime, { maxLength: 40 }),
      }),
      serverProtocol: 'HTTP',
      containerUri: this.dockerImage.imageUri,
      ...props,
    });
  }
}
```

Questo configura un `DockerImageAsset` CDK che carica l'immagine Docker dell'agente su ECR e la ospita usando AgentCore Runtime.

Potresti notare un `Dockerfile` aggiuntivo che referenzia l'immagine Docker dal progetto `story`, permettendo di collocare Dockerfile e codice sorgente insieme.

</Drawer>

## Task 4: Configurare gli strumenti di inventario

### Inventory: Progetto TypeScript

Creiamo un server MCP che fornirà strumenti allo Story Agent per gestire l'inventario del giocatore.

Iniziamo creando un progetto TypeScript:

<RunGenerator generator="ts#project" requiredParameters={{name:"inventory"}} noInteractive />

Questo creerà un progetto TypeScript vuoto.

<Drawer title="File aggiornati da ts#project" trigger="Clicca qui per esaminare questi file in dettaglio.">
Il generatore `ts#project` genera questi file. 

<FileTree>
- packages/
  - inventory/
    - src/
      - index.ts entry point con funzione di esempio
    - project.json configurazione del progetto
    - eslint.config.mjs configurazione lint
    - vite.config.ts configurazione test
    - tsconfig.json configurazione TypeScript base
    - tsconfig.lib.json configurazione per compilazione e bundling
    - tsconfig.spec.json configurazione per i test
- tsconfig.base.json aggiornato con alias per riferire questo progetto
</FileTree>

</Drawer>

### Inventory: Server MCP

Aggiungiamo un server MCP al progetto TypeScript:

<RunGenerator generator="ts#mcp-server" requiredParameters={{project:"inventory"}} noInteractive />

Questo aggiungerà un server MCP.
<Drawer title="File aggiornati da ts#mcp-server" trigger="Clicca qui per esaminare questi file in dettaglio.">
Il generatore `ts#mcp-server` genera questi file.

<FileTree>
- packages/
  - inventory/
    - src/mcp-server/
      - server.ts crea il server MCP
      - tools/
        - add.ts strumento di esempio
      - resources/
        - sample-guidance.ts risorsa di esempio
      - stdio.ts entry point per MCP con trasporto STDIO
      - http.ts entry point per MCP con trasporto HTTP streamable
      - Dockerfile builda l'immagine per AgentCore Runtime
    - rolldown.config.ts configurazione per il bundling del server MCP
  - common/constructs/
    - src
      - app/mcp-servers/inventory-mcp-server/
        - inventory-mcp-server.ts construct per deployare il server MCP in AgentCore Runtime
</FileTree>

</Drawer>

## Task 5: Creare l'interfaccia utente (UI)

In questo task, creeremo l'interfaccia utente che ti permetterà di interagire con il gioco.

### Game UI: Sito Web

Per creare l'interfaccia utente, creiamo un sito web chiamato `GameUI` seguendo questi passaggi:

<RunGenerator generator="ts#react-website" requiredParameters={{name:"GameUI"}} noInteractive />

Vedrai alcuni nuovi file apparire nella struttura delle cartelle.

<Drawer title="File aggiornati da ts#react-website" trigger="Clicca qui per esaminare questi file in dettaglio.">
Il generatore `ts#react-website` genera questi file. Esaminiamo alcuni file chiave evidenziati nella struttura:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ CDK constructs specifici per l'applicazione
          - static-websites/
            - **game-ui.ts** CDK construct per creare la Game UI
        - core/
          - static-website.ts construct generico per siti statici
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts layout generale della pagina: header, footer, sidebar, ecc
          - navitems.ts elementi di navigazione sidebar
      - hooks/
        - useAppLayout.tsx permette di impostare notifiche, stile pagina, ecc
      - routes/ routing basato su file @tanstack/react-router
        - index.tsx root '/' reindirizza a '/welcome'
        - __root.tsx componente base per tutte le pagine
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** entrypoint React
        - routeTree.gen.ts generato automaticamente da @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteName: 'GameUI',
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Questo è il CDK construct che definisce la nostra GameUI. Ha già configurato il percorso del bundle generato per la nostra UI basata su Vite. Ciò significa che al momento della `build`, il bundling avviene all'interno del target di build del progetto game-ui e l'output viene utilizzato qui.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Registra l'istanza del router per type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Questo è l'entry point dove React viene montato. Come mostrato, inizialmente configura solo un `@tanstack/react-router` in una configurazione [`file-based-routing`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Finché il server di sviluppo è in esecuzione, puoi creare file nella cartella `routes` e `@tanstack/react-router` creerà automaticamente la configurazione boilerplate per te, aggiornando anche il file `routeTree.gen.ts`. Questo file mantiene tutte le route in modo type-safe, il che significa che quando usi `<Link>`, l'opzione `to` mostrerà solo route valide. 
Per maggiori informazioni, consulta la [documentazione di `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Benvenuto nel tuo nuovo sito Cloudscape!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un componente verrà renderizzato quando si naviga verso la route `/welcome`. `@tanstack/react-router` gestirà la `Route` per te ogni volta che crei/sposti questo file (finché il server dev è in esecuzione).

</Drawer>

### Game UI: Autenticazione

Configuriamo la nostra Game UI per richiedere autenticazione tramite Amazon Cognito seguendo questi passaggi:

<RunGenerator generator="ts#react-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Vedrai alcuni nuovi file apparire/cambiare nella struttura delle cartelle.

<Drawer title="File aggiornati da ts#react-website#auth" trigger="Clicca qui per esaminare questi file in dettaglio.">
Il generatore `ts#react-website#auth` aggiorna/genera questi file. Esaminiamo alcuni file chiave evidenziati nella struttura:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts CDK construct per pool utenti/identità
    - types/
      - src/
        - runtime-config.ts aggiornato con cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx aggiunge utente/logout nell'header
        - CognitoAuth/
          - index.ts gestisce il login a Cognito
        - RuntimeConfig/
          - index.tsx recupera `runtime-config.json` e lo fornisce via context
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Aggiornato con Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra l'istanza del router per type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

I componenti `RuntimeConfigProvider` e `CognitoAuth` sono stati aggiunti al file `main.tsx` tramite una trasformazione AST. Questo permette al componente `CognitoAuth` di autenticarsi con Amazon Cognito recuperando il `runtime-config.json` che contiene la configurazione necessaria per effettuare le chiamate backend alla destinazione corretta.

</Drawer>

### Game UI: Connessione alla Game API

Configuriamo la nostra Game UI per connettersi alla Game API creata precedentemente.

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

Vedrai alcuni nuovi file apparire/cambiare nella struttura delle cartelle.

<Drawer title="File aggiornati da UI -> tRPC api-connection" trigger="Clicca qui per esaminare questi file in dettaglio.">
Il generatore `api-connection` genera/aggiorna questi file. Esaminiamo alcuni file chiave evidenziati nella struttura:

<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx configura il client GameAPI
      - hooks/
        - **useGameApi.tsx** hook per chiamare la GameApi
      - **main.tsx** inietta i provider trpc client
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { GameApiTRCPContext } from '../components/GameApiClientProvider';

export const useGameApi = GameApiTRCPContext.useTRPC;
```

Questo hook utilizza l'ultima integrazione di tRPC con [React Query](https://trpc.io/blog/introducing-tanstack-react-query-client) permettendo agli utenti di interagire direttamente con `@tanstack/react-query` senza ulteriori livelli di astrazione. Per esempi su come chiamare le API tRPC, consulta la <Link path="guides/api-connection/react-trpc#using-the-generated-code">guida all'utilizzo dell'hook tRPC</Link>.

<Aside>
L'hook `useGameApi` è diverso dall'hook `useStoryApi` poiché non richiede una build per riflettere le modifiche grazie all'utilizzo dell'[inferenza TypeScript](https://trpc.io/docs/concepts) di tRPC. Questo permette agli sviluppatori di apportare modifiche al backend che si riflettono istantaneamente nel frontend.
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra l'istanza del router per type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <RouterProvider router={router} />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Il file `main.tsx` è stato aggiornato tramite una trasformazione AST per iniettare i provider tRPC.

</Drawer>

### Game UI: Infrastruttura

Creiamo il progetto finale per l'infrastruttura CDK.

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Vedrai alcuni nuovi file apparire/cambiare nella struttura delle cartelle.

<Drawer title="File aggiornati da ts#infra" trigger="Clicca qui per esaminare questi file in dettaglio.">
Il generatore `ts#infra` genera/aggiorna questi file. Esaminiamo alcuni file chiave evidenziati nella struttura:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - checkov.ts
          - index.ts
  - infra
    - src/
      - stages/
        - **application-stage.ts** stack CDK definiti qui
      - stacks/
        - **application-stack.ts** risorse CDK definite qui
      - index.ts
      - **main.ts** entrypoint che definisce tutti gli stage
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json aggiunti riferimenti
  - tsconfig.base.json aggiunto alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStage } from './stacks/application-stage.js';
import { App } from ':dungeon-adventure/common-constructs';

const app = new App();

// Deploya un ambiente sandbox personale (richiede credenziali CLI)
new ApplicationStage(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
});

app.synth();
```

<Aside type="tip">Se vedi un errore di import nel tuo IDE, è perché il progetto infrastruttura non ha ancora un riferimento TypeScript configurato nel `tsconfig.json`. Nx è stato [configurato](https://nx.dev/nx-api/js/generators/typescript-sync) per creare questi riferimenti *dinamicamente* ogni volta che viene eseguita una build/compilazione o se esegui manualmente il comando `nx sync`. Per maggiori informazioni consulta la <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guida TypeScript</Link>.</Aside>

Questo è l'entry point per l'applicazione CDK.

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Il codice che definisce lo stack va qui
  }
}
```

Istanzieremo i nostri CDK constructs per costruire il gioco dungeon adventure.

</Drawer>

## Task 6: Aggiornare l'infrastruttura

Aggiorniamo `packages/infra/src/stacks/application-stack.ts` per istanziare alcuni dei nostri constructs generati:

<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

:::note 
Forniamo integrazioni predefinite per la nostra Game API. Per impostazione predefinita, ogni operazione nell'API è mappata a una singola funzione Lambda per gestire quell'operazione.
:::

## Task 7: Compilare il codice

<Drawer title="Comandi Nx" trigger="Ora è il momento di compilare il codice per la prima volta">

###### Target singoli vs multipli

Il comando `run-many` esegue un target su più sotto-progetti elencati (`--all` li seleziona tutti). Questo garantisce che le dipendenze vengano eseguite nell'ordine corretto.

Puoi anche attivare una build (o qualsiasi altro task) per un singolo target di progetto eseguendo il target direttamente sul progetto. Ad esempio, per compilare il progetto `@dungeon-adventure/infra`, esegui il seguente comando:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />

Puoi anche omettere lo scope e usare la sintassi abbreviata di Nx se preferisci:

<NxCommands commands={['build infra']} />

###### Visualizzare le dipendenze

Per visualizzare le dipendenze, esegui:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Caching

Nx si basa sul [caching](https://nx.dev/concepts/how-caching-works) per riutilizzare gli artefatti delle build precedenti e velocizzare lo sviluppo. È necessaria una certa configurazione per farlo funzionare correttamente e potrebbero esserci casi in cui vuoi eseguire una build **senza usare la cache**. Per farlo, aggiungi semplicemente l'argomento `--skip-nx-cache` al comando. Ad esempio:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Se per qualsiasi motivo volessi pulire la cache (memorizzata nella cartella `.nx`), puoi eseguire il seguente comando:

<NxCommands commands={['reset']} />

</Drawer>

Dalla riga di comando, esegui: 

<NxCommands commands={['run-many --target build --all']} />

Vedrai il seguente prompt:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Alcuni file di configurazione TypeScript mancano di riferimenti ai progetti dipendenti o contengono riferimenti obsoleti.

Questo causerà un errore in CI.

? Vuoi sincronizzare le modifiche identificate per aggiornare il workspace? …
Sì, sincronizza le modifiche ed esegui i task
No, esegui i task senza sincronizzare le modifiche
```

Questo messaggio indica che NX ha rilevato alcuni file che possono essere aggiornati automaticamente. In questo caso, si riferisce ai file `tsconfig.json` che non hanno riferimenti TypeScript configurati sui progetti referenziati. 

Seleziona l'opzione **Sì, sincronizza le modifiche ed esegui i task** per procedere. Dovresti notare che tutti gli errori di import dell'IDE vengono risolti automaticamente poiché il generatore sync aggiungerà automaticamente i riferimenti TypeScript mancanti!

<Aside type="tip">
Se riscontri errori di lint, esegui il seguente comando per correggerli automaticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>
Tutti gli artefatti compilati sono ora disponibili nella cartella `dist/` situata alla radice del monorepo. Questa è una pratica standard quando si utilizzano progetti generati da `@aws/nx-plugin` poiché non inquina la struttura dei file con file generati. Nel caso in cui tu voglia pulire i file, elimina la cartella `dist/` senza preoccuparti dei file generati sparsi nella struttura dei file.

Congratulazioni! Hai creato tutti i sotto-progetti necessari per iniziare a implementare il core del nostro gioco AI Dungeon Adventure.  🎉🎉🎉