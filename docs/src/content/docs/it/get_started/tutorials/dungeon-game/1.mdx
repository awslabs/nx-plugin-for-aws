---
title: "Gioco di Dungeon con IA"
description: "Una guida dettagliata su come costruire un gioco di avventura dungeon alimentato da IA utilizzando il plugin @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Modulo 1: Configura il tuo Monorepo

Inizia creando un nuovo monorepo. Un monorepo è un singolo repository che contiene più progetti distinti, con relazioni ben definite.

All'interno della directory desiderata, esegui il seguente comando:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

Questo configurerà un monorepo NX all'interno della directory `dungeon-adventure`. 
Apri la directory in VSCode. Vedrai la seguente struttura dei file:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ qui risiederanno i tuoi sotto-progetti
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura la CLI NX e le impostazioni predefinite del monorepo
- package.json tutte le dipendenze Node sono definite qui
- pnpm-lock.yaml o bun.lock, yarn.lock, package-lock.json in base al package manager
- pnpm-workspace.yaml se usi pnpm
- README.md
- tsconfig.base.json esteso da tutti i sotto-progetti basati su Node
- tsconfig.json
</FileTree>

Prima di aggiungere componenti dal `@aws/nx-plugin` nel monorepo, dobbiamo installarlo come dipendenza di sviluppo. 
Per farlo, esegui il seguente comando nella root del monorepo `dungeon-adventure`:

<InstallCommand dev pkg="@aws/nx-plugin" />

Ora siamo pronti per iniziare a creare i nostri diversi sotto-progetti utilizzando il `@aws/nx-plugin`.

<Aside type="tip">Consigliamo di eseguire il commit dei file non tracciati in Git prima di eseguire qualsiasi generatore. Questo ti permette di vedere cosa è cambiato dopo l'esecuzione del generatore tramite `git diff`.</Aside>

### Genera la Game API

Inizieremo creando la nostra Game API. Questa API viene utilizzata per gestire lo stato del gioco.
Per farlo, crea un'API tRPC chiamata `GameApi` seguendo questi passaggi:

<RunGenerator generator="ts#trpc-api" requiredParameters={{apiName:"GameApi"}} noInteractive />

<br />

Vedrai apparire nuovi file nella tua struttura di directory.

<Drawer title="File aggiornati da ts#trpc-api" trigger="Fai clic per esaminare questi file in dettaglio.">
Di seguito è riportato l'elenco di tutti i file generati dal generatore `ts#trpc-api`. Esamineremo alcuni file chiave evidenziati nella struttura:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ costrutti CDK specifici per l'applicazione
          - http-apis/
            - **game-api.ts** costrutto CDK per creare la tua API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ costrutti CDK generici
          - http-api.ts costrutto CDK base per un'API HTTP
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipi condivisi
      - src/
        - index.ts
        - runtime-config.ts definizione dell'interfaccia utilizzata sia da CDK che dal sito web
      - project.json
      - ...
  - game-api/
    - backend/ codice di implementazione tRPC
      - src/
        - client/ client vanilla tipicamente usato per chiamate machine-to-machine in TS
          - index.ts
          - sigv4.ts
        - middleware/ strumentazione Powertools
          - error.ts
          - index.ts
          - logger.ts
          - metrics.ts
          - tracer.ts
        - procedures/ implementazioni specifiche per le procedure/route dell'API
          - **echo.ts**
        - index.ts
        - init.ts configura il contesto e i middleware
        - local-server.ts utilizzato quando si esegue il server tRPC localmente
        - **router.ts** punto di ingresso per l'handler Lambda che definisce tutte le procedure
      - project.json
      - ...
    - schema/
      - src/
        - procedures/
          - **echo.ts**
        - index.ts
      - project.json
      - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Esaminiamo questi file chiave:

```ts {5,12}
// packages/game-api/backend/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>,
  ) => ctx,
});

export type AppRouter = typeof appRouter;
```
Il router definisce il punto di ingresso per la tua API tRPC ed è il luogo dove dichiarerai tutti i metodi dell'API. 
Abbiamo un metodo chiamato `echo` con la sua implementazione nel file `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/backend/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from ':dungeon-adventure/game-api-schema';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Questo file è l'implementazione del metodo `echo`, fortemente tipizzato dichiarando le sue strutture di dati di input e output. Importa queste definizioni dal progetto `:dungeon-adventure/game-api-schema` che è un [alias](https://www.typescriptlang.org/tsconfig/paths.html) per il progetto schema.

<Aside type="tip">Se vedi un errore di importazione nel tuo IDE, potrebbe essere perché il backend non ha ancora un riferimento TypeScript configurato nel suo `tsconfig.json`. Nx è stato [configurato](https://nx.dev/nx-api/js/generators/typescript-sync) per creare questi riferimenti *dinamicamente* ogni volta che viene eseguita una build/compilazione, o se esegui manualmente il comando `nx sync`. Per maggiori informazioni consulta la <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guida TypeScript</Link>.</Aside>

```ts
// packages/game-api/schema/src/procedures/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Tutte le definizioni dello schema tRPC sono definite usando [Zod](https://zod.dev/), ed esportate come tipi TypeScript tramite la sintassi `z.TypeOf`.

```ts
// packages/common/constructs/src/app/http-apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import { HttpApi } from '../../core/http-api.js';
import { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';
import { Runtime } from 'aws-cdk-lib/aws-lambda';

export class GameApi extends HttpApi {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      defaultAuthorizer: new HttpIamAuthorizer(),
      apiName: 'GameApi',
      runtime: Runtime.NODEJS_LATEST,
      handler: 'index.handler',
      handlerFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-api/backend/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Questo è il costrutto CDK che definisce la nostra GameAPI. Ha configurato il percorso del file handler per il bundle generato della nostra implementazione backend tRPC, in modo che al momento di `cdk synth` non avvenga il bundling (al contrario dell'uso di [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)), poiché lo abbiamo già incluso come parte del target di build del progetto backend.

</Drawer>

<Aside>
Il `package.json` principale è ora configurato con un `type` impostato su `module`, il che significa che ESM è il tipo di modulo predefinito per tutti i sotto-progetti Node forniti dal `@aws/nx-plugin`. Per maggiori dettagli sul lavoro con progetti TypeScript, consulta la <Link path="guides/typescript-project">guida ts#project</Link>.
</Aside>

### Genera la Story API

Successivamente, creiamo la nostra Story API utilizzando il generatore FastAPI. La Story API viene utilizzata con risposte in streaming per la generazione di storie, utilizzando Amazon Bedrock.
Per farlo, crea una Fast API chiamata `StoryApi` seguendo questi passaggi:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi"}} noInteractive />

Vedrai apparire nuovi file nella tua struttura di directory.

<Drawer title="File aggiornati da py#fast-api" trigger="Fai clic qui per esaminare questi file più in dettaglio.">
Questo è un elenco di tutti i file generati dal generatore `py#fast-api`. Esaminiamo alcuni file chiave evidenziati nella struttura:
<FileTree>
- .venv/ singolo ambiente virtuale per il monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ costrutti CDK specifici per l'applicazione
          - http-apis/
            - **story-api.ts** costrutto CDK per creare la tua Fast API
            - index.ts aggiornato per esportare la nuova story-api
      - project.json aggiornato per aggiungere una dipendenza di build su story_api
    - types/ tipi condivisi
      - src/
        - **runtime-config.ts** aggiornato per aggiungere la StoryApi
  - story_api/
    - story_api/ modulo Python
      - init.py configura Powertools, FastAPI e i middleware
      - **main.py** punto di ingresso per la Lambda contenente tutte le route
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version versione Python fissata per uv
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/http-apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import { HttpApi } from '../../core/http-api.js';
import { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';
import { Runtime } from 'aws-cdk-lib/aws-lambda';

export class StoryApi extends HttpApi {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      defaultAuthorizer: new HttpIamAuthorizer(),
      apiName: 'StoryApi',
      runtime: Runtime.PYTHON_3_12,
      handler: 'story_api.main.handler',
      handlerFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/story_api/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Questo è il costrutto CDK che definisce la nostra StoryApi. Configura il percorso del file handler per il bundle generato della nostra implementazione backend Fast API. Ciò significa che al momento di `cdk synth` non avviene il bundling (al contrario di [PythonFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/@aws-cdk_aws-lambda-python-alpha.PythonFunction.html)) poiché lo abbiamo già incluso come parte del target di build del progetto backend.

```diff lang="ts"
// packages/common/types/src/runtime-config.ts
export type ApiUrl = string;
// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-empty-interface
export interface IRuntimeConfig {
  httpApis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

Ecco un esempio del generatore che esegue una trasformazione AST che preserva tutto il codice esistente e effettua un aggiornamento. Qui puoi vedere che `StoryApi` è stato aggiunto alla definizione `IRuntimeConfig`, il che significa che quando questo verrà consumato dal nostro frontend, imporrà la type safety!

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

Questo è dove verranno definiti tutti i metodi della tua API. Come puoi vedere qui, abbiamo un metodo `read_root` mappato sulla route `GET /`. Puoi usare [Pydantic](https://docs.pydantic.dev/latest/) per dichiarare gli input e gli output dei tuoi metodi per garantire la type safety.

</Drawer>

### Aggiungi il sito web Game UI

Per interagire con il gioco, crea l'interfaccia utente utilizzando il generatore di siti web CloudScape.
Per farlo, crea un sito web chiamato `GameUI` seguendo questi passaggi:

<RunGenerator generator="ts#cloudscape-website" requiredParameters={{name:"GameUI"}} noInteractive />

Vedrai apparire nuovi file nella tua struttura di directory.

<Drawer title="File aggiornati da ts#cloudscape-website" trigger="Fai clic qui per esaminare questi file più in dettaglio.">
Di seguito è riportato un elenco di tutti i file generati dal generatore `ts#cloudscape-website`. Esaminiamo alcuni file chiave evidenziati nella struttura:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ costrutti CDK specifici per l'applicazione
          - static-websites/
            - **game-ui.ts** costrutto CDK per creare la tua Game UI
        - core/
          - static-website.ts costrutto generico per siti web statici
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts layout generale della pagina: header, footer, sidebar, ecc.
          - navitems.ts elementi di navigazione della sidebar
      - hooks/
        - useAppLayout.tsx ti permette di impostare dinamicamente elementi come notifiche, stile della pagina, ecc.
      - routes/ route basate su file @tanstack/react-router
        - index.tsx root '/' reindirizza a '/welcome'
        - __root.tsx tutte le pagine usano questo componente come base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** punto di ingresso React
        - routeTree.gen.ts questo file viene aggiornato automaticamente da @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Questo è il costrutto CDK che definisce la nostra GameUI. Come puoi vedere, ha già configurato il percorso del file per il bundle generato della nostra UI basata su Vite. Ciò significa che al momento della `build`, il bundling avviene all'interno del target di build del progetto game-ui e il suo output viene utilizzato qui.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Registra l'istanza del router per la type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Questo è il punto di ingresso dove viene montato React. Come mostrato, inizialmente configura solo un `@tanstack/react-router` in una configurazione [`file-based-routing`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Ciò significa che, finché il tuo server di sviluppo è in esecuzione, puoi semplicemente creare file nella cartella `routes` e `@tanstack/react-router` creerà automaticamente la configurazione boilerplate per te, aggiornando il file `routeTree.gen.ts`. Questo file mantiene tutte le route in modo type-safe, il che significa che quando usi `<Link>`, l'opzione `to` mostrerà solo route valide. Per maggiori informazioni, consulta la documentazione di [`@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un componente che verrà renderizzato quando si naviga alla route `/welcome`. `@tanstack/react-router` gestirà la `Route` per te ogni volta che crei/sposti questo file (purché il server di sviluppo sia in esecuzione). Questo verrà mostrato in una sezione successiva di questo tutorial.

</Drawer>

### Aggiungi autenticazione alla Game UI

Per configurare la nostra Game UI con accesso autenticato tramite Amazon Cognito, segui questi passaggi:

<RunGenerator generator="ts#cloudscape-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Vedrai apparire nuovi file nella tua struttura di directory.

<Drawer title="File aggiornati da ts#cloudscape-website#auth" trigger="Fai clic qui per esaminare questi file più in dettaglio.">
Di seguito è riportato un elenco di tutti i file generati/aggiornati dal generatore `ts#cloudscape-website#auth`. Esaminiamo alcuni file chiave evidenziati nella struttura:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts costrutto CDK per creare pool di utenti/identità
    - types/
      - src/
        - runtime-config.ts aggiornato per aggiungere cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx aggiunge l'utente loggato/logout all'header
        - CognitoAuth/
          - index.ts gestisce il login in Cognito
        - RuntimeConfig/
          - index.tsx recupera il `runtime-config.json` e lo fornisce ai figli via contesto
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Aggiornato per aggiungere Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra l'istanza del router per la type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

I componenti `RuntimeConfigProvider` e `CognitoAuth` sono stati aggiunti al file `main.tsx` tramite una trasformazione AST. Questo permette al componente `CognitoAuth` di autenticarsi con Amazon Cognito recuperando il `runtime-config.json` che contiene la configurazione di connessione Cognito necessaria per effettuare le chiamate backend alla destinazione corretta.

</Drawer>

### Configura la Game UI per connettersi alla Story API

Per configurare la nostra Game UI per connettersi alla Story API creata in precedenza, segui questi passaggi:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

Vedrai apparire nuovi file nella tua struttura di directory.

<Drawer title="File aggiornati dalla connessione API UI -> FastAPI" trigger="Fai clic qui per esaminare questi file più in dettaglio.">
Di seguito è riportato un elenco di tutti i file generati/aggiornati dal generatore `api-connection`. Esaminiamo alcuni file chiave evidenziati nella struttura:
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx utilizzato da StoryApi per firmare le richieste
        - useStoryApiClient.tsx hook per costruire un client StoryApi
        - useStoryApi.tsx hook per interagire con StoryApi usando TanStack Query
      - components/
        - QueryClientProvider.tsx provider del client TanStack Query
        - StoryApiProvider.tsx Provider per l'hook TanStack Query di StoryApi
      - main.tsx Aggiunge QueryClientProvider e StoryApiProvider
    - .gitignore ignora i file client generati
    - project.json aggiornato per aggiungere target per generare hook openapi
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json aggiornato per emettere un file openapi.json

</FileTree>

```tsx {1,12-15}
// packages/game-ui/src/hooks/useStoryApiClient.tsx
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.httpApis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

Puoi usare questo hook per effettuare richieste API autenticate alla `StoryApi`. Utilizza la `StoryApi` generata al momento della build e vedrai un errore nel tuo IDE finché non compileremo il nostro codice. Per maggiori dettagli su come viene generato il client o su come consumare l'API, consulta la <Link path="guides/api-connection/react-fastapi">guida da React a FastAPI</Link>.

```tsx
// packages/game-ui/src/components/StoryApiProvider.tsx
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useStoryApiClient } from '../hooks/useStoryApiClient';
import { StoryApiOptionsProxy } from '../generated/story-api/options-proxy.gen';

export const StoryApiContext = createContext<StoryApiOptionsProxy | undefined>(
  undefined,
);

export const StoryApiProvider: FC<PropsWithChildren> = ({ children }) => {
  const client = useStoryApiClient();
  const optionsProxy = useMemo(
    () => new StoryApiOptionsProxy({ client }),
    [client],
  );

  return (
    <StoryApiContext.Provider value={optionsProxy}>
      {children}
    </StoryApiContext.Provider>
  );
};

export default StoryApiProvider;
```

Il componente provider sopra utilizza l'hook `useStoryApiClient` e istanzia lo `StoryApiOptionsProxy`, che viene utilizzato per costruire le opzioni per gli hook TanStack Query. Puoi usare l'hook corrispondente `useStoryApi` per accedere a questo proxy di opzioni, che fornisce un modo per interagire con la tua FastAPI in modo coerente con la tua API tRPC.

Poiché `useStoryApiClient` ci fornisce un iteratore asincrono per la nostra API di streaming, in questo tutorial useremo direttamente il client vanilla.

<Aside type="caution">
I file `src/generated/story-api/*.gen.ts` non devono mai essere modificati manualmente poiché verranno rigenerati ogni volta che compili la tua API.
</Aside>

</Drawer>

### Configura la Game UI per connettersi alla Game API

Per configurare la nostra Game UI per connettersi alla nostra Game API, segui questi passaggi:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api-backend"}} noInteractive />

Dovresti vedere alcuni nuovi file apparire/modificati nella tua struttura di directory.

<Drawer title="File aggiornati dalla connessione API UI -> tRPC" trigger="Fai clic qui per esaminare questi file più in dettaglio.">
Di seguito è riportato un elenco di tutti i file generati/aggiornati dal generatore `api-connection`. Esaminiamo alcuni file chiave evidenziati nella struttura:
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - TrpcClients/
          - index.tsx
          - TrpcApis.tsx tutte le API tRPC configurate
          - TrpcClientProviders.tsx crea un provider client per ogni API tRPC
          - TrpcProvider.tsx
      - hooks/
        - **useGameApi.tsx** hook per chiamare la GameApi
      - **main.tsx** inietta i provider client trpc
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { TrpcApis } from '../components/TrpcClients';

export const useGameApi = () => TrpcApis.GameApi.useTRPC();
```

Questo hook utilizza l'ultima [integrazione React Query di tRPC](https://trpc.io/blog/introducing-tanstack-react-query-client), permettendo agli utenti di interagire direttamente con `@tanstack/react-query` senza ulteriori livelli di astrazione. Per esempi su come chiamare le API tRPC, consulta la <Link path="guides/api-connection/react-trpc#using-the-generated-code">guida all'uso dell'hook tRPC</Link>.

<Aside>
L'hook `useGameApi` è diverso dall'hook `useStoryApi` in quanto non richiede una build per riflettere le modifiche, grazie all'uso da parte di tRPC dell'[inferenza TypeScript](https://trpc.io/docs/concepts). Questo permette agli sviluppatori di apportare modifiche al backend che vengono immediatamente riflesse nel frontend!
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import TrpcClientProviders from './components/TrpcClients';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra l'istanza del router per la type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <TrpcClientProviders>
                <RouterProvider router={router} />
+              </TrpcClientProviders>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Il file `main.tsx` è stato aggiornato tramite una trasformazione AST per iniettare i provider tRPC.

</Drawer>

### Crea l'infrastruttura CDK per la Game UI

Per creare l'infrastruttura CDK come sotto-progetto finale, segui questi passaggi:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Dovresti vedere alcuni nuovi file apparire/modificati nella tua struttura di directory.

<Drawer title="File aggiornati da ts#infra" trigger="Fai clic qui per esaminare questi file più in dettaglio.">
Di seguito è riportato un elenco di tutti i file generati/aggiornati dal generatore `ts#infra`. Esaminiamo alcuni file chiave evidenziati nella struttura:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts** risorse CDK definite qui
      - index.ts
      - **main.ts** punto di ingresso che definisce tutti gli stack
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json aggiungi riferimenti
  - tsconfig.base.json aggiungi alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
  App,
  CfnGuardValidator,
  RuleSet,
} from ':dungeon-adventure/common-constructs';

const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

// Usa questo per distribuire il tuo ambiente sandbox (presuppone le credenziali della tua CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

Questo è il punto di ingresso per la tua applicazione CDK. È configurato per utilizzare [`cfn-guard`](https://github.com/cdklabs/cdk-validator-cfnguard) per eseguire la validazione dell'infrastruttura basata sul set di regole configurato. Questo viene strumentato post-sintesi.

<Aside type="tip">
Potrebbero esserci casi in cui desideri sopprimere determinate regole su alcune risorse. Puoi farlo in due modi:

###### Sopprimi una regola su un costrutto specifico

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// sopprime la RULE_NAME per il costrutto dato.
suppressRule(construct, 'RULE_NAME');
```

###### Sopprimi una regola su un costrutto discendente

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// Sopprime la RULE_NAME per il costrutto o qualsiasi suo discendente se è un'istanza di Bucket
suppressRule(construct, 'RULE_NAME', (construct) => construct instanceof Bucket);
```
</Aside>

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Il codice che definisce il tuo stack va qui
  }
}
```

Questo è dove istanziamo i nostri costrutti CDK per costruire il nostro gioco dungeon adventure.

</Drawer>

#### Aggiorna l'infrastruttura CDK

Per istanziare alcuni dei nostri costrutti già generati, aggiorniamo il nostro `packages/infra/src/stacks/application-stack.ts` :

```diff lang="ts"
+import {
+  GameApi,
+  GameUI,
+  StoryApi,
+  UserIdentity,
+} from ':dungeon-adventure/common-constructs';
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

-    // Il codice che definisce il tuo stack va qui
+    const userIdentity = new UserIdentity(this, 'UserIdentity');
+
+    const gameApi = new GameApi(this, 'GameApi');
+    const storyApi = new StoryApi(this, 'StoryApi');
+
+    // concede al nostro ruolo autenticato l'accesso per invocare le nostre API
+    [storyApi, gameApi].forEach((api) =>
+      api.grantInvokeAccess(userIdentity.identityPool.authenticatedRole),
+    );
+
+    // Assicurati che questo sia istanziato per ultimo così il runtime-config.json può essere configurato automaticamente
+    new GameUI(this, 'GameUI');
  }
}

```

### Compilazione del codice

<Drawer title="Comandi Nx" trigger="Ora è il momento di compilare il nostro codice per la prima volta">
###### Target singoli vs multipli

Il comando `run-many` eseguirà un target su più sotto-progetti elencati (`--all` li selezionerà tutti). Si assicurerà che le dipendenze siano eseguite nell'ordine corretto.

Puoi anche attivare una build (o qualsiasi altro task) per un singolo progetto target eseguendo il target sul progetto direttamente. Ad esempio, se vogliamo compilare il progetto `@dungeon-adventure/infra`, puoi eseguire il seguente comando:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualizzazione delle dipendenze

Puoi anche visualizzare le tue dipendenze tramite:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Caching

Nx si basa sul [caching](https://nx.dev/concepts/how-caching-works) per poter riutilizzare gli artefatti di build precedenti e velocizzare lo sviluppo. È necessaria una configurazione per far funzionare correttamente questo meccanismo e potrebbero esserci casi in cui desideri eseguire una build **senza utilizzare la cache**. Per farlo, aggiungi semplicemente l'argomento `--skip-nx-cache` al tuo comando. Ad esempio:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Se per qualsiasi motivo desideri cancellare la tua cache (memorizzata nella cartella `.nx`), puoi eseguire il seguente comando:

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

Ti verrà chiesto di selezionare:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? …
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Questo messaggio indica che NX ha rilevato alcuni file che possono essere aggiornati automaticamente. In questo caso, si riferisce ai file `tsconfig.json` che non hanno riferimenti TypeScript configurati sui progetti dipendenti. Seleziona l'opzione **Yes, sync the changes and run the tasks** per procedere. Dovresti notare che tutti gli errori di importazione nel tuo IDE vengono risolti automaticamente poiché il generatore di sincronizzazione aggiungerà automaticamente i riferimenti TypeScript mancanti!

<Aside type="tip">
Se incontri errori di linting, puoi eseguire il seguente comando per correggerli automaticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

<Aside type="caution" title="Errore di build su Windows">
<Drawer trigger="Se sei su Windows e incontri un errore di build, fai clic qui." title="Errore di build su Windows">
Se incontri un errore di build/synth per il progetto `@dungeon-adventure/infra`, questo è previsto poiché la libreria che strumenta `cfn-guard` attualmente non supporta Windows. C'è una richiesta di funzionalità che tiene traccia di questo, ma nel frattempo possiamo semplicemente disabilitare `cfn-guard` modificando il file `packages/infra/src/main.ts` come segue:

```diff lang="ts"
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
   App,
-  CfnGuardValidator,
-  RuleSet,
} from ':dungeon-adventure/common-constructs';
-
-const app = new App({
-  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
-});
+const app = new App();

// Usa questo per distribuire il tuo ambiente sandbox (presuppone le credenziali della tua CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```
</Drawer>
</Aside>

Tutti gli artefatti compilati sono ora disponibili all'interno della cartella `dist/` situata alla root del monorepo. Questa è una pratica standard quando si utilizzano progetti generati dal `@aws/nx-plugin` per non mescolare la tua struttura di file con file generati. Se desideri pulire i tuoi file, elimina la cartella `dist/` senza preoccuparti che i file generati vengano sparsi nella struttura di directory.

Complimenti! Hai creato tutti i sotto-progetti necessari per iniziare a implementare il nucleo del nostro gioco Dunegeon Adventure.  🎉🎉🎉