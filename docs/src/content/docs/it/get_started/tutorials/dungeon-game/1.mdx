---
title: "Gioco di Dungeon con IA"
description: "Una guida dettagliata su come costruire un gioco di avventura in dungeon alimentato dall'IA utilizzando il plugin @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Modulo 1: Configurazione del monorepo

Iniziamo creando un nuovo monorepo. Dal tuo directory desiderato, esegui il seguente comando:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" iacProvider="CDK" />

:::note
Passiamo `--iacProvider=CDK` poiché utilizzeremo CDK per l'infrastructure as code in questo tutorial. Il Plugin Nx per AWS supporta anche `Terraform`.
:::

Questo configurerà un monorepo NX all'interno della directory `dungeon-adventure` che potrai aprire in VSCode. Dovrebbe apparire così:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ qui risiederanno i tuoi sotto-progetti
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura la CLI Nx e le impostazioni predefinite del monorepo
- package.json tutte le dipendenze Node sono definite qui
- pnpm-lock.yaml o bun.lock, yarn.lock, package-lock.json in base al package manager
- pnpm-workspace.yaml se si utilizza pnpm
- README.md
- tsconfig.base.json esteso da tutti i sotto-progetti basati su Node
- tsconfig.json
- aws-nx-plugin.config.mts configurazione per il Plugin Nx per AWS
</FileTree>

Ora siamo pronti per iniziare a creare i diversi sotto-progetti utilizzando `@aws/nx-plugin`.

<Aside type="tip">È una best practice assicurarsi che tutti i file non stagiati siano commitati in Git prima di eseguire qualsiasi generatore. Questo permette di vedere cosa è cambiato dopo l'esecuzione del generatore tramite `git diff`</Aside>

### Game API

Iniziamo creando la nostra Game API. Per farlo, creiamo un'API tRPC chiamata `GameApi` seguendo questi passaggi:

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

Dovresti vedere apparire nuovi file nel tuo albero delle directory.

<Aside>
Il `package.json` principale è ora configurato con un `type` impostato a `module`, il che significa che ESM è il tipo di modulo predefinito per tutti i sotto-progetti Node gestiti da `@aws/nx-plugin`. Per maggiori dettagli sul lavoro con progetti TypeScript, consulta la <Link path="guides/typescript-project">guida ts#project</Link>.
</Aside>

<Drawer title="File aggiornati di ts#trpc-api" trigger="Clicca qui per esaminare questi file in dettaglio.">
Di seguito è riportato l'elenco di tutti i file generati dal generatore `ts#trpc-api`. Esamineremo alcuni dei file chiave evidenziati nell'albero:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ costrutti CDK specifici dell'applicazione
          - apis/
            - **game-api.ts** costrutto CDK per creare l'API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ costrutti CDK generici
          - api/
            - rest-api.ts costrutto base CDK per un'API Gateway Rest API
            - trpc-utils.ts utility per i costrutti CDK delle API tRPC
            - utils.ts utility per i costrutti delle API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipi condivisi
      - src/
        - index.ts
        - runtime-config.ts definizione dell'interfaccia usata sia da CDK che dal sito web
      - project.json
      - ...
  - game-api/ API tRPC
    - src/
      - client/ client vanilla tipicamente usato per chiamate machine-to-machine in TS
        - index.ts
        - sigv4.ts
      - middleware/ strumentazione Powertools
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ definizioni di input e output per la tua API
        - **echo.ts**
      - procedures/ implementazioni specifiche per le procedure/route della tua API
        - **echo.ts**
      - index.ts
      - init.ts configura il contesto e i middleware
      - local-server.ts usato per eseguire il server tRPC localmente
      - **router.ts** punto di ingresso per il lambda handler che definisce tutte le procedure
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Esaminiamo alcuni dei file chiave:

```ts {5,12}
// packages/game-api/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
Il router definisce il punto di ingresso per la tua API tRPC ed è il luogo dove dichiarerai tutti i metodi dell'API. Come puoi vedere sopra, abbiamo un metodo chiamato `echo` con la sua implementazione nel file `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Questo file contiene l'implementazione del metodo `echo` ed è fortemente tipizzato dichiarando le sue strutture di dati di input e output.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Tutte le definizioni degli schema tRPC sono realizzate con [Zod](https://zod.dev/) ed esportate come tipi TypeScript tramite la sintassi `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// Tipo union per tutti i nomi delle operazioni API
type Operations = Procedures<AppRouter>;

/**
 * Proprietà per la creazione di un costrutto GameApi
 *
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mappa dei nomi delle operazioni alle loro integrazioni API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un costrutto CDK che crea e configura un'API Gateway REST API
 * specifica per GameApi.
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integrazioni predefinite per tutte le operazioni, implementando ciascuna operazione
   * come una singola funzione lambda.
   *
   * @param scope - Lo scope del costrutto CDK
   * @returns Un IntegrationBuilder con integrazioni lambda predefinite
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Qui concediamo a qualsiasi credenziale AWS dell'account in cui il progetto è deployato di chiamare l'API.
          // L'accesso granulare machine-to-machine può essere definito qui usando principal più specifici (es. ruoli o
          // utenti) e risorse (es. quali percorsi API possono essere invocati da quale principal) se necessario.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Apriamo OPTIONS per permettere ai browser di fare richieste preflight non autenticate
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

Questo è il costrutto CDK che definisce la nostra GameApi. Come puoi vedere, fornisce un metodo `defaultIntegrations` che crea automaticamente una funzione lambda per ogni procedura nella nostra API tRPC, puntando all'implementazione dell'API già bundled. Ciò significa che al momento di `cdk synth` non avviene il bundling (a differenza di [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) poiché lo abbiamo già incluso come parte del target di build del progetto backend.

</Drawer>

### Story API

Ora creiamo la nostra Story API. Per farlo, creiamo un'API Fast chiamata `StoryApi` seguendo questi passaggi:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi", moduleName:"story_api"}} noInteractive />

Dovresti vedere apparire nuovi file nel tuo albero delle directory.
<Drawer title="File aggiornati di py#fast-api" trigger="Clicca qui per esaminare questi file in dettaglio.">
Di seguito è riportato l'elenco di tutti i file generati dal generatore `py#fast-api`. Esamineremo alcuni dei file chiave evidenziati nell'albero:
<FileTree>
- .venv/ singolo virtual env per il monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ costrutti CDK specifici dell'applicazione
          - apis/
            - **story-api.ts** costrutto CDK per creare la tua Fast API
            - index.ts aggiornato per esportare la nuova story-api
      - project.json aggiornato per aggiungere una dipendenza di build su story_api
    - types/ tipi condivisi
      - src/
        - **runtime-config.ts** aggiornato per aggiungere la StoryApi
  - story_api/
    - story_api/ modulo Python
      - init.py configura Powertools, FastAPI e i middleware
      - **main.py** punto di ingresso per la lambda contenente tutte le route
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version versione Python bloccata per uv
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import {
  OPERATION_DETAILS,
  Operations,
} from '../../generated/story-api/metadata.gen.js';

/**
 * Proprietà per la creazione di un costrutto StoryApi
 *
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export interface StoryApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mappa dei nomi delle operazioni alle loro integrazioni API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un costrutto CDK che crea e configura un'API Gateway REST API
 * specifica per StoryApi.
 * @template TIntegrations - Mappa dei nomi delle operazioni alle loro integrazioni
 */
export class StoryApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integrazioni predefinite per tutte le operazioni, implementando ciascuna operazione
   * come una singola funzione lambda.
   *
   * @param scope - Lo scope del costrutto CDK
   * @returns Un IntegrationBuilder con integrazioni lambda predefinite
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: OPERATION_DETAILS,
      defaultIntegrationOptions: {
        runtime: Runtime.PYTHON_3_12,
        handler: 'story_api.main.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/story_api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `StoryApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: StoryApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'StoryApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Qui concediamo a qualsiasi credenziale AWS dell'account in cui il progetto è deployato di chiamare l'API.
          // L'accesso granulare machine-to-machine può essere definito qui usando principal più specifici (es. ruoli o
          // utenti) e risorse (es. quali percorsi API possono essere invocati da quale principal) se necessario.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Apriamo OPTIONS per permettere ai browser di fare richieste preflight non autenticate
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: OPERATION_DETAILS,
      ...props,
    });
  }
}

```

Questo è il costrutto CDK che definisce la nostra StoryApi. Come puoi vedere, fornisce un metodo `defaultIntegrations` che crea automaticamente una funzione lambda per ogni operazione definita nella nostra FastAPI, puntando all'implementazione dell'API già bundled. Ciò significa che al momento di `cdk synth` non avviene il bundling (a differenza di [PythonFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/@aws-cdk_aws-lambda-python-alpha.PythonFunction.html)) poiché lo abbiamo già incluso come parte del target di build del progetto backend.

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

Qui verranno definiti tutti i metodi della tua API. Come puoi vedere, abbiamo un metodo `read_root` mappato alla route `GET /`. Puoi usare [Pydantic](https://docs.pydantic.dev/latest/) per dichiarare gli input e gli output dei metodi e garantire la type safety.

</Drawer>

### Game UI: Sito Web

Ora creiamo l'interfaccia utente che ti permetterà di interagire con il gioco. Per farlo, creiamo un sito web chiamato `GameUI` seguendo questi passaggi:

<RunGenerator generator="ts#react-website" requiredParameters={{name:"GameUI"}} noInteractive />

Dovresti vedere apparire nuovi file nel tuo albero delle directory.

<Drawer title="File aggiornati di ts#react-website" trigger="Clicca qui per esaminare questi file in dettaglio.">
Di seguito è riportato l'elenco di tutti i file generati dal generatore `ts#react-website`. Esamineremo alcuni dei file chiave evidenziati nell'albero:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ costrutti CDK specifici dell'applicazione
          - static-websites/
            - **game-ui.ts** costrutto CDK per creare la tua Game UI
        - core/
          - static-website.ts costrutto generico per siti web statici
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts layout generale della pagina: header, footer, sidebar, ecc.
          - navitems.ts elementi di navigazione della sidebar
      - hooks/
        - useAppLayout.tsx permette di impostare dinamicamente elementi come notifiche, stile della pagina, ecc.
      - routes/ route basate su file di @tanstack/react-router
        - index.tsx pagina root '/' reindirizza a '/welcome'
        - __root.tsx tutte le pagine usano questo componente come base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** entrypoint di React
        - routeTree.gen.ts questo file viene aggiornato automaticamente da @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteName: 'GameUI',
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Questo è il costrutto CDK che definisce la nostra GameUI. Come puoi vedere, ha già configurato il percorso del file per il bundle generato della nostra UI basata su Vite. Ciò significa che al momento del `build`, il bundling avviene all'interno del target di build del progetto game-ui e il suo output viene utilizzato qui.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Registra l'istanza del router per la type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Questo è il punto di ingresso dove React viene montato. Come mostrato, inizialmente configura un `@tanstack/react-router` in una configurazione [`file-based-routing`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Ciò significa che, finché il server di sviluppo è in esecuzione, puoi semplicemente creare file nella cartella `routes` e `@tanstack/react-router` creerà automaticamente la struttura dei file necessaria aggiornando il file `routeTree.gen.ts`. Questo file mantiene tutte le route in modo type-safe, quindi quando usi `<Link>`, l'opzione `to` mostrerà solo route valide. Per maggiori informazioni, consulta la [documentazione di `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un componente che verrà renderizzato quando si naviga alla route `/welcome`. `@tanstack/react-router` gestirà la `Route` per te ogni volta che crei/sposti questo file (finché il dev server è in esecuzione). Questo verrà mostrato in una sezione successiva di questo tutorial.

</Drawer>

### Game UI: Autenticazione

Ora configuriamo la nostra Game UI per richiedere l'accesso autenticato tramite Amazon Cognito seguendo questi passaggi:

<RunGenerator generator="ts#react-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Dovresti vedere apparire/modificare nuovi file nel tuo albero delle directory.

<Drawer title="File aggiornati di ts#react-website#auth" trigger="Clicca qui per esaminare questi file in dettaglio.">
Di seguito è riportato l'elenco di tutti i file generati/aggiornati dal generatore `ts#react-website#auth`. Esamineremo alcuni dei file chiave evidenziati nell'albero:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts costrutto CDK per creare pool di utenti/identità
    - types/
      - src/
        - runtime-config.ts aggiornato per aggiungere cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx aggiunge l'utente loggato/logout all'header
        - CognitoAuth/
          - index.ts gestisce il login in Cognito
        - RuntimeConfig/
          - index.tsx recupera il `runtime-config.json` e lo fornisce ai figli via context
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Aggiornato per aggiungere Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra l'istanza del router per la type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

I componenti `RuntimeConfigProvider` e `CognitoAuth` sono stati aggiunti al file `main.tsx` tramite una trasformazione AST. Questo permette al componente `CognitoAuth` di autenticarsi con Amazon Cognito recuperando il `runtime-config.json` che contiene la configurazione di connessione Cognito necessaria per effettuare le chiamate backend alla destinazione corretta.

</Drawer>

### Game UI: Connessione a Story API

Ora configuriamo la nostra Game UI per connettersi alla Story API creata precedentemente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

Dovresti vedere apparire/modificare nuovi file nel tuo albero delle directory.

<Drawer title="File aggiornati della connessione UI -> FastAPI" trigger="Clicca qui per esaminare questi file in dettaglio.">
Di seguito è riportato l'elenco di tutti i file generati/aggiornati dal generatore `api-connection`. Esamineremo alcuni dei file chiave evidenziati nell'albero:
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx usato da StoryApi per firmare le richieste
        - useStoryApiClient.tsx hook per costruire un client StoryApi
        - useStoryApi.tsx hook per interagire con StoryApi usando TanStack Query
      - components/
        - QueryClientProvider.tsx provider del client TanStack Query
        - StoryApiProvider.tsx Provider per l'hook TanStack Query di StoryApi
      - main.tsx Inietta QueryClientProvider e StoryApiProvider
    - .gitignore ignora i file client generati
    - project.json aggiornato per aggiungere target per la generazione di hook openapi
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json aggiornato per emettere un file openapi.json

</FileTree>

```tsx {1,12-15}
// packages/game-ui/src/hooks/useStoryApiClient.tsx
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

Questo hook può essere usato per effettuare richieste API autenticate alla `StoryApi`. Come puoi vedere nell'implementazione, utilizza `StoryApi` che viene generato al momento della build, quindi vedrai un errore nel tuo IDE finché non eseguiremo la build del codice. Per maggiori dettagli su come viene generato il client o su come consumare l'API, consulta la <Link path="guides/api-connection/react-fastapi">guida React to FastAPI</Link>.

```tsx
// packages/game-ui/src/components/StoryApiProvider.tsx
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useStoryApiClient } from '../hooks/useStoryApiClient';
import { StoryApiOptionsProxy } from '../generated/story-api/options-proxy.gen';

export const StoryApiContext = createContext<StoryApiOptionsProxy | undefined>(
  undefined,
);

export const StoryApiProvider: FC<PropsWithChildren> = ({ children }) => {
  const client = useStoryApiClient();
  const optionsProxy = useMemo(
    () => new StoryApiOptionsProxy({ client }),
    [client],
  );

  return (
    <StoryApiContext.Provider value={optionsProxy}>
      {children}
    </StoryApiContext.Provider>
  );
};

export default StoryApiProvider;
```

Il componente provider sopra utilizza l'hook `useStoryApiClient` e istanzia `StoryApiOptionsProxy`, che viene usato per costruire le opzioni per gli hook TanStack Query. Puoi usare l'hook corrispondente `useStoryApi` per accedere a questo options proxy, che fornisce un modo per interagire con la tua FastAPI in modo coerente con la tua API tRPC.

Poiché `useStoryApiClient` ci fornisce un async iterator per la nostra streaming API, in questo tutorial useremo direttamente il client vanilla.

<Aside type="caution">
I file `src/generated/story-api/*.gen.ts` non devono mai essere modificati manualmente poiché verranno rigenerati ogni volta che esegui la build della tua API.
</Aside>

</Drawer>

### Game UI: Connessione a Game API

Ora configuriamo la nostra Game UI per connettersi alla Game API creata precedentemente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

Dovresti vedere apparire/modificare nuovi file nel tuo albero delle directory.

<Drawer title="File aggiornati della connessione UI -> tRPC" trigger="Clicca qui per esaminare questi file in dettaglio.">
Di seguito è riportato l'elenco di tutti i file generati/aggiornati dal generatore `api-connection`. Esamineremo alcuni dei file chiave evidenziati nell'albero:
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx configura il client GameAPI
      - hooks/
        - **useGameApi.tsx** hook per chiamare la GameApi
      - **main.tsx** inietta i provider del client trpc
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { GameApiTRCPContext } from '../components/GameApiClientProvider';

export const useGameApi = GameApiTRCPContext.useTRPC;
```

Questo hook utilizza l'ultima [integrazione React Query di tRPC](https://trpc.io/blog/introducing-tanstack-react-query-client) permettendo agli utenti di interagire direttamente con `@tanstack/react-query` senza ulteriori livelli di astrazione. Per esempi su come chiamare le API tRPC, consulta la <Link path="guides/api-connection/react-trpc#using-the-generated-code">guida all'uso dell'hook tRPC</Link>.

<Aside>
L'hook `useGameApi` è diverso da `useStoryApi` poiché non richiede una build per riflettere le modifiche grazie all'uso di [TypeScript inference](https://trpc.io/docs/concepts) da parte di tRPC. Questo permette agli sviluppatori di apportare modifiche al backend che si riflettono istantaneamente nel frontend!
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra l'istanza del router per la type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <RouterProvider router={router} />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Il file `main.tsx` è stato aggiornato tramite una trasformazione AST per iniettare i provider tRPC.

</Drawer>

### Game UI: Infrastruttura

Ora l'ultimo sotto-progetto che dobbiamo creare è per l'infrastruttura CDK. Per crearlo, segui questi passaggi:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Dovresti vedere apparire/modificare nuovi file nel tuo albero delle directory.

<Drawer title="File aggiornati di ts#infra" trigger="Clicca qui per esaminare questi file in dettaglio.">
Di seguito è riportato l'elenco di tutti i file generati/aggiornati dal generatore `ts#infra`. Esamineremo alcuni dei file chiave evidenziati nell'albero:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - checkov.ts
          - index.ts
  - infra
    - src/
      - stages/
        - **application-stage.ts** stack CDK definiti qui
      - stacks/
        - **application-stack.ts** risorse CDK definite qui
      - index.ts
      - **main.ts** entrypoint che definisce tutti gli stage
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json aggiunge riferimenti
  - tsconfig.base.json aggiunge alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStage } from './stacks/application-stage.js';
import { App } from ':dungeon-adventure/common-constructs';

const app = new App();

// Usa questo per deployare il tuo ambiente sandbox (presuppone le credenziali CLI)
new ApplicationStage(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
});

app.synth();
```

<Aside type="tip">Se vedi un errore di importazione nel tuo IDE, è perché il nostro progetto infrastruttura non ha ancora un riferimento TypeScript configurato nel suo tsconfig.json. Nx è stato [configurato](https://nx.dev/nx-api/js/generators/typescript-sync) per creare questi riferimenti *dinamicamente* ogni volta che viene eseguita una build/compilazione o se esegui manualmente il comando `nx sync`. Per maggiori informazioni consulta la <Link path="guides/typescript-project#importing-your-library-code-inother-projects">guida TypeScript</Link>.</Aside>

Questo è l'entrypoint per la tua applicazione CDK.

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Il codice che definisce il tuo stack va qui
  }
}
```

Qui istanzieremo i nostri costrutti CDK per costruire il nostro gioco dungeon adventure.

</Drawer>

#### Aggiorniamo la nostra infrastruttura

Apportiamo un aggiornamento al nostro `packages/infra/src/stacks/application-stack.ts` per istanziare alcuni dei costrutti già generati:


<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

Nota che forniamo integrazioni predefinite per le nostre due API. Per impostazione predefinita, ogni operazione nella nostra API è mappata a una singola funzione lambda per gestire quell'operazione.

### Costruiamo il nostro codice

<Drawer title="Comandi Nx" trigger="Ora è il momento di costruire il nostro codice per la prima volta">
###### Target singoli vs multipli

Il comando `run-many` eseguirà un target su più sotto-progetti elencati (`--all` li selezionerà tutti). Garantirà che le dipendenze siano eseguite nell'ordine corretto.

Puoi anche attivare una build (o qualsiasi altro task) per un target di progetto singolo eseguendo il target direttamente sul progetto. Ad esempio, se vogliamo buildare il progetto `@dungeon-adventure/infra`, puoi eseguire:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualizzare le dipendenze

Puoi anche visualizzare le tue dipendenze tramite:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Caching

Nx si basa sul [caching](https://nx.dev/concepts/how-caching-works) per riutilizzare gli artefatti di build precedenti e velocizzare lo sviluppo. È necessaria una configurazione per far funzionare correttamente questa funzionalità e potrebbero esserci casi in cui vuoi eseguire una build **senza usare la cache**. Per farlo, aggiungi semplicemente l'argomento `--skip-nx-cache` al tuo comando. Ad esempio:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Se per qualsiasi motivo volessi cancellare la tua cache (memorizzata nella cartella `.nx`), puoi eseguire:

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

Dovresti ricevere il seguente prompt:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? …
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Questo messaggio indica che NX ha rilevato alcuni file che possono essere aggiornati automaticamente. In questo caso, si riferisce ai file `tsconfig.json` che non hanno riferimenti TypeScript configurati sui progetti referenziati. Seleziona l'opzione **Yes, sync the changes and run the tasks** per procedere. Noterai che tutti gli errori di importazione nel tuo IDE verranno automaticamente risolti poiché il generatore di sync aggiungerà automaticamente i riferimenti TypeScript mancanti!

<Aside type="tip">
Se incontri errori di lint, puoi eseguire il seguente comando per correggerli automaticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

Tutti gli artefatti di build sono ora disponibili nella cartella `dist/` alla radice del monorepo. Questa è una pratica standard quando si utilizzano progetti generati da `@aws/nx-plugin` poiché non inquina l'albero dei file con file generati. Se vuoi pulire i file, puoi semplicemente eliminare la cartella `dist/` senza preoccuparti di file generati sparsi nell'albero.

Complimenti! Hai creato tutti i sotto-progetti necessari per iniziare a implementare il cuore del nostro gioco Dungeon Adventure.  🎉🎉🎉