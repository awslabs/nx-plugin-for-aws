---
title: "Gioco di Dungeon con IA Agentiva"
description: "Una guida dettagliata su come costruire un gioco di avventura in dungeon alimentato da IA agentiva utilizzando @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import E2EDiff from '@components/e2e-diff.astro';
import E2ECode from '@components/e2e-code.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

import { getDungeonAdventureElectroDbDependencies } from '../../../../../../../../e2e/src/utils';

## Modulo 2: Implementazione dell'API del gioco e del server MCP per l'inventario

Inizieremo implementando la nostra Game API. Per farlo, dobbiamo creare 5 API in totale:

1. `saveGame` - crea o aggiorna un gioco.
2. `queryGames` - restituisce una lista paginata di giochi salvati precedentemente.
3. `saveAction` - salva un'azione per un determinato gioco.
4. `queryActions` - restituisce una lista paginata di tutte le azioni relative a un gioco.
5. `queryInventory` - restituisce una lista paginata degli oggetti nell'inventario di un giocatore.

### Schema dell'API

Per definire gli input e gli output della nostra API, creiamo il nostro schema utilizzando [Zod](https://zod.dev/) nella directory `packages/game-api/src/schema` come segue:

<Tabs>
  <TabItem label="action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/action.ts.template" />
  </TabItem>
  <TabItem label="common.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/common.ts.template" />
  </TabItem>
  <TabItem label="game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/game.ts.template" />
  </TabItem>
  <TabItem label="inventory.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/inventory.ts.template" />
  </TabItem>
  <TabItem label="index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/schema/index.ts.old.template" after="dungeon-adventure/2/schema/index.ts.template" />
  </TabItem>
</Tabs>

Puoi anche eliminare il file `packages/game-api/src/schema/echo.ts` dato che non lo utilizzeremo in questo progetto.

<Aside type="tip">
Come puoi vedere sopra, per ognuno degli schemi che definiamo in Zod, esportiamo anche un'interfaccia utilizzando la sintassi `z.TypeOf`. Questo converte la nostra definizione Zod in un'interfaccia TypeScript senza duplicare gli sforzi!
</Aside>

### Modellazione delle entità

Il diagramma ER per la nostra applicazione è il seguente:

<Image class="centered-image white-bg" src={dungeonAdventureErPng} alt="dungeon-adventure-er.png" width="400" height="300" />

{/* Generated from the following PlantUML: */}
{/*
@startuml Game API Entity Relationship Diagram

!theme plain

skinparam linetype ortho
skinparam roundcorner 10

entity "Game" as game {
  + playerName : string <<PK>>
  --
  genre : string
  lastUpdated : string
}

entity "Action" as action {
  + playerName : string <<PK>>
  + timestamp : string <<SK>>
  --
  role : string
  content : string
}

entity "Item" as item {
  + playerName : string <<PK>>
  + itemName : string
  --
  emoji : string (optional)
  lastUpdated : string
  quantity : number
}

game ||--o{ action
game ||--o{ item

@enduml
*/}

Implementeremo il nostro database in DynamoDB e utilizzeremo la libreria client [ElectroDB](https://electrodb.dev/en/core-concepts/introduction/) per semplificare le operazioni. Per iniziare, dobbiamo prima installare `electrodb` e il DynamoDB Client eseguendo il seguente comando:

<InstallCommand pkg={getDungeonAdventureElectroDbDependencies()} />

<Aside>
Tutte le dipendenze vengono aggiunte al file `package.json` principale poiché `@aws/nx-plugin` segue il principio della [single version policy](https://nx.dev/concepts/decisions/dependency-management#single-version-policy). Per maggiori informazioni, consulta la <Link path="guides/typescript-project#dependencies">guida ts#project</Link>.
</Aside>

Ora creiamo i seguenti file nella nostra cartella `packages/game-api/src/entities` per definire le entità ElectroDB secondo il diagramma ER sopra:

<Tabs>
  <TabItem label="action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/action.ts.template" />
  </TabItem>
  <TabItem label="game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/game.ts.template" />
  </TabItem>
  <TabItem label="inventory.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/inventory.ts.template" />
  </TabItem>
</Tabs>

ElectroDB ci permette non solo di definire i nostri tipi, ma può anche fornire valori predefiniti per certi campi come i timestamp sopra. Inoltre, ElectroDB segue il [single-table design](https://electrodb.dev/en/core-concepts/single-table-relationships/), che è la best practice quando si utilizza DynamoDB.

<Aside>
Sebbene ElectroDB supporti le [collections](https://electrodb.dev/en/modeling/collections/), in questo tutorial abbiamo scelto di non utilizzarle per semplicità.
</Aside>

Per preparare il server MCP a interagire con l'inventario, assicuriamoci di esportare l'entità dell'inventario in `packages/game-api/src/index.ts`:

<Tabs>
<TabItem label="packages/game-api/src/index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/index.ts.old.template" after="dungeon-adventure/2/index.ts.template" />
</TabItem>
</Tabs>

:::note
La struttura del pacchetto sarebbe migliore se rifattorizzassimo le entità in un progetto condiviso separato, in modo che il server MCP non debba dipendere dall'API.
:::

### Aggiunta del client DynamoDB al contesto tRPC

Dato che abbiamo bisogno di accedere al client DynamoDB in ognuna delle nostre procedure, vogliamo creare un'unica istanza del client che possiamo passare tramite il contesto. Per farlo, apporta le seguenti modifiche in `packages/game-api/src`:

<Tabs>
  <TabItem label="middleware/dynamodb.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/middleware/dynamodb.ts.template" />

Questo è un plugin che strumentiamo per creare il `DynamoDBClient` e iniettarlo nel contesto.
  </TabItem>
  <TabItem label="middleware/index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/middleware/index.ts.old.template" after="dungeon-adventure/2/middleware/index.ts.template" />

Estendiamo il nostro `IMiddlewareContext` per aggiungere `IDynamoDBContext`.
  </TabItem>
  <TabItem label="init.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/init.ts.old.template" after="dungeon-adventure/2/init.ts.template" />

Il plugin DynamoDB viene strumentato.

<Aside>
L'API `concat` associa il nostro middleware alle procedure che definiamo. Per maggiori dettagli, consulta la [guida concat](https://trpc.io/docs/server/middlewares#concat).
</Aside>
  </TabItem>
</Tabs>

### Definizione delle procedure

Ora è il momento di implementare i metodi dell'API. Per farlo, apporta le seguenti modifiche in `packages/game-api/src/procedures`:

#### Query

<Tabs>
  <TabItem label="query-actions.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-actions.ts.template" />
  </TabItem>
  <TabItem label="query-games.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-games.ts.template" />
  </TabItem>
  <TabItem label="query-inventory.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-inventory.ts.template" />
  </TabItem>
</Tabs>

#### Mutazioni

<Tabs>
  <TabItem label="save-action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/save-action.ts.template" />
  </TabItem>
  <TabItem label="save-game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/save-game.ts.template" />
  </TabItem>
</Tabs>

Puoi anche eliminare il file `echo.ts` (da `packages/game-api/src/procedures`) dato che non lo utilizzeremo in questo progetto.

### Configurazione del router

Ora che abbiamo definito le nostre procedure, colleghiamole alla nostra API. Per farlo, aggiorna il seguente file:

<Tabs>
  <TabItem label="packages/game-api/src/router.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/router.ts.old.template" after="dungeon-adventure/2/router.ts.template" />
</TabItem>
</Tabs>

### Server MCP per l'inventario

Ora creiamo un server MCP che permetterà al nostro agente di gestire gli oggetti nell'inventario di un giocatore.

Definiremo i seguenti strumenti per il nostro Agente:

- `list-inventory-items` per recuperare gli oggetti correnti nell'inventario del giocatore
- `add-to-inventory` per aggiungere oggetti all'inventario del giocatore
- `remove-from-inventory` per rimuovere oggetti dall'inventario del giocatore

Per risparmiare tempo, definiremo tutti gli strumenti inline:

<Tabs>
  <TabItem label="packages/inventory/src/mcp-server/server.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/mcp/server.ts.old.template" after="dungeon-adventure/2/mcp/server.ts.template" />
</TabItem>
</Tabs>

Man mano che il numero di strumenti cresce, puoi eventualmente rifattorizzarli in file separati.

Ora puoi eliminare le directory `tools` e `resources` in `packages/inventory/src/mcp-server` poiché non sono utilizzate.

### Infrastruttura

Il passo finale è aggiornare la nostra infrastruttura per creare la tabella DynamoDB e concedere i permessi per eseguire operazioni dalla Game API. Per farlo, aggiorna `packages/infra/src` come segue:

<Tabs>
  <TabItem label="constructs/electrodb-table.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/constructs/electrodb-table.ts.template" />
  </TabItem>
  <TabItem label="stacks/application-stack.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/1/application-stack.ts.template" after="dungeon-adventure/2/stacks/application-stack.ts.template" />

:::note
Nota qui che poiché ogni procedura è gestita da una singola funzione lambda, possiamo seguire il principio del minimo privilegio e assegnare solo i permessi di lettura/scrittura necessari in base all'implementazione della procedura.
:::
  </TabItem>
</Tabs>

### Deployment e testing

Prima di tutto, compiliamo la codebase:

<NxCommands commands={['run-many --target build --all']} />

<Aside type="tip">
Se incontri errori di linting, puoi eseguire il seguente comando per correggerli automaticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

La tua applicazione può ora essere deployata eseguendo il seguente comando:

<NxCommands commands={['deploy infra dungeon-adventure-infra-sandbox/*']} />

:::caution
Potresti dover eseguire il bootstrap del tuo account AWS prima, con:

<NxCommands commands={['bootstrap infra']} />
:::

Il primo deployment richiederà circa 8 minuti. I deployment successivi richiederanno circa 2 minuti.

:::tip
Se stai modificando il codice delle funzioni lambda, puoi eseguire il deploy con il flag `--hotswap` dopo aver compilato la codebase per un tempo di deployment molto più breve (2-3 secondi).

<NxCommands commands={['run @dungeon-adventure/infra:deploy dungeon-adventure-infra-sandbox/* --hotswap']} />
:::

Una volta completato il deployment, dovresti vedere degli output simili ai seguenti _(alcuni valori sono stati oscurati)_:

```bash
dungeon-adventure-sandbox-Application
dungeon-adventure-sandbox-Application: deploying... [2/2]

 ✅  dungeon-adventure-sandbox-Application

✨  Deployment time: 354s

Outputs:
dungeon-adventure-sandbox-Application.ElectroDbTableTableNameXXX = dungeon-adventure-sandbox-Application-ElectroDbTableXXX-YYY
dungeon-adventure-sandbox-Application.GameApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-sandbox-Application.GameUIDistributionDomainNameXXX = xxx.cloudfront.net
dungeon-adventure-sandbox-Application.StoryApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-sandbox-Application.UserIdentityUserIdentityIdentityPoolIdXXX = region:xxx
dungeon-adventure-sandbox-Application.UserIdentityUserIdentityUserPoolIdXXX = region_xxx
```

Possiamo testare la nostra API in due modi:
<ul>
<li>Avviando un'istanza locale del backend tRPC e invocando le API con `curl`.</li>
<li>
<Drawer title="Curl con Sigv4 abilitato" trigger="Chiamare l'API deployata utilizzando curl con Sigv4">

<Tabs>
  <TabItem label="Bash/Linux/macOS">
Puoi aggiungere il seguente script al tuo file `.bashrc` (e eseguire `source`) o incollarlo direttamente nel terminale dove vuoi eseguire i comandi.
```bash
// ~/.bashrc
acurl () {
    REGION=$1
    SERVICE=$2
    shift; shift;
    curl --aws-sigv4 "aws:amz:$REGION:$SERVICE" --user "$(aws configure get aws_access_key_id):$(aws configure get aws_secret_access_key)" -H "X-Amz-Security-Token: $(aws configure get aws_session_token)" "$@"
}
```

Per effettuare una richiesta curl autenticata con sigv4, puoi invocare `acurl` come negli esempi seguenti:

###### API Gateway
```bash
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### Streaming Lambda function url
```bash
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
  </TabItem>
  <TabItem label="Windows PowerShell">
Puoi aggiungere la seguente funzione al tuo profilo PowerShell o incollarla direttamente nella sessione corrente.
```powershell
# Profilo PowerShell o sessione corrente
function acurl {
    param(
        [Parameter(Mandatory=$true)][string]$Region,
        [Parameter(Mandatory=$true)][string]$Service,
        [Parameter(ValueFromRemainingArguments=$true)][string[]]$CurlArgs
    )

    $AccessKey = aws configure get aws_access_key_id
    $SecretKey = aws configure get aws_secret_access_key
    $SessionToken = aws configure get aws_session_token

    & curl --aws-sigv4 "aws:amz:$Region`:$Service" --user "$AccessKey`:$SecretKey" -H "X-Amz-Security-Token: $SessionToken" @CurlArgs
}
```

Per effettuare una richiesta curl autenticata con sigv4, puoi invocare `acurl` come negli esempi seguenti:

###### API Gateway
```powershell
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### Streaming Lambda function url
```powershell
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
  </TabItem>
</Tabs>

</Drawer>
</li>
</ul>


<Tabs>
  <TabItem label="Locale">
    Avvia il server locale `game-api` eseguendo:

    <NxCommands highlights={['dungeon-adventure-infra-sandbox-Application-ElectroDbTableXXX-YYY']} env={{TABLE_NAME:"dungeon-adventure-infra-sandbox-Application-ElectroDbTableXXX-YYY"}} commands={["run @dungeon-adventure/game-api:serve"]} />

    <Aside type="caution">
    Utilizza il valore `dungeon-adventure-infra-sandbox-Application.ElectroDbTableTableNameXXX` dall'output del deploy CDK per sostituire il segnaposto evidenziato.
    </Aside>

    Una volta avviato il server, puoi chiamarlo con:
    
    ```bash
    curl -X GET 'http://localhost:2022/games.query?input=%7B%7D'
    ```
  </TabItem>
  <TabItem label="Deployato">
```bash "https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/" "ap-southeast-2"
acurl ap-southeast-2 execute-api -X GET 'https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/games.query?input=%7B%7D'
```
    <Aside type="caution">
    Utilizza il valore `dungeon-adventure-infra-sandbox-Application.GameApiGameApiEndpointXXX` dall'output del deploy CDK per sostituire il segnaposto e imposta la regione di conseguenza.
    </Aside>
  </TabItem>
</Tabs>

:::note
Il `%7B%7D` che passiamo per testare l'API è un oggetto JSON vuoto (`{}`) codificato in URI.
:::

Se il comando viene eseguito con successo, dovresti vedere una risposta come:

```json
{"result":{"data":{"items":[],"cursor":null}}}
```

Complimenti, hai costruito e deployato la tua prima API utilizzando tRPC! 🎉🎉🎉