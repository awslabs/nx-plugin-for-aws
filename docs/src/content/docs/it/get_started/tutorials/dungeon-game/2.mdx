---
title: "Implementare l'API del Gioco e il server MCP dell'Inventario"
description: "Una guida dettagliata su come costruire un gioco di avventura in dungeon alimentato da IA agentiva utilizzando @aws/nx-plugin."
---

import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import E2EDiff from '@components/e2e-diff.astro';
import E2ECode from '@components/e2e-code.astro';
import Snippet from '@components/snippet.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

import { getDungeonAdventureElectroDbDependencies } from '../../../../../../../../e2e/src/utils';

## Task 1: Implementare la Game API

Implementeremo le seguenti API in questa sezione:

1. `saveGame` - crea o aggiorna un gioco.
2. `queryGames` - restituisce una lista paginata di giochi salvati precedentemente.
3. `saveAction` - salva un'azione per un determinato gioco.
4. `queryActions` - restituisce una lista paginata di tutte le azioni relative a un gioco.
5. `queryInventory` - restituisce una lista paginata degli oggetti nell'inventario di un giocatore.

### Schema dell'API

Per definire gli input e gli output della nostra API, creiamo il nostro schema utilizzando [Zod](https://zod.dev/) nel file `packages/game-api/src/schema/index.ts` come segue:

<E2EDiff lang="typescript" before="dungeon-adventure/2/schema/index.ts.old.template" after="dungeon-adventure/2/schema/index.ts.template" />

Elimina il file `packages/game-api/src/schema/echo.ts` poich√© non lo utilizzeremo in questo progetto.

<Aside type="tip">
Per ognuno degli schemi che definiamo in Zod, esportiamo anche un'interfaccia utilizzando la sintassi `z.TypeOf`. Questo converte la nostra definizione Zod in un'interfaccia TypeScript senza duplicare gli sforzi.
</Aside>

### Modellazione delle entit√†

Questo √® il diagramma ER per la nostra applicazione.

<Image class="centered-image white-bg" src={dungeonAdventureErPng} alt="dungeon-adventure-er.png" width="400" height="300" />

{/* Generated from the following PlantUML: */}
{/*
@startuml Game API Entity Relationship Diagram

!theme plain

skinparam linetype ortho
skinparam roundcorner 10

entity "Game" as game {
  + playerName : string <<PK>>
  --
  genre : string
  lastUpdated : string
}

entity "Action" as action {
  + playerName : string <<PK>>
  + timestamp : string <<SK>>
  --
  role : string
  content : string
}

entity "Item" as item {
  + playerName : string <<PK>>
  + itemName : string
  --
  emoji : string (optional)
  lastUpdated : string
  quantity : number
}

game ||--o{ action
game ||--o{ item

@enduml
*/}

Implementeremo il nostro database in DynamoDB e utilizzeremo la libreria client [ElectroDB](https://electrodb.dev/en/core-concepts/introduction/) per semplificare le operazioni. Per installare `electrodb` e il DynamoDB Client, esegui questo comando:

<InstallCommand pkg={getDungeonAdventureElectroDbDependencies()} />

<Aside>
Tutte le dipendenze vengono aggiunte al file `package.json` principale poich√© `@aws/nx-plugin` segue il principio della [single version policy](https://nx.dev/concepts/decisions/dependency-management#single-version-policy). Per maggiori informazioni, consulta la <Link path="guides/typescript-project#dependencies">guida ts#project</Link>.
</Aside>

Per definire le entit√† ElectroDB dal diagramma ER, creiamo il file `packages/game-api/src/entities/index.ts`:

<E2ECode lang="typescript" path="dungeon-adventure/2/entities/index.ts.template" />

ElectroDB ci permette non solo di definire i nostri tipi, ma pu√≤ anche fornire valori predefiniti per certi campi come i timestamp. Inoltre, ElectroDB segue il [single-table design](https://electrodb.dev/en/core-concepts/single-table-relationships/), che √® la best practice quando si utilizza DynamoDB.

<Aside>
Sebbene ElectroDB supporti le [collections](https://electrodb.dev/en/modeling/collections/), in questo tutorial abbiamo scelto di non utilizzarle per semplicit√†.
</Aside>

Per preparare il server MCP a interagire con l'inventario, assicuriamoci di esportare l'entit√† dell'inventario in `packages/game-api/src/index.ts`:

<Tabs>
<TabItem label="packages/game-api/src/index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/index.ts.old.template" after="dungeon-adventure/2/index.ts.template" />
</TabItem>
</Tabs>

:::note
La struttura del pacchetto sarebbe migliore se rifattorizzassimo le entit√† in un progetto condiviso separato, in modo che il server MCP non debba dipendere dall'API.
:::

### Definizione delle procedure

Per implementare i metodi dell'API, apporta le seguenti modifiche in `packages/game-api/src/procedures`:

<Tabs>
  <TabItem label="actions.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/actions.ts.template" />
  </TabItem>
  <TabItem label="games.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/games.ts.template" />
  </TabItem>
  <TabItem label="inventory.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/inventory.ts.template" />
  </TabItem>
</Tabs>

Elimina il file `echo.ts` (da `packages/game-api/src/procedures`) poich√© non lo utilizzeremo in questo progetto.

### Configurazione del router

Dopo aver definito le nostre procedure, per collegarle alla nostra API, aggiorna il seguente file:

<Tabs>
  <TabItem label="packages/game-api/src/router.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/router.ts.old.template" after="dungeon-adventure/2/router.ts.template" />
</TabItem>
</Tabs>

## Task 2: Creare un server MCP per l'inventario

Creiamo un server MCP che permetter√† al nostro agente di gestire gli oggetti nell'inventario di un giocatore.

Definiremo i seguenti strumenti per il nostro agente:

- `list-inventory-items` per recuperare gli oggetti correnti nell'inventario del giocatore
- `add-to-inventory` per aggiungere oggetti all'inventario del giocatore
- `remove-from-inventory` per rimuovere oggetti dall'inventario del giocatore

Per risparmiare tempo, definiremo tutti gli strumenti inline:

<Tabs>
  <TabItem label="packages/inventory/src/mcp-server/server.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/mcp/server.ts.old.template" after="dungeon-adventure/2/mcp/server.ts.template" />
</TabItem>
</Tabs>

Man mano che il numero di strumenti cresce, puoi eventualmente rifattorizzarli in file separati.

Elimina le directory `tools` e `resources` in `packages/inventory/src/mcp-server` poich√© non verranno utilizzate.

## Task 3: Aggiornare l'infrastruttura

Il passo finale √® aggiornare la nostra infrastruttura per creare la tabella DynamoDB e concedere i permessi per eseguire operazioni dalla Game API.
Per farlo, aggiorna `packages/infra/src` come segue:

<Tabs>
  <TabItem label="constructs/electrodb-table.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/constructs/electrodb-table.ts.template" />
  </TabItem>
  <TabItem label="stacks/application-stack.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/1/application-stack.ts.template" after="dungeon-adventure/2/stacks/application-stack.ts.template" />

:::note
Nota qui che poich√© ogni procedura √® gestita da una singola funzione lambda, possiamo seguire il principio del minimo privilegio e assegnare solo i permessi di lettura/scrittura necessari in base all'implementazione della procedura.
:::
  </TabItem>
</Tabs>

## Task 4: Deployment e testing

Prima, correggi eventuali problemi di linting:

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />

Poi compila la codebase:

<NxCommands commands={['run-many --target build --all']} />

### Deployare l'applicazione
Per deployare la tua applicazione, esegui il seguente comando:

<NxCommands commands={['deploy infra "dungeon-adventure-infra-sandbox/*"']} />

:::caution
Per eseguire il bootstrap del tuo account AWS prima, esegui:

<NxCommands commands={['bootstrap infra']} />
:::

Il primo deployment richieder√† circa 8 minuti. I deployment successivi richiederanno circa 2 minuti.

:::tip
Se stai modificando il codice delle funzioni Lambda, puoi eseguire il deploy con il flag `--hotswap` dopo aver compilato la codebase per un tempo di deployment molto pi√π breve (2-3 secondi).

<NxCommands commands={['run @dungeon-adventure/infra:deploy "dungeon-adventure-infra-sandbox/*" --hotswap']} />
:::

Una volta completato il deployment, vedrai output simili ai seguenti _(alcuni valori sono stati oscurati)_:

```bash
dungeon-adventure-sandbox-Application
dungeon-adventure-sandbox-Application: deploying... [2/2]

 ‚úÖ  dungeon-adventure-sandbox-Application

‚ú®  Deployment time: 354s

Outputs:
dungeon-adventure-sandbox-Application.ElectroDbTableTableNameXXX = dungeon-adventure-sandbox-Application-ElectroDbTableXXX-YYY
dungeon-adventure-sandbox-Application.GameApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-sandbox-Application.GameUIDistributionDomainNameXXX = xxx.cloudfront.net
dungeon-adventure-sandbox-Application.StoryApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-sandbox-Application.UserIdentityUserIdentityIdentityPoolIdXXX = region:xxx
dungeon-adventure-sandbox-Application.UserIdentityUserIdentityUserPoolIdXXX = region_xxx
```
### Testare l'API
Puoi testare l'API in due modi:
<ul>
<li>Avviando un'istanza locale del backend tRPC e invocando le API con `curl`.</li>
<li>
<Drawer title="Curl con Sigv4 abilitato" trigger="Chiamare l'API deployata utilizzando curl con sigv4 abilitato">
<Snippet name="tools/acurl" />
</Drawer>
</li>
</ul>


<Tabs>
  <TabItem label="Locale">
    Per avviare il server locale `game-api`, esegui il seguente comando:

    <NxCommands highlights={['dungeon-adventure-infra-sandbox-Application-ElectroDbTableXXX-YYY']} env={{TABLE_NAME:"dungeon-adventure-infra-sandbox-Application-ElectroDbTableXXX-YYY"}} commands={["run @dungeon-adventure/game-api:serve"]} />

    <Aside type="caution">
    Utilizza il valore `dungeon-adventure-infra-sandbox-Application.ElectroDbTableTableNameXXX` dall'output del deploy CDK per sostituire il segnaposto evidenziato.
    </Aside>

    Una volta avviato il server, puoi chiamarlo eseguendo il seguente comando:

    ```bash
    curl -X GET 'http://localhost:2022/games.query?input=%7B%7D'
    ```
  </TabItem>
  <TabItem label="Deployato">
```bash "https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/" "ap-southeast-2"
acurl ap-southeast-2 execute-api -X GET 'https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/games.query?input=%7B%7D'
```
    <Aside type="caution">
    Utilizza il valore `dungeon-adventure-infra-sandbox-Application.GameApiGameApiEndpointXXX` dall'output del deploy CDK per sostituire il segnaposto evidenziato e imposta la regione di conseguenza.
    </Aside>
  </TabItem>
</Tabs>

:::note
Il `%7B%7D` che passiamo per testare l'API √® un oggetto JSON vuoto (`{}`) codificato in URI.
:::

Se il comando viene eseguito con successo, vedrai una risposta come:

```json
{"result":{"data":{"items":[],"cursor":null}}}
```

Complimenti, hai costruito e deployato la tua prima API utilizzando tRPC!  üéâüéâüéâ