---
title: "Gioco di Dungeon con IA Agentiva"
description: "Una guida dettagliata su come costruire un gioco di avventura in dungeon alimentato da IA agentiva utilizzando @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import E2EDiff from '@components/e2e-diff.astro';
import E2ECode from '@components/e2e-code.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Modulo 2: Implementazione dell'API di gioco e del server MCP per l'inventario

Inizieremo implementando la nostra Game API. Per farlo, dobbiamo creare 5 API in totale:

1. `saveGame` - creare o aggiornare un gioco.
2. `queryGames` - restituire una lista paginata di giochi salvati precedentemente.
3. `saveAction` - salvare un'azione per un determinato gioco.
4. `queryActions` - restituire una lista paginata di tutte le azioni relative a un gioco.
5. `queryInventory` - restituire una lista paginata degli oggetti nell'inventario di un giocatore.

### Schema delle API

Per definire gli input e output delle nostre API, creiamo lo schema utilizzando [Zod](https://zod.dev/) nella directory `packages/game-api/src/schema` come segue:

<Tabs>
  <TabItem label="action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/action.ts.template" />
  </TabItem>
  <TabItem label="common.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/common.ts.template" />
  </TabItem>
  <TabItem label="game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/game.ts.template" />
  </TabItem>
  <TabItem label="inventory.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/inventory.ts.template" />
  </TabItem>
  <TabItem label="index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/schema/index.ts.old.template" after="dungeon-adventure/2/schema/index.ts.template" />
  </TabItem>
</Tabs>

Puoi anche eliminare il file `packages/game-api/src/schema/echo.ts` dato che non verrà utilizzato in questo progetto.

<Aside type="tip">
Come puoi vedere sopra, per ogni schema definito con Zod, esportiamo anche un'interfaccia utilizzando la sintassi `z.TypeOf`. Questo ci permette di convertire la definizione Zod in un'interfaccia TypeScript senza duplicare gli sforzi!
</Aside>

### Modellazione delle entità

Il diagramma ER per la nostra applicazione è il seguente:

<Image class="centered-image white-bg" src={dungeonAdventureErPng} alt="dungeon-adventure-er.png" width="400" height="300" />

{/* Generated from the following PlantUML: */}
{/*
@startuml Game API Entity Relationship Diagram

!theme plain

skinparam linetype ortho
skinparam roundcorner 10

entity "Game" as game {
  + playerName : string <<PK>>
  --
  genre : string
  lastUpdated : string
}

entity "Action" as action {
  + playerName : string <<PK>>
  + timestamp : string <<SK>>
  --
  role : string
  content : string
}

entity "Item" as item {
  + playerName : string <<PK>>
  + itemName : string
  --
  emoji : string (optional)
  lastUpdated : string
  quantity : number
}

game ||--o{ action
game ||--o{ item

@enduml
*/}

Implementeremo il database su DynamoDB utilizzando la libreria client [ElectroDB](https://electrodb.dev/en/core-concepts/introduction/) per semplificare le operazioni. Per iniziare, installiamo `electrodb` eseguendo:

<InstallCommand pkg="electrodb @aws-sdk/client-dynamodb" />

<Aside>
Tutte le dipendenze vengono aggiunte al file `package.json` principale poiché `@aws/nx-plugin` segue il principio di [single version policy](https://nx.dev/concepts/decisions/dependency-management#single-version-policy). Per maggiori informazioni, consulta la <Link path="guides/typescript-project#dependencies">guida ts#project</Link>.
</Aside>

Ora creiamo i seguenti file nella cartella `packages/game-api/src/entities` per definire le nostre entità ElectroDB secondo il diagramma ER sopra:

<Tabs>
  <TabItem label="action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/action.ts.template" />
  </TabItem>
  <TabItem label="game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/game.ts.template" />
  </TabItem>
  <TabItem label="inventory.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/inventory.ts.template" />
  </TabItem>
</Tabs>

ElectroDB ci permette non solo di definire i tipi, ma anche di fornire valori predefiniti per alcuni campi come i timestamp sopra. Inoltre, ElectroDB utilizza il [single-table design](https://electrodb.dev/en/core-concepts/single-table-relationships/), considerata best practice con DynamoDB.

<Aside>
Sebbene ElectroDB supporti le [collections](https://electrodb.dev/en/modeling/collections/), in questo tutorial non le utilizzeremo per semplicità.
</Aside>

Per preparare l'interazione del server MCP con l'inventario, assicuriamoci di esportare l'entità inventory in `packages/game-api/src/index.ts`:

<Tabs>
<TabItem label="packages/game-api/src/index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/index.ts.old.template" after="dungeon-adventure/2/index.ts.template" />
</TabItem>
</Tabs>

:::note
La struttura del pacchetto migliorerebbe se rifattorizzassimo le entità in un progetto condiviso, evitando che il server MCP dipenda direttamente dall'API.
:::

### Aggiunta del client DynamoDB al contesto tRPC

Dato che abbiamo bisogno di accedere al client DynamoDB in ogni procedura, vogliamo creare un'istanza unica del client da passare tramite contesto. Apportiamo queste modifiche in `packages/game-api/src`:

<Tabs>
  <TabItem label="middleware/dynamodb.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/middleware/dynamodb.ts.template" />

Questo è un plugin che utilizziamo per creare il `DynamoDBClient` e iniettarlo nel contesto.
  </TabItem>
  <TabItem label="middleware/index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/middleware/index.ts.old.template" after="dungeon-adventure/2/middleware/index.ts.template" />

Estendiamo `IMiddlewareContext` per aggiungere `IDynamoDBContext`.
  </TabItem>
  <TabItem label="init.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/init.ts.old.template" after="dungeon-adventure/2/init.ts.template" />

Il plugin DynamoDB viene integrato.

<Aside>
L'API `concat` associa il nostro middleware alle procedure definite. Per dettagli, consulta la [guida concat](https://trpc.io/docs/server/middlewares#concat).
</Aside>
  </TabItem>
</Tabs>

### Definizione delle procedure

Ora implementiamo i metodi dell'API. Apportiamo queste modifiche in `packages/game-api/src/procedures`:

#### Query

<Tabs>
  <TabItem label="query-actions.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-actions.ts.template" />
  </TabItem>
  <TabItem label="query-games.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-games.ts.template" />
  </TabItem>
  <TabItem label="query-inventory.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-inventory.ts.template" />
  </TabItem>
</Tabs>

#### Mutazioni

<Tabs>
  <TabItem label="save-action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/save-action.ts.template" />
  </TabItem>
  <TabItem label="save-game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/save-game.ts.template" />
  </TabItem>
</Tabs>

Puoi anche eliminare il file `echo.ts` (da `packages/game-api/src/procedures`) poiché non verrà utilizzato.

### Configurazione del router

Ora che abbiamo definito le procedure, colleghiamole all'API. Aggiorniamo:

<Tabs>
  <TabItem label="packages/game-api/src/router.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/router.ts.old.template" after="dungeon-adventure/2/router.ts.template" />
</TabItem>
</Tabs>

### Server MCP per l'inventario

Creiamo ora un server MCP che permetta al nostro agente di gestire gli oggetti nell'inventario del giocatore.

Definiamo i seguenti strumenti per l'Agente:

- `list-inventory-items` per recuperare gli oggetti correnti nell'inventario
- `add-to-inventory` per aggiungere oggetti all'inventario
- `remove-from-inventory` per rimuovere oggetti dall'inventario

Per risparmiare tempo, definiremo tutti gli strumenti inline:

<Tabs>
  <TabItem label="packages/inventory/src/mcp-server/server.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/mcp/server.ts.old.template" after="dungeon-adventure/2/mcp/server.ts.template" />
</TabItem>
</Tabs>

Man mano che il numero di strumenti cresce, puoi eventualmente organizzarli in file separati.

Ora puoi eliminare le directory `tools` e `resources` in `packages/inventory/src/mcp-server` poiché non sono utilizzate.

### Infrastruttura

L'ultimo passo è aggiornare l'infrastruttura per creare la tabella DynamoDB e concedere i permessi alle operazioni dell'API. Modifichiamo `packages/infra/src` come segue:

<Tabs>
  <TabItem label="constructs/electrodb-table.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/constructs/electrodb-table.ts.template" />
  </TabItem>
  <TabItem label="stacks/application-stack.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/1/application-stack.ts.template" after="dungeon-adventure/2/stacks/application-stack.ts.template" />

:::note
Nota che ogni procedura è servita da una funzione lambda separata, permettendoci di applicare il principio del minimo privilegio assegnando solo i permessi necessari.
:::
  </TabItem>
</Tabs>

### Deployment e test

Prima compiliamo il codice:

<NxCommands commands={['run-many --target build --all']} />

<Aside type="tip">
Se incontri errori di linting, puoi eseguire:

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

Ora puoi deployare l'applicazione con:

<NxCommands commands={['deploy infra dungeon-adventure-infra-sandbox/*']} />

:::caution
Potresti dover eseguire il bootstrap dell'account AWS prima con:

<NxCommands commands={['bootstrap infra']} />
:::

Il primo deployment richiederà circa 8 minuti. I successivi circa 2 minuti.

:::tip
Per modifiche al codice lambda, puoi usare il flag `--hotswap` dopo la build per deployment rapidi (2-3 secondi):

<NxCommands commands={['run @dungeon-adventure/infra:deploy dungeon-adventure-infra-sandbox/* --hotswap']} />
:::

Al termine del deployment, vedrai output simili a questi _(alcuni valori sono oscurati)_:

```bash
dungeon-adventure-sandbox-Application
dungeon-adventure-sandbox-Application: deploying... [2/2]

 ✅  dungeon-adventure-sandbox-Application

✨  Deployment time: 354s

Outputs:
dungeon-adventure-sandbox-Application.ElectroDbTableTableNameXXX = dungeon-adventure-sandbox-Application-ElectroDbTableXXX-YYY
dungeon-adventure-sandbox-Application.GameApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-sandbox-Application.GameUIDistributionDomainNameXXX = xxx.cloudfront.net
dungeon-adventure-sandbox-Application.StoryApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-sandbox-Application.UserIdentityUserIdentityIdentityPoolIdXXX = region:xxx
dungeon-adventure-sandbox-Application.UserIdentityUserIdentityUserPoolIdXXX = region_xxx
```

Possiamo testare l'API in due modi:
<ul>
<li>Avviando un'istanza locale del backend tRPC e invocando le API con `curl`</li>
<li>
<Drawer title="curl abilitato per Sigv4" trigger="Chiamare l'API deployata usando curl con Sigv4">

<Tabs>
  <TabItem label="Bash/Linux/macOS">
Aggiungi questo script al tuo `.bashrc` o incollalo nella stessa sessione terminale:
```bash
// ~/.bashrc
acurl () {
    REGION=$1
    SERVICE=$2
    shift; shift;
    curl --aws-sigv4 "aws:amz:$REGION:$SERVICE" --user "$(aws configure get aws_access_key_id):$(aws configure get aws_secret_access_key)" -H "X-Amz-Security-Token: $(aws configure get aws_session_token)" "$@"
}
```

Esempi di utilizzo:

###### API Gateway
```bash
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### Lambda function URL
```bash
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
  </TabItem>
  <TabItem label="Windows PowerShell">
Aggiungi questa funzione al tuo profilo PowerShell o incollala nella sessione corrente:
```powershell
function acurl {
    param(
        [Parameter(Mandatory=$true)][string]$Region,
        [Parameter(Mandatory=$true)][string]$Service,
        [Parameter(ValueFromRemainingArguments=$true)][string[]]$CurlArgs
    )

    $AccessKey = aws configure get aws_access_key_id
    $SecretKey = aws configure get aws_secret_access_key
    $SessionToken = aws configure get aws_session_token

    & curl --aws-sigv4 "aws:amz:$Region`:$Service" --user "$AccessKey`:$SecretKey" -H "X-Amz-Security-Token: $SessionToken" @CurlArgs
}
```

Esempi di utilizzo:

###### API Gateway
```powershell
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### Lambda function URL
```powershell
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
  </TabItem>
</Tabs>

</Drawer>
</li>
</ul>


<Tabs>
  <TabItem label="Locale">
    Avvia il server locale `game-api` con:

    <NxCommands highlights={['dungeon-adventure-infra-sandbox-Application-ElectroDbTableXXX-YYY']} env={{TABLE_NAME:"dungeon-adventure-infra-sandbox-Application-ElectroDbTableXXX-YYY"}} commands={["run @dungeon-adventure/game-api:serve"]} />

    <Aside type="caution">
    Utilizza il valore `dungeon-adventure-infra-sandbox-Application.ElectroDbTableTableNameXXX` dall'output del deploy CDK.
    </Aside>

    Esegui poi:
    ```bash
    curl -X GET 'http://localhost:2022/games.query?input=%7B%7D'
    ```
  </TabItem>
  <TabItem label="Deployato">
```bash "https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/" "ap-southeast-2"
acurl ap-southeast-2 execute-api -X GET 'https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/games.query?input=%7B%7D'
```
    <Aside type="caution">
    Utilizza il valore `dungeon-adventure-infra-sandbox-Application.GameApiGameApiEndpointXXX` dall'output CDK.
    </Aside>
  </TabItem>
</Tabs>

:::note
Il parametro `%7B%7D` rappresenta un oggetto JSON vuoto (`{}`) codificato in URI.
:::

Se il comando ha successo, vedrai:
```json
{"result":{"data":{"items":[],"cursor":null}}}
```

Complimenti, hai implementato e deployato la tua prima API con tRPC! 🎉🎉🎉