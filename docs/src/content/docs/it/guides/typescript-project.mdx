---
title: "Progetti TypeScript"
description: "Documentazione di riferimento per progetti TypeScript"
---

import { FileTree } from '@astrojs/starlight/components';
import RunGenerator from '@components/run-generator.astro';
import InstallCommand from '@components/install-command.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import PackageManagerShortCommand from '@components/package-manager-short-command.astro';
import Link from '@components/link.astro';

Il generatore di progetti TypeScript può essere utilizzato per creare una libreria o un'applicazione moderna [TypeScript](https://www.typescriptlang.org/) configurata con le migliori pratiche come [ECMAScript Modules (ESM)](https://www.typescriptlang.org/docs/handbook/modules/reference.html), i [riferimenti di progetto](https://www.typescriptlang.org/docs/handbook/project-references.html) di TypeScript, [Vitest](https://vitest.dev/) per l'esecuzione dei test e [ESLint](https://eslint.org/) per l'analisi statica.

## Utilizzo

### Genera un progetto TypeScript

Puoi generare un nuovo progetto TypeScript in due modi:

<RunGenerator generator="ts#project" />

### Opzioni

<GeneratorParameters generator="ts#project" />

## Output del generatore

Il generatore creerà la seguente struttura del progetto nella directory `<directory>/<name>`:

<FileTree>

  - src Codice sorgente TypeScript
    - index.ts
  - project.json Configurazione del progetto e target di build
  - tsconfig.json Configurazione TypeScript di base per questo progetto (estende tsconfig.base.json nella root del workspace)
  - tsconfig.lib.json Configurazione TypeScript per la tua libreria (codice runtime o sorgente impacchettato)
  - tsconfig.spec.json Configurazione TypeScript per i test
  - vitest.config.mts Configurazione per Vitest
  - eslint.config.mjs Configurazione per ESLint

</FileTree>

:::tip
Nota che non viene creato alcun file `package.json` per questo progetto! Puoi scoprire il motivo [qui sotto](#dependencies).
:::

Noterai anche alcune modifiche ai seguenti file nella root del workspace:

<FileTree>

  - nx.json La configurazione di Nx viene aggiornata per configurare il plugin @nx/js/typescript per il tuo progetto
  - tsconfig.base.json Viene impostato un alias TypeScript per il tuo progetto in modo che possa essere importato da altri progetti nel workspace
  - tsconfig.json Viene aggiunto un riferimento di progetto TypeScript per il tuo progetto

</FileTree>

## Scrivere codice TypeScript

Aggiungi il tuo codice TypeScript nella directory `src`.

### Sintassi di import ESM

Poiché il tuo progetto TypeScript è un ES Module, assicurati di scrivere le istruzioni di import con la corretta sintassi ESM, riferendo esplicitamente l'estensione del file:

```ts title="index.ts" ".js"
import { sayHello } from './hello.js';
```

:::note
Anche se stiamo usando TypeScript e `sayHello` è definito in `hello.ts`, utilizziamo l'estensione `.js` nel nostro import. Puoi leggere maggiori dettagli [qui](https://www.typescriptlang.org/docs/handbook/modules/reference.html).
:::

### Esportare per altri progetti TypeScript

Il punto di ingresso per il tuo progetto TypeScript è `src/index.ts`. Puoi aggiungere qui le esportazioni per qualsiasi elemento che desideri rendere disponibile ad altri progetti:

```ts title="src/index.ts"
export { sayHello } from './hello.js';
export * from './algorithms/index.js';
```

### Importare il codice della libreria in altri progetti

Gli [alias TypeScript](https://www.typescriptlang.org/docs/handbook/modules/reference.html#paths) per il tuo progetto sono configurati nel `tsconfig.base.json` del workspace, consentendo di riferire il tuo progetto TypeScript da altri progetti TypeScript:

```ts title="packages/my-other-project/src/index.ts"
import { sayHello } from ':my-scope/my-library';
```

:::note
Gli alias per i progetti TypeScript iniziano con `:` invece del tradizionale `@`, per evitare possibili conflitti di nome tra pacchetti locali nel workspace e pacchetti remoti su [NPM](https://www.npmjs.com/).
:::

Quando aggiungi un'istruzione di import per un nuovo progetto nel workspace per la prima volta, potresti vedere un errore nel tuo IDE simile al seguente:

<details>
<summary>Errore di importazione</summary>

```bash wrap
File '/path/to/my/workspace/packages/my-library/src/index.ts' is not under 'rootDir' '/path/to/my/workspace/packages/my-consumer'. 'rootDir' is expected to contain all source files.
  File is ECMAScript module because '/path/to/my/workspace/package.json' has field "type" with value "module" ts(6059)
File '/path/to/my/workspace/packages/my-library/src/index.ts' is not listed within the file list of project '/path/to/my/workspace/packages/my-consumer/tsconfig.lib.json'. Projects must list all files or use an 'include' pattern.
  File is ECMAScript module because '/path/to/my/workspace/package.json' has field "type" with value "module" ts(6307)
```

</details>

Questo accade perché non è stato configurato un [riferimento di progetto](https://www.typescriptlang.org/docs/handbook/project-references.html).

I progetti TypeScript sono configurati con il generatore Nx TypeScript Sync out-of-the-box, evitando la necessità di configurare manualmente i riferimenti. Esegui semplicemente il seguente comando e Nx aggiungerà la configurazione necessaria:

<NxCommands commands={['sync']} />

Dopo questo passaggio, l'errore nel tuo IDE dovrebbe scomparire e sarai pronto a utilizzare la tua libreria.

:::tip
Puoi anche semplicemente buildare il tuo progetto e vedrai un messaggio come:

```bash wrap
[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date?
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Seleziona `Yes` per consentire a Nx di aggiornare i riferimenti del progetto.
:::

### Mantenere gli alias di percorso sincronizzati

Se aggiungi voci personalizzate `compilerOptions.paths` nel `tsconfig.json` di un progetto, TypeScript smette di ereditare gli alias del workspace definiti in `tsconfig.base.json`. Il generatore nascosto `ts#sync` viene eseguito prima del target `compile` (configurato in `nx.json`) per copiare eventuali alias di base mancanti nei file `tsconfig.json`, `tsconfig.lib.json` e `tsconfig.app.json` che già dichiarano `paths`. Per disattivare questa funzionalità, rimuovi `@aws/nx-plugin:ts#sync` da `targetDefaults.compile.syncGenerators` in `nx.json`.

### Dipendenze

Noterai che il tuo progetto TypeScript non ha un file `package.json`, cosa che potrebbe sorprendere se sei abituato a monorepo TypeScript tradizionali.

Per aggiungere una dipendenza a un pacchetto TypeScript nel tuo monorepo, aggiungi semplicemente la dipendenza al `package.json` nella root del workspace. Puoi farlo tramite la linea di comando del tuo package manager:

<InstallCommand pkg="some-npm-package" />

La dipendenza sarà quindi disponibile per qualsiasi progetto TypeScript nel workspace.

#### Codice runtime

Quando utilizzi il tuo progetto TypeScript come codice runtime (ad esempio come handler per una funzione AWS Lambda), è consigliato utilizzare uno strumento come [Rolldown](https://rolldown.rs/) per bundle del progetto, poiché permette di effettuare [tree-shaking](https://rolldown.rs/guide/in-depth/why-bundlers) per includere solo le dipendenze effettivamente utilizzate.

Puoi ottenere questo aggiungendo un target come il seguente nel tuo file `project.json`:

```json
{
  ...
  "targets": {
    ...
    "bundle": {
      "cache": true,
      "executor": "nx:run-commands",
      "outputs": ["{workspaceRoot}/dist/packages/my-library/bundle"],
      "options": {
        "command": "rolldown -c rolldown.config.ts"
      }
    },
  },
}
```

E aggiungendo il file `rolldown.config.ts` come segue:

```ts
// rolldown.config.ts
import { defineConfig } from 'rolldown';

export default defineConfig([
  {
    input: 'src/index.ts',
    output: {
      file: '../../dist/packages/my-library/bundle/index.js',
      format: 'cjs',
      inlineDynamicImports: true,
    },
  },
]);
```

:::note
Nota che nel target sopra abbiamo scelto `src/index.ts` come entrypoint per il bundle, il che significa che il codice esportato da questo file sarà incluso nel bundle, insieme a tutte le sue dipendenze.
:::

:::tip
Se stai costruendo una funzione AWS Lambda, consulta il generatore <Link path="/guides/ts-lambda-function">`ts#lambda-function`</Link> che configura il bundling automaticamente, oltre a generare l'infrastruttura e aggiungere osservabilità e type-safety.
:::

#### Pubblicazione su NPM

Se pubblichi il tuo progetto TypeScript su NPM, devi creare un file `package.json` per esso.

Questo deve dichiarare le dipendenze utilizzate dal progetto. Poiché al momento della build le dipendenze vengono risolte tramite il `package.json` della root del workspace, è consigliato configurare il [Nx Dependency Checks ESLint Plugin](https://nx.dev/nx-api/eslint-plugin/documents/dependency-checks) per assicurarsi che il `package.json` del progetto pubblicato includa tutte le dipendenze utilizzate.

### Build

Il tuo progetto TypeScript è configurato con un target `build` (definito in `project.json`), che puoi eseguire tramite:

<NxCommands commands={['run <project-name>:build']} />

Dove `<project-name>` è il nome completo del tuo progetto.

Il target `build` compilerà, eseguirà il lint e testerà il progetto.

L'output della build si trova nella cartella `dist` della root del workspace, all'interno di una directory specifica per il pacchetto e il target, ad esempio `dist/packages/<my-library>/tsc`

Per buildare tutti i progetti nel tuo workspace, esegui:

<NxCommands commands={['run-many --target build']} />

Oppure utilizza il comando abbreviato:

<PackageManagerShortCommand commands={["build"]} />

## Testing

[Vitest](https://vitest.dev/) è configurato per testare il tuo progetto.

### Scrivere test

I test devono essere scritti in file `.spec.ts` o `.test.ts`, posizionati nella cartella `src` del progetto.

Esempio:

<FileTree>
  - src
    - hello.ts Codice sorgente della libreria
    - hello.spec.ts Test per hello.ts
</FileTree>

Vitest fornisce una sintassi simile a Jest per definire i test, con utility come `describe`, `it`, `test` e `expect`.

```ts title="hello.spec.ts"
import { sayHello } from './hello.js';

describe('sayHello', () => {

  it('should greet the caller', () => {
    expect(sayHello('Darth Vader')).toBe('Hello, Darth Vader!');
  });

});

```

Per maggiori dettagli su come scrivere test e funzionalità come il mocking delle dipendenze, consulta la [documentazione di Vitest](https://vitest.dev/guide/#writing-tests)

### Eseguire i test

I test verranno eseguiti come parte del target `build` del progetto, ma puoi anche eseguirli separatamente con il target `test`:

<NxCommands commands={['run <project-name>:test']} />

Puoi eseguire un singolo test o una suite di test usando il flag `-t`:

<NxCommands commands={["run <project-name>:test -t 'sayHello'"]} />

:::tip
Se utilizzi VSCode, ti consigliamo di installare l'estensione [Vitest Runner for VSCode that actually works](https://marketplace.visualstudio.com/items?itemName=rluvaton.vscode-vitest), che permette di eseguire, monitorare o debuggare i test direttamente dall'IDE.
:::

## Linting

I progetti TypeScript utilizzano [ESLint](https://eslint.org/) per il linting, insieme a [Prettier](https://prettier.io/) per la formattazione.

Consigliamo di configurare ESLint nel file `eslint.config.mjs` della root del workspace, in modo che le modifiche si applichino a tutti i progetti TypeScript nel workspace garantendo coerenza.

Allo stesso modo, puoi configurare Prettier nel file `.prettierrc` della root.

### Eseguire il linter

Per invocare il linter e verificare il progetto, puoi eseguire il target `lint`:

<NxCommands commands={["run <project-name>:lint"]} />

### Correggere i problemi di lint

La maggior parte dei problemi di linting o formattazione può essere corretta automaticamente. Puoi chiedere a ESLint di correggere i problemi eseguendo con l'argomento `--configuration=fix`:

<NxCommands commands={["run <project-name>:lint --configuration=fix"]} />

Analogamente, se vuoi correggere tutti i problemi di lint in tutti i pacchetti del workspace, puoi eseguire:

<NxCommands commands={["run-many --target lint --all --configuration=fix"]} />

:::tip
Questo ha un comando abbreviato dalla root del tuo workspace:

<PackageManagerShortCommand commands={["lint"]} />
:::

### Saltare i problemi di lint

Per evitare che i problemi di linting ti rallentino durante lo sviluppo (in particolare se hai problemi non auto-correggibili nel tuo progetto), puoi eseguire una build con la configurazione `skip-lint`:

<NxCommands commands={["run-many --target build --configuration=skip-lint"]} />

Questo eseguirà comunque ESLint come parte della build, ma il target lint sarà sempre considerato riuscito.

:::tip
Questo ha un comando abbreviato dalla root del tuo workspace:

<PackageManagerShortCommand commands={["build:skip-lint"]} />
:::