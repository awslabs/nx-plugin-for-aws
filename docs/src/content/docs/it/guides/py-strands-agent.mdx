---
title: "Agente Python Strands"
description: "Genera un Agente Python Strands per costruire agenti AI con strumenti e distribuirli su Amazon Bedrock AgentCore Runtime"
---

import { FileTree } from '@astrojs/starlight/components';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import Link from '@components/link.astro';
import Snippet from '@components/snippet.astro';
import Infrastructure from '@components/infrastructure.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import Drawer from '@components/drawer.astro';

Genera un [Agente Strands](https://strandsagents.com/) in Python per costruire agenti AI con strumenti, e opzionalmente distribuiscilo su [Amazon Bedrock AgentCore Runtime](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/).

## Cos'è Strands?

[Strands](https://strandsagents.com/latest/documentation/docs/) è un framework Python leggero e pronto per la produzione per costruire agenti AI. Caratteristiche principali:

- **Leggero e personalizzabile**: Ciclo agenti semplice che non ostacola il lavoro
- **Pronto per la produzione**: Osservabilità completa, tracciamento e opzioni di distribuzione scalabili
- **Agnostico su modelli e provider**: Supporta molti modelli diversi da vari provider  
- **Strumenti della community**: Set potente di strumenti contribuiti dalla community
- **Supporto multi-agente**: Tecniche avanzate come team di agenti e agenti autonomi
- **Modalità interattive flessibili**: Supporto conversazionale, streaming e non-streaming

## Utilizzo

### Genera un Agente Strands

Puoi generare un Agente Strands in Python in due modi:

<RunGenerator generator="py#strands-agent" />

:::tip
Prima utilizza il generatore <Link path="/guides/python-project">`py#project`</Link> per creare un progetto a cui aggiungere il tuo Strands Agent.
:::

### Opzioni

<GeneratorParameters generator="py#strands-agent" />

## Output del Generatore

Il generatore aggiungerà i seguenti file al tuo progetto Python esistente:

<FileTree>
  - your-project/
    - your_module/
      - agent/ (o nome personalizzato se specificato)
        - \_\_init\_\_.py Inizializzazione pacchetto Python
        - agent.py Definizione principale dell'agente con strumenti di esempio
        - main.py Punto d'ingresso per Bedrock AgentCore Runtime
        - agentcore_mcp_client.py Factory client utile per invocare server MCP ospitati su Bedrock AgentCore Runtime
        - Dockerfile Punto d'ingresso per ospitare il tuo agente (escluso se `computeType` è impostato a `None`)
    - pyproject.toml Aggiornato con le dipendenze Strands
    - project.json Aggiornato con i target di servizio dell'agente
</FileTree>

### Infrastruttura

:::note
Se hai selezionato `None` per `computeType`, il generatore non produrrà alcuna infrastruttura as code.
:::

<Snippet name="shared-constructs" />

Per la distribuzione del tuo Strands Agent, vengono generati i seguenti file:

<Infrastructure>
<Fragment slot="cdk">
<FileTree>
  - packages/common/constructs/src
    - app
      - agents
        - \<project-name>
          - \<project-name>.ts Costrutto CDK per distribuire l'agente
          - Dockerfile File Docker pass-through usato dal costrutto CDK
</FileTree>
</Fragment>
<Fragment slot="terraform">
<FileTree>
  - packages/common/terraform/src
    - app
      - agents
        - \<project-name>
          - \<project-name>.tf Modulo per distribuire l'agente
    - core
      - agent-core
        - runtime.tf Modulo generico per distribuire su Bedrock AgentCore Runtime
</FileTree>
</Fragment>
</Infrastructure>

## Lavorare con il tuo Strands Agent

### Aggiungere Strumenti

Gli strumenti sono funzioni che l'agente AI può chiamare per eseguire azioni. Il framework Strands utilizza un approccio semplice basato su decoratori per definire gli strumenti.

Puoi aggiungere nuovi strumenti nel file [`agent.py`](packages/nx-plugin/src/py/strands-agent/files/agent.py.template:6):

```python
from strands import Agent, tool

@tool
def calculate_sum(numbers: list[int]) -> int:
    """Calcola la somma di una lista di numeri"""
    return sum(numbers)

@tool
def get_weather(city: str) -> str:
    """Ottieni informazioni meteo per una città"""
    # Integrazione con l'API meteo qui
    return f"Meteo a {city}: Soleggiato, 25°C"

# Aggiungi strumenti al tuo agente
agent = Agent(
    system_prompt="Sei un assistente utile con accesso a vari strumenti.",
    tools=[calculate_sum, get_weather],
)
```

Il framework Strands gestisce automaticamente:
- Validazione dei tipi basata sugli hint di tipo delle funzioni
- Generazione dello schema JSON per le chiamate agli strumenti
- Gestione errori e formattazione delle risposte

### Utilizzare Strumenti Predefiniti

Strands fornisce una collezione di strumenti predefiniti tramite il pacchetto `strands-tools`:

```python
from strands_tools import current_time, http_request, file_read

agent = Agent(
    system_prompt="Sei un assistente utile.",
    tools=[current_time, http_request, file_read],
)
```

### Configurazione del Modello

Di default, gli agenti Strands usano Claude 4 Sonnet, ma puoi personalizzare il provider del modello. Vedi la [documentazione Strands sui provider di modelli](https://strandsagents.com/latest/documentation/docs/user-guide/quickstart/#model-providers) per le opzioni di configurazione:

```python
from strands import Agent
from strands.models import BedrockModel

# Crea un BedrockModel
bedrock_model = BedrockModel(
    model_id="anthropic.claude-sonnet-4-20250514-v1:0",
    region_name="us-west-2",
    temperature=0.3,
)

agent = Agent(model=bedrock_model)
```

### Utilizzare Server MCP

Puoi [aggiungere strumenti da server MCP](https://strandsagents.com/latest/documentation/docs/user-guide/concepts/tools/mcp-tools/) al tuo agente Strands.

Per utilizzare server MCP creati con i generatori <Link path="/guides/py-mcp-server">`py#mcp-server`</Link> o <Link path="/guides/ts-mcp-server">`ts#mcp-server`</Link> (o altri ospitati su Bedrock AgentCore Runtime), viene generata per te una factory client in `agentcore_mcp_client.py`.

Puoi aggiornare il tuo metodo `get_agent` in `agent.py` per creare client MCP e aggiungere strumenti. L'esempio seguente mostra come farlo con autenticazione IAM (SigV4):

```python
# agent.py
import os
from contextlib import contextmanager

import boto3
from strands import Agent

from .agentcore_mcp_client import AgentCoreMCPClient

# Ottieni regione e credenziali
region = os.environ["AWS_REGION"]
boto_session = boto3.Session(region_name=region)
credentials = boto_session.get_credentials()

@contextmanager
def get_agent(session_id: str):
    mcp_client = AgentCoreMCPClient.with_iam_auth(
        agent_runtime_arn=os.environ["MCP_AGENTCORE_RUNTIME_ARN"],
        credentials=credentials,
        region=region,
        session_id=session_id,
    )

    with mcp_client:
        mcp_tools = mcp_client.list_tools_sync()

        yield Agent(
            system_prompt="..."
            tools=[*mcp_tools],
        )
```

:::tip
Se il tuo server MCP target usa autenticazione JWT, puoi usare il metodo `AgentCoreMCPClient.with_jwt_auth` per creare il client.
:::

Con l'esempio di autenticazione IAM sopra, dobbiamo configurare due cose nella nostra infrastruttura. Primo, aggiungere la variabile d'ambiente che il nostro agente consuma per l'ARN del Runtime AgentCore del server MCP, e secondo, concedere i permessi al nostro agente per invocare il server MCP. Questo può essere ottenuto come segue:

<Infrastructure>
<Fragment slot="cdk">
```ts {9, 13}
import { MyProjectAgent, MyProjectMcpServer } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const mcpServer = new MyProjectMcpServer(this, 'MyProjectMcpServer');

    const agent = new MyProjectAgent(this, 'MyProjectAgent', {
      environmentVariables: {
        MCP_AGENTCORE_RUNTIME_ARN: mcpServer.agentCoreRuntime.agentRuntimeArn,
      },
    });

    mcpServer.agentCoreRuntime.grantInvoke(agent.agentCoreRuntime);
  }
}
```
</Fragment>
<Fragment slot="terraform">
```terraform
# MCP Server
module "my_project_mcp_server" {
  source = "../../common/terraform/src/app/mcp-servers/my-project-mcp-server"
}

# Agent
module "my_project_agent" {
  source = "../../common/terraform/src/app/agents/my-project-agent"

  env = {
    MCP_AGENTCORE_RUNTIME_ARN = module.my_project_mcp_server.agent_core_runtime_arn
  }

  additional_iam_policy_statements = [
    {
      Effect = "Allow"
      Action = [
        "bedrock-agentcore:InvokeAgentRuntime"
      ]
      Resource = [
        module.my_project_mcp_server.agent_core_runtime_arn,
        "${module.my_project_mcp_server.agent_core_runtime_arn}/*"
      ]
    }
  ]
}
```
</Fragment>
</Infrastructure>

### Approfondimenti

Per una guida più dettagliata sulla scrittura di agenti Strands, consulta la [documentazione Strands](https://strandsagents.com/latest/documentation/docs/).

## Server FastAPI

Il generatore utilizza [FastAPI](https://fastapi.tiangolo.com/) per creare il server HTTP per il tuo Strands Agent. FastAPI fornisce un framework web moderno e veloce per costruire API con Python, con documentazione API automatica e validazione dei tipi.

Il server generato include:
- Configurazione dell'applicazione FastAPI con middleware CORS
- Middleware per la gestione degli errori
- Generazione dello schema OpenAPI
- Endpoint di controllo dello stato (`/ping`)
- Endpoint di invocazione dell'agente (`/invocations`)

### Personalizzare Input e Output di Invocazione con Pydantic

L'endpoint di invocazione dell'agente utilizza modelli [Pydantic](https://docs.pydantic.dev/) per definire e validare gli schemi di richiesta e risposta. Puoi personalizzare questi modelli in `main.py` per adattarli ai requisiti del tuo agente.

#### Definire Modelli di Input

Il modello `InvokeInput` predefinito accetta un prompt e un ID di sessione.

```python
from pydantic import BaseModel

class InvokeInput(BaseModel):
    prompt: str
    session_id: str
```

Puoi estendere questo modello per includere qualsiasi campo aggiuntivo di cui il tuo agente ha bisogno.

:::caution
Probabilmente vorrai astrarre parte o tutto l'ID di sessione dal chiamante se gli utenti devono invocare il tuo agente direttamente. Ad esempio, potresti usare l'ID utente autenticato come parte dell'ID di sessione.

Vale anche la pena notare che a seconda del tuo caso d'uso potresti dover implementare l'autorizzazione per le sessioni, ad esempio assicurandoti che gli utenti possano accedere solo alle proprie sessioni e non a quelle di altri utenti.
:::

#### Definire Modelli di Output

Per le risposte in streaming, il generatore fornisce `JsonStreamingResponse` che serializza automaticamente i modelli Pydantic in formato JSON Lines (`application/jsonl`). Questo formato è compatibile con la specifica di streaming di OpenAPI 3.2 e funziona perfettamente con il client TypeScript generato.

Di default, l'agente produce oggetti `StreamChunk` contenenti il testo di risposta dell'agente:

```python
class StreamChunk(BaseModel):
    content: str
```

Puoi personalizzare il modello `StreamChunk` per adattarlo alle tue esigenze:

```python
from pydantic import BaseModel

class StreamChunk(BaseModel):
    content: str
    timestamp: str
    token_count: int
```

:::note
Nota che poiché FastAPI attualmente non supporta la generazione di una specifica OpenAPI per le risposte in streaming, dobbiamo impostare esplicitamente il modello di risposta per ogni operazione di streaming, cioè:

```python
@app.post(
    "/invocations",
    response_class=JsonStreamingResponse,
    responses={200: JsonStreamingResponse.openapi_response(StreamChunk)},
)
async def invoke(input: InvokeInput) -> JsonStreamingResponse:
    return JsonStreamingResponse(handle_invoke(input))
```
:::

Esiste una [richiesta di funzionalità aperta per il supporto nativo in FastAPI](https://github.com/fastapi/fastapi/discussions/14362).

## Bedrock AgentCore Python SDK

Il generatore include una dipendenza sul [Bedrock AgentCore Python SDK](https://github.com/aws/bedrock-agentcore-sdk-python) per le costanti `PingStatus`. Se desiderato, è semplice utilizzare `BedrockAgentCoreApp` invece di FastAPI, tuttavia nota che la type-safety viene persa.

Puoi trovare maggiori dettagli sulle capacità dell'SDK nella [documentazione qui](https://aws.github.io/bedrock-agentcore-starter-toolkit/user-guide/runtime/quickstart.html).

:::note
Poiché il generatore fornisce infrastruttura CDK o Terraform che gestisce la distribuzione del tuo agente, non è necessario utilizzare il `bedrock-agentcore-starter-toolkit` menzionato nella documentazione per distribuire l'agente.
:::

## Eseguire il tuo Strands Agent

### Sviluppo Locale

Il generatore configura un target chiamato `<your-agent-name>-serve`, che avvia il tuo Strands Agent localmente per sviluppo e test.

<NxCommands commands={['run your-project:agent-serve']} />

Questo comando usa `uv run` per eseguire il tuo Strands Agent utilizzando il [Bedrock AgentCore Python SDK](https://github.com/aws/bedrock-agentcore-sdk-python).

## Distribuire il tuo Strands Agent su Bedrock AgentCore Runtime

<Snippet name="agent/bedrock-deployment" parentHeading="Distribuire il tuo Strands Agent su Bedrock AgentCore Runtime" />

### Target Bundle e Docker

Per costruire il tuo Strands Agent per Bedrock AgentCore Runtime, viene aggiunto un target `bundle` al tuo progetto, che:

- Esporta le dipendenze Python in un file `requirements.txt` usando `uv export`
- Installa le dipendenze per la piattaforma target (`aarch64-manylinux2014`) usando `uv pip install`

Viene anche aggiunto un target `docker` specifico per il tuo Strands Agent, che:

- Costruisce un'immagine docker dal `Dockerfile` che esegue il tuo agente, secondo il [contratto runtime di AgentCore](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-service-contract.html)

:::tip
L'immagine docker è costruita usando un tag (ad esempio `my-scope-my-project-agent:latest`), referenziato dalla tua infrastruttura CDK o Terraform, permettendo al tuo `Dockerfile` di essere co-locato con il progetto Strands Agent.
:::

### Autenticazione

#### IAM

Di default, il tuo Strands Agent sarà protetto con autenticazione IAM, distribuiscilo semplicemente senza argomenti:

<Infrastructure>
<Fragment slot="cdk">
```ts {5}
import { MyProjectAgent } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    new MyProjectAgent(this, 'MyProjectAgent');
  }
}
```

Puoi concedere l'accesso per invocare il tuo agente su Bedrock AgentCore Runtime usando il metodo `grantInvoke`, ad esempio:

```ts {8}
import { MyProjectAgent } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const agent = new MyProjectAgent(this, 'MyProjectAgent');
    const lambdaFunction = new Function(this, ...);

    agent.agentCoreRuntime.grantInvoke(lambdaFunction);
  }
}
```
</Fragment>
<Fragment slot="terraform">
```terraform
# Agent
module "my_project_agent" {
  # Percorso relativo al modulo generato nel progetto common/terraform
  source = "../../common/terraform/src/app/agents/my-project-agent"
}
```

Per concedere l'accesso a invocare il tuo agente, dovrai aggiungere una policy come la seguente, referenziando l'output `module.my_project_agent.agent_core_runtime_arn`:

```terraform
{
  Effect = "Allow"
  Action = [
    "bedrock-agentcore:InvokeAgentRuntime"
  ]
  Resource = [
    module.my_project_agent.agent_core_runtime_arn,
    "${module.my_project_agent.agent_core_runtime_arn}/*"
  ]
}
```
</Fragment>
</Infrastructure>

#### Autenticazione JWT con Cognito

Quanto segue dimostra come configurare l'autenticazione Cognito per il tuo agente.

<Infrastructure>
<Fragment slot="cdk">
Per configurare l'autenticazione JWT usando Cognito, usa il metodo factory `RuntimeAuthorizerConfiguration.usingCognito()`:

```ts {13-16}
import { MyProjectAgent } from ':my-scope/common-constructs';
import { RuntimeAuthorizerConfiguration } from '@aws-cdk/aws-bedrock-agentcore-alpha';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const userPool = new UserPool(this, 'UserPool');
    const client = userPool.addClient('Client', {
      authFlows: {
        userPassword: true,
      },
    });

    new MyProjectAgent(this, 'MyProjectAgent', {
      authorizerConfiguration: RuntimeAuthorizerConfiguration.usingCognito(
        userPool,
        [client],
      ),
    });
  }
}
```

In alternativa, per l'autenticazione JWT personalizzata con il tuo provider OIDC, usa `RuntimeAuthorizerConfiguration.usingJWT()`:

```ts {6-10}
import { MyProjectAgent } from ':my-scope/common-constructs';
import { RuntimeAuthorizerConfiguration } from '@aws-cdk/aws-bedrock-agentcore-alpha';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    new MyProjectAgent(this, 'MyProjectAgent', {
      authorizerConfiguration: RuntimeAuthorizerConfiguration.usingJWT(
        'https://example.com/.well-known/openid-configuration',
        ['client1', 'client2'], // ID Client Consentiti (opzionale)
        ['audience1'],          // Audience Consentite (opzionale)
      ),
    });
  }
}
```
</Fragment>
<Fragment slot="terraform">
Per configurare l'autenticazione JWT, puoi modificare il tuo modulo agent per configurare la variabile `authorizer_configuration` come segue:

```terraform {18-23}
# packages/common/terraform/src/app/agents/my-project-agent/my-project-agent.tf

data "aws_region" "current" {}

locals {
  aws_region = data.aws_region.current.id

  # Sostituisci con i tuoi ID user pool e client o esponili come variabili
  user_pool_id = "xxx"
  user_pool_client_ids = ["yyy"]
}

module "agent_core_runtime" {
  source = "../../../core/agent-core"
  agent_runtime_name = "MyProjectAgent"
  docker_image_tag = "my-scope-my-project-agent:latest"
  server_protocol = "HTTP"
  authorizer_configuration = {
    custom_jwt_authorizer = {
      discovery_url = "https://cognito-idp.${local.aws_region}.amazonaws.com/${local.user_pool_id}/.well-known/openid-configuration"
      allowed_clients = local.user_pool_client_ids
    }
  }
  env = var.env
  additional_iam_policy_statements = var.additional_iam_policy_statements
  tags = var.tags
}
```
</Fragment>
</Infrastructure>

### Osservabilità

Il tuo agente è configurato automaticamente con osservabilità usando [AWS Distro for Open Telemetry](https://aws.amazon.com/otel/) (ADOT), configurando auto-strumentazione nel tuo `Dockerfile`.

Puoi trovare le tracce nella Console AWS CloudWatch, selezionando "GenAI Observability" nel menu. Nota che per popolare le tracce dovrai abilitare [Transaction Search](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Transaction-Search.html).

Per maggiori dettagli, consulta la [documentazione AgentCore sull'osservabilità](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/observability-configure.html).

## Invocare il tuo Strands Agent

### Invocare il Server Locale

Per invocare un Agente in esecuzione localmente tramite il target `<your-agent-name>-serve`, puoi inviare una semplice richiesta POST a `/invocations` sulla porta su cui il tuo agente locale è in esecuzione. Ad esempio, con `curl`:

```bash
curl -N -X POST http://localhost:8081/invocations \
  -d '{"prompt": "what is 3 + 5?", "session_id": "abcdefghijklmnopqrstuvwxyz0123456789"}' \
  -H "Content-Type: application/json"
```

:::note
L'argomento `-N` dato a `curl` disabilita il buffering dello stream di output, così puoi vedere la risposta in streaming in tempo reale.
:::

### Invocare l'Agente Distribuito

<Snippet name="agent/runtime-arn" parentHeading="Invocare l'Agente Distribuito" />

#### Autenticazione IAM

Per l'Autenticazione IAM, la richiesta deve essere firmata usando AWS Signature Version 4 (SigV4).

```bash
acurl <region> bedrock-agentcore -N -X POST \
'https://bedrock
-agentcore.<region>.amazonaws.com/runtimes/<url-encoded-arn>/invocations' \
-d '{"prompt": "what is 3 + 5?", "session_id": "abcdefghijklmnopqrstuvwxyz0123456789"}' \
-H 'Content-Type: application/json'
```

<Drawer title="curl abilitato per Sigv4" trigger="Clicca qui per maggiori dettagli sulla configurazione del comando acurl sopra">
<Snippet name="tools/acurl" />
</Drawer>

#### Autenticazione JWT / Cognito

Per l'Autenticazione Cognito, passa il Token di Accesso Cognito nell'header `Authorization`:

```bash
curl -N -X POST 'https://bedrock
-agentcore.<region>.amazonaws.com/runtimes/<url-encoded-arn>/invocations' \
  -d '{"prompt": "what is 3 + 5?", "session_id": "abcdefghijklmnopqrstuvwxyz0123456789"}' \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <access-token>"
```

Puoi ottenere il token di accesso usando il comando `cognito-idp admin-initiate-auth` dell'AWS CLI, ad esempio:

```bash
aws cognito-idp admin-initiate-auth \
  --user-pool-id <user-pool-id> \
  --client-id <user-pool-client-id> \
  --auth-flow ADMIN_NO_SRP_AUTH \
  --auth-parameters USERNAME=<username>,PASSWORD=<password> \
  --region <region> \
  --query 'AuthenticationResult.AccessToken' \
  --output text
```