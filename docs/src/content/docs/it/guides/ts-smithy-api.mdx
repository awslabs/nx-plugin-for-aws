---
title: "Smithy TypeScript API"
description: "Documentazione di riferimento per Smithy TypeScript API"
---



import { FileTree, AnchorHeading, Tabs, TabItem } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Infrastructure from '@components/infrastructure.astro';
import Snippet from '@components/snippet.astro';

[Smithy](https://smithy.io/) è un linguaggio di definizione di interfacce indipendente dal protocollo per creare API in modo modellato.

Il generatore Smithy TypeScript API crea una nuova API utilizzando Smithy per la definizione del servizio e lo [Smithy TypeScript Server SDK](https://github.com/awslabs/smithy-typescript) per l'implementazione. Il generatore fornisce infrastrutture come codice CDK o Terraform per distribuire il servizio su AWS Lambda, esposto tramite un'API REST AWS API Gateway. Offre sviluppo di API type-safe con generazione automatica del codice dai modelli Smithy. L'handler generato utilizza [AWS Lambda Powertools for TypeScript](https://docs.powertools.aws.dev/lambda/typescript/latest/) per l'osservabilità, inclusi logging, tracciamento AWS X-Ray e metriche CloudWatch.

## Utilizzo

### Generare un'API Smithy TypeScript

Puoi generare una nuova API Smithy TypeScript in due modi:

<RunGenerator generator="ts#smithy-api" />

### Opzioni

<GeneratorParameters generator="ts#smithy-api" />

## Output del Generatore

Il generatore crea due progetti correlati nella directory `<directory>/<api-name>`:

<FileTree>

- **model/** Progetto del modello Smithy
  - project.json Configurazione del progetto e target di build
  - smithy-build.json Configurazione di build Smithy
  - build.Dockerfile Configurazione Docker per la creazione di artefatti Smithy
  - src/
    - main.smithy Definizione principale del servizio
    - operations/
      - echo.smithy Esempio di definizione di operazione
- **backend/** Implementazione backend TypeScript
  - project.json Configurazione del progetto e target di build
  - rolldown.config.ts Configurazione del bundle
  - src/
    - handler.ts Handler AWS Lambda
    - local-server.ts Server di sviluppo locale
    - service.ts Implementazione del servizio
    - context.ts Definizione del contesto del servizio
    - operations/
      - echo.ts Esempio di implementazione di operazione
    - generated/ SDK TypeScript generato (creato durante la build)

</FileTree>

### Infrastruttura

Poiché questo generatore crea infrastrutture come codice in base al `iacProvider` scelto, genererà un progetto in `packages/common` che include i costrutti CDK o i moduli Terraform rilevanti.

Il progetto comune di infrastruttura come codice è strutturato come segue:

<Infrastructure>
<Fragment slot="cdk">
<FileTree>
  - packages/common/constructs
    - src
      - app/ Costrutti per infrastrutture specifiche di un progetto/generatore
        - apis/
          - \<project-name>.ts Costrutto CDK per distribuire la tua API
      - core/ Costrutti generici riutilizzati da quelli in `app`
        - api/
          - rest-api.ts Costrutto CDK per distribuire un'API REST
          - utils.ts Utility per i costrutti API
      - index.ts Punto di ingresso che esporta i costrutti da `app`
    - project.json Target di build e configurazione del progetto
</FileTree>

:::note
Questo progetto è generato utilizzando il generatore [`ts#project`](guides/typescript-project) e quindi configura gli stessi target di build.
:::
</Fragment>
<Fragment slot="terraform">
<FileTree>
  - packages/common/terraform
    - src
      - app/ Moduli Terraform per infrastrutture specifiche di un progetto/generatore
        - apis/
          - \<project-name>/
            - \<project-name>.tf Modulo per distribuire la tua API
      - core/ Moduli generici riutilizzati da quelli in `app`
        - api/
          - rest-api/
            - rest-api.tf Modulo per distribuire un'API REST
    - project.json Target di build e configurazione del progetto
</FileTree>

:::note
Questo progetto è generato utilizzando il generatore [`terraform#project`](guides/terraform-project) e quindi configura gli stessi target di build.
:::
</Fragment>
</Infrastructure>

## Implementazione della tua API Smithy

### Definizione delle Operazioni in Smithy

Le operazioni sono definite in file Smithy all'interno del progetto del modello. La definizione principale del servizio si trova in `main.smithy`:

```smithy
$version: "2.0"

namespace your.namespace

use aws.protocols#restJson1
use smithy.framework#ValidationException

@title("YourService")
@restJson1
service YourService {
    version: "1.0.0"
    operations: [
        Echo,
        // Aggiungi qui le tue operazioni
    ]
    errors: [
        ValidationException
    ]
}
```

Le singole operazioni sono definite in file separati nella directory `operations/`:

```smithy
$version: "2.0"

namespace your.namespace

@http(method: "POST", uri: "/echo")
operation Echo {
    input: EchoInput
    output: EchoOutput
}

structure EchoInput {
    @required
    message: String

    foo: Integer
    bar: String
}

structure EchoOutput {
    @required
    message: String
}
```

:::note
Puoi modificare la struttura delle cartelle come preferisci - tutti i file `.smithy` nella cartella `src` verranno inclusi nella build Smithy.
:::

:::tip
Per maggiori dettagli su Smithy e la sua sintassi, consulta la [specifica Smithy](https://smithy.io/2.0/spec/index.html).
:::

### Implementazione delle Operazioni in TypeScript

Le implementazioni delle operazioni si trovano nella directory `src/operations/` del progetto backend. Ogni operazione è implementata utilizzando i tipi generati dall'SDK Server TypeScript (generato al momento della build dal tuo modello Smithy).

```typescript
import { ServiceContext } from '../context.js';
import { Echo as EchoOperation } from '../generated/ssdk/index.js';

export const Echo: EchoOperation<ServiceContext> = async (input) => {
  // La tua logica di business qui
  return {
    message: `Echo: ${input.message}` // type-safe basato sul modello Smithy
  };
};
```

Le operazioni devono essere registrate nella definizione del servizio in `src/service.ts`:

```typescript
import { ServiceContext } from './context.js';
import { YourServiceService } from './generated/ssdk/index.js';
import { Echo } from './operations/echo.js';
// Importa altre operazioni qui

// Registra le operazioni al servizio qui
export const Service: YourServiceService<ServiceContext> = {
  Echo,
  // Aggiungi altre operazioni qui
};
```

### Contesto del Servizio

Puoi definire un contesto condiviso per le tue operazioni in `context.ts`:

```typescript
export interface ServiceContext {
  // Tracer, logger e metrics di Powertools sono forniti di default
  tracer: Tracer;
  logger: Logger;
  metrics: Metrics;
  // Aggiungi dipendenze condivise, connessioni al database, ecc.
  dbClient: any;
  userIdentity: string;
}
```

Questo contesto viene passato a tutte le implementazioni delle operazioni e può essere utilizzato per condividere risorse come connessioni al database, configurazioni o utility di logging.

:::caution
Devi costruire il contesto manualmente sia in `handler.ts` (punto di ingresso della funzione Lambda) che in `local-server.ts` (punto di ingresso per l'esecuzione locale tramite il target `serve`).
:::

### Osservabilità con AWS Lambda Powertools

#### Logging

Il generatore configura il logging strutturato utilizzando AWS Lambda Powertools con iniezione automatica del contesto tramite middleware Middy.

```typescript {4}
// handler.ts
export const handler = middy<APIGatewayProxyEvent, APIGatewayProxyResult>()
  .use(captureLambdaHandler(tracer))
  .use(injectLambdaContext(logger))
  .use(logMetrics(metrics))
  .handler(lambdaHandler);
```

Puoi accedere al logger dalle tue implementazioni delle operazioni tramite il contesto:

```typescript {6}
// operations/echo.ts
import { ServiceContext } from '../context.js';
import { Echo as EchoOperation } from '../generated/ssdk/index.js';

export const Echo: EchoOperation<ServiceContext> = async (input, ctx) => {
  ctx.logger.info('Il tuo messaggio di log');
  // ...
};
```

#### Tracing

Il tracciamento AWS X-Ray è configurato automaticamente tramite il middleware `captureLambdaHandler`.

```typescript {3}
// handler.ts
export const handler = middy<APIGatewayProxyEvent, APIGatewayProxyResult>()
  .use(captureLambdaHandler(tracer))
  .use(injectLambdaContext(logger))
  .use(logMetrics(metrics))
  .handler(lambdaHandler);
```

Puoi aggiungere sottosegmenti personalizzati ai tuoi trace nelle operazioni:

```typescript {7, 11, 14}
// operations/echo.ts
import { ServiceContext } from '../context.js';
import { Echo as EchoOperation } from '../generated/ssdk/index.js';

export const Echo: EchoOperation<ServiceContext> = async (input, ctx) => {
  // Crea un nuovo sottosegmento
  const subsegment = ctx.tracer.getSegment()?.addNewSubsegment('custom-operation');
  try {
    // La tua logica qui
  } catch (error) {
    subsegment?.addError(error as Error);
    throw error;
  } finally {
    subsegment?.close();
  }
};
```

#### Metriche

Le metriche CloudWatch vengono raccolte automaticamente per ogni richiesta tramite il middleware `logMetrics`.

```typescript {5}
// handler.ts
export const handler = middy<APIGatewayProxyEvent, APIGatewayProxyResult>()
  .use(captureLambdaHandler(tracer))
  .use(injectLambdaContext(logger))
  .use(logMetrics(metrics))
  .handler(lambdaHandler);
```

Puoi aggiungere metriche personalizzate nelle tue operazioni:

```typescript {7}
// operations/echo.ts
import { MetricUnit } from '@aws-lambda-powertools/metrics';
import { ServiceContext } from '../context.js';
import { Echo as EchoOperation } from '../generated/ssdk/index.js';

export const Echo: EchoOperation<ServiceContext> = async (input, ctx) => {
  ctx.metrics.addMetric("CustomMetric", MetricUnit.Count, 1);
  // ...
};
```

### Gestione degli Errori

Smithy fornisce una gestione degli errori integrata. Puoi definire errori personalizzati nel tuo modello Smithy:

```smithy
@error("client")
@httpError(400)
structure InvalidRequestError {
    @required
    message: String
}
```

E registrarli alla tua operazione/servizio:

```smithy
operation MyOperation {
  ...
  errors: [InvalidRequestError]
}
```

Poi lanciali nella tua implementazione TypeScript:

```typescript
import { InvalidRequestError } from '../generated/ssdk/index.js';

export const MyOperation: MyOperationHandler<ServiceContext> = async (input) => {
  if (!input.requiredField) {
    throw new InvalidRequestError({
      message: "Il campo obbligatorio è mancante"
    });
  }

  return { /* risposta di successo */ };
};
```

## Build e Generazione del Codice

Il progetto del modello Smithy utilizza [Docker](https://www.docker.com/) per costruire gli artefatti Smithy e generare l'SDK Server TypeScript:

<NxCommands commands={['run <model-project>:build']} />

Questo processo:

1. **Compila il modello Smithy** e lo valida
2. **Genera la specifica OpenAPI** dal modello Smithy
3. **Crea l'SDK Server TypeScript** con interfacce type-safe per le operazioni
4. **Produce artefatti di build** in `dist/<model-project>/build/`

Il progetto backend copia automaticamente l'SDK generato durante la compilazione:

<NxCommands commands={['run <backend-project>:copy-ssdk']} />

### Target di Bundle

Il progetto backend utilizza [Rolldown](https://rolldown.rs/) per creare un pacchetto di distribuzione del service handler per AWS Lambda.

<NxCommands commands={['run <backend-project>:bundle']} />

## Sviluppo Locale

Il generatore configura un server di sviluppo locale con hot reloading:

<NxCommands commands={['run <backend-project>:serve']} />

:::tip
Il server locale non solo ricarica automaticamente le modifiche al codice TypeScript del backend, ma si riavvia anche quando modifichi il progetto del modello Smithy, permettendoti di iterare continuamente su modello e server.
:::

## Distribuzione della tua API Smithy

Il generatore crea infrastrutture CDK o Terraform in base al `iacProvider` selezionato.

<Infrastructure>
<Fragment slot="cdk">
Il costrutto CDK per distribuire la tua API si trova nella cartella `common/constructs`:

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    // Aggiungi l'API al tuo stack
    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
    });
  }
}
```

Questo configura:

1. Una funzione AWS Lambda per il servizio Smithy
2. API Gateway REST API come trigger della funzione
3. Ruoli e permessi IAM
4. Gruppo di log CloudWatch
5. Configurazione del tracciamento X-Ray

:::note
Se hai selezionato l'autenticazione `Cognito`, dovrai fornire la proprietà `identity` al costrutto API:

```ts {9}
import { MyApi, UserIdentity } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const identity = new UserIdentity(this, 'Identity');

    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
      identity,
    });
  }
}
```

Il costrutto `UserIdentity` può essere generato utilizzando il generatore <Link path="/guides/react-website-auth">`ts#react-website-auth`</Link>
:::
</Fragment>
<Fragment slot="terraform">
I moduli Terraform per distribuire la tua API si trovano nella cartella `common/terraform`:

```hcl {2}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Variabili d'ambiente per la funzione Lambda
  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  # Politiche IAM aggiuntive se necessarie
  additional_iam_policy_statements = [
    # Aggiungi eventuali permessi aggiuntivi richiesti dalla tua API
  ]

  tags = local.common_tags
}
```

Questo configura:

1. Una funzione AWS Lambda che serve l'API Smithy
2. API Gateway REST API come trigger della funzione
3. Ruoli e permessi IAM
4. Gruppo di log CloudWatch
5. Configurazione del tracciamento X-Ray
6. Configurazione CORS

:::note
Se hai selezionato l'autenticazione `Cognito`, dovrai fornire la configurazione Cognito:

```hcl {4-5}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  user_pool_id         = local.user_pool_id
  user_pool_client_ids = [local.client_id]

  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  tags = local.common_tags
}
```
:::

Il modulo Terraform fornisce diversi output:

```hcl
# Accedi all'endpoint API
output "api_url" {
  value = module.my_api.stage_invoke_url
}

# Accedi ai dettagli della funzione Lambda
output "lambda_function_name" {
  value = module.my_api.lambda_function_name
}
```
</Fragment>
</Infrastructure>

### Integrazioni

<Snippet name="api/type-safe-api-integrations" parentHeading="Integrazioni" />

#### Generazione del Codice

<Infrastructure>
<Fragment slot="cdk">
Poiché le operazioni sono definite in Smithy, utilizziamo la generazione del codice per fornire metadati al costrutto CDK per integrazioni type-safe.

Un target `generate:<ApiName>-metadata` viene aggiunto al `project.json` dei costrutti comuni per facilitare questa generazione, producendo un file come `packages/common/constructs/src/generated/my-api/metadata.gen.ts`. Essendo generato al momento della build, viene ignorato dal version control.

:::note
Dovrai eseguire una build ogni volta che modifichi il modello Smithy per garantire che i tipi consumati dal costrutto CDK siano aggiornati.

<NxCommands commands={["run-many --target build --all"]} />
:::

:::tip
Se stai lavorando attivamente sia sull'infrastruttura CDK che sull'API Smithy, puoi usare [`nx watch`](https://nx.dev/nx-api/nx/documents/watch) per rigenerare questi tipi ad ogni modifica del modello:

<NxCommands
  commands={[
    'watch --projects=<ModelProject> -- \\ ',
    'run <InfraProject>:"generate:<ApiName>-metadata"',
  ]}
/>
:::
</Fragment>
<Fragment slot="terraform">
:::note
Non supportiamo integrazioni type-safe per Terraform, quindi nessun target di generazione codice viene configurato se hai selezionato Terraform come `iacProvider`.
:::
</Fragment>
</Infrastructure>

### Concessione dell'Accesso (Solo IAM)

Se hai selezionato l'autenticazione `IAM`, puoi usare il metodo `grantInvokeAccess` per concedere l'accesso alla tua API:

<Infrastructure>
<Fragment slot="cdk">
```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```
</Fragment>
<Fragment slot="terraform">
```hcl
# Crea una politica IAM per consentire l'invocazione dell'API
resource "aws_iam_policy" "api_invoke_policy" {
  name        = "MyApiInvokePolicy"
  description = "Politica per consentire l'invocazione dell'API Smithy"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = "execute-api:Invoke"
        Resource = "${module.my_api.api_execution_arn}/*/*"
      }
    ]
  })
}

# Allega la politica a un ruolo IAM
resource "aws_iam_role_policy_attachment" "api_invoke_access" {
  role       = aws_iam_role.authenticated_user_role.name
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}
```
</Fragment>
</Infrastructure>

## Invocazione della tua API Smithy

Per invocare la tua API da un sito React, puoi utilizzare il generatore <Link path="guides/api-connection/react-smithy">`api-connection`</Link>, che fornisce la generazione di client type-safe dal tuo modello Smithy.