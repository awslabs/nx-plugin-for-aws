---
title: "tRPC"
description: "Documentazione di riferimento per tRPC"
---



import { FileTree, Tabs, TabItem } from '@astrojs/starlight/components';
import AnchorHeading from '@astrojs/starlight/components/AnchorHeading.astro';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Infrastructure from '@components/infrastructure.astro';
import Snippet from '@components/snippet.astro';

[tRPC](https://trpc.io/) è un framework per la creazione di API in TypeScript con type safety end-to-end. Utilizzando tRPC, gli aggiornamenti agli input e output delle operazioni dell'API si riflettono immediatamente nel codice client e sono visibili nel tuo IDE senza necessità di ricompilare il progetto.

Il generatore di API tRPC crea una nuova API tRPC con configurazione dell'infrastruttura AWS CDK o Terraform. Il backend generato utilizza AWS Lambda per il deployment serverless, esposto tramite un'API AWS API Gateway, e include la validazione degli schemi tramite [Zod](https://zod.dev/). Configura [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/) per l'osservabilità, inclusi logging, tracciamento AWS X-Ray e metriche Cloudwatch.

## Utilizzo

### Generare un'API tRPC

Puoi generare una nuova API tRPC in due modi:

<RunGenerator generator="ts#trpc-api" />

### Opzioni

<GeneratorParameters generator="ts#trpc-api" />

<Snippet name="api/api-choice-note" />

## Output del Generatore

Il generatore creerà la seguente struttura del progetto nella directory `<directory>/<api-name>`:

<FileTree>
  - src
    - init.ts Inizializzazione backend tRPC
    - router.ts Definizione router tRPC (punto di ingresso API per Lambda handler)
    - schema Definizioni schema con Zod
      - echo.ts Esempio di definizioni per input e output della procedura "echo"
    - procedures Procedure (o operazioni) esposte dalla tua API
      - echo.ts Procedura di esempio
    - middleware
      - error.ts Middleware per la gestione degli errori
      - logger.ts middleware per configurare AWS Powertools per il logging in Lambda
      - tracer.ts middleware per configurare AWS Powertools per il tracciamento in Lambda
      - metrics.ts middleware per configurare AWS Powertools per le metriche in Lambda
    - local-server.ts Punto di ingresso dell'adapter standalone tRPC per server di sviluppo locale
    - client
      - index.ts Client type-safe per chiamate API machine-to-machine
  - tsconfig.json Configurazione TypeScript
  - project.json Configurazione progetto e build targets

</FileTree>

### Infrastruttura

<Snippet name="shared-constructs" />

<Snippet name="api/shared-constructs" />

## Implementazione della tua API tRPC

A livello generale, le API tRPC consistono in un router che delega le richieste a procedure specifiche. Ogni procedura ha un input e un output definiti come schema Zod.

### Schema

La directory `src/schema` contiene i tipi condivisi tra il codice client e server. In questo pacchetto, questi tipi sono definiti utilizzando [Zod](https://zod.dev/), una libreria TypeScript-first per la dichiarazione e validazione di schemi.

Uno schema di esempio potrebbe essere il seguente:

```ts
import { z } from 'zod';

// Definizione schema
export const UserSchema = z.object({
  name: z.string(),
  height: z.number(),
  dateOfBirth: z.string().datetime(),
});

// Tipo TypeScript corrispondente
export type User = z.TypeOf<typeof UserSchema>;
```

Dato lo schema sopra, il tipo `User` è equivalente al seguente TypeScript:

```ts
interface User {
  name: string;
  height: number;
  dateOfBirth: string;
}
```

Gli schemi sono condivisi sia dal codice server che client, fornendo un unico punto di aggiornamento quando si modificano le strutture utilizzate nella tua API.

Gli schemi sono automaticamente validati dalla tua API tRPC a runtime, evitando la necessità di scrivere logiche di validazione manuali nel backend.

Zod fornisce utility potenti per combinare o derivare schemi come `.merge`, `.pick`, `.omit` e altri. Puoi trovare maggiori informazioni sul [sito della documentazione di Zod](https://zod.dev/?id=basic-usage).

### Router e Procedure

Il punto di ingresso della tua API si trova in `src/router.ts`. Questo file contiene il lambda handler che instrada le richieste alle "procedure" in base all'operazione invocata. Ogni procedura definisce l'input atteso, l'output e l'implementazione.

Il router di esempio generato per te ha una singola operazione chiamata `echo`:

```ts
import { echo } from './procedures/echo.js';

export const appRouter = router({
  echo,
});
```

La procedura `echo` di esempio è generata per te in `src/procedures/echo.ts`:

```ts
export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Analizzando il codice sopra:

- `publicProcedure` definisce un metodo pubblico nell'API, includendo il middleware configurato in `src/middleware`. Questo middleware include l'integrazione con AWS Lambda Powertools per logging, tracciamento e metriche.
- `input` accetta uno schema Zod che definisce l'input atteso per l'operazione. Le richieste per questa operazione sono automaticamente validate rispetto a questo schema.
- `output` accetta uno schema Zod che definisce l'output atteso. Vedrai errori di tipo nell'implementazione se non restituisci un output conforme allo schema.
- `query` accetta una funzione che definisce l'implementazione della tua API. Questa implementazione riceve `opts`, che contiene l'`input` passato all'operazione, oltre ad altro contesto configurato dal middleware, disponibile in `opts.ctx`. La funzione passata a `query` deve restituire un output conforme allo schema `output`.

L'uso di `query` per definire l'implementazione indica che l'operazione non è mutativa. Usalo per definire metodi di recupero dati. Per implementare un'operazione mutativa, utilizza invece il metodo `mutation`.

Se aggiungi una nuova procedura, assicurati di registrarla aggiungendola al router in `src/router.ts`.

## Personalizzazione della tua API tRPC

### Errori

Nella tua implementazione, puoi restituire errori ai client lanciando un `TRPCError`. Questi accettano un `code` che indica il tipo di errore, ad esempio:

```ts
throw new TRPCError({
  code: 'NOT_FOUND',
  message: 'La risorsa richiesta non è stata trovata',
});
```

### Organizzazione delle Operazioni

Man mano che la tua API cresce, potresti voler raggruppare operazioni correlate.

Puoi raggruppare operazioni utilizzando router annidati, ad esempio:

```ts
import { getUser } from './procedures/users/get.js';
import { listUsers } from './procedures/users/list.js';

const appRouter = router({
   users: router({
      get: getUser,
      list: listUsers,
   }),
   ...
})
```

I client riceveranno questo raggruppamento di operazioni, ad esempio invocare l'operazione `listUsers` in questo caso potrebbe apparire così:

```ts
client.users.list.query();
```

### Logging

Il logger AWS Lambda Powertools è configurato in `src/middleware/logger.ts` e può essere accessibile in un'implementazione API tramite `opts.ctx.logger`. Puoi usarlo per loggare su CloudWatch Logs e/o controllare valori aggiuntivi da includere in ogni messaggio di log strutturato. Ad esempio:

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.logger.info('Operazione chiamata con input', opts.input);

      return ...;
   });
```

Per maggiori informazioni sul logger, consulta la [documentazione di AWS Lambda Powertools Logger](https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/).

### Registrazione Metriche

Le metriche AWS Lambda Powertools sono configurate in `src/middleware/metrics.ts` e possono essere accessibili in un'implementazione API tramite `opts.ctx.metrics`. Puoi usarle per registrare metriche in CloudWatch senza bisogno di importare e usare l'AWS SDK, ad esempio:

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.metrics.addMetric('Invocations', 'Count', 1);

      return ...;
   });
```

Per maggiori informazioni, consulta la [documentazione di AWS Lambda Powertools Metrics](https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/).

### Ottimizzazione Tracciamento X-Ray

Il tracer AWS Lambda Powertools è configurato in `src/middleware/tracer.ts` e può essere accessibile in un'implementazione API tramite `opts.ctx.tracer`. Puoi usarlo per aggiungere tracce con AWS X-Ray per fornire insight dettagliati sulle prestazioni e il flusso delle richieste API. Ad esempio:

```ts {5-7}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      const subSegment = opts.ctx.tracer.getSegment()!.addNewSubsegment('MyAlgorithm');
      // ... logica del mio algoritmo da tracciare
      subSegment.close();

      return ...;
   });
```

Per maggiori informazioni, consulta la [documentazione di AWS Lambda Powertools Tracer](https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/).

### Implementazione Middleware Personalizzato

Puoi aggiungere valori aggiuntivi al contesto fornito alle procedure implementando middleware.

Come esempio, implementiamo un middleware per estrarre dettagli sull'utente chiamante dalla nostra API in `src/middleware/identity.ts`.

:::warning
Questo esempio assume che `auth` sia impostato su `IAM`. Per autenticazione Cognito, il middleware per l'identità è più diretto, estraendo i claim rilevanti dall'`event`.
:::

Per prima cosa, definiamo cosa aggiungeremo al contesto:

```ts
export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}
```

Nota che definiamo una proprietà _opzionale_ aggiuntiva al contesto. tRPC gestisce l'assicurazione che questa sia definita nelle procedure che hanno configurato correttamente questo middleware.

Successivamente, implementiamo il middleware stesso. Questo ha la seguente struttura:

```ts
export const createIdentityPlugin = () => {
   const t = initTRPC.context<...>().create();
   return t.procedure.use(async (opts) => {
      // Aggiungi logica qui da eseguire prima della procedura

      const response = await opts.next(...);

      // Aggiungi logica qui da eseguire dopo la procedura

      return response;
   });
};
```

Nel nostro caso, vogliamo estrarre dettagli sull'utente Cognito chiamante. Lo faremo estraendo l'ID subject (o "sub") dell'utente dall'evento API Gateway e recuperando i dettagli utente da Cognito. L'implementazione varia leggermente a seconda che l'evento sia fornito dalla nostra funzione da un'API REST o HTTP:

<Tabs>
<TabItem label="REST">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEvent } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEvent>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoAuthenticationProvider = opts.ctx.event.requestContext?.identity?.cognitoAuthenticationProvider;

    let sub: string | undefined = undefined;
    if (cognitoAuthenticationProvider) {
      const providerParts = cognitoAuthenticationProvider.split(':');
      sub = providerParts[providerParts.length - 1];
    }

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `Impossibile determinare l'utente chiamante`,
      });
    }

    const { Users } = await cognito.listUsers({
      // Assume che l'ID del user pool sia configurato nell'ambiente lambda
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `Nessun utente trovato con subjectId ${sub}`,
      });
    }

    // Fornisce l'identità ad altre procedure nel contesto
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
<TabItem label="HTTP">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoIdentity = opts.ctx.event.requestContext?.authorizer?.iam
      ?.cognitoIdentity as unknown as
      | {
          amr: string[];
        }
      | undefined;

    const sub = (cognitoIdentity?.amr ?? [])
      .flatMap((s) => (s.includes(':CognitoSignIn:') ? [s] : []))
      .map((s) => {
        const parts = s.split(':');
        return parts[parts.length - 1];
      })?.[0];

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `Impossibile determinare l'utente chiamante`,
      });
    }

    const { Users } = await cognito.listUsers({
      // Assume che l'ID del user pool sia configurato nell'ambiente lambda
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `Nessun utente trovato con subjectId ${sub}`,
      });
    }

    // Fornisce l'identità ad altre procedure nel contesto
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
</Tabs>

## Deployment della tua API tRPC

Il generatore di API tRPC crea infrastruttura come codice CDK o Terraform in base al `iacProvider` selezionato. Puoi usarlo per deployare la tua API tRPC.

<Infrastructure>
<Fragment slot="cdk">
Il costrutto CDK per deployare la tua API si trova nella cartella `common/constructs`. Puoi utilizzarlo in un'applicazione CDK, ad esempio:

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs`;

export class ExampleStack extends Stack {
   constructor(scope: Construct, id: string) {
      // Aggiungi l'API al tuo stack
      const api = new MyApi(this, 'MyApi', {
        integrations: MyApi.defaultIntegrations(this).build(),
      });
   }
}
```

Questo configura l'infrastruttura della tua API, inclusa un'API AWS API Gateway REST o HTTP, funzioni AWS Lambda per la business logic e autenticazione basata sul metodo `auth` scelto.

:::note
Se hai selezionato l'autenticazione `Cognito`, dovrai fornire la proprietà `identity` al costrutto API:

```ts {9}
import { MyApi, UserIdentity } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const identity = new UserIdentity(this, 'Identity');

    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
      identity,
    });
  }
}
```

Il costrutto `UserIdentity` può essere generato utilizzando il generatore <Link path="/guides/react-website-auth">`ts#react-website-auth`</Link>
:::
</Fragment>
<Fragment slot="terraform">
I moduli Terraform per deployare la tua API si trovano nella cartella `common/terraform`. Puoi usarli in una configurazione Terraform:

```hcl {6-8}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Variabili d'ambiente per la funzione Lambda
  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  # Politiche IAM aggiuntive se necessarie
  additional_iam_policy_statements = [
    # Aggiungi eventuali permessi aggiuntivi richiesti dalla tua API
  ]

  tags = local.common_tags
}
```

Questo configura:

1. Una funzione AWS Lambda che serve tutte le procedure tRPC
2. API Gateway HTTP/REST API come trigger della funzione
3. Ruoli e permessi IAM
4. Gruppo di log CloudWatch
5. Configurazione tracciamento X-Ray
6. Configurazione CORS

:::note
Se hai selezionato l'autenticazione `Cognito`, dovrai fornire la configurazione Cognito:

```hcl {4-5}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  user_pool_id         = local.user_pool_id
  user_pool_client_ids = [local.client_id]

  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  tags = local.common_tags
}
```

Puoi configurare Cognito User Pool e Client utilizzando le risorse o moduli Terraform appropriati.
:::

Il modulo Terraform fornisce diversi output utilizzabili:

```hcl
# Accedi all'endpoint API
output "api_url" {
  value = module.my_api.stage_invoke_url
}

# Accedi ai dettagli della funzione Lambda
output "lambda_function_name" {
  value = module.my_api.lambda_function_name
}

# Accedi al ruolo IAM per concedere permessi aggiuntivi
output "lambda_execution_role_arn" {
  value = module.my_api.lambda_execution_role_arn
}
```

Puoi personalizzare le impostazioni CORS passando variabili al modulo:

```hcl
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Configurazione CORS personalizzata
  cors_allow_origins = ["https://myapp.com", "https://staging.myapp.com"]
  cors_allow_methods = ["GET", "POST", "PUT", "DELETE"]
  cors_allow_headers = [
    "authorization",
    "content-type",
    "x-custom-header"
  ]

  tags = local.common_tags
}
```

:::caution
Se hai selezionato `None` per `auth` durante l'esecuzione del generatore, potresti vedere errori nei check Checkov come:

<Tabs syncKey="http-rest">
<TabItem label="HTTP API">
```
Check: CKV_AWS_309: "Ensure API GatewayV2 routes specify an authorization type"
 FAILED for resource: aws_apigatewayv2_route.proxy_routes["PUT"]
```
</TabItem>
<TabItem label="REST API">
```
Check: CKV_AWS_59: "Ensure there is no open access to back-end resources through API"
 FAILED for resource: aws_api_gateway_method.proxy_method
```
</TabItem>
</Tabs>

Puoi [aggiungere un commento di soppressione](https://www.checkov.io/2.Basics/Suppressing%20and%20Skipping%20Policies.html) se sei sicuro di volere la tua API pubblica.
:::
</Fragment>
</Infrastructure>

### Integrazioni

<Snippet name="api/type-safe-api-integrations" parentHeading="Integrazioni" />

:::tip
Se hai selezionato CDK come `iacProvider`, quando aggiungi o rimuovi una procedura nella tua API tRPC, queste modifiche si rifletteranno immediatamente nel costrutto CDK senza necessità di ricompilare.
:::

### Concessione Accesso (Solo IAM)

Se hai selezionato l'autenticazione `IAM`, puoi concedere accesso alla tua API:

<Infrastructure>
<Fragment slot="cdk">
```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```
</Fragment>
<Fragment slot="terraform">
```hcl
# Crea una politica IAM per consentire l'invocazione dell'API
resource "aws_iam_policy" "api_invoke_policy" {
  name        = "MyApiInvokePolicy"
  description = "Policy per consentire l'invocazione dell'API tRPC"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = "execute-api:Invoke"
        Resource = "${module.my_api.api_execution_arn}/*/*"
      }
    ]
  })
}

# Allega la politica a un ruolo IAM (es. per utenti autenticati)
resource "aws_iam_role_policy_attachment" "api_invoke_access" {
  role       = aws_iam_role.authenticated_user_role.name
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}

# O allega a un ruolo esistente per nome
resource "aws_iam_role_policy_attachment" "api_invoke_access_existing" {
  role       = "MyExistingRole"
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}
```

Gli output chiave dal modulo API utilizzabili per le politiche IAM sono:

- `module.my_api.api_execution_arn` - Per concedere permessi execute-api:Invoke
- `module.my_api.api_arn` - L'ARN di API Gateway
- `module.my_api.lambda_function_arn` - L'ARN della funzione Lambda
</Fragment>
</Infrastructure>

### Bundle Target

<Snippet name="ts-bundle" />

## Server tRPC Locale

Puoi usare il target `serve` per eseguire un server locale per la tua API, ad esempio:

<NxCommands commands={['run @my-scope/my-api:serve']} />

Il punto di ingresso per il server locale è `src/local-server.ts`.

Questo si ricaricherà automaticamente quando apporti modifiche alla tua API.

## Invocazione della tua API tRPC

Puoi creare un client tRPC per invocare la tua API in modo type-safe. Se stai chiamando la tua API tRPC da un altro backend, puoi usare il client in `src/client/index.ts`, ad esempio:

```ts
import { createMyApiClient } from ':my-scope/my-api';

const client = createMyApiClient({ url: 'https://my-api-url.example.com/' });

await client.echo.query({ message: 'Hello world!' });
```

Se stai chiamando la tua API da un sito React, considera l'uso del generatore <Link path="guides/api-connection/react-trpc">API Connection</Link> per configurare il client.

## Ulteriori Informazioni

Per maggiori informazioni su tRPC, consulta la [documentazione di tRPC](https://trpc.io/docs).