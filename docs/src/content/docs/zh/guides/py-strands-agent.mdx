---
title: "Python Strands 代理"
description: "生成用于构建带工具的 AI 代理并部署到 Amazon Bedrock AgentCore Runtime 的 Python Strands 代理"
---

import { FileTree } from '@astrojs/starlight/components';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import Link from '@components/link.astro';
import Snippet from '@components/snippet.astro';
import Infrastructure from '@components/infrastructure.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import Drawer from '@components/drawer.astro';

生成一个用于构建AI智能体工具的Python [Strands Agent](https://strandsagents.com/)，并可选部署到[Amazon Bedrock AgentCore Runtime](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/)。

## 什么是Strands？

[Strands](https://strandsagents.com/latest/documentation/docs/)是一个轻量级、生产就绪的Python框架，用于构建AI智能体。主要特性包括：

- **轻量且可定制**：简洁的智能体循环设计，不干扰开发
- **生产就绪**：完整的可观测性、追踪和规模化部署选项
- **模型与供应商无关**：支持多种不同供应商的模型
- **社区驱动工具**：强大的社区贡献工具集
- **多智能体支持**：支持智能体团队和自主智能体等高级技术
- **灵活交互模式**：支持对话式、流式和非流式交互

## 使用方式

### 生成Strands智能体

可通过两种方式生成Python Strands智能体：

<RunGenerator generator="py#strands-agent" />

:::tip
建议先使用<Link path="/guides/python-project">`py#project`</Link>生成器创建项目，再添加Strands智能体。
:::

### 选项配置

<GeneratorParameters generator="py#strands-agent" />

## 生成器输出

生成器将在现有Python项目中添加以下文件：

<FileTree>
  - your-project/
    - your_module/
      - agent/ (可自定义名称)
        - \_\_init\_\_.py Python包初始化文件
        - agent.py 主智能体定义（含示例工具）
        - main.py Bedrock AgentCore Runtime入口点
        - agentcore_mcp_client.py 用于调用MCP服务的客户端工厂
        - Dockerfile 智能体托管入口文件（当`computeType`设为`None`时不生成）
    - pyproject.toml 更新Strands依赖
    - project.json 更新服务目标配置
</FileTree>

### 基础设施

:::note
若选择`None`作为`computeType`，生成器不会创建任何基础设施即代码。
:::

<Snippet name="shared-constructs" />

部署Strands智能体时生成以下文件：

<Infrastructure>
<Fragment slot="cdk">
<FileTree>
  - packages/common/constructs/src
    - app
      - agents
        - \<project-name>
          - \<project-name>.ts 部署智能体的CDK构造
          - Dockerfile CDK构造使用的透传Docker文件
</FileTree>
</Fragment>
<Fragment slot="terraform">
<FileTree>
  - packages/common/terraform/src
    - app
      - agents
        - \<project-name>
          - \<project-name>.tf 部署智能体的Terraform模块
    - core
      - agent-core
        - runtime.tf 部署到Bedrock AgentCore Runtime的通用模块
</FileTree>
</Fragment>
</Infrastructure>

## 使用Strands智能体

### 添加工具

工具是AI智能体可调用的功能函数。Strands框架使用基于装饰器的简单方式定义工具。

在[`agent.py`](packages/nx-plugin/src/py/strands-agent/files/agent.py.template:6)文件中添加新工具：

```python
from strands import Agent, tool

@tool
def calculate_sum(numbers: list[int]) -> int:
    """计算数字列表的总和"""
    return sum(numbers)

@tool
def get_weather(city: str) -> str:
    """获取城市天气信息"""
    # 此处集成天气API
    return f"{city}天气：晴，25°C"

# 将工具添加到智能体
agent = Agent(
    system_prompt="您是一个拥有多种工具的智能助手。",
    tools=[calculate_sum, get_weather],
)
```

Strands框架自动处理：
- 基于函数类型提示的类型验证
- 工具调用的JSON模式生成
- 错误处理和响应格式化

### 使用预置工具

通过`strands-tools`包使用预置工具：

```python
from strands_tools import current_time, http_request, file_read

agent = Agent(
    system_prompt="您是一个智能助手。",
    tools=[current_time, http_request, file_read],
)
```

### 模型配置

默认使用Claude 4 Sonnet模型，可自定义模型供应商。参考[Strands模型供应商文档](https://strandsagents.com/latest/documentation/docs/user-guide/quickstart/#model-providers)进行配置：

```python
from strands import Agent
from strands.models import BedrockModel

# 创建Bedrock模型实例
bedrock_model = BedrockModel(
    model_id="anthropic.claude-sonnet-4-20250514-v1:0",
    region_name="us-west-2",
    temperature=0.3,
)

agent = Agent(model=bedrock_model)
```

### 使用MCP服务

可通过[添加MCP服务工具](https://strandsagents.com/latest/documentation/docs/user-guide/concepts/tools/mcp-tools/)扩展智能体功能。

对于使用<Link path="/guides/py-mcp-server">`py#mcp-server`</Link>或<Link path="/guides/ts-mcp-server">`ts#mcp-server`</Link>生成器创建的MCP服务（或部署在Bedrock AgentCore Runtime的其他服务），生成器会在`agentcore_mcp_client.py`中创建客户端工厂。

在`agent.py`中更新`get_agent`方法以创建MCP客户端并添加工具。以下示例展示使用IAM（SigV4）认证：

```python
# agent.py
import os
from contextlib import contextmanager

import boto3
from strands import Agent

from .agentcore_mcp_client import AgentCoreMCPClient

# 获取区域和凭证
region = os.environ["AWS_REGION"]
boto_session = boto3.Session(region_name=region)
credentials = boto_session.get_credentials()

@contextmanager
def get_agent(session_id: str):
    mcp_client = AgentCoreMCPClient.with_iam_auth(
        agent_runtime_arn=os.environ["MCP_AGENTCORE_RUNTIME_ARN"],
        credentials=credentials,
        region=region,
        session_id=session_id,
    )

    with mcp_client:
        mcp_tools = mcp_client.list_tools_sync()

        yield Agent(
            system_prompt="..."
            tools=[*mcp_tools],
        )
```

:::tip
若目标MCP服务使用JWT认证，可使用`AgentCoreMCPClient.with_jwt_auth`方法创建客户端。
:::

上述IAM认证示例需在基础设施中配置两点：添加MCP服务AgentCore Runtime ARN环境变量，并授予智能体调用权限：

<Infrastructure>
<Fragment slot="cdk">
```ts {9, 13}
import { MyProjectAgent, MyProjectMcpServer } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const mcpServer = new MyProjectMcpServer(this, 'MyProjectMcpServer');

    const agent = new MyProjectAgent(this, 'MyProjectAgent', {
      environmentVariables: {
        MCP_AGENTCORE_RUNTIME_ARN: mcpServer.agentCoreRuntime.agentRuntimeArn,
      },
    });

    mcpServer.agentCoreRuntime.grantInvoke(agent.agentCoreRuntime);
  }
}
```
</Fragment>
<Fragment slot="terraform">
```terraform
# MCP服务
module "my_project_mcp_server" {
  source = "../../common/terraform/src/app/mcp-servers/my-project-mcp-server"
}

# 智能体
module "my_project_agent" {
  source = "../../common/terraform/src/app/agents/my-project-agent"

  env = {
    MCP_AGENTCORE_RUNTIME_ARN = module.my_project_mcp_server.agent_core_runtime_arn
  }

  additional_iam_policy_statements = [
    {
      Effect = "Allow"
      Action = [
        "bedrock-agentcore:InvokeAgentRuntime"
      ]
      Resource = [
        module.my_project_mcp_server.agent_core_runtime_arn,
        "${module.my_project_mcp_server.agent_core_runtime_arn}/*"
      ]
    }
  ]
}
```
</Fragment>
</Infrastructure>

### 更多信息

深入指南请参考[Strands官方文档](https://strandsagents.com/latest/documentation/docs/)。

## FastAPI服务器

生成器使用[FastAPI](https://fastapi.tiangolo.com/)为Strands智能体创建HTTP服务器。FastAPI提供了一个现代、高性能的Python API构建框架，具有自动API文档生成和类型验证功能。

生成的服务器包含：
- 配置CORS中间件的FastAPI应用
- 错误处理中间件
- OpenAPI模式生成
- 健康检查端点（`/ping`）
- 智能体调用端点（`/invocations`）

### 使用Pydantic自定义调用输入和输出

智能体的调用端点使用[Pydantic](https://docs.pydantic.dev/)模型来定义和验证请求及响应模式。您可以在`main.py`中自定义这些模型以满足智能体需求。

#### 定义输入模型

默认的`InvokeInput`模型接受提示词和会话ID。

```python
from pydantic import BaseModel

class InvokeInput(BaseModel):
    prompt: str
    session_id: str
```

您可以扩展此模型以包含智能体所需的任何额外字段。

:::caution
如果用户直接调用您的智能体，您可能需要对调用者抽象部分或全部会话ID。例如，您可以使用已认证用户ID作为会话ID的一部分。

还需要注意的是，根据您的使用场景，可能需要为会话实现授权机制，例如确保用户只能访问自己的会话而不能访问其他用户的会话。
:::

#### 定义输出模型

对于流式响应，端点的返回类型注解对应于生成器函数yield的每个值的类型。默认情况下，智能体yield包含从Strands流式返回的智能体响应文本的字符串：

```python
@app.post("/invocations", openapi_extra={"x-streaming": True})
async def invoke(input: InvokeInput) -> str:
    """智能体调用入口点"""
    return StreamingResponse(handle_invoke(input), media_type="text/event-stream")
```

您可以定义Pydantic模型来yield结构化数据。为此，您需要序列化`handle_invoke`所yield的pydantic模型：

```python
from pydantic import BaseModel

class StreamChunk(BaseModel):
    content: str
    timestamp: str
    token_count: int

def handle_invoke(...):
    ...
    yield StreamChunk(content="xx", timestamp="yy", token_count=5)

def serialize_stream(generator):
    async for output in generator:
        yield (output.model_dump_json() + "\n").encode("utf-8")

@app.post("/invocations", openapi_extra={"x-streaming": True})
async def invoke(input: InvokeInput) -> StreamChunk:
    return StreamingResponse(serialize_stream(handle_invoke(input)), media_type="application/json")
```

:::caution
请注意，提供的服务器（以及上述`serialize_stream`方法）目前不符合Server-Sent Events（SSE）标准，因此如果希望通过生成的TypeScript客户端从前端调用智能体，目前不支持SSE格式的流式事件。如果这影响到您，请为[此GitHub issue](https://github.com/awslabs/nx-plugin-for-aws/issues/369)点赞，以帮助我们优先处理此问题。
:::

## Bedrock AgentCore Python SDK

生成器包含对[Bedrock AgentCore Python SDK](https://github.com/aws/bedrock-agentcore-sdk-python)的依赖，用于`PingStatus`常量。如果需要，可以直接使用`BedrockAgentCoreApp`替代FastAPI，但请注意会失去类型安全性。

SDK功能详情请参阅[文档](https://aws.github.io/bedrock-agentcore-starter-toolkit/user-guide/runtime/quickstart.html)。

:::note
由于生成器提供CDK或Terraform基础设施来管理部署，无需使用文档中提到的`bedrock-agentcore-starter-toolkit`进行部署。
:::

## 运行Strands智能体

### 本地开发

生成器配置了名为`<your-agent-name>-serve`的目标，用于本地开发和测试：

<NxCommands commands={['run your-project:agent-serve']} />

该命令使用`uv run`通过[Bedrock AgentCore Python SDK](https://github.com/aws/bedrock-agentcore-sdk-python)运行智能体。

## 部署到Bedrock AgentCore Runtime

<Snippet name="agent/bedrock-deployment" parentHeading="部署到Bedrock AgentCore Runtime" />

### 打包与Docker目标

为构建Bedrock AgentCore Runtime部署包，项目中添加了`bundle`目标：
- 使用`uv export`导出Python依赖到`requirements.txt`
- 使用`uv pip install`为目标平台（`aarch64-manylinux2014`）安装依赖

同时添加智能体专用的`docker`目标：
- 根据[AgentCore运行时协议](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-service-contract.html)构建Docker镜像

:::tip
Docker镜像使用特定标签（如`my-scope-my-project-agent:latest`），与CDK/Terraform基础设施关联，确保Dockerfile与项目位置一致。
:::

### 认证配置

#### IAM认证

默认使用IAM认证，直接部署即可：

<Infrastructure>
<Fragment slot="cdk">
```ts {5}
import { MyProjectAgent } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    new MyProjectAgent(this, 'MyProjectAgent');
  }
}
```

可使用`grantInvoke`方法授权调用Bedrock AgentCore Runtime上的智能体，例如：

```ts {8}
import { MyProjectAgent } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const agent = new MyProjectAgent(this, 'MyProjectAgent');
    const lambdaFunction = new Function(this, ...);

    agent.agentCoreRuntime.grantInvoke(lambdaFunction);
  }
}
```
</Fragment>
<Fragment slot="terraform">
```terraform
# 智能体
module "my_project_agent" {
  # common/terraform项目中生成模块的相对路径
  source = "../../common/terraform/src/app/agents/my-project-agent"
}
```

要授予调用智能体的权限，需添加如下策略，引用`module.my_project_agent.agent_core_runtime_arn`输出：

```terraform
{
  Effect = "Allow"
  Action = [
    "bedrock-agentcore:InvokeAgentRuntime"
  ]
  Resource = [
    module.my_project_agent.agent_core_runtime_arn,
    "${module.my_project_agent.agent_core_runtime_arn}/*"
  ]
}
```
</Fragment>
</Infrastructure>

#### Cognito JWT认证

以下演示如何配置Cognito认证：

<Infrastructure>
<Fragment slot="cdk">
使用Cognito配置JWT认证时，使用`RuntimeAuthorizerConfiguration.usingCognito()`工厂方法：

```ts {13-16}
import { MyProjectAgent } from ':my-scope/common-constructs';
import { RuntimeAuthorizerConfiguration } from '@aws-cdk/aws-bedrock-agentcore-alpha';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const userPool = new UserPool(this, 'UserPool');
    const client = userPool.addClient('Client', {
      authFlows: {
        userPassword: true,
      },
    });

    new MyProjectAgent(this, 'MyProjectAgent', {
      authorizerConfiguration: RuntimeAuthorizerConfiguration.usingCognito(
        userPool,
        [client],
      ),
    });
  }
}
```

或者，对于使用自有OIDC提供商的自定义JWT认证，使用`RuntimeAuthorizerConfiguration.usingJWT()`：

```ts {6-10}
import { MyProjectAgent } from ':my-scope/common-constructs';
import { RuntimeAuthorizerConfiguration } from '@aws-cdk/aws-bedrock-agentcore-alpha';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    new MyProjectAgent(this, 'MyProjectAgent', {
      authorizerConfiguration: RuntimeAuthorizerConfiguration.usingJWT(
        'https://example.com/.well-known/openid-configuration',
        ['client1', 'client2'], // 允许的客户端ID（可选）
        ['audience1'],          // 允许的受众（可选）
      ),
    });
  }
}
```
</Fragment>
<Fragment slot="terraform">
配置JWT认证时，可编辑智能体模块配置`authorizer_configuration`变量：

```terraform {18-23}
# packages/common/terraform/src/app/agents/my-project-agent/my-project-agent.tf

data "aws_region" "current" {}

locals {
  aws_region = data.aws_region.current.id

  # 替换为您的用户池和客户端ID或作为变量暴露
  user_pool_id = "xxx"
  user_pool_client_ids = ["yyy"]
}

module "agent_core_runtime" {
  source = "../../../core/agent-core"
  agent_runtime_name = "MyProjectAgent"
  docker_image_tag = "my-scope-my-project-agent:latest"
  server_protocol = "HTTP"
  authorizer_configuration = {
    custom_jwt_authorizer = {
      discovery_url = "https://cognito-idp.${local.aws_region}.amazonaws.com/${local.user_pool_id}/.well-known/openid-configuration"
      allowed_clients = local.user_pool_client_ids
    }
  }
  env = var.env
  additional_iam_policy_statements = var.additional_iam_policy_statements
  tags = var.tags
}
```
</Fragment>
</Infrastructure>

### 可观测性

通过[Dockerfile中的自动配置](https://aws.amazon.com/otel/)，使用AWS分布式OpenTelemetry（ADOT）实现可观测性。

在CloudWatch控制台选择"GenAI Observability"查看追踪数据，需启用[事务搜索](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Transaction-Search.html)。

详细配置参考[AgentCore可观测性文档](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/observability-configure.html)。

## 调用Strands智能体

### 调用本地服务器

要调用通过`<your-agent-name>-serve`目标本地运行的智能体，可以向本地智能体运行端口的`/invocations`发送简单的POST请求。例如，使用`curl`：

```bash
curl -N -X POST http://localhost:8081/invocations \
  -d '{"prompt": "what is 3 + 5?", "session_id": "abcdefghijklmnopqrstuvwxyz0123456789"}' \
  -H "Content-Type: application/json"
```

:::note
传递给`curl`的`-N`参数禁用输出流缓冲，以便实时查看流式响应。
:::

### 调用已部署的智能体

<Snippet name="agent/runtime-arn" parentHeading="调用已部署的智能体" />

#### IAM认证

对于IAM认证，请求必须使用AWS Signature Version 4（SigV4）签名。

```bash
acurl <region> bedrock-agentcore -N -X POST \
'https://bedrock
-agentcore.<region>.amazonaws.com/runtimes/<url-encoded-arn>/invocations' \
-d '{"prompt": "what is 3 + 5?", "session_id": "abcdefghijklmnopqrstuvwxyz0123456789"}' \
-H 'Content-Type: application/json'
```

<Drawer title="支持Sigv4的curl" trigger="点击此处了解配置上述acurl命令的更多详情">
<Snippet name="tools/acurl" />
</Drawer>

#### JWT / Cognito认证

对于Cognito认证，在`Authorization`标头中传递Cognito访问令牌：

```bash
curl -N -X POST 'https://bedrock
-agentcore.<region>.amazonaws.com/runtimes/<url-encoded-arn>/invocations' \
  -d '{"prompt": "what is 3 + 5?", "session_id": "abcdefghijklmnopqrstuvwxyz0123456789"}' \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <access-token>"
```

可使用AWS CLI的`cognito-idp admin-initiate-auth`命令获取访问令牌，例如：

```bash
aws cognito-idp admin-initiate-auth \
  --user-pool-id <user-pool-id> \
  --client-id <user-pool-client-id> \
  --auth-flow ADMIN_NO_SRP_AUTH \
  --auth-parameters USERNAME=<username>,PASSWORD=<password> \
  --region <region> \
  --query 'AuthenticationResult.AccessToken' \
  --output text
```