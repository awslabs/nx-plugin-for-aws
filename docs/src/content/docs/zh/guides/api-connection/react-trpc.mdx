---
title: "React 连接到 tRPC"
description: "将 React 网站连接到 tRPC API"
---

<think>

import { FileTree } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import schema from '../../../../../../../packages/nx-plugin/src/api-connection/schema.json';

Nx 的 AWS 插件提供了一个生成器，可快速将您的 <Link path="guides/trpc">tRPC API</Link> 与 React 网站集成。它会配置所有必要的连接设置以接入 tRPC 后端，包括 AWS IAM 身份验证支持和正确的错误处理。该集成提供前端与 tRPC 后端之间的完整端到端类型安全。

## 前提条件

使用此生成器前，请确保您的 React 应用具备以下条件：

1. 有一个渲染应用的 `main.tsx` 文件
2. 包含将自动注入 tRPC provider 的 `<App/>` JSX 元素
3. 拥有正常运行的 tRPC 后端（使用 tRPC 后端生成器生成）

<details>
<summary>所需 `main.tsx` 结构示例</summary>

```tsx
import { StrictMode } from 'react';
import * as ReactDOM from 'react-dom/client';
import App from './app/app';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement,
);
root.render(
  <StrictMode>
    <App />
  </StrictMode>,
);
```

</details>

## 使用方式

### 运行生成器

<RunGenerator generator="api-connection" />

### 选项

<GeneratorParameters schema={schema} />

## 生成器输出

生成器会在您的 React 应用中创建以下结构：

<FileTree>

- src
  - components
    - TrpcClients
      - index.tsx
      - TrpcProvider.tsx 用于多个 tRPC API 的 Provider
      - TrpcApis.tsx 包含所有 tRPC API 连接的对象
      - TrpcClientProviders.tsx 设置 tRPC 客户端并绑定到后端 schema
    - QueryClientProvider.tsx TanStack React Query 客户端提供者
  - hooks
    - useSigV4.tsx 用于使用 SigV4 签名 HTTP 请求的钩子（仅限 IAM）
    - use\<ApiName>.tsx 对应后端 API 的钩子。ApiName 将解析为 API 名称

</FileTree>

同时会安装所需依赖：

  - `@trpc/client`
  - `@trpc/tanstack-react-query`
  - `@tanstack/react-query`
  - `aws4fetch`（若使用 IAM 认证）

## 使用生成代码

### 使用 tRPC 钩子

生成器提供 `use<ApiName>` 钩子，用于访问类型安全的 tRPC 客户端：

```tsx {5,8,11}
import { useQuery, useMutation } from '@tanstack/react-query';
import { useMyApi } from './hooks/useMyApi';

function MyComponent() {
  const trpc = useMyApi();

  // 示例查询
  const { data, isLoading, error } = useQuery(trpc.users.list.queryOptions());

  // 示例变更
  const mutation = useMutation(trpc.users.create.mutationOptions());

  const handleCreate = () => {
    mutation.mutate({
      name: 'John Doe',
      email: 'john@example.com',
    });
  };

  if (isLoading) return <div>加载中...</div>;

  return (
    <ul>
      {data.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

### 错误处理

集成内置的错误处理能正确解析 tRPC 错误：

```tsx {4, 6}
function MyComponent() {
  const trpc = useMyApi();

  const { data, error } = useQuery(trpc.users.list.queryOptions());

  if (error) {
    return (
      <div>
        <h2>发生错误：</h2>
        <p>{error.message}</p>
        {error.data?.code && <p>错误码：{error.data.code}</p>}
      </div>
    );
  }

  return (
    <ul>
      {data.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

## 最佳实践

### 处理加载状态

始终处理加载和错误状态以提升用户体验：

```tsx {6}
function UserList() {
  const trpc = useMyApi();

  const users = useQuery(trpc.users.list.queryOptions());

  if (users.isLoading) {
    return <LoadingSpinner />;
  }

  if (users.error) {
    return <ErrorMessage error={users.error} />;
  }

  return (
    <ul>
      {users.data.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

### 乐观更新

使用乐观更新提升用户体验：

```tsx {15-17,20-22,28-31}
import { useQueryClient, useQuery, useMutation } from '@tanstack/react-query';

function UserList() {
  const trpc = useMyApi();
  const users = useQuery(trpc.users.list.queryOptions());
  const queryClient = useQueryClient();

  const deleteMutation = useMutation(
    trpc.users.delete.mutationOptions({
      onMutate: async (userId) => {
        // 取消正在进行的请求
        await queryClient.cancelQueries(trpc.users.list.queryFilter());

        // 获取当前数据快照
        const previousUsers = queryClient.getQueryData(
          trpc.users.list.queryKey(),
        );

        // 乐观删除用户
        queryClient.setQueryData(trpc.users.list.queryKey(), (old) =>
          old?.filter((user) => user.id !== userId),
        );

        return { previousUsers };
      },
      onError: (err, userId, context) => {
        // 出错时恢复数据
        queryClient.setQueryData(
          trpc.users.list.queryKey(),
          context?.previousUsers,
        );
      },
    }),
  );

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>
          {user.name}
          <button onClick={() => deleteMutation.mutate(user.id)}>删除</button>
        </li>
      ))}
    </ul>
  );
}
```

### 数据预取

通过预取数据提升性能：

```tsx {8}
function UserList() {
  const trpc = useMyApi();
  const users = useQuery(trpc.users.list.queryOptions());
  const queryClient = useQueryClient();

  // 悬停时预取用户详情
  const prefetchUser = async (userId: string) => {
    await queryClient.prefetchQuery(trpc.users.getById.queryOptions(userId));
  };

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id} onMouseEnter={() => prefetchUser(user.id)}>
          <Link to={`/users/${user.id}`}>{user.name}</Link>
        </li>
      ))}
    </ul>
  );
}
```

### 无限查询

使用无限查询处理分页：

```tsx {5-12}
function UserList() {
  const trpc = useMyApi();

  const { data, fetchNextPage, hasNextPage, isFetchingNextPage } =
    useInfiniteQuery(
      trpc.users.list.infiniteQueryOptions(
        { limit: 10 },
        {
          getNextPageParam: (lastPage) => lastPage.nextCursor,
        },
      ),
    );

  return (
    <div>
      {data?.pages.map((page) =>
        page.users.map((user) => <UserCard key={user.id} user={user} />),
      )}

      {hasNextPage && (
        <button onClick={() => fetchNextPage()} disabled={isFetchingNextPage}>
          {isFetchingNextPage ? '加载中...' : '加载更多'}
        </button>
      )}
    </div>
  );
}
```

需要注意的是，无限查询仅适用于输入参数包含名为 `cursor` 属性的过程。

## 类型安全

该集成提供完整的端到端类型安全。您的 IDE 将为所有 API 调用提供完整的自动补全和类型检查：

```tsx
function UserForm() {
  const trpc = useMyApi();

  // ✅ 输入完全类型化
  const createUser = trpc.users.create.useMutation();

  const handleSubmit = (data: CreateUserInput) => {
    // ✅ 输入不匹配 schema 时会出现类型错误
    createUser.mutate(data);
  };

  return <form onSubmit={handleSubmit}>{/* ... */}</form>;
}
```

类型会根据后端路由器和 schema 定义自动推断，确保 API 的任何变更都能立即在前端代码中反映，无需重新构建。

## 更多信息

更多信息请参考 [tRPC TanStack React Query 文档](https://trpc.io/docs/client/tanstack-react-query/usage)。

也可直接查看 [TanStack Query 文档](https://tanstack.com/query/v5)。