---
title: "React 连接到 Smithy API"
description: "将 React 网站连接到 Smithy TypeScript API"
---

import { FileTree, Steps } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import Drawer from '@components/drawer.astro';
import GeneratorParameters from '@components/generator-parameters.astro';

`api-connection` 生成器提供了一种快速将 React 网站与 Smithy TypeScript API 后端集成的方式。它设置了所有必要的配置，以类型安全的方式连接到 Smithy API，包括客户端和 [TanStack Query](https://tanstack.com/query/v5) 钩子生成、AWS IAM 和 Cognito 身份验证支持以及正确的错误处理。

## 前提条件

使用此生成器前，请确保您的 React 应用具备：

1. 渲染应用的 `main.tsx` 文件
2. 可运行的 Smithy TypeScript API 后端（使用 <Link path="/guides/ts-smithy-api">`ts#smithy-api` 生成器</Link>生成）
3. 如果连接使用 Cognito 或 IAM 身份验证的 API，需通过 <Link path="/guides/react-website-auth">`ts#react-website-auth` 生成器</Link>添加 Cognito 身份验证

<details>
<summary>所需 `main.tsx` 结构示例</summary>

```tsx
import { StrictMode } from 'react';
import * as ReactDOM from 'react-dom/client';
import App from './app/app';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement,
);
root.render(
  <StrictMode>
    <App />
  </StrictMode>,
);
```

</details>

## 使用方式

### 运行生成器

<RunGenerator generator="api-connection" />

### 选项

<GeneratorParameters generator="api-connection" />

## 生成器输出

生成器将修改 React 应用中的以下文件：

<FileTree>

- src
  - components
    - \<ApiName>Provider.tsx API 客户端提供者
    - QueryClientProvider.tsx TanStack React Query 客户端提供者
    - RuntimeConfig/ 本地开发运行时配置组件
  - hooks
    - use\<ApiName>.tsx 添加通过 TanStack Query 管理状态的 API 调用钩子
    - use\<ApiName>Client.tsx 添加实例化原生 API 客户端的钩子
    - useSigV4.tsx 添加使用 SigV4 签名 HTTP 请求的钩子（如果选择 IAM 身份验证）
- project.json 添加生成类型安全客户端的新构建目标
- .gitignore 默认忽略生成的客户端文件

</FileTree>

生成器还会在网站基础设施中添加运行时配置（如果尚未存在），确保 Smithy API 的 URL 在网站中可用，并由 `use<ApiName>.tsx` 钩子自动配置。

### 代码生成

构建时，根据 Smithy API 的 OpenAPI 规范生成类型安全客户端。这将在 React 应用中添加三个新文件：

<FileTree>

- src
  - generated
    - \<ApiName>
      - types.gen.ts 从 Smithy 模型结构生成的类型
      - client.gen.ts 调用 API 的类型安全客户端
      - options-proxy.gen.ts 提供创建 TanStack Query 钩子选项的方法

</FileTree>

:::tip
默认情况下生成的客户端会被版本控制忽略。如需提交，可从 React 应用的 `.gitignore` 中移除对应条目，但注意手动修改 `.gen.ts` 文件会在项目构建时被覆盖。
:::

## 使用生成代码

建议通过 TanStack Query 钩子使用生成的类型安全客户端，但也可直接使用原生客户端。

:::note
修改 Smithy API 模型后需重新构建项目以使更改生效。例如：

<NxCommands commands={['run-many --target build --all']} />
:::

:::tip
若需同时开发 React 应用和 Smithy API，可使用 `serve-local` 目标自动在 API 变更时重新生成客户端，并热重载网站和本地 Smithy API 服务器：

<NxCommands commands={['run <WebsiteProject>:serve-local']} />

如需更精细控制，可使用 `watch-generate:<ApiName>-client` 目标在 API 变更时重新生成客户端：

<NxCommands commands={['run <WebsiteProject>:"watch-generate:<ApiName>-client"']}
/>
:::

### 使用 API 钩子

生成器提供 `use<ApiName>` 钩子用于通过 TanStack Query 调用 API。

### 查询

使用 `queryOptions` 方法获取调用 API 所需的选项：

```tsx {7}
import { useQuery } from '@tanstack/react-query';
import { useState, useEffect } from 'react';
import { useMyApi } from './hooks/useMyApi';

function MyComponent() {
  const api = useMyApi();
  const item = useQuery(api.getItem.queryOptions({ itemId: 'some-id' }));

  if (item.isLoading) return <div>加载中...</div>;
  if (item.isError) return <div>错误: {item.error.message}</div>;

  return <div>项目: {item.data.name}</div>;
}
```

<Drawer title="直接使用 API 客户端" trigger="点击查看直接使用原生客户端的示例。">
```tsx {5,13}
import { useState, useEffect } from 'react';
import { useMyApiClient } from './hooks/useMyApiClient';

function MyComponent() {
  const api = useMyApiClient();
  const [item, setItem] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchItem = async () => {
      try {
        const data = await api.getItem({ itemId: 'some-id' });
        setItem(data);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };
    fetchItem();
  }, [api]);

  if (loading) return <div>加载中...</div>;
  if (error) return <div>错误: {error.message}</div>;

  return <div>项目: {item.name}</div>;
}
```
</Drawer>

### 变更操作

生成的钩子支持使用 TanStack Query 的 `useMutation` 处理创建、更新和删除操作，提供加载状态、错误处理和乐观更新功能。

```tsx {5-7,11}
import { useMutation } from '@tanstack/react-query';
import { useMyApi } from './hooks/useMyApi';

function CreateItemForm() {
  const api = useMyApi();
  // 使用生成的变更选项创建变更操作
  const createItem = useMutation(api.createItem.mutationOptions());

  const handleSubmit = (e) => {
    e.preventDefault();
    createItem.mutate({ name: '新项目', description: '新建项目' });
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* 表单字段 */}
      <button
        type="submit"
        disabled={createItem.isPending}
      >
        {createItem.isPending ? '创建中...' : '创建项目'}
      </button>

      {createItem.isSuccess && (
        <div className="success">
          创建项目 ID: {createItem.data.id}
        </div>
      )}

      {createItem.isError && (
        <div className="error">
          错误: {createItem.error.message}
        </div>
      )}
    </form>
  );
}
```

可为不同变更状态添加回调：

```tsx
const createItem = useMutation({
  ...api.createItem.mutationOptions(),
  onSuccess: (data) => {
    console.log('项目创建:', data);
    navigate(`/items/${data.id}`);
  },
  onError: (error) => {
    console.error('创建失败:', error);
  },
  onSettled: () => {
    queryClient.invalidateQueries({ queryKey: api.listItems.queryKey() });
  }
});
```

<Drawer title="直接使用客户端进行变更" trigger="点击查看直接使用客户端的示例。">
```tsx
import { useState } from 'react';
import { useMyApiClient } from './hooks/useMyApiClient';

function CreateItemForm() {
  const api = useMyApiClient();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [createdItem, setCreatedItem] = useState(null);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    try {
      const newItem = await api.createItem({
        name: '新项目',
        description: '新建项目'
      });
      setCreatedItem(newItem);
    } catch (err) {
      setError(err);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <button
        type="submit"
        disabled={isLoading}
      >
        {isLoading ? '创建中...' : '创建项目'}
      </button>

      {createdItem && (
        <div className="success">
          创建项目 ID: {createdItem.id}
        </div>
      )}

      {error && (
        <div className="error">
          错误: {error.message}
        </div>
      )}
    </form>
  );
}
```
</Drawer>

### 分页与无限查询

对于接受 `cursor` 参数的端点，生成的钩子支持使用 `useInfiniteQuery` 实现"加载更多"或无限滚动功能。

```tsx {6-16,30-34}
import { useInfiniteQuery } from '@tanstack/react-query';
import { useMyApi } from './hooks/useMyApi';

function ItemList() {
  const api = useMyApi();
  const items = useInfiniteQuery({
    ...api.listItems.infiniteQueryOptions({
      limit: 10,
    }, {
      getNextPageParam: (lastPage) =>
        lastPage.nextCursor || undefined
      }),
  });

  if (items.isLoading) return <LoadingSpinner />;

  if (items.isError) return <ErrorMessage message={items.error.message} />;

  return (
    <div>
      <ul>
        {items.data.pages.flatMap(page =>
          page.items.map(item => (
            <li key={item.id}>{item.name}</li>
          ))
        )}
      </ul>

      <button
        onClick={() => items.fetchNextPage()}
        disabled={!items.hasNextPage || items.isFetchingNextPage}
      >
        {items.isFetchingNextPage
          ? '加载更多...'
          : items.hasNextPage
          ? '加载更多'
          : '无更多项目'}
      </button>
    </div>
  );
}
```

:::tip
若分页参数非 `cursor`，可通过 `x-cursor` OpenAPI 扩展自定义。
:::

<Drawer title="直接使用客户端分页" trigger="点击查看直接使用客户端的示例。">
```tsx
import { useState, useEffect } from 'react';
import { useMyApiClient } from './hooks/useMyApiClient';

function ItemList() {
  const api = useMyApiClient();
  const [items, setItems] = useState([]);
  const [nextCursor, setNextCursor] = useState(null);
  const [isFetchingMore, setIsFetchingMore] = useState(false);

  useEffect(() => {
    const fetchItems = async () => {
      const response = await api.listItems({ limit: 10 });
      setItems(response.items);
      setNextCursor(response.nextCursor);
    };
    fetchItems();
  }, [api]);

  const loadMore = async () => {
    const response = await api.listItems({ limit: 10, cursor: nextCursor });
    setItems(prev => [...prev, ...response.items]);
    setNextCursor(response.nextCursor);
  };

  return (
    <div>
      <ul>{items.map(item => <li key={item.id}>{item.name}</li>)}</ul>
      <button onClick={loadMore} disabled={!nextCursor || isFetchingMore}>
        {isFetchingMore ? '加载中...' : nextCursor ? '加载更多' : '无更多项目'}
      </button>
    </div>
  );
}
```
</Drawer>

### 错误处理

集成内置类型化错误响应处理，通过检查 `status` 可处理特定错误类型。

```tsx {12}
import { useMutation } from '@tanstack/react-query';

function MyComponent() {
  const api = useMyApi();
  const createItem = useMutation(api.createItem.mutationOptions());

  const handleClick = () => {
    createItem.mutate({ name: '新项目' });
  };

  if (createItem.error) {
    switch (createItem.error.status) {
      case 400:
        return <div>无效输入: {createItem.error.error.message}</div>;
      case 403:
        return <div>未授权: {createItem.error.error.reason}</div>;
      case 500:
        return <div>服务器错误: {createItem.error.error.message}</div>;
    }
  }

  return <button onClick={handleClick}>创建项目</button>;
}
```

<Drawer title="直接处理客户端错误" trigger="点击查看直接处理错误的示例。">
```tsx {9,15}
function MyComponent() {
  const api = useMyApiClient();
  const [error, setError] = useState<CreateItemError | null>(null);

  const handleClick = async () => {
    try {
      await api.createItem({ name: '新项目' });
    } catch (err) {
      setError(err as CreateItemError);
    }
  };

  if (error) {
    switch (error.status) {
      case 400:
        return <div>无效输入: {error.error.message}</div>;
      case 403:
        return <div>未授权: {error.error.reason}</div>;
      case 500:
        return <div>服务器错误: {error.error.message}</div>;
    }
  }

  return <button onClick={handleClick}>创建项目</button>;
}
```
</Drawer>

## 自定义生成代码

### 查询与变更操作

默认将 `PUT`、`POST`、`PATCH`、`DELETE` 方法视为变更操作，其他视为查询。可通过 `x-query` 和 `x-mutation` 扩展修改此行为。

#### x-query

在 Smithy 模型中添加 `@query` 特性强制视为查询：

```smithy
@http(method: "POST", uri: "/items")
@query
operation ListItems {
    input: ListItemsInput
    output: ListItemsOutput
}
```

#### x-mutation

添加 `@mutation` 特性强制视为变更操作：

```smithy
@http(method: "GET", uri: "/start-processing")
@mutation
operation StartProcessing {
    input: StartProcessingInput
    output: StartProcessingOutput
}
```

### 自定义分页游标

通过 `x-cursor` 扩展自定义分页参数：

```smithy
@cursor(inputToken: "nextToken")
operation ListItems {
    input: ListItemsInput
    output: ListItemsOutput
}
```

禁用分页：

```smithy
@cursor(enabled: false)
operation ListItems {
    input: ListItemsInput
    output: ListItemsOutput
}
```

### 操作分组

使用 `@tags` 特性按标签分组操作，提升代码组织性和 IDE 自动补全：

```smithy
@tags(["items"])
operation ListItems {
    input: ListItemsInput
    output: ListItemsOutput
}
```

分组后可通过 `api.items` 和 `api.users` 访问不同组操作。

### 错误处理

在 Smithy 模型中定义自定义错误结构，生成客户端会自动处理这些类型：

```smithy
@error("client")
@httpError(400)
structure InvalidRequestError {
    @required
    message: String
    fieldErrors: FieldErrorList
}
```

在 React 组件中处理类型化错误：

```tsx
switch (error.status) {
  case 400:
    console.error('验证错误:', error.error.fieldErrors);
    break;
  case 403:
    console.error('未授权:', error.error.reason);
    break;
}
```

## 最佳实践

### 处理加载状态

始终处理加载和错误状态以提升用户体验：

```tsx
if (items.isLoading) return <LoadingSpinner />;
if (items.isError) return <ErrorMessage message={items.error.message} />;
```

### 乐观更新

实现乐观更新提升用户体验：

```tsx
const deleteMutation = useMutation({
  ...api.deleteItem.mutationOptions(),
  onMutate: async (itemId) => {
    const previousItems = queryClient.getQueryData(api.listItems.queryKey());
    queryClient.setQueryData(api.listItems.queryKey(), old => old.filter(item => item.id !== itemId));
    return { previousItems };
  },
  onError: (err, itemId, context) => {
    queryClient.setQueryData(api.listItems.queryKey(), context.previousItems);
  }
});
```

## 类型安全

集成提供端到端类型安全，IDE 会为所有 API 调用提供自动补全和类型检查：

```tsx
const createItem = useMutation({
  ...api.createItem.mutationOptions(),
  onSuccess: (data) => { // data 自动推断类型
    console.log(`创建项目 ID: ${data.id}`);
  },
});

const handleSubmit = (data: CreateItemInput) => { // 输入类型检查
  createItem.mutate(data);
};
```

所有类型均从 Smithy API 的 OpenAPI 模式生成，确保前端代码与 API 变更保持同步。