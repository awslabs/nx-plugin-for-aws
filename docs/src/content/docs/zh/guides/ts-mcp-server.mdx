---
title: "TypeScript MCP 服务器"
description: "为大型语言模型提供上下文的 TypeScript 模型上下文协议（MCP）服务器"
---



import { FileTree } from '@astrojs/starlight/components';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import Link from '@components/link.astro';
import Snippet from '@components/snippet.astro';
import GeneratorParameters from '@components/generator-parameters.astro';

生成一个TypeScript [模型上下文协议（MCP）](https://modelcontextprotocol.io/)服务端，用于为大型语言模型（LLMs）提供上下文，并可选部署到[Amazon Bedrock AgentCore](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/)。

## 什么是MCP？

[模型上下文协议（MCP）](https://modelcontextprotocol.io/)是一个开放标准，允许AI助手与外部工具和资源交互。它为LLMs提供了一致的方式来：

- 执行执行操作或检索信息的工具（函数）
- 访问提供上下文或数据的资源

## 使用方式

### 生成MCP服务端

您可以通过两种方式生成TypeScript MCP服务端：

<RunGenerator generator="ts#mcp-server" />

:::tip
建议先使用<Link path="/guides/typescript-project">`ts#project`</Link>生成器创建项目，再向其中添加MCP服务端。
:::

### 选项参数

<GeneratorParameters generator="ts#mcp-server" />

## 生成器输出

生成器将在现有TypeScript项目中添加以下文件：

<FileTree>
  - your-project/
    - src/
      - mcp-server/ （或指定的自定义名称）
        - index.ts 导出服务端
        - server.ts 主服务端定义
        - stdio.ts STDIO传输入口点，适用于简单本地MCP服务端
        - http.ts 可流式HTTP传输入口点，适用于托管MCP服务端
        - tools/
          - add.ts 示例工具
        - resources/
          - sample-guidance.ts 示例资源
        - Dockerfile 托管MCP服务端的入口点（当`computeType`设为`BedrockAgentCoreRuntime`时）
    - package.json 更新了bin入口和MCP依赖
    - project.json 更新了MCP服务端运行目标
</FileTree>

:::note
如果为`computeType`选择了`BedrockAgentCoreRuntime`，生成器还会创建用于部署MCP服务端的CDK构造。
:::

## 使用MCP服务端

### 添加工具

工具是AI助手可以调用的功能函数。您可以在`server.ts`文件中添加新工具：

```typescript
server.tool("工具名称", "工具描述",
  { 参数1: z.string(), 参数2: z.number() }, // 使用Zod的输入模式
  async ({ 参数1, 参数2 }) => {
    // 工具实现
    return {
      content: [{ type: "text", text: "结果" }]
    };
  }
);
```

:::caution
当前MCP SDK仅支持Zod v3。为了允许其他生成器使用Zod v4，Zod v3依赖被安装为`zod-v3`。在MCP工具模式中需要按以下方式导入Zod：

```ts
import { z } from 'zod-v3';
```

待[MCP SDK的此问题](https://github.com/modelcontextprotocol/typescript-sdk/issues/164)解决后，可移除额外的`zod-v3`依赖，直接从`zod`导入。
:::

### 添加资源

资源为AI助手提供上下文。您可以从文件添加静态资源或动态资源：

```typescript
const 示例上下文 = '要返回的上下文内容';

server.resource('资源名称', 'example://resource', async (uri) => ({
  contents: [{ uri: uri.href, text: 示例上下文 }],
}));

// 动态资源
server.resource('动态资源', 'dynamic://resource', async (uri) => {
  const 数据 = await 获取数据();
  return {
    contents: [{ uri: uri.href, text: 数据 }],
  };
});
```

## 配置AI助手

<Snippet name="mcp/configuration-ts" parentHeading="配置AI助手" />

## 运行MCP服务端

### 检查器

生成器配置了名为`<your-server-name>-inspect`的目标，用于启动[MCP检查器](https://github.com/modelcontextprotocol/inspector)并通过STDIO传输连接到您的MCP服务端。

<NxCommands commands={['run your-project:your-server-name-inspect']} />

这将启动检查器服务，地址为`http://localhost:6274`。点击"Connect"按钮开始使用。

### STDIO模式

测试和使用MCP服务端最简单的方式是使用检查器或按上述方式配置AI助手。

您也可以通过`<your-server-name>-serve-stdio`目标直接使用[STDIO传输](https://modelcontextprotocol.io/docs/concepts/transports#standard-input%2Foutput-stdio)运行服务端：

<NxCommands commands={['run your-project:your-server-name-serve-stdio']} />

该命令使用`tsx --watch`在文件变更时自动重启服务端。

### 可流式HTTP

如需使用[可流式HTTP传输](https://modelcontextprotocol.io/docs/concepts/transports#streamable-http)在本地运行MCP服务端，可使用`<your-server-name>-serve-http`目标：

<NxCommands commands={['run your-project:your-server-name-serve-http']} />

该命令同样使用`tsx --watch`实现自动重启。

## 部署到Bedrock AgentCore Runtime

<Snippet name="mcp/bedrock-deployment" parentHeading="部署到Bedrock AgentCore Runtime" />

### 打包目标

为构建适用于Bedrock AgentCore Runtime的MCP服务端，项目中添加了`<your-mcp-server>-bundle`目标，该目标：

- 使用[`esbuild`](https://esbuild.github.io/)将MCP服务端打包为单个JavaScript文件，以`http.ts`作为可流式HTTP MCP服务端的入口
- 根据`Dockerfile`构建docker镜像，该镜像按照[MCP协议约定](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-service-contract.html#mcp-protocol-contract)在端口`8000`运行打包后的服务端

:::tip
docker镜像使用特定标签（例如`my-scope-my-project-mcp-server:latest`）构建，CDK构造的`Dockerfile`继承该标签，使得您的`Dockerfile`可以与MCP服务端项目共存。
:::

### 可观测性

<Snippet name="mcp/observability" parentHeading="可观测性" />