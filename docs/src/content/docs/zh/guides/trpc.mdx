---
title: "tRPC"
description: "tRPC 参考文档"
---

import { FileTree, Tabs, TabItem } from '@astrojs/starlight/components';
import AnchorHeading from '@astrojs/starlight/components/AnchorHeading.astro';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Infrastructure from '@components/infrastructure.astro';
import Snippet from '@components/snippet.astro';

[tRPC](https://trpc.io/) 是一个用于在 TypeScript 中构建端到端类型安全 API 的框架。使用 tRPC 时,API 操作输入输出的更新会立即反映在客户端代码中,并可在 IDE 中直接查看,无需重新构建项目。

tRPC API 生成器会创建一个新的 tRPC API,并配置 AWS CDK 或 Terraform 基础设施。生成的后端使用 AWS Lambda 进行无服务器部署,通过 AWS API Gateway API 暴露,并包含使用 [Zod](https://zod.dev/) 的模式验证。它配置了 [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/) 用于可观测性,包括日志记录、AWS X-Ray 追踪和 Cloudwatch 指标。

## 用法

### 生成 tRPC API

您可以通过两种方式生成新的 tRPC API:

<RunGenerator generator="ts#trpc-api" />

### 选项

<GeneratorParameters generator="ts#trpc-api" />

<Snippet name="api/api-choice-note" />

:::tip
如果您希望使用 [tRPC 订阅](https://trpc.io/docs/server/subscriptions)来流式传输响应,请选择 `ServerlessApiGatewayRestApi`(默认)作为您的 `computeType`。
:::

## 生成器输出

生成器将在 `<directory>/<api-name>` 目录中创建以下项目结构:

<FileTree>
  - src
    - init.ts 后端 tRPC 初始化
    - handler.ts Lambda 处理程序入口点
    - router.ts tRPC 路由定义
    - schema 使用 Zod 的模式定义
      - echo.ts "echo" 过程的输入输出示例定义
      - z-async-iterable.ts 订阅的 Zod 辅助工具(仅限 REST API)
    - procedures API 暴露的过程(或操作)
      - echo.ts 示例过程
    - middleware
      - error.ts 错误处理中间件
      - logger.ts 配置 AWS Lambda Powertools 日志记录的中间件
      - tracer.ts 配置 AWS Lambda Powertools 追踪的中间件
      - metrics.ts 配置 AWS Lambda Powertools 指标的中间件
    - local-server.ts 本地开发服务器使用的 tRPC 独立适配器入口点
    - client
      - index.ts 用于机器间 API 调用的类型安全客户端
  - tsconfig.json TypeScript 配置
  - project.json 项目配置和构建目标

</FileTree>

### 基础设施

<Snippet name="shared-constructs" />

<Snippet name="api/shared-constructs" />

## 实现 tRPC API

从高层次来看,tRPC API 由将请求委托给特定过程的路由器组成。每个过程都有使用 Zod 模式定义的输入和输出。

### 模式

`src/schema` 目录包含客户端和服务器代码共享的类型。在本包中,这些类型使用 [Zod](https://zod.dev/)(一个 TypeScript 优先的模式声明和验证库)定义。

示例模式可能如下所示:

```ts
import { z } from 'zod';

// 模式定义
export const UserSchema = z.object({
  name: z.string(),
  height: z.number(),
  dateOfBirth: z.string().datetime(),
});

// 对应的 TypeScript 类型
export type User = z.TypeOf<typeof UserSchema>;
```

根据上述模式,`User` 类型等效于以下 TypeScript:

```ts
interface User {
  name: string;
  height: number;
  dateOfBirth: string;
}
```

模式在服务器和客户端代码之间共享,当需要修改 API 使用的结构时,只需在此处更新即可。

tRPC API 在运行时自动验证模式,无需在后端手工编写验证逻辑。

Zod 提供了强大的工具来组合或派生模式,如 `.merge`、`.pick`、`.omit` 等。更多信息请参阅 [Zod 文档网站](https://zod.dev/?id=basic-usage)。

### 路由与过程

您的 tRPC 路由在 `src/router.ts` 中定义,它注册所有过程。每个过程定义预期的输入、输出和实现。Lambda 处理程序入口点在 `src/handler.ts` 中,它将请求转发到您的路由器。

生成的示例路由器有一个名为 `echo` 的单一操作:

```ts
import { echo } from './procedures/echo.js';

export const appRouter = router({
  echo,
});
```

示例 `echo` 过程在 `src/procedures/echo.ts` 中生成:

```ts
export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

分解上述代码:

- `publicProcedure` 定义 API 的公共方法,包含在 `src/middleware` 中设置的中间件。该中间件包括用于日志记录、追踪和指标的 AWS Lambda Powertools 集成
- `input` 接受定义操作预期输入的 Zod 模式。发送到此操作的请求会自动根据此模式验证
- `output` 接受定义操作预期输出的 Zod 模式。如果返回不符合模式的输出,实现中会出现类型错误
- `query` 接受定义 API 实现的函数。该实现接收包含操作输入的 `opts`,以及中间件设置的上下文(通过 `opts.ctx` 访问)。传递给 `query` 的函数必须返回符合 `output` 模式的输出

使用 `query` 定义实现表示该操作是非变更性的。使用此方法来定义数据检索方法。要实现变更性操作,请改用 `mutation` 方法。

如果添加新过程,请确保在 `src/router.ts` 的路由器中注册它。

### 订阅(流式传输)

:::caution
订阅仅在 `computeType` 为 `ServerlessApiGatewayRestApi`(默认)时受支持,因为 API Gateway HTTP API 不支持响应流式传输。
:::

tRPC 订阅允许您使用[服务器发送事件(SSE)](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)从服务器向客户端流式传输数据。当您选择 `ServerlessApiGatewayRestApi` 作为计算类型时,生成器会自动配置流式传输所需的基础设施,以及流式传输 Lambda 处理程序和 `ZodAsyncIterable` 模式辅助工具。

要定义订阅过程,请使用 `.subscription` 方法和异步生成器函数。使用 `src/schema/z-async-iterable.ts` 中的 `ZodAsyncIterable` 辅助工具来定义输出模式:

```ts
import { publicProcedure } from '../init.js';
import { z } from 'zod';
import { ZodAsyncIterable } from '../schema/z-async-iterable.js';

const InputSchema = z.object({ query: z.string() });
const ChunkSchema = z.object({ text: z.string() });

export const myStream = publicProcedure
  .input(InputSchema)
  .output(
    ZodAsyncIterable({
      yield: ChunkSchema,
    }),
  )
  .subscription(async function* (opts) {
    // 在数据可用时向客户端产出数据
    for (const chunk of await getResults(opts.input.query)) {
      yield { text: chunk };
    }
  });
```

像注册任何其他过程一样在路由器中注册订阅:

```ts
export const appRouter = router({
  echo,
  myStream,
});
```

生成的基础设施对所有 REST API 操作使用具有 `ResponseTransferMode.STREAM` 的流式传输 Lambda 处理程序,这使订阅能够与常规查询和变更一起工作。

## 自定义 tRPC API

### 错误处理

在实现中,您可以通过抛出 `TRPCError` 向客户端返回错误响应。这些错误接受表示错误类型的 `code`,例如:

```ts
throw new TRPCError({
  code: 'NOT_FOUND',
  message: '找不到请求的资源',
});
```

### 组织操作

随着 API 的增长,您可能希望将相关操作分组。

您可以使用嵌套路由器对操作进行分组,例如:

```ts
import { getUser } from './procedures/users/get.js';
import { listUsers } from './procedures/users/list.js';

const appRouter = router({
   users: router({
      get: getUser,
      list: listUsers,
   }),
   ...
})
```

客户端将接收此操作分组,例如在此情况下调用 `listUsers` 操作可能如下所示:

```ts
client.users.list.query();
```

### 日志记录

AWS Lambda Powertools 日志记录器在 `src/middleware/logger.ts` 中配置,可通过 `opts.ctx.logger` 在 API 实现中访问。您可以使用此记录器向 CloudWatch Logs 记录日志,并/或控制每个结构化日志消息中包含的额外值。例如:

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.logger.info('操作调用输入', opts.input);

      return ...;
   });
```

有关日志记录器的更多信息,请参阅 [AWS Lambda Powertools 日志记录器文档](https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/)。

### 记录指标

AWS Lambda Powertools 指标在 `src/middleware/metrics.ts` 中配置,可通过 `opts.ctx.metrics` 在 API 实现中访问。您可以使用此功能在 CloudWatch 中记录指标,而无需导入和使用 AWS SDK,例如:

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.metrics.addMetric('Invocations', 'Count', 1);

      return ...;
   });
```

更多信息请参阅 [AWS Lambda Powertools 指标文档](https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/)。

### 微调 X-Ray 追踪

AWS Lambda Powertools 追踪器在 `src/middleware/tracer.ts` 中配置,可通过 `opts.ctx.tracer` 在 API 实现中访问。您可以使用此功能添加 AWS X-Ray 追踪,以提供 API 请求性能和流程的详细洞察。例如:

```ts {5-7}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      const subSegment = opts.ctx.tracer.getSegment()!.addNewSubsegment('MyAlgorithm');
      // ... 要捕获的算法逻辑
      subSegment.close();

      return ...;
   });
```

更多信息请参阅 [AWS Lambda Powertools 追踪器文档](https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/)。

### 实现自定义中间件

您可以通过实现中间件向过程提供的上下文中添加额外值。

例如,让我们在 `src/middleware/identity.ts` 中实现一些中间件来从 API 中提取调用用户的详细信息。

:::warning
此示例假设 `auth` 设置为 `IAM`。对于 Cognito 身份验证,身份中间件更简单,直接从 `event` 中提取相关声明。
:::

首先,我们定义要添加到上下文中的内容:

```ts
export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}
```

注意,我们向上下文定义了一个额外的 _可选_ 属性。tRPC 会管理确保在正确配置此中间件的过程中有此定义。

接下来,我们将实现中间件本身。其结构如下:

```ts
export const createIdentityPlugin = () => {
   const t = initTRPC.context<...>().create();
   return t.procedure.use(async (opts) => {
      // 在此添加过程前运行的逻辑

      const response = await opts.next(...);

      // 在此添加过程后运行的逻辑

      return response;
   });
};
```

在我们的案例中,我们希望提取调用 Cognito 用户的详细信息。我们将通过从 API Gateway 事件中提取用户的主题 ID(或 "sub"),并从 Cognito 检索用户详细信息来实现。具体实现根据事件是由 REST API 还是 HTTP API 提供给我们的函数而略有不同:

<Tabs>
<TabItem label="REST">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEvent } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEvent>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoAuthenticationProvider = opts.ctx.event.requestContext?.identity?.cognitoAuthenticationProvider;

    let sub: string | undefined = undefined;
    if (cognitoAuthenticationProvider) {
      const providerParts = cognitoAuthenticationProvider.split(':');
      sub = providerParts[providerParts.length - 1];
    }

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `无法确定调用用户`,
      });
    }

    const { Users } = await cognito.listUsers({
      // 假设用户池 ID 在 Lambda 环境中配置
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `找不到主题 ID 为 ${sub} 的用户`,
      });
    }

    // 向其他过程提供身份信息
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
<TabItem label="HTTP">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoIdentity = opts.ctx.event.requestContext?.authorizer?.iam
      ?.cognitoIdentity as unknown as
      | {
          amr: string[];
        }
      | undefined;

    const sub = (cognitoIdentity?.amr ?? [])
      .flatMap((s) => (s.includes(':CognitoSignIn:') ? [s] : []))
      .map((s) => {
        const parts = s.split(':');
        return parts[parts.length - 1];
      })?.[0];

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `无法确定调用用户`,
      });
    }

    const { Users } = await cognito.listUsers({
      // 假设用户池 ID 在 Lambda 环境中配置
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `找不到主题 ID 为 ${sub} 的用户`,
      });
    }

    // 向其他过程提供身份信息
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
</Tabs>

## 部署 tRPC API

tRPC API 生成器根据您选择的 `iacProvider` 创建 CDK 或 Terraform 基础设施即代码。您可以使用此代码部署 tRPC API。

<Infrastructure>
<Fragment slot="cdk">
`common/constructs` 文件夹中包含用于部署 API 的 CDK 构造。您可以在 CDK 应用程序中使用此构造,例如:

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs`;

export class ExampleStack extends Stack {
   constructor(scope: Construct, id: string) {
      // 将 API 添加到堆栈
      const api = new MyApi(this, 'MyApi', {
        integrations: MyApi.defaultIntegrations(this).build(),
      });
   }
}
```

这将设置您的 API 基础设施,包括 AWS API Gateway REST 或 HTTP API、用于业务逻辑的 AWS Lambda 函数,以及根据您选择的 `auth` 方法配置的身份验证。

<Snippet name="api/cors-configuration-cdk-note" />

:::note
如果选择使用 `Cognito` 身份验证,您需要向 API 构造提供 `identity` 属性:

```ts {9}
import { MyApi, UserIdentity } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const identity = new UserIdentity(this, 'Identity');

    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
      identity,
    });
  }
}
```

可以使用 <Link path="/guides/react-website-auth">`ts#react-website-auth` 生成器</Link> 生成 `UserIdentity` 构造
:::
</Fragment>
<Fragment slot="terraform">
`common/terraform` 文件夹中包含用于部署 API 的 Terraform 模块。您可以在 Terraform 配置中使用此模块:

```hcl {6-8}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Lambda 函数的环境变量
  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  # 如果需要额外的 IAM 策略
  additional_iam_policy_statements = [
    # 添加 API 需要的额外权限
  ]

  tags = local.common_tags
}
```

这将设置:

1. 服务所有 tRPC 过程的 AWS Lambda 函数
2. 作为函数触发器的 API Gateway HTTP/REST API
3. IAM 角色和权限
4. CloudWatch 日志组
5. X-Ray 追踪配置
6. CORS 配置

<Snippet name="api/cors-configuration-terraform-note" />

:::note
如果选择使用 `Cognito` 身份验证,您需要提供 Cognito 配置:

```hcl {4-5}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  user_pool_id         = local.user_pool_id
  user_pool_client_ids = [local.client_id]

  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  tags = local.common_tags
}
```

您可以使用适当的 Terraform 资源或模块设置 Cognito 用户池和客户端。
:::

Terraform 模块提供多个输出供您使用:

```hcl
# 访问 API 端点
output "api_url" {
  value = module.my_api.stage_invoke_url
}

# 访问 Lambda 函数详情
output "lambda_function_name" {
  value = module.my_api.lambda_function_name
}

# 访问用于授予额外权限的 IAM 角色
output "lambda_execution_role_arn" {
  value = module.my_api.lambda_execution_role_arn
}
```

您可以通过传递变量自定义 CORS 设置:

```hcl
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # 自定义 CORS 配置
  cors_allow_origins = ["https://myapp.com", "https://staging.myapp.com"]
  cors_allow_methods = ["GET", "POST", "PUT", "DELETE"]
  cors_allow_headers = [
    "authorization",
    "content-type",
    "x-custom-header"
  ]

  tags = local.common_tags
}
```

:::caution
如果在运行生成器时为 `auth` 选择 `None`,可能会看到 Checkov 检查失败,例如:

<Tabs syncKey="http-rest">
<TabItem label="HTTP API">
```
Check: CKV_AWS_309: "Ensure API GatewayV2 routes specify an authorization type"
 FAILED for resource: aws_apigatewayv2_route.proxy_routes["PUT"]
```
</TabItem>
<TabItem label="REST API">
```
Check: CKV_AWS_59: "Ensure there is no open access to back-end resources through API"
 FAILED for resource: aws_api_gateway_method.proxy_method
```
</TabItem>
</Tabs>

如果确定需要 API 公开访问,可以[添加抑制注释](https://www.checkov.io/2.Basics/Suppressing%20and%20Skipping%20Policies.html)。
:::
</Fragment>
</Infrastructure>

### 集成

<Snippet name="api/type-safe-api-integrations" parentHeading="集成" />

:::tip
如果为 `iacProvider` 选择 CDK,当在 tRPC API 中添加或删除过程时,这些更改将立即反映在 CDK 构造中,无需重新构建。
:::

### 授予访问权限(仅限 IAM)

如果选择使用 `IAM` 身份验证,可以授予 API 访问权限:

<Infrastructure>
<Fragment slot="cdk">
```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```
</Fragment>
<Fragment slot="terraform">
```hcl
# 创建允许调用 API 的 IAM 策略
resource "aws_iam_policy" "api_invoke_policy" {
  name        = "MyApiInvokePolicy"
  description = "允许调用 tRPC API 的策略"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = "execute-api:Invoke"
        Resource = "${module.my_api.api_execution_arn}/*/*"
      }
    ]
  })
}

# 将策略附加到 IAM 角色(例如已验证用户角色)
resource "aws_iam_role_policy_attachment" "api_invoke_access" {
  role       = aws_iam_role.authenticated_user_role.name
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}

# 或按名称附加到现有角色
resource "aws_iam_role_policy_attachment" "api_invoke_access_existing" {
  role       = "MyExistingRole"
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}
```

API 模块的关键输出可用于 IAM 策略:

- `module.my_api.api_execution_arn` - 用于授予 execute-api:Invoke 权限
- `module.my_api.api_arn` - API Gateway ARN
- `module.my_api.lambda_function_arn` - Lambda 函数 ARN
</Fragment>
</Infrastructure>

### 打包目标

<Snippet name="ts-bundle" />

## 本地 tRPC 服务器

您可以使用 `serve` 目标运行 API 的本地服务器,例如:

<NxCommands commands={['run @my-scope/my-api:serve']} />

本地服务器的入口点是 `src/local-server.ts`。

当对 API 进行更改时,此服务器会自动重新加载。

## 调用 tRPC API

您可以创建 tRPC 客户端以类型安全的方式调用 API。如果从其他后端调用 tRPC API,可以使用 `src/client/index.ts` 中的客户端,例如:

```ts
import { createMyApiClient } from ':my-scope/my-api';

const client = createMyApiClient({ url: 'https://my-api-url.example.com/' });

await client.echo.query({ message: 'Hello world!' });
```

如果从 React 网站调用 API,请考虑使用 <Link path="guides/connection/react-trpc">连接</Link> 生成器来配置客户端。

## 更多信息

有关 tRPC 的更多信息,请参阅 [tRPC 文档](https://trpc.io/docs)。