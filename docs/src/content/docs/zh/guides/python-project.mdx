---
title: "Python 项目"
description: "Python 项目的参考文档"
---



import { FileTree } from '@astrojs/starlight/components';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import schema from '../../../../../../packages/nx-plugin/src/py/project/schema.json';

Python 项目生成器可用于创建配置了最佳实践的现代 [Python](https://www.python.org/) 库或应用程序，使用 [UV](https://docs.astral.sh/uv/) 进行管理，采用单一锁文件和 [UV 工作区](https://docs.astral.sh/uv/concepts/projects/workspaces/) 中的虚拟环境，使用 [pytest](https://docs.pytest.org/en/stable/) 运行测试，以及 [Ruff](https://docs.astral.sh/ruff/) 进行静态分析。

## 使用方式

### 生成 Python 项目

你可以通过两种方式生成新的 Python 项目：

<RunGenerator generator="py#project" />

### 选项参数

<GeneratorParameters schema={schema} />

## 生成器输出

生成器将在 `<directory>/<name>` 目录下创建以下项目结构：

<FileTree>

  - \<模块名称>
    - \_\_init\_\_.py 模块初始化文件
    - hello.py Python 源文件示例
  - tests
    - \_\_init\_\_.py 模块初始化文件
    - conftest.py 测试配置
    - test_hello.py 测试示例
  - project.json 项目配置和构建目标
  - pyproject.toml UV 使用的打包配置文件
  - .python-version 包含项目的 Python 版本

</FileTree>

你可能还会注意到工作区根目录下创建/更新了以下文件：

<FileTree>

  - pyproject.toml UV 的工作区级打包配置
  - .python-version 包含工作区 Python 版本
  - uv.lock Python 依赖锁文件

</FileTree>

## 编写 Python 源代码

在 `<模块名称>` 目录下添加你的 Python 源代码。

### 在其他项目中导入你的库代码

由于已经配置了 [UV 工作区](https://docs.astral.sh/uv/concepts/projects/workspaces/)，你可以从工作区中的任何其他 Python 项目引用你的 Python 项目：

```python title="packages/my_other_project/my_other_project/main.py"
from "my_library.hello" import say_hello
```

上述代码中，`my_library` 是模块名称，`hello` 对应 Python 源文件 `hello.py`，`say_hello` 是在 `hello.py` 中定义的方法。

### 依赖管理

要为项目添加依赖，可以运行 Python 项目中的 `add` 目标，例如：

<NxCommands commands={['run my_scope.my_library:add some-pip-package']} />

这会将依赖添加到项目的 `pyproject.toml` 文件，并更新根目录的 `uv.lock`。

#### 运行时代码

当将 Python 项目用作运行时代码（例如作为 AWS lambda 函数的处理程序）时，需要创建源代码及其所有依赖的打包文件。可以通过在 `project.json` 文件中添加如下目标实现：

```json title="project.json"
{
  ...
  "targets": {
    ...
    "bundle": {
      "cache": true,
      "executor": "nx:run-commands",
      "outputs": ["{workspaceRoot}/dist/packages/my_library/bundle"],
      "options": {
        "commands": [
          "uv export --frozen --no-dev --no-editable --project my_library -o dist/packages/my_library/bundle/requirements.txt",
          "uv pip install -n --no-installer-metadata --no-compile-bytecode --python-platform x86_64-manylinux2014 --python `uv python pin` --target dist/packages/my_library/bundle -r dist/packages/my_library/bundle/requirements.txt"
        ],
        "parallel": false
      },
      "dependsOn": ["compile"]
    },
  },
}
```

### 构建

你的 Python 项目配置了 `build` 目标（定义在 `project.json` 中），可通过以下命令运行：

<NxCommands commands={['run <project-name>:build']} />

其中 `<project-name>` 是你的项目的完全限定名称。

`build` 目标将执行编译、代码检查和测试。

构建输出可在工作区根目录的 `dist` 文件夹中找到，位于对应包的目录下，例如 `dist/packages/<my-library>/build`。

## 测试

[pytest](https://docs.pytest.org/en/stable/) 已配置用于项目测试。

### 编写测试

测试应位于项目内的 `test` 目录中，文件名以 `test_` 开头，例如：

<FileTree>
  - my_library
    - hello.py
  - test
    - test_hello.py hello.py 的测试
</FileTree>

测试方法应以 `test_` 开头并通过断言验证预期结果，例如：

```python title="test/test_hello.py"
from my_library.hello import say_hello

def test_say_hello():
  assert say_hello("Darth Vader") == "Hello, Darth Vader!"
```

有关编写测试的更多细节，请参考 [pytest 文档](https://docs.pytest.org/en/stable/how-to/assert.html#)。

### 运行测试

测试将作为项目 `build` 目标的一部分运行，但也可以单独运行 `test` 目标：

<NxCommands commands={['run <project-name>:test']} />

可以使用 `-k` 标志运行单个测试或测试套件，指定测试文件或方法名称：

<NxCommands commands={["run <project-name>:test -k 'test_say_hello'"]} />

## 代码检查

Python 项目使用 [Ruff](https://docs.astral.sh/ruff/) 进行代码检查。

### 运行检查器

要检查项目代码质量，可运行 `lint` 目标：

<NxCommands commands={["run <project-name>:lint"]} />

### 修复检查问题

大多数代码检查或格式问题可以自动修复。通过添加 `--configuration=fix` 参数让 Ruff 自动修复问题：

<NxCommands commands={["run <project-name>:lint --configuration=fix"]} />

若要修复工作区中所有包的检查问题，可运行：

<NxCommands commands={["run-many --target lint --all --configuration=fix"]} />