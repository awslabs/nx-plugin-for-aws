---
title: "FastAPI"
description: "FastAPI 参考文档"
---



import { FileTree } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import schema from '../../../../../../packages/nx-plugin/src/py/fast-api/schema.json';

[FastAPI](https://fastapi.tiangolo.com/) 是一个用于构建 Python API 的框架。

FastAPI 生成器会创建一个配置了 AWS CDK 基础设施的新 FastAPI 项目。生成的后端使用 AWS Lambda 进行无服务器部署，通过 AWS API Gateway HTTP API 对外暴露。项目会自动配置 [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/python/latest/) 用于可观测性功能，包括日志记录、AWS X-Ray 追踪和 CloudWatch 指标。

## 使用方法

### 生成 FastAPI

您可以通过两种方式生成新的 FastAPI：

<RunGenerator generator="py#fast-api" />

### 选项配置

<GeneratorParameters schema={schema} />

## 生成器输出

生成器会在 `<directory>/<api-name>` 目录下创建以下项目结构：

<FileTree>

- project.json 项目配置和构建目标
- pyproject.toml Python 项目配置和依赖项
- \<模块名称>
  - \_\_init\_\_.py 模块初始化
  - init.py 设置 FastAPI 应用并配置 powertools 中间件
  - main.py API 实现

</FileTree>

生成器还会在 `packages/common/constructs` 目录下创建用于部署 API 的 CDK 构造体。

## 实现 FastAPI

主要的 API 实现位于 `main.py` 文件，这里可以定义 API 路由及其实现。示例如下：

```python
from .init import app, tracer
from pydantic import BaseModel

class Item(BaseModel):
  name: str

@app.get("/items/{item_id}")
def get_item(item_id: int) -> Item:
    return Item(name=...)

@app.post("/items")
def create_item(item: Item):
    return ...
```

生成器自动配置了以下功能：

1. 用于可观测性的 AWS Lambda Powertools 集成
2. 错误处理中间件
3. 请求/响应关联
4. 指标收集
5. 使用 Mangum 的 AWS Lambda 处理程序

### 使用 AWS Lambda Powertools 实现可观测性

#### 日志记录

生成器使用 AWS Lambda Powertools 配置结构化日志记录。可以在路由处理程序中访问日志记录器：

```python
from .init import app, logger

@app.get("/items/{item_id}")
def read_item(item_id: int):
    logger.info("Fetching item", extra={"item_id": item_id})
    return {"item_id": item_id}
```

日志记录器自动包含：

- 用于请求追踪的关联 ID
- 请求路径和方法
- Lambda 上下文信息
- 冷启动标识

#### 追踪

自动配置 AWS X-Ray 追踪。可以添加自定义子分段到追踪中：

```python
from .init import app, tracer

@app.get("/items/{item_id}")
@tracer.capture_method
def read_item(item_id: int):
    # 创建新的子分段
    with tracer.provider.in_subsegment("fetch-item-details"):
        # 业务逻辑
        return {"item_id": item_id}
```

#### 指标

自动收集每个请求的 CloudWatch 指标。可以添加自定义指标：

```python
from .init import app, metrics
from aws_lambda_powertools.metrics import MetricUnit

@app.get("/items/{item_id}")
def read_item(item_id: int):
    metrics.add_metric(name="ItemViewed", unit=MetricUnit.Count, value=1)
    return {"item_id": item_id}
```

默认指标包括：

- 请求计数
- 成功/失败计数
- 冷启动指标
- 按路由统计指标

### 错误处理

生成器包含全面的错误处理机制：

```python
from fastapi import HTTPException

@app.get("/items/{item_id}")
def read_item(item_id: int):
    if item_id < 0:
        raise HTTPException(status_code=400, detail="Item ID must be positive")
    return {"item_id": item_id}
```

未处理的异常会被中间件捕获并：

1. 记录完整异常堆栈
2. 记录失败指标
3. 返回安全的 500 响应
4. 保留关联 ID

:::tip
如果使用 `api-connection` 生成器，建议为 API 操作指定响应模型以获得更好的代码生成效果。<Link path="guides/api-connection/react-fastapi#errors">详见此处</Link>。
:::

### 流式传输

使用 FastAPI 可以通过 [`StreamingResponse`](https://fastapi.tiangolo.com/reference/responses/?h=streaming#fastapi.responses.StreamingResponse) 响应类型向调用方流式传输响应。

#### 基础设施变更

由于 AWS API Gateway 不支持流式响应，需要将 FastAPI 部署到支持此功能的平台。最简单的方法是使用 AWS Lambda 函数 URL。可以通过调整生成的 `HttpApi` 构造体来添加流式传输选项，并根据条件实例化相关构造体。

<details>
<summary>变更示例</summary>

```diff lang="ts"
 import { Construct } from 'constructs';
-import { CfnOutput, Duration } from 'aws-cdk-lib';
+import { CfnOutput, Duration, Stack } from 'aws-cdk-lib';
 import {
   CorsHttpMethod,
   HttpApi as _HttpApi,
@@ -7,7 +7,16 @@ import {
   IHttpRouteAuthorizer,
 } from 'aws-cdk-lib/aws-apigatewayv2';

       },
     });

-    this.api = new _HttpApi(this, id, {
-      corsPreflight: {
-        allowOrigins: props.allowedOrigins ?? ['*'],
-        allowMethods: [CorsHttpMethod.ANY],
-        allowHeaders: [
-          'authorization',
-          'content-type',
-          'x-amz-content-sha256',
-          'x-amz-date',
-          'x-amz-security-token',
-        ],
-      },
-      defaultAuthorizer: props.defaultAuthorizer,
-    });
+    let apiUrl;
+    if (props.apiType === 'api-gateway') {
+      this.api = new _HttpApi(this, id, {
+        corsPreflight: {
+          allowOrigins: props.allowedOrigins ?? ['*'],
+          allowMethods: [CorsHttpMethod.ANY],
+          allowHeaders: [
+            'authorization',
+            'content-type',
+            'x-amz-content-sha256',
+            'x-amz-date',
+            'x-amz-security-token',
+          ],
+        },
+        defaultAuthorizer: props.defaultAuthorizer,
+      });

-    this.api.addRoutes({
-      path: '/{proxy+}',
-      methods: [
-        HttpMethod.GET,
-        HttpMethod.DELETE,
-        HttpMethod.POST,
-        HttpMethod.PUT,
-        HttpMethod.PATCH,
-        HttpMethod.HEAD,
-      ],
-      integration: new HttpLambdaIntegration(
-        'RouterIntegration',
-        this.routerFunction,
-      ),
-    });
+      this.api.addRoutes({
+        path: '/{proxy+}',
+        methods: [
+          HttpMethod.GET,
+          HttpMethod.DELETE,
+          HttpMethod.POST,
+          HttpMethod.PUT,
+          HttpMethod.PATCH,
+          HttpMethod.HEAD,
+        ],
+        integration: new HttpLambdaIntegration(
+          'RouterIntegration',
+          this.routerFunction,
+        ),
+      });
+      apiUrl = this.api.url;
+    } else {
+      const stack = Stack.of(this);
+      this.routerFunction.addLayers(
+        LayerVersion.fromLayerVersionArn(
+          this,
+          'LWALayer',
+          `arn:aws:lambda:${stack.region}:753240598075:layer:LambdaAdapterLayerX86:24`,
+        ),
+      );
+      this.routerFunction.addEnvironment('PORT', '8000');
+      this.routerFunction.addEnvironment(
+        'AWS_LWA_INVOKE_MODE',
+        'response_stream',
+      );
+      this.routerFunction.addEnvironment(
+        'AWS_LAMBDA_EXEC_WRAPPER',
+        '/opt/bootstrap',
+      );
+      this.routerFunctionUrl = this.routerFunction.addFunctionUrl({
+        authType: FunctionUrlAuthType.AWS_IAM,
+        invokeMode: InvokeMode.RESPONSE_STREAM,
+        cors: {
+          allowedOrigins: props.allowedOrigins ?? ['*'],
+          allowedHeaders: [
+            'authorization',
+            'content-type',
+            'x-amz-content-sha256',
+            'x-amz-date',
+            'x-amz-security-token',
+          ],
+        },
+      });
+      apiUrl = this.routerFunctionUrl.url;
+    }

-    new CfnOutput(this, `${props.apiName}Url`, { value: this.api.url! });
+    new CfnOutput(this, `${props.apiName}Url`, { value: apiUrl! });

     RuntimeConfig.ensure(this).config.httpApis = {
       ...RuntimeConfig.ensure(this).config.httpApis!,
-      [props.apiName]: this.api.url!,
+      [props.apiName]: apiUrl,
     };
   }

   public grantInvokeAccess(role: IRole) {
-    role.addToPrincipalPolicy(
-      new PolicyStatement({
-        effect: Effect.ALLOW,
-        actions: ['execute-api:Invoke'],
-        resources: [this.api.arnForExecuteApi('*', '/*', '*')],
-      }),
-    );
+    if (this.api) {
+      role.addToPrincipalPolicy(
+        new PolicyStatement({
+          effect: Effect.ALLOW,
+          actions: ['execute-api:Invoke'],
+          resources: [this.api.arnForExecuteApi('*', '/*', '*')],
+        }),
+      );
+    } else if (this.routerFunction) {
+      role.addToPrincipalPolicy(
+        new PolicyStatement({
+          effect: Effect.ALLOW,
+          actions: ['lambda:InvokeFunctionUrl'],
+          resources: [this.routerFunction.functionArn],
+          conditions: {
+            StringEquals: {
+              'lambda:FunctionUrlAuthType': 'AWS_IAM',
+            },
+          },
+        }),
+      );
+    }
   }
 }
```

</details>

完成这些变更后，请确保更新 `packages/common/constructs/src/app/http-apis/<my-api>.ts` 来使用新的函数 URL 选项。

#### 实现

更新基础设施以支持流式传输后，可以在 FastAPI 中实现流式 API。API 应该：

- 返回 [`StreamingResponse`](https://fastapi.tiangolo.com/reference/responses/?h=streaming#fastapi.responses.StreamingResponse)
- 声明每个响应块的返回类型
- 如果计划使用 <Link path="guides/api-connection/react-fastapi">API 连接</Link>，需添加 OpenAPI 扩展 `x-streaming: true`

例如，如果需要从 API 流式传输一系列 JSON 对象，可以按如下方式实现：

```py /return (StreamingResponse)/ /openapi_extra[^)]*/ /-> (Chunk)/
from pydantic import BaseModel
from fastapi.responses import StreamingResponse

class Chunk(BaseModel):
  message: str
  timestamp: datetime

async def stream_chunks():
  for i in range(0, 100):
    yield Chunk(message=f"This is chunk {i}", timestamp=datetime.now())

@app.get("/stream", openapi_extra={'x-streaming': True})
def my_stream() -> Chunk:
    return StreamingResponse(stream_chunks(), media_type="application/json")
```

#### 消费

要消费流式响应，可以使用 <Link path="guides/api-connection/react-fastapi#consuming-a-stream">API 连接生成器</Link>，该生成器将提供类型安全的方法来迭代流式数据块。

## 部署 FastAPI

FastAPI 生成器在 `common/constructs` 文件夹中创建了用于部署 API 的 CDK 构造体。可以在 CDK 应用程序中使用：

```ts
import { MyApi } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    // 将 API 添加到堆栈
    const api = new MyApi(this, 'MyApi');
  }
}
```

这会配置：

1. 运行 FastAPI 应用的 AWS Lambda 函数
2. 作为函数触发器的 API Gateway HTTP API
3. IAM 角色和权限
4. CloudWatch 日志组
5. X-Ray 追踪配置
6. CloudWatch 指标命名空间

### 授予访问权限

可以使用 `grantInvokeAccess` 方法授予 API 访问权限：

```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```

## 本地开发

生成器配置了可通过以下命令运行的本地开发服务器：

<NxCommands commands={['run my-api:serve']} />

这会启动本地 FastAPI 开发服务器，具有以下功能：

- 代码变更自动重载
- 交互式 API 文档（位于 `/docs` 或 `/redoc`）
- OpenAPI 模式（位于 `/openapi.json`）

## 调用 FastAPI

要从 React 网站调用 API，可以使用 <Link path="guides/api-connection/react-fastapi">`api-connection`</Link> 生成器。