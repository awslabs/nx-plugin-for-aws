---
title: AI Dungeon Game
description: A walkthrough of how to build an AI powered dungeon adventure game using the @aws/nx-plugin.
---

import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Drawer from '../../../components/drawer.astro';
import RunGenerator from '../../../components/run-generator.astro';
import NxCommands from '../../../components/nx-commands.astro';
import InstallCommand from '../../../components/install-command.astro';
import dungeonAdventureArchitecturePng from '../assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '../assets/dungeon-adventure-er.png'
import nxGraphPng from '../assets/nx-graph.png'

You will build an AI powered dungeon adventure game during this tutorial. This tutorial does not assume any existing knowledge of the `@aws/nx-plugin` or related technologies. The techniques you'll learn in this tutorial are fundamental to building any `@aws/nx-plugin` based application, and fully understanding it will give you a deep understanding of the `@aws/nx-plugin` and a basic understanding of how to use [NX](https://nx.dev/).

<Aside>This tutorial is designed for people who prefer to learn by doing and want to quickly try making something tangible. If you prefer learning each concept step by step, refer to the individual component Guides</Aside>

Users who complete this tutorial can expect to walk away with the knowledge to:

- use the `@aws/nx-plugin` to create new applications
- use NX to manage/build their codebase
- build APIs using both tRPC and FastAPI
- use Tanstack router to create new pages
- use Tanstack query to call backend APIs
- make modifications to generated code to be fit for purpose
- create and deploy CDK infrastructure

## What are you building?

In this tutorial, you'll build an AI powered dungeon adventure game with `@aws/nx-plugin`.

You can see what it will look like when you're finished here:

<Aside type="caution">Add gif of completed tutorial here</Aside>

### Components of the application

The AI powered dungeon adventure game will be built using the following component architecture:

<Image src={dungeonAdventureArchitecturePng} alt="dungeon-game-architecture.png" width="800" height="600" />

- tRPC API which uses ElectroDB/DynamoDB from managing the game state
- Python/FastAPI Lambda function with streaming responses for story generation (powered by Bedrock)
- React/Vite frontend website utilising:
  - Amazon Cognito/Identity Pools for secure API calls
  - Tanstack router which supports type-safe file based routing
  - Generated SDKs for calling the Game and Story APIs (leveraging Tanstack query)
- CDK infrastructure to deploy the application

## Prerequisites

The following global dependencies are needed before proceeding:

- [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
- [Node >= 22](https://nodejs.org/en/download) (We recommend using something like [NVM](https://github.com/nvm-sh/nvm) to manage your node versions)
  - verify by running `node --version`
- [PNPM >= 10](https://pnpm.io/installation#using-npm) (you can also just use npm/yarn/bun if you prefer, however this tutorial will use `pnpm`)
  - verify by running `pnpm --version`
- [UV >= 0.5.29](https://docs.astral.sh/uv/getting-started/installation/)
  1. install Python 3.12 by running: `uv python install 3.12.0`
  2. verify with `uv python list --only-installed`
- [AWS SDK with credentials](https://docs.aws.amazon.com/sdkref/latest/guide/access.html) configured to your target AWS account (where your application will be deployed)
  - Ensure your AWS account has enabled access to the Anthropic Claude 2.5 v2 model within Bedrock for your target region
- If you are using VSCode, install the [Nx Console VSCode Plugin](https://marketplace.visualstudio.com/items?itemName=nrwl.angular-console) if you haven't already.

## Module 1: Monorepo setup

We are going to start by creating a new monorepo. From within your desired directory, run the following command:

```bash
npx create-nx-workspace@20.4.6 dungeon-adventure --preset=ts --ci=skip --pm=pnpm --formatter=prettier
```

This will set up a NX monorepo within the `dungeon-adventure` directory which you can then open in vscode. It should look like the following:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ this is where your sub-projects will reside
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configures the Nx CLI and monorepo defaults
- package.json all node dependencies are defined here
- pnpm-lock.yaml
- pnpm-workspace.yaml
- README.md
- tsconfig.base.json all node based sub-projects extend this
- tsconfig.json
</FileTree>

<Aside>
The `package.json` defines a `type` of `module` which means ESM is the default module type for all node based sub-projects vended by the `@aws/nx-plugin`.
</Aside>

In order to start adding components from the `@aws/nx-plugin` into the monorepo, we need to install it as a dev dependency by running the following command:

```bash
pnpm add -Dw @aws/nx-plugin
```

Now we are ready to start creating our different sub-projects using the `@aws/nx-plugin`.

<Aside type="tip">It is a best practice to ensure all your unstaged files are commited in Git before running any generators. This allows you to see what has changed after running your generator via `git diff`</Aside>

### Game API

First let's create our Game API. To do this, let's create a tRPC API called `GameApi` by following the below steps:

<RunGenerator generator="ts#trpc-api" requiredParameters={{apiName:"GameApi"}} noInteractive />

<br />

You should see some new files have appeared in your file tree.
<Drawer title="ts#trpc-api updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated by the `ts#trpc-api` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ app specific cdk constructs
          - http-apis/
            - **game-api.ts** cdk construct to create your tRPC API
            - index.ts
            - ...
          - index.ts
        - core/ generic cdk constructs
          - http-api.ts base cdk construct for a Http based API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ shared types
      - src/
        - index.ts
        - runtime-config.ts interface definition used by both CDK and website
      - project.json
      - ...
  - game-api/
    - backend/ tRPC implementation code
      - src/
        - client/ vanilla client typically used for ts machine to machine calls
          - index.ts
          - sigv4.ts
        - middleware/ powertools instrumentation
          - error.ts
          - index.ts
          - logger.ts
          - metrics.ts
          - tracer.ts
        - procedures/ specific implementations for your API procedures/routes
          - **echo.ts**
        - index.ts
        - init.ts sets up context and middleware
        - local-server.ts used when running the tRPC server locally
        - **router.ts** entrypoint for your lambda handler which defines all procedures
      - project.json
      - ...
    - schema/
      - src/
        - procedures/
          - **echo.ts**
        - index.ts
      - project.json
      - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Taking a look at a few of the key files:

###### packages/game-api/backend/src/router.ts
```ts {5,12}
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>,
  ) => ctx,
});

export type AppRouter = typeof appRouter;
```
The router defines the entrypoint for your tRPC API and is the place where you will declare all of your API methods. As you can see above, we have a method called `echo` with it's implementation living in the `./procedures/echo.ts` file.

###### packages/game-api/backend/src/procedures/echo.ts
```ts {2-5}
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from ':dungeon-adventure/game-api-schema';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

This file is the implementation of the `echo` method and as you can see is strongly typed by declaring its input and output data structures. It is importing these definitions from the `:dungeon-adventure/game-api-schema` project which is an [alias](https://www.typescriptlang.org/tsconfig/paths.html) for the schema project.

<Aside type="tip">If you are seeing an import error within your IDE, this is because our backend does not have a typescript reference set up yet in it's tsconfig.json. Nx has been [configured](https://nx.dev/nx-api/js/generators/typescript-sync) to create these references *dynamically* whenever a build/compile is run or if you run the `pnpm nx sync` command manually. For more information refer to the [Typescript guide](/guides/typescript-project#importing-your-library-code-in-other-projects).</Aside>

###### packages/game-api/schema/src/procedures/echo.ts
```ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

All tRPC schema definitions are defined using [Zod](https://zod.dev/) and are exported as typescript types via the `z.TypeOf` syntax.

###### packages/common/constructs/src/app/http-apis/game-api.ts
```ts
import { Construct } from 'constructs';
import * as url from 'url';
import { HttpApi } from '../../core/http-api.js';
import { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';
import { Runtime } from 'aws-cdk-lib/aws-lambda';

export class GameApi extends HttpApi {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      defaultAuthorizer: new HttpIamAuthorizer(),
      apiName: 'GameApi',
      runtime: Runtime.NODEJS_LATEST,
      handler: 'index.handler',
      handlerFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-api/backend/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

This is the CDK construct that defines our GameApi. As you can see, it has already configured the handler file path to the generated bundle for our tRPC backend implementation. This means that at `cdk synth` time, bundling does not occur as we have already bundled it as part of the backend project's build target.

</Drawer>

### Story API

Now let's create our Story API. To do this, let's create a Fast API called `StoryApi` by following the below steps:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi"}} noInteractive />

You should see some new files have appeared in your file tree.
<Drawer title="py#fast-api updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated by the `py#fast-api` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- .venv/ single virtual env for monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ app specific cdk constructs
          - http-apis/
            - **story-api.ts** cdk construct to create your Fast API
            - index.ts updated to export the new story-api
      - project.json updated to add a build dep on story_api
    - types/ shared types
      - src/
        - **runtime-config.ts** updated to add the StoryApi
  - story_api/
    - story_api/ python module
      - init.py sets up powertools, FastAPI and middleware
      - **main.py** entrypoint for the lambda containing all routes
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version pinned uv python version
- pyproject.toml
- uv.lock
</FileTree>

###### packages/common/constructs/src/app/http-apis/story-api.ts
```ts
import { Construct } from 'constructs';
import * as url from 'url';
import { HttpApi } from '../../core/http-api.js';
import { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';
import { Runtime } from 'aws-cdk-lib/aws-lambda';

export class StoryApi extends HttpApi {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      defaultAuthorizer: new HttpIamAuthorizer(),
      apiName: 'StoryApi',
      runtime: Runtime.PYTHON_3_12,
      handler: 'story_api.main.handler',
      handlerFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/story_api/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

This is the CDK construct that defines our StoryApi. As you can see, it has already configured the handler file path to the generated bundle for our Fast API backend implementation. This means that at `cdk synth` time, bundling does not occur as we have already bundled it as part of the backend project's build target.

###### packages/common/types/src/runtime-config.ts
```diff lang="ts"
export type ApiUrl = string;
// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-empty-interface
export interface IRuntimeConfig {
  httpApis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

Here is an example of the generator performing an AST transform which preserves all existing code and performs an update. Here you can see the `StoryApi` was added to the `IRuntimeConfig` definition which means when this is eventually consumed by our frontend which enables type safety!

###### packages/story_api/story_api/main.py
```py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

This is where all your API method will be defined. As you can see here, we have a `read_root` method mapped to the `GET /` route. You can use [Pydantic](https://docs.pydantic.dev/latest/) to declare your method inputs and outputs to ensure type safety.

</Drawer>

### Game UI: Website

Now let's create the UI which will enable you to interact with the game. To do this, let's create a website called `GameUI` by following the below steps:

<RunGenerator generator="ts#cloudscape-website" requiredParameters={{name:"GameUI"}} noInteractive />

You should see some new files have appeared in your file tree.

<Drawer title="ts#cloudscape-website updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated by the `ts#cloudscape-website` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ app specific cdk constructs
          - static-websites/
            - **game-ui.ts** cdk construct to create your Game UI
        - core/
          - static-website.ts generic static website construct
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts overall page layout: header, footer, sidebar, etc
          - navitems.ts sidebar nav items
      - hooks/
        - useAppLayout.tsx allows you to dynamically set things like notifications, page style, etc
      - routes/ @tanstack/react-router file based routes
        - index.tsx root '/' page redirects to '/welcome'
        - __root.tsx all pages use this component as a base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** React entrypoint
        - routeTree.gen.ts this is automatically updated by @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

###### packages/common/constructs/src/app/static-websites/game-ui.ts
```ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

This is the CDK construct that defines our GameUI. As you can see, it has already configured the file path to the generated bundle for our Vite based UI. This means that at `build` time, bundling occurs within the game-ui project's build target and it's output is used here.

###### packages/game-ui/src/main.tsx
```tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Register the router instance for type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

This is the entrypoint where React is mounted. As shown, it initially just configures a `@tanstack/react-router` in a [`file-based-routing`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing) configuration. This means, as long as your development server is running - you can simply create files within the `routes` folder and `@tanstack/react-router` will create the boilerplate file setup for you along with updating the `routeTree.gen.ts` file. This file maintains all routes in a type-safe manner, which means when you use `<Link>`- the `to` option will only show valid routes. For more information, refer to the [`@tanstack/react-router` docs](https://tanstack.com/router/v1/docs/framework/react/quick-start).

###### packages/game-ui/src/routes/welcome/index.tsx
```tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

A component which will be rendered when navigating to the `/welcome` route. `@tanstack/react-router` will manage the `Route` for you whenever you create/move this file (as long as the dev server is running). This will be shown in a later section of this tutorial.

</Drawer>

### Game UI: Auth

Now let's configure our Game UI to require authenticated access via Amazon Cognito by following the below steps:

<RunGenerator generator="ts#cloudscape-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

You should see some new files have appeared/changed in your file tree.

<Drawer title="ts#cloudscape-website#auth updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated/updated by the `ts#cloudscape-website#auth` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts cdk construct for creating user/identity pools
    - types/
      - src/
        - runtime-config.ts updated to add the cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx adds the logged in user/logout to the header
        - CognitoAuth/
          - index.ts manages logging into Cognito
        - RuntimeConfig/
          - index.tsx fetches the `runtime-config.json` and provides it to children via context
      - hooks/
        - useRuntimeConfig.tsx 
      - **main.tsx** Updated to add Cognito
</FileTree>

###### packages/game-ui/src/main.tsx
```diff lang="tsx"
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Register the router instance for type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

The `RuntimeConfigProvider` and `CognitoAuth` components have been added to the `main.tsx` file via an AST transform. This allows the `CognitoAuth` component to authenticate with Amazon Cognito by fetching the `runtime-config.json` which contains the required cognito connection configuration in order to make the backend calls to the correct destination.

</Drawer>

### Game UI: Connect to Story API

Now let's configure our Game UI to connect to our previously created Story API:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

You should see some new files have appeared/changed in your file tree.

<Drawer title="UI -> FastAPI api-connection updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated/updated by the `api-connection` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx used by StoryApi to sign requests
        - useStoryApi.tsx hooks to call the StoryApi
    - .gitignore ignore generated client files
    - project.json updated to add targets for generating openapi client
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json updated to emit an openapi.json file

</FileTree>

###### packages/game-ui/src/hooks/useStoryApi.tsx
```tsx {1,12-15}
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.httpApis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

This hook is what will be used to make authenticated API requests to the `StoryApi`. As you can see in the implemenetation, it uses the `StoryApi` which is generated at build time and as such you will see an error in your IDE until we build our code. For more details on how the client is generated or how to consume the API, refer to the [React to FastAPI guide](/guides/api-connection/react-fastapi).

<Aside type="caution">
The `client.gen.ts` file that is generated should never be modified manually as this will be re-generated any time a change to the backend API is detected.
</Aside>

</Drawer>

### Game UI: Connect to Game API

Now let's configure our Game UI to connect to our previously created Game API:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api-backend"}} noInteractive />

You should see some new files have appeared/changed in your file tree.

<Drawer title="UI -> tRPC api-connection updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated/updated by the `api-connection` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - TrpcClients/
          - index.tsx
          - TrpcApis.tsx all configured tRPC APIs
          - TrpcClientProviders.tsx creates a client provider per tRPC API
          - TrpcProvider.tsx 
        - QueryClientProvider.tsx sets up the query client
      - hooks/
        - **useGameApi.tsx** hooks to call the GameApi
      - **main.tsx** injects the trpc client providers
- package.json

</FileTree>

###### packages/game-ui/src/hooks/useGameApi.tsx
```tsx
import { TrpcApis } from '../components/TrpcClients';

export const useGameApi = () => TrpcApis.GameApi.useTRPC();
```

This hooks uses tRPC's latest [React Query integration](https://trpc.io/blog/introducing-tanstack-react-query-client) allowing user's to interact with `@tanstack/react-query` directly without any additional layers of abstraction. For examples on how to call tRPC APIs, refer to the [using the tRPC hook guide](/guides/api-connection/react-trpc#using-the-generated-code).

<Aside>
The `useGameApi` hook is different to the `useStoryApi` hook as it does not require a build in order for changes to be reflected courtesy of tRPC's usage of [Typescript inference](https://trpc.io/docs/concepts). This allows developers to make changes to their backend which instantly are reflected in their frontend!
</Aside>

###### packages/game-ui/src/main.tsx
```diff lang="tsx"
+import TrpcClientProviders from './components/TrpcClients';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Register the router instance for type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <TrpcClientProviders>
                <RouterProvider router={router} />
+              </TrpcClientProviders>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

The `main.tsx` file has been updated via an AST transform to inject the tRPC providers.

</Drawer>

### Game UI: Infrastructure

Now the final sub-project we need to create is for the CDK infrastructure. To create this, follow the below steps:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

You should see some new files have appeared/changed in your file tree.

<Drawer title="ts#infra updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated/updated by the `ts#infra` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts**
      - index.ts
      - **main.ts** entrypoint which defines all stacks
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json add references
  - tsconfig.base.json add alias

</FileTree>

###### packages/infra/src/main.ts
```ts
import { App } from 'aws-cdk-lib';
import { ApplicationStack } from './stacks/application-stack.js';
import {
  CfnGuardValidator,
  RuleSet,
} from ':dungeon-adventure/common-constructs';

const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

// Use this to deploy your own sandbox environment (assumes your CLI credentials)
new ApplicationStack(app, 'infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

This is the entrypoint for your CDK application. 

It is configured to use [`cfn-guard`](https://github.com/cdklabs/cdk-validator-cfnguard) to run infrastructure validation based on the configured ruleset. This is instrumented post synthesis.

<Aside type="tip">
There may be instances where you want to suppress certain rules on resources. You can do this in two ways:

###### Supress a rule on a given construct

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// suppresses the RULE_NAME for the given construct.
suppressRule(construct, 'RULE_NAME');
```

###### Supress a rule on a descendant construct

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// Supresses the RULE_NAME for the construct or any of its descendants if it is an instance of Bucket
suppressRule(construct, 'RULE_NAME', (construct) => construct instanceof Bucket);
```
</Aside>

###### packages/infra/src/stacks/application-stack.ts
```ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // The code that defines your stack goes here
  }
}
```

This is where we will instantiate our CDK constructs to build our dungeon adventure game.

</Drawer>

#### Update our infrastructure

Let's make an update to our `packages/infra/src/stacks/application-stack.ts` to instantiate some of our already generated constructs:

```diff lang="ts"
+import {
+  GameApi,
+  GameUI,
+  StoryApi,
+  UserIdentity,
+} from ':dungeon-adventure/common-constructs';
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

-    // The code that defines your stack goes here
+    const userIdentity = new UserIdentity(this, 'UserIdentity');
+
+    const gameApi = new GameApi(this, 'GameApi');
+    const storyApi = new StoryApi(this, 'StoryApi');
+
+    // grant our authenticated role access to invoke our APIs
+    [storyApi, gameApi].forEach((api) =>
+      api.grantInvokeAccess(userIdentity.identityPool.authenticatedRole),
+    );
+
+    // Ensure this is instantiated last so our runtime-config.json can be automatically configured
+    new GameUI(this, 'GameUI');
  }
}

```

### Building our code

<Drawer title="Nx commands" trigger="Now it's time for us to build our code for the first time">
###### Single vs Multiple targets

The `run-many` command will run a target on multiple listed subprojects (`--all` will target them all). It will ensure dependencies are executed in the correct order. 

You can also trigger a build (or any other task) for a single project target by running the target on the project directly. For example, if we want to build the `@dungeon-adventure/infra` project, you can run the following command:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualizing your dependencies

You can also visualize your dependencies via:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Caching

Nx relies on [caching](https://nx.dev/concepts/how-caching-works) so that you can re-use artifacts from previous builds in order to speed up development. There is a little bit on configuration required to get this to work correctly and there may be cases where you want to perform a build **without using the cache**. To do that, simply append the `--skip-nx-cache` argument to your command. For example:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
If for whatever reason you ever wanted to clear your cache (stored in the `.nx` folder), you can run the following command:

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

You should be prompted with the following:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? … 
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

This message indicates that NX has detected some files which can be updated automatically for you. In this case, it is referring to the `tsconfig.json` files which do not have Typescript references set up on references projects. Select the **Yes, sync the changes and run the tasks** option to proceed. You should notice all of you IDE related import errors get automatically resolved as the sync generator will add the missing typescript references automatically!

<Aside type="tip">
If you encounter any lint errors, you can run the following command to automatically fix them.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

All built artifacts are now available within the `dist/` folder located at the root of the monorepo. This is a standard practice when using projects generated by the `@aws/nx-plugin` as it does not pollute your file-tree with generated files. In the event you want to clean yor files, you can simply delete the `dist/` folder without having to worry about generated files being littered throughout the file tree.

Congratulations! You’ve created all of the required sub-projects needed to start implementing the core of our Dunegeon Adventure game.  🎉🎉🎉

## Module 2: Game API implementation

We are going to start by implementing our Game API. To do this, we need to create 4 API's in total:

1. `createGame` - this will create a new game instance.
2. `queryGames` - this will return a paginated list of previously saved games.
3. `saveAction` - this will save an action for a given game.
4. `queryActions` - this will return a paginated list of all actions related to a game.

### Entity modelling

The ER diagram for our application is as follows:

<Image className="centered-image" src={dungeonAdventureErPng} alt="dungeon-adventure-er.png" width="400" height="300" />

We are going to implement our Database in DynamoDB and will be using the [ElectroDB](https://electrodb.dev/en/core-concepts/introduction/) DynamoDB client library to simplify things. To get started we need to first install `electrodb` by running the following command:

<InstallCommand pkg="electrodb @aws-sdk/client-dynamodb" />

Now let's create the following files within our `packages/game-api/backend/src/entities` folder to define our ElectroDB entities as per the above ER Diagram:

<Tabs>
  <TabItem label="action.ts">
```typescript
import { Entity } from 'electrodb';
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';

export const createActionEntity = (client?: DynamoDBClient) =>
  new Entity(
    {
      model: {
        entity: 'Action',
        version: '1',
        service: 'game',
      },
      attributes: {
        playerName: { type: 'string', required: true, readOnly: true },
        timestamp: {
          type: 'string',
          required: true,
          readOnly: true,
          default: () => new Date().toISOString(),
        },
        role: { type: 'string', required: true, readOnly: true },
        content: { type: 'string', required: true, readOnly: true },
      },
      indexes: {
        primary: {
          pk: { field: 'pk', composite: ['playerName'] },
          sk: { field: 'sk', composite: ['timestamp'] },
        },
      },
    },
    { client, table: process.env.TABLE_NAME },
  );
```
  </TabItem>
  <TabItem label="game.ts">
```typescript
import { Entity } from 'electrodb';
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';

export const createGameEntity = (client?: DynamoDBClient) =>
  new Entity(
    {
      model: {
        entity: 'Game',
        version: '1',
        service: 'game',
      },
      attributes: {
        playerName: { type: 'string', required: true, readOnly: true },
        genre: { type: 'string', required: true, readOnly: true },
        lastUpdated: {
          type: 'string',
          required: true,
          default: () => new Date().toISOString(),
        },
      },
      indexes: {
        primary: {
          pk: { field: 'pk', composite: ['playerName'] },
          sk: {
            field: 'sk',
            composite: [],
          },
        },
      },
    },
    { client, table: process.env.TABLE_NAME },
  );
```
  </TabItem>
</Tabs>

ElectroDB is very powerful and allows us to not only define our types, but can also provide defaults for certain values like the timestamps above. In addition, ElectroDB follows [single-table design](https://electrodb.dev/en/core-concepts/single-table-relationships/) which is the best practive when using DynamoDB.

<Aside>
Whilst ElectroDB does support [collections](https://electrodb.dev/en/modeling/collections/), we have chosen not to use them in this tutorial for simplicity.
</Aside>

### API Schema

To define our API inputs and outputs, let's create our schema using [Zod](https://zod.dev/) within the `packages/game-api/schema/schema/src` project as follows:

<Tabs>
  <TabItem label="types/action.ts">
```typescript
import { z } from 'zod';

export const ActionSchema = z.object({
  playerName: z.string(),
  timestamp: z.string().datetime(),
  role: z.enum(['assistant', 'user']),
  content: z.string(),
});

export type IAction = z.TypeOf<typeof ActionSchema>;
```
  </TabItem>
  <TabItem label="types/common.ts">
```typescript
import { z } from 'zod';

export const QueryInputSchema = z.object({
  cursor: z.string().optional(),
  limit: z.number().optional().default(100),
});

export const createPaginatedQueryOutput = <ItemType extends z.ZodTypeAny>(
  itemSchema: ItemType,
) => {
  return z.object({
    items: z.array(itemSchema),
    cursor: z.string().nullable(),
  });
};

export type IQueryInput = z.TypeOf<typeof QueryInputSchema>;
```
  </TabItem>
  <TabItem label="types/game.ts">
```typescript
import { z } from 'zod';

export const GameSchema = z.object({
  playerName: z.string(),
  genre: z.enum(['zombie', 'superhero', 'medieval']),
  lastUpdated: z.string().datetime(),
});

export type IGame = z.TypeOf<typeof GameSchema>;
```
  </TabItem>
  <TabItem label="index.ts">
```diff lang="typescript"
-export * from './procedures/echo.js';
+export * from './types/action.js';
+export * from './types/common.js';
+export * from './types/game.js';
```
You can also delete the `./procedures/echo.ts` file given we will not be using it in this project.
  </TabItem>
</Tabs>

<Aside type="tip">
As you can see above, for each of the schemas we define in Zod, we also export an interface using the `z.TypeOf` syntax. This converts our zod definition into a Typescript interface without having to duplicate effort!
</Aside>

### Adding the dynamoDB client to our tRPC context

Given we need access to the DynamoDB client in each of our procedures, we want to be able to create a single instance of the client which we can pass through via context. To do this, make the following changes within `packages/game-api/backend/src`:

<Tabs>
  <TabItem label="middleware/dynamodb.ts">
```typescript
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { initTRPC } from '@trpc/server';

export interface IDynamoDBContext {
  dynamoDb?: DynamoDBClient;
}

export const createDynamoDBPlugin = () => {
  const t = initTRPC.context<IDynamoDBContext>().create();
  return t.procedure.use(async (opts) => {
    const dynamoDb = new DynamoDBClient();

    const response = await opts.next({
      ctx: {
        ...opts.ctx,
        dynamoDb,
      },
    });

    return response;
  });
};
```

This is a plugin that we instrument to create the `DynamoDBClient` and inject it into the context.
  </TabItem>
  <TabItem label="middleware/index.ts">
```diff lang="ts"
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import type { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';
import { ILoggerContext } from './logger.js';
import { IMetricsContext } from './metrics.js';
import { ITracerContext } from './tracer.js';
+import { IDynamoDBContext } from './dynamodb.js';

+export * from './dynamodb.js';
export * from './logger.js';
export * from './metrics.js';
export * from './tracer.js';
export * from './error.js';

export type IMiddlewareContext =
  CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer> &
+    IDynamoDBContext &
    ILoggerContext &
    IMetricsContext &
    ITracerContext;
```

Augment our `IMiddlewareContext` to add the `IDynamoDBContext`.
  </TabItem>
  <TabItem label="init.ts">
```diff lang="ts"
import { initTRPC } from '@trpc/server';
import {
+  createDynamoDBPlugin,
  createErrorPlugin,
  createLoggerPlugin,
  createMetricsPlugin,
  createTracerPlugin,
  IMiddlewareContext,
} from './middleware/index.js';

process.env.POWERTOOLS_SERVICE_NAME = 'GameApi';
process.env.POWERTOOLS_METRICS_NAMESPACE = 'GameApi';

export type Context = IMiddlewareContext;

export const t = initTRPC.context<Context>().create();

export const publicProcedure = t.procedure
+  .unstable_concat(createDynamoDBPlugin())
  .unstable_concat(createLoggerPlugin())
  .unstable_concat(createTracerPlugin())
  .unstable_concat(createMetricsPlugin())
  .unstable_concat(createErrorPlugin());
```

The DynamoDB plugin is instrumented.

<Aside>
We are using the `unstable_concat` api here which is safe to use. The only reason it has the `unstable_` prefixed is because it is a new API. For more information refer to the [concat guide](https://trpc.io/docs/server/middlewares#concat).
</Aside>
  </TabItem>
</Tabs>

### Defining our procedures

Now it's time to implement the API methods. To do this, make the following changes within `packages/game-api/backend/src`:

<Tabs>
  <TabItem label="procedures/query-actions.ts">
```typescript
import { createActionEntity } from '../entities/action.js';
import {
  ActionSchema,
  IAction,
  QueryInputSchema,
  createPaginatedQueryOutput,
} from ':dungeon-adventure/game-api-schema';
import { publicProcedure } from '../init.js';
import { z } from 'zod';

export const queryActions = publicProcedure
  .input(QueryInputSchema.extend({ playerName: z.string() }))
  .output(createPaginatedQueryOutput(ActionSchema))
  .query(async ({ input, ctx }) => {
    const actionEntity = createActionEntity(ctx.dynamoDb);
    const result = await actionEntity.query
      .primary({ playerName: input.playerName })
      .go({ cursor: input.cursor, count: input.limit });

    return {
      items: result.data as IAction[],
      cursor: result.cursor,
    };
  });
```
  </TabItem>
  <TabItem label="procedures/query-games.ts">
```typescript
import { createGameEntity } from '../entities/game.js';
import {
  GameSchema,
  IGame,
  QueryInputSchema,
  createPaginatedQueryOutput,
} from ':dungeon-adventure/game-api-schema';
import { publicProcedure } from '../init.js';

export const queryGames = publicProcedure
  .input(QueryInputSchema)
  .output(createPaginatedQueryOutput(GameSchema))
  .query(async ({ input, ctx }) => {
    const gameEntity = createGameEntity(ctx.dynamoDb);
    const result = await gameEntity.scan.go({
      cursor: input.cursor,
      count: input.limit,
    });

    return {
      items: result.data as IGame[],
      cursor: result.cursor,
    };
  });
```
  </TabItem>
  <TabItem label="procedures/save-action.ts">
```typescript
import { ActionSchema, IAction } from ':dungeon-adventure/game-api-schema';
import { publicProcedure } from '../init.js';
import { createActionEntity } from '../entities/action.js';
import { createGameEntity } from '../entities/game.js';

export const saveAction = publicProcedure
  .input(ActionSchema)
  .output(ActionSchema)
  .mutation(async ({ input, ctx }) => {
    const actionEntity = createActionEntity(ctx.dynamoDb);
    const gameEntity = createGameEntity(ctx.dynamoDb);

    const action = await actionEntity.put(input).go();
    await gameEntity
      .update({ playerName: input.playerName })
      .set({ lastUpdated: action.data.timestamp })
      .go();
    return action.data as IAction;
  });
```
  </TabItem>
  <TabItem label="procedures/save-game.ts">
```typescript
import { createGameEntity } from '../entities/game.js';
import { GameSchema, IGame } from ':dungeon-adventure/game-api-schema';
import { publicProcedure } from '../init.js';

export const saveGame = publicProcedure
  .input(GameSchema.omit({ lastUpdated: true }))
  .output(GameSchema)
  .mutation(async ({ input, ctx }) => {
    const gameEntity = createGameEntity(ctx.dynamoDb);

    const result = await gameEntity.put(input).go();
    return result.data as IGame;
  });
```
  </TabItem>
  <TabItem label="router.ts">
```diff lang="ts"
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { t } from './init.js';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';
-import { echo } from './procedures/echo.js';
+import { queryActions } from './procedures/query-actions.js';
+import { saveAction } from './procedures/save-action.js';
+import { queryGames } from './procedures/query-games.js';
+import { saveGame } from './procedures/save-game.js';

export const router = t.router;

export const appRouter = router({
-  echo,
+  actions: router({
+    query: queryActions,
+    save: saveAction,
+  }),
+  games: router({
+    query: queryGames,
+    save: saveGame,
+  }),
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>,
  ) => ctx,
});

export type AppRouter = typeof appRouter;
```
You can also delete the `./procedures/echo.ts` file given we will not be using it in this project.
  </TabItem>
</Tabs>

### Infrastructure

The final step is to update our infrastructure to create the DynamoDB table and grant permissions to perform operations from the Game API. To do so, update the `packages/infra/src` as follows:

<Tabs>
  <TabItem label="constructs/electrodb-table.ts">
```typescript
import { CfnOutput } from 'aws-cdk-lib';
import {
  AttributeType,
  BillingMode,
  ProjectionType,
  Table,
  TableProps,
} from 'aws-cdk-lib/aws-dynamodb';
import { Construct } from 'constructs';

export type ElectrodbDynamoTableProps = Omit<
  TableProps,
  'partitionKey' | 'sortKey' | 'billingMode'
>;

export class ElectrodbDynamoTable extends Table {
  constructor(scope: Construct, id: string, props?: ElectrodbDynamoTableProps) {
    super(scope, id, {
      partitionKey: {
        name: 'pk',
        type: AttributeType.STRING,
      },
      sortKey: {
        name: 'sk',
        type: AttributeType.STRING,
      },
      billingMode: BillingMode.PAY_PER_REQUEST,
      ...props,
    });

    this.addGlobalSecondaryIndex({
      indexName: 'gsi1pk-gsi1sk-index',
      partitionKey: {
        name: 'gsi1pk',
        type: AttributeType.STRING,
      },
      sortKey: {
        name: 'gsi1sk',
        type: AttributeType.STRING,
      },
      projectionType: ProjectionType.ALL,
    });

    new CfnOutput(this, 'TableName', { value: this.tableName });
  }
}
```
  </TabItem>
  <TabItem label="stacks/application-stack.ts">
```diff lang="ts"
import {
  GameApi,
  GameUI,
  StoryApi,
  UserIdentity,
} from ':dungeon-adventure/common-constructs';
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
+import { ElectrodbDynamoTable } from '../constructs/electrodb-table.js';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // The code that defines your stack goes here
    const userIdentity = new UserIdentity(this, 'UserIdentity');
+
+    const electroDbTable = new ElectrodbDynamoTable(this, 'ElectroDbTable');

    const gameApi = new GameApi(this, 'GameApi');
    const storyApi = new StoryApi(this, 'StoryApi');
+
+    gameApi.routerFunction.addEnvironment(
+      'TABLE_NAME',
+      electroDbTable.tableName,
+    );
+    // grant the gameAPI rw access to DynamoDB 
+    electroDbTable.grantReadWriteData(gameApi.routerFunction);

    // grant our authenticated role access to invoke our APIs
    [storyApi, gameApi].forEach((api) =>
      api.grantInvokeAccess(userIdentity.identityPool.authenticatedRole),
    );

    // Ensure this is instantiated last so our runtime-config.json can be automatically configured
    new GameUI(this, 'GameUI');
  }
}
```
  </TabItem>
</Tabs>

### Deployment and testing

First, lets build the codebase:

<NxCommands commands={['run-many --target build --all']} />

<Drawer title="Deployment command" trigger="Your application can now be deployed by running the following command:">

You can also deploy all stacks contained in the CDK application by running:

<NxCommands commands={['nx run @dungeon-adventure/infra:deploy --all']} />

This is **not recommended** given that you may choose to seperate out your deployment stages as seperate stacks `i.e. infra-prod`. In this case the `--all` flag will attempt to deploy all stacks which can result in unwanted deployments!

</Drawer>

<NxCommands commands={['nx run @dungeon-adventure/infra:deploy infra-sandbox']} />

Once the deployment completes, you should see some outputs similar to the following _(some values have been redacted)_:

```bash
infra-sandbox
infra-sandbox: deploying... [2/2]

 ✅  infra-sandbox (no changes)

✨  Deployment time: 354s

Outputs:
infra-sandbox.ElectroDbTableTableNameXXX = infra-sandbox-ElectroDbTableXXX-YYY
infra-sandbox.GameApiGameApiUrlXXX = https://xxx.region.amazonaws.com/
infra-sandbox.GameUIDistributionDomainNameXXX = xxx.cloudfront.net
infra-sandbox.StoryApiStoryApiUrlXXX = https://xxx.execute-api.region.amazonaws.com/
infra-sandbox.UserIdentityUserIdentityIdentityPoolIdXXX = region:xxx
infra-sandbox.UserIdentityUserIdentityUserPoolIdXXX = region_xxx
```

We can test our API by either: 
<ul>
<li>Starting a local instance of the tRPC backend and invoke the API's using `curl`.</li>
<li>
<Drawer title="Sigv4 enabled curl" trigger="Calling the deployed API using sigv4 enabled curl directly">
You can either add the following script to your `.bashrc` file (and `source` it) or simply paste the following into the same terminal you wish to run the command in.
```bash
// ~/.bashrc
acurl () {
    REGION=$1
    SERVICE=$2
    shift; shift;
    curl --aws-sigv4 "aws:amz:$REGION:$SERVICE" --user "$(aws configure get aws_access_key_id):$(aws configure get aws_secret_access_key)" -H "X-Amz-Security-Token: $(aws configure get aws_session_token)" "$@"
}
```

Then to make a sigv4 authenticated curl request, you can simply invoke `acurl` like the following examples:

###### API Gateway
```bash
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### Streaming Lambda function url
```bash
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
</Drawer>
</li>
</ul>


<Tabs>
  <TabItem label="Local">
    <NxCommands highlights={['infra-sandbox-ElectroDbTableXXX-YYY']} env={{TABLE_NAME:"infra-sandbox-ElectroDbTableXXX-YYY"}} commands={["run @dungeon-adventure/game-api-backend:serve"]} postCommands={['curl -X GET http://localhost:2022/games.query\?input="\\{\\}"']} />
    <Aside type="caution">
    Use the CDK deploy output value of `infra-sandbox.ElectroDbTableTableNameXXX` to replace the highlighted placeholder.
    </Aside>
  </TabItem>
  <TabItem label="Deployed">
```bash "https://xxx.region.amazonaws.com/" "ap-southeast-2"
acurl ap-southeast-2 execute-api -X GET \
  https://xxx.region.amazonaws.com/games.query\?input\={} 
```
    <Aside type="caution">
    Use the CDK deploy output value of `infra-sandbox.GameApiGameApiUrlXXX` to replace the highlighted placeholder and set the region accordingly..
    </Aside>
  </TabItem>
</Tabs>

If the command executes successfully, you should see a response as follows:

```json
{"result":{"data":{"items":[],"cursor":null}}}
```

Congratulations. You have built and deployed your first API using tRPC!  🎉🎉🎉

## Module 3: Story API implementation

<Aside type="caution">
Ensure you have granted access to the **Anthropic Claude 3.5 Sonnet v2** model via the steps outlined in [this guide](https://docs.aws.amazon.com/bedrock/latest/userguide/model-access-modify.html).
</Aside>

The StoryApi comprises of a single API `generate_story` which given `Game` and a list of `Action`'s for context, will progress a story. This API will be implemented as a streaming API in Python/FastAPI and will additionally demonstrate how changes can be made to the generated code to be fit for purpose.

### API implementation

To create our API, we first need to install a couple of additional dependencies.

- `boto3` will be used to call Amazon Bedrock;
- `uvicorn` will be used to start our API when used in conjunction with the [Lambda Web Adapter (LWA)](https://github.com/awslabs/aws-lambda-web-adapter).
- `copyfiles` is an npm dependency that we will need to support cross-platform copying of files when updating our `bundle` task.

To install these dependencies, run the following commands:

<NxCommands commands={["run dungeon_adventure.story_api:add --args boto3 uvicorn"]} />
<InstallCommand pkg="copyfiles" dev />

Now let's replace the contents of `packages/story_api/story_api/main.py` as follows:

```python
// packages/story_api/story_api/main.py
import json

from boto3 import client
from fastapi.responses import PlainTextResponse, StreamingResponse
from pydantic import BaseModel

from .init import app, lambda_handler

handler = lambda_handler

bedrock = client('bedrock-runtime')

class Action(BaseModel):
    role: str
    content: str

class StoryRequest(BaseModel):
    genre: str
    playerName: str
    actions: list[Action]

async def bedrock_stream(request: StoryRequest):
    messages = [
        {"role": "user", "content": "Continue or create a new story..."}
    ]

    for action in request.actions:
        messages.append({"role": action.role, "content": action.content})

    response = bedrock.invoke_model_with_response_stream(
        modelId='anthropic.claude-3-sonnet-20240229-v1:0',
        body=json.dumps({
            "system":f"""
            You are running an AI text adventure game in the {request.genre} genre.
            Player: {request.playerName}. Return less than 200 characters of text.
            """,
            "messages": messages,
            "max_tokens": 1000,
            "temperature": 0.7,
            "anthropic_version": "bedrock-2023-05-31"
        })
    )

    stream = response.get('body')
    if stream:
        for event in stream:
            chunk = event.get('chunk')
            if chunk:
                message = json.loads(chunk.get("bytes").decode())
                if message['type'] == "content_block_delta":
                    yield message['delta']['text'] or ""
                elif message['type'] == "message_stop":
                    yield "\n"

@app.post("/story/generate",
          openapi_extra={'x-Streaming': True},
          response_class=PlainTextResponse)
def generate_story(request: StoryRequest) -> str:
    return StreamingResponse(bedrock_stream(request), media_type="text/plain")
```

Analyzing the code above:

- We use the `x-Streaming` setting to indicate that this is a streaming API when we eventually generate our client SDK. This will allow us to consume this API in a streaming manner whilst maintaining type-safety!
- Our API simply returns a stream of text as defined by both the `media_type="text/plain"` and the `response_class=PlainTextResponse`

### Infrastructure

The [Infrastructure we set up previously](#game-ui-infrastructure) assumes that all API's have a API Gateway integrating with a Lambda. For our `story_api` we actually don't want to use API Gateway as this does not supporting streaming repsonses. Instead, we will use a [Lambda Function URL configured with response streaming](https://docs.aws.amazon.com/lambda/latest/dg/configuration-response-streaming.html).

To support this, we are going to make the following changes:

<Tabs>
<TabItem label="story-api.ts">
```diff lang="typescript"
// packages/common/constructs/src/app/http-apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import { HttpApi } from '../../core/http-api.js';
import { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';
import { Runtime } from 'aws-cdk-lib/aws-lambda';
+import { Effect, PolicyStatement } from 'aws-cdk-lib/aws-iam';

export class StoryApi extends HttpApi {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      defaultAuthorizer: new HttpIamAuthorizer(),
      apiName: 'StoryApi',
      runtime: Runtime.PYTHON_3_12,
+      apiType: 'function-url-streaming',
+      handler: 'run.sh',
      handlerFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/story_api/bundle',
          import.meta.url,
        ),
      ),
    });
+
+    this.routerFunction.addToRolePolicy(
+      new PolicyStatement({
+        effect: Effect.ALLOW,
+        actions: ['bedrock:InvokeModelWithResponseStream'],
+        resources: [
+          'arn:aws:bedrock:*::foundation-model/anthropic.claude-3-sonnet-20240229-v1:0',
+        ],
+      }),
+    );
  }
}
```
</TabItem>
<TabItem label="run.sh">
```bash
// packages/story_api/run.sh
#!/bin/bash

PATH=$PATH:$LAMBDA_TASK_ROOT/bin \
    PYTHONPATH=$PYTHONPATH:/opt/python:$LAMBDA_RUNTIME_DIR \
    exec python -m uvicorn --port=$PORT story_api.main:app
```
</TabItem>
<TabItem label="project.json">
```diff lang="json"
// packages/story_api/project.json
{
  "name": "dungeon_adventure.story_api",
  "$schema": "../../node_modules/nx/schemas/project-schema.json",
  "projectType": "application",
  "sourceRoot": "packages/story_api/story_api",
  "targets": {
    ...
    "bundle": {
      "cache": true,
      "executor": "nx:run-commands",
      "outputs": ["{workspaceRoot}/dist/packages/story_api/bundle"],
      "options": {
        "commands": [
          "uv export --frozen --no-dev --no-editable --project story_api -o dist/packages/story_api/bundle/requirements.txt",
          "uv pip install -n --no-installer-metadata --no-compile-bytecode --python-platform x86_64-manylinux2014 --python `uv python pin` --target dist/packages/story_api/bundle -r dist/packages/story_api/bundle/requirements.txt",
+          "copyfiles -f packages/story_api/run.sh dist/packages/story_api/bundle"
        ],
        "parallel": false
      },
      "dependsOn": ["compile"]
    },
    ...
  }
}
```
</TabItem>
<TabItem label="http-api.ts">
```typescript
// packages/common/constructs/src/core/http-api.ts
import { Construct } from 'constructs';
import { CfnOutput, Duration, Stack } from 'aws-cdk-lib';
import {
  CorsHttpMethod,
  HttpApi as _HttpApi,
  HttpMethod,
  IHttpRouteAuthorizer,
} from 'aws-cdk-lib/aws-apigatewayv2';
import { HttpLambdaIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';
import {
  Code,
  Function,
  FunctionUrl,
  FunctionUrlAuthType,
  InvokeMode,
  LayerVersion,
  Runtime,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import { Effect, IRole, PolicyStatement } from 'aws-cdk-lib/aws-iam';
import { RuntimeConfig } from './runtime-config.js';

export interface HttpApiProps {
  readonly apiName: string;
  readonly handler: string;
  readonly handlerFilePath: string;
  readonly runtime: Runtime;
  readonly defaultAuthorizer: IHttpRouteAuthorizer;
  readonly apiType?: 'api-gateway' | 'function-url-streaming';
  readonly allowedOrigins?: string[];
}

export class HttpApi extends Construct {
  public readonly api?: _HttpApi;
  public readonly routerFunctionUrl?: FunctionUrl;
  public readonly routerFunction: Function;

  constructor(scope: Construct, id: string, props: HttpApiProps) {
    super(scope, id);

    this.routerFunction = new Function(this, `${id}Handler`, {
      timeout: Duration.seconds(30),
      runtime: props.runtime,
      handler: props.handler,
      code: Code.fromAsset(props.handlerFilePath),
      tracing: Tracing.ACTIVE,
      environment: {
        AWS_CONNECTION_REUSE_ENABLED: '1',
      },
    });

    let apiUrl;
    if (props.apiType === 'function-url-streaming') {
      const stack = Stack.of(this);
      this.routerFunction.addLayers(
        LayerVersion.fromLayerVersionArn(
          this,
          'LWALayer',
          `arn:aws:lambda:${stack.region}:753240598075:layer:LambdaAdapterLayerX86:24`,
        ),
      );
      this.routerFunction.addEnvironment('PORT', '8000');
      this.routerFunction.addEnvironment(
        'AWS_LWA_INVOKE_MODE',
        'response_stream',
      );
      this.routerFunction.addEnvironment(
        'AWS_LAMBDA_EXEC_WRAPPER',
        '/opt/bootstrap',
      );
      this.routerFunctionUrl = this.routerFunction.addFunctionUrl({
        authType: FunctionUrlAuthType.AWS_IAM,
        invokeMode: InvokeMode.RESPONSE_STREAM,
        cors: {
          allowedOrigins: props.allowedOrigins ?? ['*'],
          allowedHeaders: [
            'authorization',
            'content-type',
            'x-amz-content-sha256',
            'x-amz-date',
            'x-amz-security-token',
          ],
        },
      });
      apiUrl = this.routerFunctionUrl.url;
    } else {
      this.api = new _HttpApi(this, id, {
        corsPreflight: {
          allowOrigins: props.allowedOrigins ?? ['*'],
          allowMethods: [CorsHttpMethod.ANY],
          allowHeaders: [
            'authorization',
            'content-type',
            'x-amz-content-sha256',
            'x-amz-date',
            'x-amz-security-token',
          ],
        },
        defaultAuthorizer: props.defaultAuthorizer,
      });

      this.api.addRoutes({
        path: '/{proxy+}',
        methods: [
          HttpMethod.GET,
          HttpMethod.DELETE,
          HttpMethod.POST,
          HttpMethod.PUT,
          HttpMethod.PATCH,
          HttpMethod.HEAD,
        ],
        integration: new HttpLambdaIntegration(
          'RouterIntegration',
          this.routerFunction,
        ),
      });
      apiUrl = this.api.url;
    }

    new CfnOutput(this, `${props.apiName}Url`, { value: apiUrl! });

    RuntimeConfig.ensure(this).config.httpApis = {
      ...RuntimeConfig.ensure(this).config.httpApis!,
      [props.apiName]: apiUrl,
    };
  }

  public grantInvokeAccess(role: IRole) {
    if (this.api) {
      role.addToPrincipalPolicy(
        new PolicyStatement({
          effect: Effect.ALLOW,
          actions: ['execute-api:Invoke'],
          resources: [this.api.arnForExecuteApi('*', '/*', '*')],
        }),
      );
    } else if (this.routerFunction) {
      role.addToPrincipalPolicy(
        new PolicyStatement({
          effect: Effect.ALLOW,
          actions: ['lambda:InvokeFunctionUrl'],
          resources: [this.routerFunction.functionArn],
          conditions: {
            StringEquals: {
              'lambda:FunctionUrlAuthType': 'AWS_IAM',
            },
          },
        }),
      );
    }
  }
}
```
</TabItem>
</Tabs>

### Deployment and testing

First, lets build the codebase:

<NxCommands commands={['run-many --target build --all']} />

<Drawer title="Deployment command" trigger="Your application can now be deployed by running the following command:">

You can also deploy all stacks contained in the CDK application by running:

<NxCommands commands={['nx run @dungeon-adventure/infra:deploy --all']} />

This is **not recommended** given that you may choose to seperate out your deployment stages as seperate stacks `i.e. infra-prod`. In this case the `--all` flag will attempt to deploy all stacks which can result in unwanted deployments!

</Drawer>

<NxCommands commands={['nx run @dungeon-adventure/infra:deploy infra-sandbox']} />

Once the deployment completes, you should see some outputs similar to the following _(some values have been redacted)_:

```bash
infra-sandbox
infra-sandbox: deploying... [2/2]

 ✅  infra-sandbox (no changes)

✨  Deployment time: 354s

Outputs:
infra-sandbox.ElectroDbTableTableNameXXX = infra-sandbox-ElectroDbTableXXX-YYY
infra-sandbox.GameApiGameApiUrlXXX = https://xxx.region.amazonaws.com/
infra-sandbox.GameUIDistributionDomainNameXXX = xxx.cloudfront.net
infra-sandbox.StoryApiStoryApiUrlXXX = https://xxx.lambda-url.ap-southeast-2.on.aws/
infra-sandbox.UserIdentityUserIdentityIdentityPoolIdXXX = region:xxx
infra-sandbox.UserIdentityUserIdentityUserPoolIdXXX = region_xxx
```

We can test our API by either:
<ul>
<li>Starting a local instance of the FastApi server and invoke the API's using `curl`.</li>
<li>
<Drawer title="Sigv4 enabled curl" trigger="Calling the deployed API using sigv4 enabled curl directly">
You can either add the following script to your `.bashrc` file (and `source` it) or simply paste the following into the same terminal you wish to run the command in.
```bash
// ~/.bashrc
acurl () {
    REGION=$1
    SERVICE=$2
    shift; shift;
    curl --aws-sigv4 "aws:amz:$REGION:$SERVICE" --user "$(aws configure get aws_access_key_id):$(aws configure get aws_secret_access_key)" -H "X-Amz-Security-Token: $(aws configure get aws_session_token)" "$@"
}
```

Then to make a sigv4 authenticated curl request, you can simply invoke `acurl` like the following examples:

###### API Gateway
```bash
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### Streaming Lambda function url
```bash
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
</Drawer>
</li>
</ul>

<Tabs>
  <TabItem label="Local">
    <NxCommands commands={["run dungeon_adventure.story_api:serve"]} postCommands={['curl -N -X POST http://127.0.0.1:8000/story/generate \\', '  -d "{\"genre\":\"superhero\", \"actions\":[], \"playerName\":\"UnnamedHero\"}" \\', '  -H "Content-Type: application/json"']} />
  </TabItem>
  <TabItem label="Deployed">
```bash "https://xxx.lambda-url.ap-southeast-2.on.aws/" "ap-southeast-2"
acurl ap-southeast-2 lambda -XN POST \
  https://xxx.lambda-url.ap-southeast-2.on.aws/story/generate \
  -d "{\"genre\":\"superhero\", \"actions\":[], \"playerName\":\"UnnamedHero\"}" \
  -H "Content-Type: application/json"
```
    <Aside type="caution">
    Use the CDK deploy output value of `infra-sandbox.StoryApiStoryApiUrlXXX` to replace the highlighted url placeholder and set the region accordingly.
    </Aside>
  </TabItem>
</Tabs>

If the command executes successfully, you should see a response being streamed similar to:

```
UnnamedHero stood tall, his cape billowing in the wind. Danger lurked in the city streets, but he was ready to face any threat with his incredible powers and unwavering courage.
```

Congratulations. You have built and deployed your first API using FastAPI!  🎉🎉🎉

## Module 4: Final cleanup

<Aside type="caution">TODO: CDK destroy</Aside>

## Wrapping up

Congratulations! You’ve created a dungeon adventure game that utilizes many of the available generators found within the `@aws/nx-plugin`.  🎉🎉🎉

<Aside type="danger">
## TODO
Verify windows
link to other docs
</Aside>