---
title: AI Dungeon Game
description: A walkthrough of how to build an AI powered dungeon adventure game using the @aws/nx-plugin.
---

import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Drawer from '../../../components/drawer.astro';
import RunGenerator from '../../../components/run-generator.astro';
import NxCommands from '../../../components/nx-commands.astro';
import InstallCommand from '../../../components/install-command.astro';
import dungeonAdventureArchitecturePng from '../assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '../assets/dungeon-adventure-er.png'
import baselineWebsitePng from '../assets/baseline-website.png'
import baselineGamePng from '../assets/baseline-game.png'
import nxGraphPng from '../assets/nx-graph.png'
import gameSelectPng from '../assets/game-select.png'
import gameConversationPng from '../assets/game-conversation.png'

You will build an AI powered dungeon adventure game during this tutorial. This tutorial does not assume any existing knowledge of the `@aws/nx-plugin` or related technologies. The techniques you'll learn in this tutorial are fundamental to building any `@aws/nx-plugin` based application, and fully understanding it will give you a deep understanding of the `@aws/nx-plugin` and a basic understanding of how to use [NX](https://nx.dev/).

<Aside>This tutorial is designed for people who prefer to learn by doing and want to quickly try making something tangible. If you prefer learning each concept step by step, refer to the individual component Guides</Aside>

Users who complete this tutorial can expect to walk away with the knowledge to:

- use the `@aws/nx-plugin` to create new applications
- use NX to manage/build their codebase
- build APIs using both tRPC and FastAPI
- use Tanstack router to create new pages
- use Tanstack query to call backend APIs
- make modifications to generated code to be fit for purpose
- create and deploy CDK infrastructure

## What are you building?

In this tutorial, you'll build an AI powered dungeon adventure game with `@aws/nx-plugin`.

You can see what it will look like when you're finished here:

<Image src={gameSelectPng} alt="game-select.png" width="500" height="400" />
<div style="margin-top: -100px; margin-left: 100px;">
<Image src={gameConversationPng} alt="game-conversation.png" width="500" height="400" />
</div>

### Components of the application

The AI powered dungeon adventure game will be built using the following component architecture:

<Image src={dungeonAdventureArchitecturePng} alt="dungeon-game-architecture.png" width="800" height="600" />

- tRPC API which uses ElectroDB/DynamoDB from managing the game state
- Python/FastAPI Lambda function with streaming responses for story generation (powered by Bedrock)
- React/Vite frontend website utilising:
  - Amazon Cognito/Identity Pools for secure API calls
  - Tanstack router which supports type-safe file based routing
  - Generated SDKs for calling the Game and Story APIs (leveraging Tanstack query)
- CDK infrastructure to deploy the application

## Prerequisites

The following global dependencies are needed before proceeding:

- [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
- [Node >= 22](https://nodejs.org/en/download) (We recommend using something like [NVM](https://github.com/nvm-sh/nvm) to manage your node versions)
  - verify by running `node --version`
- [PNPM >= 10](https://pnpm.io/installation#using-npm) (you can also just use npm/yarn/bun if you prefer, however this tutorial will use `pnpm`)
  - verify by running `pnpm --version`
- [UV >= 0.5.29](https://docs.astral.sh/uv/getting-started/installation/)
  1. install Python 3.12 by running: `uv python install 3.12.0`
  2. verify with `uv python list --only-installed`
- [AWS SDK with credentials](https://docs.aws.amazon.com/sdkref/latest/guide/access.html) configured to your target AWS account (where your application will be deployed)
  - Ensure your AWS account has enabled access to the Anthropic Claude 2.5 v2 model within Bedrock for your target region
- If you are using VSCode, install the [Nx Console VSCode Plugin](https://marketplace.visualstudio.com/items?itemName=nrwl.angular-console) if you haven't already.

## Module 1: Monorepo setup

We are going to start by creating a new monorepo. From within your desired directory, run the following command:

```bash
npx create-nx-workspace@20.4.6 dungeon-adventure --preset=ts --ci=skip --pm=pnpm --formatter=prettier
```

This will set up a NX monorepo within the `dungeon-adventure` directory which you can then open in vscode. It should look like the following:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ this is where your sub-projects will reside
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configures the Nx CLI and monorepo defaults
- package.json all node dependencies are defined here
- pnpm-lock.yaml
- pnpm-workspace.yaml
- README.md
- tsconfig.base.json all node based sub-projects extend this
- tsconfig.json
</FileTree>

<Aside>
The `package.json` defines a `type` of `module` which means ESM is the default module type for all node based sub-projects vended by the `@aws/nx-plugin`.
</Aside>

In order to start adding components from the `@aws/nx-plugin` into the monorepo, we need to install it as a dev dependency by running the following command:

```bash
pnpm add -Dw @aws/nx-plugin
```

Now we are ready to start creating our different sub-projects using the `@aws/nx-plugin`.

<Aside type="tip">It is a best practice to ensure all your unstaged files are commited in Git before running any generators. This allows you to see what has changed after running your generator via `git diff`</Aside>

### Game API

First let's create our Game API. To do this, let's create a tRPC API called `GameApi` by following the below steps:

<RunGenerator generator="ts#trpc-api" requiredParameters={{apiName:"GameApi"}} noInteractive />

<br />

You should see some new files have appeared in your file tree.
<Drawer title="ts#trpc-api updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated by the `ts#trpc-api` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ app specific cdk constructs
          - http-apis/
            - **game-api.ts** cdk construct to create your tRPC API
            - index.ts
            - ...
          - index.ts
        - core/ generic cdk constructs
          - http-api.ts base cdk construct for a Http based API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ shared types
      - src/
        - index.ts
        - runtime-config.ts interface definition used by both CDK and website
      - project.json
      - ...
  - game-api/
    - backend/ tRPC implementation code
      - src/
        - client/ vanilla client typically used for ts machine to machine calls
          - index.ts
          - sigv4.ts
        - middleware/ powertools instrumentation
          - error.ts
          - index.ts
          - logger.ts
          - metrics.ts
          - tracer.ts
        - procedures/ specific implementations for your API procedures/routes
          - **echo.ts**
        - index.ts
        - init.ts sets up context and middleware
        - local-server.ts used when running the tRPC server locally
        - **router.ts** entrypoint for your lambda handler which defines all procedures
      - project.json
      - ...
    - schema/
      - src/
        - procedures/
          - **echo.ts**
        - index.ts
      - project.json
      - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Taking a look at a few of the key files:

###### packages/game-api/backend/src/router.ts
```ts {5,12}
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>,
  ) => ctx,
});

export type AppRouter = typeof appRouter;
```
The router defines the entrypoint for your tRPC API and is the place where you will declare all of your API methods. As you can see above, we have a method called `echo` with it's implementation living in the `./procedures/echo.ts` file.

###### packages/game-api/backend/src/procedures/echo.ts
```ts {2-5}
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from ':dungeon-adventure/game-api-schema';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

This file is the implementation of the `echo` method and as you can see is strongly typed by declaring its input and output data structures. It is importing these definitions from the `:dungeon-adventure/game-api-schema` project which is an [alias](https://www.typescriptlang.org/tsconfig/paths.html) for the schema project.

<Aside type="tip">If you are seeing an import error within your IDE, this is because our backend does not have a typescript reference set up yet in it's tsconfig.json. Nx has been [configured](https://nx.dev/nx-api/js/generators/typescript-sync) to create these references *dynamically* whenever a build/compile is run or if you run the `pnpm nx sync` command manually. For more information refer to the [Typescript guide](/guides/typescript-project#importing-your-library-code-in-other-projects).</Aside>

###### packages/game-api/schema/src/procedures/echo.ts
```ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

All tRPC schema definitions are defined using [Zod](https://zod.dev/) and are exported as typescript types via the `z.TypeOf` syntax.

###### packages/common/constructs/src/app/http-apis/game-api.ts
```ts
import { Construct } from 'constructs';
import * as url from 'url';
import { HttpApi } from '../../core/http-api.js';
import { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';
import { Runtime } from 'aws-cdk-lib/aws-lambda';

export class GameApi extends HttpApi {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      defaultAuthorizer: new HttpIamAuthorizer(),
      apiName: 'GameApi',
      runtime: Runtime.NODEJS_LATEST,
      handler: 'index.handler',
      handlerFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-api/backend/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

This is the CDK construct that defines our GameApi. As you can see, it has already configured the handler file path to the generated bundle for our tRPC backend implementation. This means that at `cdk synth` time, bundling does not occur as we have already bundled it as part of the backend project's build target.

</Drawer>

### Story API

Now let's create our Story API. To do this, let's create a Fast API called `StoryApi` by following the below steps:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi"}} noInteractive />

You should see some new files have appeared in your file tree.
<Drawer title="py#fast-api updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated by the `py#fast-api` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- .venv/ single virtual env for monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ app specific cdk constructs
          - http-apis/
            - **story-api.ts** cdk construct to create your Fast API
            - index.ts updated to export the new story-api
      - project.json updated to add a build dep on story_api
    - types/ shared types
      - src/
        - **runtime-config.ts** updated to add the StoryApi
  - story_api/
    - story_api/ python module
      - init.py sets up powertools, FastAPI and middleware
      - **main.py** entrypoint for the lambda containing all routes
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version pinned uv python version
- pyproject.toml
- uv.lock
</FileTree>

###### packages/common/constructs/src/app/http-apis/story-api.ts
```ts
import { Construct } from 'constructs';
import * as url from 'url';
import { HttpApi } from '../../core/http-api.js';
import { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';
import { Runtime } from 'aws-cdk-lib/aws-lambda';

export class StoryApi extends HttpApi {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      defaultAuthorizer: new HttpIamAuthorizer(),
      apiName: 'StoryApi',
      runtime: Runtime.PYTHON_3_12,
      handler: 'story_api.main.handler',
      handlerFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/story_api/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

This is the CDK construct that defines our StoryApi. As you can see, it has already configured the handler file path to the generated bundle for our Fast API backend implementation. This means that at `cdk synth` time, bundling does not occur as we have already bundled it as part of the backend project's build target.

###### packages/common/types/src/runtime-config.ts
```diff lang="ts"
export type ApiUrl = string;
// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-empty-interface
export interface IRuntimeConfig {
  httpApis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

Here is an example of the generator performing an AST transform which preserves all existing code and performs an update. Here you can see the `StoryApi` was added to the `IRuntimeConfig` definition which means when this is eventually consumed by our frontend which enables type safety!

###### packages/story_api/story_api/main.py
```py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

This is where all your API method will be defined. As you can see here, we have a `read_root` method mapped to the `GET /` route. You can use [Pydantic](https://docs.pydantic.dev/latest/) to declare your method inputs and outputs to ensure type safety.

</Drawer>

### Game UI: Website

Now let's create the UI which will enable you to interact with the game. To do this, let's create a website called `GameUI` by following the below steps:

<RunGenerator generator="ts#cloudscape-website" requiredParameters={{name:"GameUI"}} noInteractive />

You should see some new files have appeared in your file tree.

<Drawer title="ts#cloudscape-website updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated by the `ts#cloudscape-website` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ app specific cdk constructs
          - static-websites/
            - **game-ui.ts** cdk construct to create your Game UI
        - core/
          - static-website.ts generic static website construct
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts overall page layout: header, footer, sidebar, etc
          - navitems.ts sidebar nav items
      - hooks/
        - useAppLayout.tsx allows you to dynamically set things like notifications, page style, etc
      - routes/ @tanstack/react-router file based routes
        - index.tsx root '/' page redirects to '/welcome'
        - __root.tsx all pages use this component as a base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** React entrypoint
        - routeTree.gen.ts this is automatically updated by @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

###### packages/common/constructs/src/app/static-websites/game-ui.ts
```ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

This is the CDK construct that defines our GameUI. As you can see, it has already configured the file path to the generated bundle for our Vite based UI. This means that at `build` time, bundling occurs within the game-ui project's build target and it's output is used here.

###### packages/game-ui/src/main.tsx
```tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Register the router instance for type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

This is the entrypoint where React is mounted. As shown, it initially just configures a `@tanstack/react-router` in a [`file-based-routing`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing) configuration. This means, as long as your development server is running - you can simply create files within the `routes` folder and `@tanstack/react-router` will create the boilerplate file setup for you along with updating the `routeTree.gen.ts` file. This file maintains all routes in a type-safe manner, which means when you use `<Link>`- the `to` option will only show valid routes. For more information, refer to the [`@tanstack/react-router` docs](https://tanstack.com/router/v1/docs/framework/react/quick-start).

###### packages/game-ui/src/routes/welcome/index.tsx
```tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

A component which will be rendered when navigating to the `/welcome` route. `@tanstack/react-router` will manage the `Route` for you whenever you create/move this file (as long as the dev server is running). This will be shown in a later section of this tutorial.

</Drawer>

### Game UI: Auth

Now let's configure our Game UI to require authenticated access via Amazon Cognito by following the below steps:

<RunGenerator generator="ts#cloudscape-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

You should see some new files have appeared/changed in your file tree.

<Drawer title="ts#cloudscape-website#auth updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated/updated by the `ts#cloudscape-website#auth` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts cdk construct for creating user/identity pools
    - types/
      - src/
        - runtime-config.ts updated to add the cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx adds the logged in user/logout to the header
        - CognitoAuth/
          - index.ts manages logging into Cognito
        - RuntimeConfig/
          - index.tsx fetches the `runtime-config.json` and provides it to children via context
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Updated to add Cognito
</FileTree>

###### packages/game-ui/src/main.tsx
```diff lang="tsx"
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Register the router instance for type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

The `RuntimeConfigProvider` and `CognitoAuth` components have been added to the `main.tsx` file via an AST transform. This allows the `CognitoAuth` component to authenticate with Amazon Cognito by fetching the `runtime-config.json` which contains the required cognito connection configuration in order to make the backend calls to the correct destination.

</Drawer>

### Game UI: Connect to Story API

Now let's configure our Game UI to connect to our previously created Story API:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

You should see some new files have appeared/changed in your file tree.

<Drawer title="UI -> FastAPI api-connection updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated/updated by the `api-connection` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx used by StoryApi to sign requests
        - useStoryApi.tsx hooks to call the StoryApi
    - .gitignore ignore generated client files
    - project.json updated to add targets for generating openapi client
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json updated to emit an openapi.json file

</FileTree>

###### packages/game-ui/src/hooks/useStoryApi.tsx
```tsx {1,12-15}
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.httpApis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

This hook is what will be used to make authenticated API requests to the `StoryApi`. As you can see in the implemenetation, it uses the `StoryApi` which is generated at build time and as such you will see an error in your IDE until we build our code. For more details on how the client is generated or how to consume the API, refer to the [React to FastAPI guide](/guides/api-connection/react-fastapi).

<Aside type="caution">
The `client.gen.ts` file that is generated should never be modified manually as this will be re-generated any time a change to the backend API is detected.
</Aside>

</Drawer>

### Game UI: Connect to Game API

Now let's configure our Game UI to connect to our previously created Game API:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api-backend"}} noInteractive />

You should see some new files have appeared/changed in your file tree.

<Drawer title="UI -> tRPC api-connection updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated/updated by the `api-connection` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - TrpcClients/
          - index.tsx
          - TrpcApis.tsx all configured tRPC APIs
          - TrpcClientProviders.tsx creates a client provider per tRPC API
          - TrpcProvider.tsx
        - QueryClientProvider.tsx sets up the query client
      - hooks/
        - **useGameApi.tsx** hooks to call the GameApi
      - **main.tsx** injects the trpc client providers
- package.json

</FileTree>

###### packages/game-ui/src/hooks/useGameApi.tsx
```tsx
import { TrpcApis } from '../components/TrpcClients';

export const useGameApi = () => TrpcApis.GameApi.useTRPC();
```

This hooks uses tRPC's latest [React Query integration](https://trpc.io/blog/introducing-tanstack-react-query-client) allowing user's to interact with `@tanstack/react-query` directly without any additional layers of abstraction. For examples on how to call tRPC APIs, refer to the [using the tRPC hook guide](/guides/api-connection/react-trpc#using-the-generated-code).

<Aside>
The `useGameApi` hook is different to the `useStoryApi` hook as it does not require a build in order for changes to be reflected courtesy of tRPC's usage of [Typescript inference](https://trpc.io/docs/concepts). This allows developers to make changes to their backend which instantly are reflected in their frontend!
</Aside>

###### packages/game-ui/src/main.tsx
```diff lang="tsx"
+import TrpcClientProviders from './components/TrpcClients';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Register the router instance for type safety
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <TrpcClientProviders>
                <RouterProvider router={router} />
+              </TrpcClientProviders>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

The `main.tsx` file has been updated via an AST transform to inject the tRPC providers.

</Drawer>

### Game UI: Infrastructure

Now the final sub-project we need to create is for the CDK infrastructure. To create this, follow the below steps:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

You should see some new files have appeared/changed in your file tree.

<Drawer title="ts#infra updated files" trigger="Click here to examine these files in more detail.">
Below is a list of all files which have been generated/updated by the `ts#infra` generator. We are going to examine some of the key files highlighted in the file tree:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts**
      - index.ts
      - **main.ts** entrypoint which defines all stacks
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json add references
  - tsconfig.base.json add alias

</FileTree>

###### packages/infra/src/main.ts
```ts
import { App } from 'aws-cdk-lib';
import { ApplicationStack } from './stacks/application-stack.js';
import {
  CfnGuardValidator,
  RuleSet,
} from ':dungeon-adventure/common-constructs';

const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

// Use this to deploy your own sandbox environment (assumes your CLI credentials)
new ApplicationStack(app, 'infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

This is the entrypoint for your CDK application.

It is configured to use [`cfn-guard`](https://github.com/cdklabs/cdk-validator-cfnguard) to run infrastructure validation based on the configured ruleset. This is instrumented post synthesis.

<Aside type="tip">
There may be instances where you want to suppress certain rules on resources. You can do this in two ways:

###### Supress a rule on a given construct

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// suppresses the RULE_NAME for the given construct.
suppressRule(construct, 'RULE_NAME');
```

###### Supress a rule on a descendant construct

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// Supresses the RULE_NAME for the construct or any of its descendants if it is an instance of Bucket
suppressRule(construct, 'RULE_NAME', (construct) => construct instanceof Bucket);
```
</Aside>

###### packages/infra/src/stacks/application-stack.ts
```ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // The code that defines your stack goes here
  }
}
```

This is where we will instantiate our CDK constructs to build our dungeon adventure game.

</Drawer>

#### Update our infrastructure

Let's make an update to our `packages/infra/src/stacks/application-stack.ts` to instantiate some of our already generated constructs:

```diff lang="ts"
+import {
+  GameApi,
+  GameUI,
+  StoryApi,
+  UserIdentity,
+} from ':dungeon-adventure/common-constructs';
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

-    // The code that defines your stack goes here
+    const userIdentity = new UserIdentity(this, 'UserIdentity');
+
+    const gameApi = new GameApi(this, 'GameApi');
+    const storyApi = new StoryApi(this, 'StoryApi');
+
+    // grant our authenticated role access to invoke our APIs
+    [storyApi, gameApi].forEach((api) =>
+      api.grantInvokeAccess(userIdentity.identityPool.authenticatedRole),
+    );
+
+    // Ensure this is instantiated last so our runtime-config.json can be automatically configured
+    new GameUI(this, 'GameUI');
  }
}

```

### Building our code

<Drawer title="Nx commands" trigger="Now it's time for us to build our code for the first time">
###### Single vs Multiple targets

The `run-many` command will run a target on multiple listed subprojects (`--all` will target them all). It will ensure dependencies are executed in the correct order.

You can also trigger a build (or any other task) for a single project target by running the target on the project directly. For example, if we want to build the `@dungeon-adventure/infra` project, you can run the following command:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualizing your dependencies

You can also visualize your dependencies via:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Caching

Nx relies on [caching](https://nx.dev/concepts/how-caching-works) so that you can re-use artifacts from previous builds in order to speed up development. There is a little bit on configuration required to get this to work correctly and there may be cases where you want to perform a build **without using the cache**. To do that, simply append the `--skip-nx-cache` argument to your command. For example:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
If for whatever reason you ever wanted to clear your cache (stored in the `.nx` folder), you can run the following command:

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

You should be prompted with the following:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? â€¦
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

This message indicates that NX has detected some files which can be updated automatically for you. In this case, it is referring to the `tsconfig.json` files which do not have Typescript references set up on references projects. Select the **Yes, sync the changes and run the tasks** option to proceed. You should notice all of you IDE related import errors get automatically resolved as the sync generator will add the missing typescript references automatically!

<Aside type="tip">
If you encounter any lint errors, you can run the following command to automatically fix them.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

All built artifacts are now available within the `dist/` folder located at the root of the monorepo. This is a standard practice when using projects generated by the `@aws/nx-plugin` as it does not pollute your file-tree with generated files. In the event you want to clean yor files, you can simply delete the `dist/` folder without having to worry about generated files being littered throughout the file tree.

Congratulations! Youâ€™ve created all of the required sub-projects needed to start implementing the core of our Dunegeon Adventure game.  ðŸŽ‰ðŸŽ‰ðŸŽ‰

## Module 2: Game API implementation

We are going to start by implementing our Game API. To do this, we need to create 4 API's in total:

1. `createGame` - this will create a new game instance.
2. `queryGames` - this will return a paginated list of previously saved games.
3. `saveAction` - this will save an action for a given game.
4. `queryActions` - this will return a paginated list of all actions related to a game.

### Entity modelling

The ER diagram for our application is as follows:

<Image className="centered-image" src={dungeonAdventureErPng} alt="dungeon-adventure-er.png" width="400" height="300" />

We are going to implement our Database in DynamoDB and will be using the [ElectroDB](https://electrodb.dev/en/core-concepts/introduction/) DynamoDB client library to simplify things. To get started we need to first install `electrodb` by running the following command:

<InstallCommand pkg="electrodb @aws-sdk/client-dynamodb" />

Now let's create the following files within our `packages/game-api/backend/src/entities` folder to define our ElectroDB entities as per the above ER Diagram:

<Tabs>
  <TabItem label="action.ts">
```typescript
import { Entity } from 'electrodb';
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';

export const createActionEntity = (client?: DynamoDBClient) =>
  new Entity(
    {
      model: {
        entity: 'Action',
        version: '1',
        service: 'game',
      },
      attributes: {
        playerName: { type: 'string', required: true, readOnly: true },
        timestamp: {
          type: 'string',
          required: true,
          readOnly: true,
          set: () => new Date().toISOString(),
          default: () => new Date().toISOString(),
        },
        role: { type: 'string', required: true, readOnly: true },
        content: { type: 'string', required: true, readOnly: true },
      },
      indexes: {
        primary: {
          pk: { field: 'pk', composite: ['playerName'] },
          sk: { field: 'sk', composite: ['timestamp'] },
        },
      },
    },
    { client, table: process.env.TABLE_NAME },
  );
```
  </TabItem>
  <TabItem label="game.ts">
```typescript
import { Entity } from 'electrodb';
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';

export const createGameEntity = (client?: DynamoDBClient) =>
  new Entity(
    {
      model: {
        entity: 'Game',
        version: '1',
        service: 'game',
      },
      attributes: {
        playerName: { type: 'string', required: true, readOnly: true },
        genre: { type: 'string', required: true, readOnly: true },
        lastUpdated: {
          type: 'string',
          required: true,
          default: () => new Date().toISOString(),
        },
      },
      indexes: {
        primary: {
          pk: { field: 'pk', composite: ['playerName'] },
          sk: {
            field: 'sk',
            composite: [],
          },
        },
      },
    },
    { client, table: process.env.TABLE_NAME },
  );
```
  </TabItem>
</Tabs>

ElectroDB is very powerful and allows us to not only define our types, but can also provide defaults for certain values like the timestamps above. In addition, ElectroDB follows [single-table design](https://electrodb.dev/en/core-concepts/single-table-relationships/) which is the best practive when using DynamoDB.

<Aside>
Whilst ElectroDB does support [collections](https://electrodb.dev/en/modeling/collections/), we have chosen not to use them in this tutorial for simplicity.
</Aside>

### API Schema

To define our API inputs and outputs, let's create our schema using [Zod](https://zod.dev/) within the `packages/game-api/schema/schema/src` project as follows:

<Tabs>
  <TabItem label="types/action.ts">
```typescript
import { z } from 'zod';

export const ActionSchema = z.object({
  playerName: z.string(),
  timestamp: z.string().datetime(),
  role: z.enum(['assistant', 'user']),
  content: z.string(),
});

export type IAction = z.TypeOf<typeof ActionSchema>;
```
  </TabItem>
  <TabItem label="types/common.ts">
```typescript
import { z } from 'zod';

export const QueryInputSchema = z.object({
  cursor: z.string().optional(),
  limit: z.number().optional().default(100),
});

export const createPaginatedQueryOutput = <ItemType extends z.ZodTypeAny>(
  itemSchema: ItemType,
) => {
  return z.object({
    items: z.array(itemSchema),
    cursor: z.string().nullable(),
  });
};

export type IQueryInput = z.TypeOf<typeof QueryInputSchema>;
```
  </TabItem>
  <TabItem label="types/game.ts">
```typescript
import { z } from 'zod';

export const GameSchema = z.object({
  playerName: z.string(),
  genre: z.enum(['zombie', 'superhero', 'medieval']),
  lastUpdated: z.string().datetime(),
});

export type IGame = z.TypeOf<typeof GameSchema>;
```
  </TabItem>
  <TabItem label="index.ts">
```diff lang="typescript"
-export * from './procedures/echo.js';
+export * from './types/action.js';
+export * from './types/common.js';
+export * from './types/game.js';
```
You can also delete the `./procedures/echo.ts` file given we will not be using it in this project.
  </TabItem>
</Tabs>

<Aside type="tip">
As you can see above, for each of the schemas we define in Zod, we also export an interface using the `z.TypeOf` syntax. This converts our zod definition into a Typescript interface without having to duplicate effort!
</Aside>

### Adding the dynamoDB client to our tRPC context

Given we need access to the DynamoDB client in each of our procedures, we want to be able to create a single instance of the client which we can pass through via context. To do this, make the following changes within `packages/game-api/backend/src`:

<Tabs>
  <TabItem label="middleware/dynamodb.ts">
```typescript
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { initTRPC } from '@trpc/server';

export interface IDynamoDBContext {
  dynamoDb?: DynamoDBClient;
}

export const createDynamoDBPlugin = () => {
  const t = initTRPC.context<IDynamoDBContext>().create();
  return t.procedure.use(async (opts) => {
    const dynamoDb = new DynamoDBClient();

    const response = await opts.next({
      ctx: {
        ...opts.ctx,
        dynamoDb,
      },
    });

    return response;
  });
};
```

This is a plugin that we instrument to create the `DynamoDBClient` and inject it into the context.
  </TabItem>
  <TabItem label="middleware/index.ts">
```diff lang="ts"
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import type { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';
import { ILoggerContext } from './logger.js';
import { IMetricsContext } from './metrics.js';
import { ITracerContext } from './tracer.js';
+import { IDynamoDBContext } from './dynamodb.js';

+export * from './dynamodb.js';
export * from './logger.js';
export * from './metrics.js';
export * from './tracer.js';
export * from './error.js';

export type IMiddlewareContext =
  CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer> &
+    IDynamoDBContext &
    ILoggerContext &
    IMetricsContext &
    ITracerContext;
```

Augment our `IMiddlewareContext` to add the `IDynamoDBContext`.
  </TabItem>
  <TabItem label="init.ts">
```diff lang="ts"
import { initTRPC } from '@trpc/server';
import {
+  createDynamoDBPlugin,
  createErrorPlugin,
  createLoggerPlugin,
  createMetricsPlugin,
  createTracerPlugin,
  IMiddlewareContext,
} from './middleware/index.js';

process.env.POWERTOOLS_SERVICE_NAME = 'GameApi';
process.env.POWERTOOLS_METRICS_NAMESPACE = 'GameApi';

export type Context = IMiddlewareContext;

export const t = initTRPC.context<Context>().create();

export const publicProcedure = t.procedure
+  .unstable_concat(createDynamoDBPlugin())
  .unstable_concat(createLoggerPlugin())
  .unstable_concat(createTracerPlugin())
  .unstable_concat(createMetricsPlugin())
  .unstable_concat(createErrorPlugin());
```

The DynamoDB plugin is instrumented.

<Aside>
We are using the `unstable_concat` api here which is safe to use. The only reason it has the `unstable_` prefixed is because it is a new API. For more information refer to the [concat guide](https://trpc.io/docs/server/middlewares#concat).
</Aside>
  </TabItem>
</Tabs>

### Defining our procedures

Now it's time to implement the API methods. To do this, make the following changes within `packages/game-api/backend/src`:

<Tabs>
  <TabItem label="procedures/query-actions.ts">
```typescript
import { createActionEntity } from '../entities/action.js';
import {
  ActionSchema,
  IAction,
  QueryInputSchema,
  createPaginatedQueryOutput,
} from ':dungeon-adventure/game-api-schema';
import { publicProcedure } from '../init.js';
import { z } from 'zod';

export const queryActions = publicProcedure
  .input(QueryInputSchema.extend({ playerName: z.string() }))
  .output(createPaginatedQueryOutput(ActionSchema))
  .query(async ({ input, ctx }) => {
    const actionEntity = createActionEntity(ctx.dynamoDb);
    const result = await actionEntity.query
      .primary({ playerName: input.playerName })
      .go({ cursor: input.cursor, count: input.limit });

    return {
      items: result.data as IAction[],
      cursor: result.cursor,
    };
  });
```
  </TabItem>
  <TabItem label="procedures/query-games.ts">
```typescript
import { createGameEntity } from '../entities/game.js';
import {
  GameSchema,
  IGame,
  QueryInputSchema,
  createPaginatedQueryOutput,
} from ':dungeon-adventure/game-api-schema';
import { publicProcedure } from '../init.js';

export const queryGames = publicProcedure
  .input(QueryInputSchema)
  .output(createPaginatedQueryOutput(GameSchema))
  .query(async ({ input, ctx }) => {
    const gameEntity = createGameEntity(ctx.dynamoDb);
    const result = await gameEntity.scan.go({
      cursor: input.cursor,
      count: input.limit,
    });

    return {
      items: result.data as IGame[],
      cursor: result.cursor,
    };
  });
```
  </TabItem>
  <TabItem label="procedures/save-action.ts">
```typescript
import { ActionSchema, IAction } from ':dungeon-adventure/game-api-schema';
import { publicProcedure } from '../init.js';
import { createActionEntity } from '../entities/action.js';
import { createGameEntity } from '../entities/game.js';

export const saveAction = publicProcedure
  .input(ActionSchema.omit({ timestamp: true }))
  .output(ActionSchema)
  .mutation(async ({ input, ctx }) => {
    const actionEntity = createActionEntity(ctx.dynamoDb);
    const gameEntity = createGameEntity(ctx.dynamoDb);

    const action = await actionEntity.put(input).go();
    await gameEntity
      .update({ playerName: input.playerName })
      .set({ lastUpdated: action.data.timestamp })
      .go();
    return action.data as IAction;
  });
```
  </TabItem>
  <TabItem label="procedures/save-game.ts">
```typescript
import { createGameEntity } from '../entities/game.js';
import { GameSchema, IGame } from ':dungeon-adventure/game-api-schema';
import { publicProcedure } from '../init.js';

export const saveGame = publicProcedure
  .input(GameSchema.omit({ lastUpdated: true }))
  .output(GameSchema)
  .mutation(async ({ input, ctx }) => {
    const gameEntity = createGameEntity(ctx.dynamoDb);

    const result = await gameEntity.put(input).go();
    return result.data as IGame;
  });
```
  </TabItem>
  <TabItem label="router.ts">
```diff lang="ts"
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { t } from './init.js';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';
-import { echo } from './procedures/echo.js';
+import { queryActions } from './procedures/query-actions.js';
+import { saveAction } from './procedures/save-action.js';
+import { queryGames } from './procedures/query-games.js';
+import { saveGame } from './procedures/save-game.js';

export const router = t.router;

export const appRouter = router({
-  echo,
+  actions: router({
+    query: queryActions,
+    save: saveAction,
+  }),
+  games: router({
+    query: queryGames,
+    save: saveGame,
+  }),
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>,
  ) => ctx,
});

export type AppRouter = typeof appRouter;
```
You can also delete the `./procedures/echo.ts` file given we will not be using it in this project.
  </TabItem>
</Tabs>

### Infrastructure

The final step is to update our infrastructure to create the DynamoDB table and grant permissions to perform operations from the Game API. To do so, update the `packages/infra/src` as follows:

<Tabs>
  <TabItem label="constructs/electrodb-table.ts">
```typescript
import { CfnOutput } from 'aws-cdk-lib';
import {
  AttributeType,
  BillingMode,
  ProjectionType,
  Table,
  TableProps,
} from 'aws-cdk-lib/aws-dynamodb';
import { Construct } from 'constructs';

export type ElectrodbDynamoTableProps = Omit<
  TableProps,
  'partitionKey' | 'sortKey' | 'billingMode'
>;

export class ElectrodbDynamoTable extends Table {
  constructor(scope: Construct, id: string, props?: ElectrodbDynamoTableProps) {
    super(scope, id, {
      partitionKey: {
        name: 'pk',
        type: AttributeType.STRING,
      },
      sortKey: {
        name: 'sk',
        type: AttributeType.STRING,
      },
      billingMode: BillingMode.PAY_PER_REQUEST,
      ...props,
    });

    this.addGlobalSecondaryIndex({
      indexName: 'gsi1pk-gsi1sk-index',
      partitionKey: {
        name: 'gsi1pk',
        type: AttributeType.STRING,
      },
      sortKey: {
        name: 'gsi1sk',
        type: AttributeType.STRING,
      },
      projectionType: ProjectionType.ALL,
    });

    new CfnOutput(this, 'TableName', { value: this.tableName });
  }
}
```
  </TabItem>
  <TabItem label="stacks/application-stack.ts">
```diff lang="ts"
import {
  GameApi,
  GameUI,
  StoryApi,
  UserIdentity,
} from ':dungeon-adventure/common-constructs';
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
+import { ElectrodbDynamoTable } from '../constructs/electrodb-table.js';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // The code that defines your stack goes here
    const userIdentity = new UserIdentity(this, 'UserIdentity');
+
+    const electroDbTable = new ElectrodbDynamoTable(this, 'ElectroDbTable');

    const gameApi = new GameApi(this, 'GameApi');
    const storyApi = new StoryApi(this, 'StoryApi');
+
+    gameApi.routerFunction.addEnvironment(
+      'TABLE_NAME',
+      electroDbTable.tableName,
+    );
+    // grant the gameAPI rw access to DynamoDB
+    electroDbTable.grantReadWriteData(gameApi.routerFunction);

    // grant our authenticated role access to invoke our APIs
    [storyApi, gameApi].forEach((api) =>
      api.grantInvokeAccess(userIdentity.identityPool.authenticatedRole),
    );

    // Ensure this is instantiated last so our runtime-config.json can be automatically configured
    new GameUI(this, 'GameUI');
  }
}
```
  </TabItem>
</Tabs>

### Deployment and testing

First, lets build the codebase:

<NxCommands commands={['run-many --target build --all']} />

<Drawer title="Deployment command" trigger="Your application can now be deployed by running the following command:">

You can also deploy all stacks contained in the CDK application by running:

<NxCommands commands={['nx run @dungeon-adventure/infra:deploy --all']} />

This is **not recommended** given that you may choose to seperate out your deployment stages as seperate stacks `i.e. infra-prod`. In this case the `--all` flag will attempt to deploy all stacks which can result in unwanted deployments!

</Drawer>

<NxCommands commands={['nx run @dungeon-adventure/infra:deploy infra-sandbox']} />

Once the deployment completes, you should see some outputs similar to the following _(some values have been redacted)_:

```bash
infra-sandbox
infra-sandbox: deploying... [2/2]

 âœ…  infra-sandbox (no changes)

âœ¨  Deployment time: 354s

Outputs:
infra-sandbox.ElectroDbTableTableNameXXX = infra-sandbox-ElectroDbTableXXX-YYY
infra-sandbox.GameApiGameApiUrlXXX = https://xxx.region.amazonaws.com/
infra-sandbox.GameUIDistributionDomainNameXXX = xxx.cloudfront.net
infra-sandbox.StoryApiStoryApiUrlXXX = https://xxx.execute-api.region.amazonaws.com/
infra-sandbox.UserIdentityUserIdentityIdentityPoolIdXXX = region:xxx
infra-sandbox.UserIdentityUserIdentityUserPoolIdXXX = region_xxx
```

We can test our API by either:
<ul>
<li>Starting a local instance of the tRPC backend and invoke the API's using `curl`.</li>
<li>
<Drawer title="Sigv4 enabled curl" trigger="Calling the deployed API using sigv4 enabled curl directly">
You can either add the following script to your `.bashrc` file (and `source` it) or simply paste the following into the same terminal you wish to run the command in.
```bash
// ~/.bashrc
acurl () {
    REGION=$1
    SERVICE=$2
    shift; shift;
    curl --aws-sigv4 "aws:amz:$REGION:$SERVICE" --user "$(aws configure get aws_access_key_id):$(aws configure get aws_secret_access_key)" -H "X-Amz-Security-Token: $(aws configure get aws_session_token)" "$@"
}
```

Then to make a sigv4 authenticated curl request, you can simply invoke `acurl` like the following examples:

###### API Gateway
```bash
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### Streaming Lambda function url
```bash
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
</Drawer>
</li>
</ul>


<Tabs>
  <TabItem label="Local">
    <NxCommands highlights={['infra-sandbox-ElectroDbTableXXX-YYY']} env={{TABLE_NAME:"infra-sandbox-ElectroDbTableXXX-YYY"}} commands={["run @dungeon-adventure/game-api-backend:serve"]} postCommands={['curl -X GET http://localhost:2022/games.query\?input="\\{\\}"']} />
    <Aside type="caution">
    Use the CDK deploy output value of `infra-sandbox.ElectroDbTableTableNameXXX` to replace the highlighted placeholder.
    </Aside>
  </TabItem>
  <TabItem label="Deployed">
```bash "https://xxx.region.amazonaws.com/" "ap-southeast-2"
acurl ap-southeast-2 execute-api -X GET \
  https://xxx.region.amazonaws.com/games.query\?input\={}
```
    <Aside type="caution">
    Use the CDK deploy output value of `infra-sandbox.GameApiGameApiUrlXXX` to replace the highlighted placeholder and set the region accordingly..
    </Aside>
  </TabItem>
</Tabs>

If the command executes successfully, you should see a response as follows:

```json
{"result":{"data":{"items":[],"cursor":null}}}
```

Congratulations. You have built and deployed your first API using tRPC!  ðŸŽ‰ðŸŽ‰ðŸŽ‰

## Module 3: Story API implementation

<Aside type="caution">
Ensure you have granted access to the **Anthropic Claude 3.5 Sonnet v2** model via the steps outlined in [this guide](https://docs.aws.amazon.com/bedrock/latest/userguide/model-access-modify.html).
</Aside>

The StoryApi comprises of a single API `generate_story` which given `Game` and a list of `Action`'s for context, will progress a story. This API will be implemented as a streaming API in Python/FastAPI and will additionally demonstrate how changes can be made to the generated code to be fit for purpose.

### API implementation

To create our API, we first need to install a couple of additional dependencies.

- `boto3` will be used to call Amazon Bedrock;
- `uvicorn` will be used to start our API when used in conjunction with the [Lambda Web Adapter (LWA)](https://github.com/awslabs/aws-lambda-web-adapter).
- `copyfiles` is an npm dependency that we will need to support cross-platform copying of files when updating our `bundle` task.

To install these dependencies, run the following commands:

<NxCommands commands={["run dungeon_adventure.story_api:add --args boto3 uvicorn"]} />
<InstallCommand pkg="copyfiles" dev />

Now let's replace the contents of `packages/story_api/story_api/main.py` as follows:

```python
// packages/story_api/story_api/main.py
import json

from boto3 import client
from fastapi.responses import PlainTextResponse, StreamingResponse
from pydantic import BaseModel

from .init import app, lambda_handler

handler = lambda_handler

bedrock = client('bedrock-runtime')

class Action(BaseModel):
    role: str
    content: str

class StoryRequest(BaseModel):
    genre: str
    playerName: str
    actions: list[Action]

async def bedrock_stream(request: StoryRequest):
    messages = [
        {"role": "user", "content": "Continue or create a new story..."}
    ]

    for action in request.actions:
        messages.append({"role": action.role, "content": action.content})

    response = bedrock.invoke_model_with_response_stream(
        modelId='anthropic.claude-3-sonnet-20240229-v1:0',
        body=json.dumps({
            "system":f"""
            You are running an AI text adventure game in the {request.genre} genre.
            Player: {request.playerName}. Return less than 200 characters of text.
            """,
            "messages": messages,
            "max_tokens": 1000,
            "temperature": 0.7,
            "anthropic_version": "bedrock-2023-05-31"
        })
    )

    stream = response.get('body')
    if stream:
        for event in stream:
            chunk = event.get('chunk')
            if chunk:
                message = json.loads(chunk.get("bytes").decode())
                if message['type'] == "content_block_delta":
                    yield message['delta']['text'] or ""
                elif message['type'] == "message_stop":
                    yield "\n"

@app.post("/story/generate",
          openapi_extra={'x-streaming': True},
          response_class=PlainTextResponse)
def generate_story(request: StoryRequest) -> str:
    return StreamingResponse(bedrock_stream(request), media_type="text/plain")
```

Analyzing the code above:

- We use the `x-streaming` setting to indicate that this is a streaming API when we eventually generate our client SDK. This will allow us to consume this API in a streaming manner whilst maintaining type-safety!
- Our API simply returns a stream of text as defined by both the `media_type="text/plain"` and the `response_class=PlainTextResponse`

### Infrastructure

The [Infrastructure we set up previously](#game-ui-infrastructure) assumes that all API's have a API Gateway integrating with a Lambda. For our `story_api` we actually don't want to use API Gateway as this does not supporting streaming repsonses. Instead, we will use a [Lambda Function URL configured with response streaming](https://docs.aws.amazon.com/lambda/latest/dg/configuration-response-streaming.html).

To support this, we are going to make the following changes:

<Tabs>
<TabItem label="story-api.ts">
```diff lang="typescript"
// packages/common/constructs/src/app/http-apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import { HttpApi } from '../../core/http-api.js';
import { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';
import { Runtime } from 'aws-cdk-lib/aws-lambda';
+import { Effect, PolicyStatement } from 'aws-cdk-lib/aws-iam';

export class StoryApi extends HttpApi {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      defaultAuthorizer: new HttpIamAuthorizer(),
      apiName: 'StoryApi',
      runtime: Runtime.PYTHON_3_12,
+      apiType: 'function-url-streaming',
+      handler: 'run.sh',
      handlerFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/story_api/bundle',
          import.meta.url,
        ),
      ),
    });
+
+    this.routerFunction.addToRolePolicy(
+      new PolicyStatement({
+        effect: Effect.ALLOW,
+        actions: ['bedrock:InvokeModelWithResponseStream'],
+        resources: [
+          'arn:aws:bedrock:*::foundation-model/anthropic.claude-3-sonnet-20240229-v1:0',
+        ],
+      }),
+    );
  }
}
```
</TabItem>
<TabItem label="run.sh">
```bash
// packages/story_api/run.sh
#!/bin/bash

PATH=$PATH:$LAMBDA_TASK_ROOT/bin \
    PYTHONPATH=$PYTHONPATH:/opt/python:$LAMBDA_RUNTIME_DIR \
    exec python -m uvicorn --port=$PORT story_api.main:app
```
</TabItem>
<TabItem label="project.json">
```diff lang="json"
// packages/story_api/project.json
{
  "name": "dungeon_adventure.story_api",
  "$schema": "../../node_modules/nx/schemas/project-schema.json",
  "projectType": "application",
  "sourceRoot": "packages/story_api/story_api",
  "targets": {
    ...
    "bundle": {
      "cache": true,
      "executor": "nx:run-commands",
      "outputs": ["{workspaceRoot}/dist/packages/story_api/bundle"],
      "options": {
        "commands": [
          "uv export --frozen --no-dev --no-editable --project story_api -o dist/packages/story_api/bundle/requirements.txt",
          "uv pip install -n --no-installer-metadata --no-compile-bytecode --python-platform x86_64-manylinux2014 --python `uv python pin` --target dist/packages/story_api/bundle -r dist/packages/story_api/bundle/requirements.txt",
+          "copyfiles -f packages/story_api/run.sh dist/packages/story_api/bundle"
        ],
        "parallel": false
      },
      "dependsOn": ["compile"]
    },
    ...
  }
}
```
</TabItem>
<TabItem label="http-api.ts">
```typescript
// packages/common/constructs/src/core/http-api.ts
import { Construct } from 'constructs';
import { CfnOutput, Duration, Stack } from 'aws-cdk-lib';
import {
  CorsHttpMethod,
  HttpApi as _HttpApi,
  HttpMethod,
  IHttpRouteAuthorizer,
} from 'aws-cdk-lib/aws-apigatewayv2';
import { HttpLambdaIntegration } from 'aws-cdk-lib/aws-apigatewayv2-integrations';
import {
  Code,
  Function,
  FunctionUrl,
  FunctionUrlAuthType,
  InvokeMode,
  LayerVersion,
  Runtime,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import { Effect, IRole, PolicyStatement } from 'aws-cdk-lib/aws-iam';
import { RuntimeConfig } from './runtime-config.js';

export interface HttpApiProps {
  readonly apiName: string;
  readonly handler: string;
  readonly handlerFilePath: string;
  readonly runtime: Runtime;
  readonly defaultAuthorizer: IHttpRouteAuthorizer;
  readonly apiType?: 'api-gateway' | 'function-url-streaming';
  readonly allowedOrigins?: string[];
}

export class HttpApi extends Construct {
  public readonly api?: _HttpApi;
  public readonly routerFunctionUrl?: FunctionUrl;
  public readonly routerFunction: Function;

  constructor(scope: Construct, id: string, props: HttpApiProps) {
    super(scope, id);

    this.routerFunction = new Function(this, `${id}Handler`, {
      timeout: Duration.seconds(30),
      runtime: props.runtime,
      handler: props.handler,
      code: Code.fromAsset(props.handlerFilePath),
      tracing: Tracing.ACTIVE,
      environment: {
        AWS_CONNECTION_REUSE_ENABLED: '1',
      },
    });

    let apiUrl;
    if (props.apiType === 'function-url-streaming') {
      const stack = Stack.of(this);
      this.routerFunction.addLayers(
        LayerVersion.fromLayerVersionArn(
          this,
          'LWALayer',
          `arn:aws:lambda:${stack.region}:753240598075:layer:LambdaAdapterLayerX86:24`,
        ),
      );
      this.routerFunction.addEnvironment('PORT', '8000');
      this.routerFunction.addEnvironment(
        'AWS_LWA_INVOKE_MODE',
        'response_stream',
      );
      this.routerFunction.addEnvironment(
        'AWS_LAMBDA_EXEC_WRAPPER',
        '/opt/bootstrap',
      );
      this.routerFunctionUrl = this.routerFunction.addFunctionUrl({
        authType: FunctionUrlAuthType.AWS_IAM,
        invokeMode: InvokeMode.RESPONSE_STREAM,
        cors: {
          allowedOrigins: props.allowedOrigins ?? ['*'],
          allowedHeaders: [
            'authorization',
            'content-type',
            'x-amz-content-sha256',
            'x-amz-date',
            'x-amz-security-token',
          ],
        },
      });
      apiUrl = this.routerFunctionUrl.url;
    } else {
      this.api = new _HttpApi(this, id, {
        corsPreflight: {
          allowOrigins: props.allowedOrigins ?? ['*'],
          allowMethods: [CorsHttpMethod.ANY],
          allowHeaders: [
            'authorization',
            'content-type',
            'x-amz-content-sha256',
            'x-amz-date',
            'x-amz-security-token',
          ],
        },
        defaultAuthorizer: props.defaultAuthorizer,
      });

      this.api.addRoutes({
        path: '/{proxy+}',
        methods: [
          HttpMethod.GET,
          HttpMethod.DELETE,
          HttpMethod.POST,
          HttpMethod.PUT,
          HttpMethod.PATCH,
          HttpMethod.HEAD,
        ],
        integration: new HttpLambdaIntegration(
          'RouterIntegration',
          this.routerFunction,
        ),
      });
      apiUrl = this.api.url;
    }

    new CfnOutput(this, `${props.apiName}Url`, { value: apiUrl! });

    RuntimeConfig.ensure(this).config.httpApis = {
      ...RuntimeConfig.ensure(this).config.httpApis!,
      [props.apiName]: apiUrl,
    };
  }

  public grantInvokeAccess(role: IRole) {
    if (this.api) {
      role.addToPrincipalPolicy(
        new PolicyStatement({
          effect: Effect.ALLOW,
          actions: ['execute-api:Invoke'],
          resources: [this.api.arnForExecuteApi('*', '/*', '*')],
        }),
      );
    } else if (this.routerFunction) {
      role.addToPrincipalPolicy(
        new PolicyStatement({
          effect: Effect.ALLOW,
          actions: ['lambda:InvokeFunctionUrl'],
          resources: [this.routerFunction.functionArn],
          conditions: {
            StringEquals: {
              'lambda:FunctionUrlAuthType': 'AWS_IAM',
            },
          },
        }),
      );
    }
  }
}
```
</TabItem>
</Tabs>

### Deployment and testing

First, lets build the codebase:

<NxCommands commands={['run-many --target build --all']} />

<Drawer title="Deployment command" trigger="Your application can now be deployed by running the following command:">

You can also deploy all stacks contained in the CDK application by running:

<NxCommands commands={['nx run @dungeon-adventure/infra:deploy --all']} />

This is **not recommended** given that you may choose to seperate out your deployment stages as seperate stacks `i.e. infra-prod`. In this case the `--all` flag will attempt to deploy all stacks which can result in unwanted deployments!

</Drawer>

<NxCommands commands={['nx run @dungeon-adventure/infra:deploy infra-sandbox']} />

Once the deployment completes, you should see some outputs similar to the following _(some values have been redacted)_:

```bash
infra-sandbox
infra-sandbox: deploying... [2/2]

 âœ…  infra-sandbox (no changes)

âœ¨  Deployment time: 354s

Outputs:
infra-sandbox.ElectroDbTableTableNameXXX = infra-sandbox-ElectroDbTableXXX-YYY
infra-sandbox.GameApiGameApiUrlXXX = https://xxx.region.amazonaws.com/
infra-sandbox.GameUIDistributionDomainNameXXX = xxx.cloudfront.net
infra-sandbox.StoryApiStoryApiUrlXXX = https://xxx.lambda-url.ap-southeast-2.on.aws/
infra-sandbox.UserIdentityUserIdentityIdentityPoolIdXXX = region:xxx
infra-sandbox.UserIdentityUserIdentityUserPoolIdXXX = region_xxx
```

We can test our API by either:
<ul>
<li>Starting a local instance of the FastApi server and invoke the API's using `curl`.</li>
<li>
<Drawer title="Sigv4 enabled curl" trigger="Calling the deployed API using sigv4 enabled curl directly">
You can either add the following script to your `.bashrc` file (and `source` it) or simply paste the following into the same terminal you wish to run the command in.
```bash
// ~/.bashrc
acurl () {
    REGION=$1
    SERVICE=$2
    shift; shift;
    curl --aws-sigv4 "aws:amz:$REGION:$SERVICE" --user "$(aws configure get aws_access_key_id):$(aws configure get aws_secret_access_key)" -H "X-Amz-Security-Token: $(aws configure get aws_session_token)" "$@"
}
```

Then to make a sigv4 authenticated curl request, you can simply invoke `acurl` like the following examples:

###### API Gateway
```bash
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### Streaming Lambda function url
```bash
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
</Drawer>
</li>
</ul>

<Tabs>
  <TabItem label="Local">
    <NxCommands commands={["run dungeon_adventure.story_api:serve"]} postCommands={['curl -N -X POST http://127.0.0.1:8000/story/generate \\', '  -d "{\"genre\":\"superhero\", \"actions\":[], \"playerName\":\"UnnamedHero\"}" \\', '  -H "Content-Type: application/json"']} />
  </TabItem>
  <TabItem label="Deployed">
```bash "https://xxx.lambda-url.ap-southeast-2.on.aws/" "ap-southeast-2"
acurl ap-southeast-2 lambda -XN POST \
  https://xxx.lambda-url.ap-southeast-2.on.aws/story/generate \
  -d "{\"genre\":\"superhero\", \"actions\":[], \"playerName\":\"UnnamedHero\"}" \
  -H "Content-Type: application/json"
```
    <Aside type="caution">
    Use the CDK deploy output value of `infra-sandbox.StoryApiStoryApiUrlXXX` to replace the highlighted url placeholder and set the region accordingly.
    </Aside>
  </TabItem>
</Tabs>

If the command executes successfully, you should see a response being streamed similar to:

```
UnnamedHero stood tall, his cape billowing in the wind. Danger lurked in the city streets, but he was ready to face any threat with his incredible powers and unwavering courage.
```

Congratulations. You have built and deployed your first API using FastAPI!  ðŸŽ‰ðŸŽ‰ðŸŽ‰

## Module 4: UI implementation

To start building the UI, we want to configure our local dev server to point to our deployed sandbox. To do this, run the following command:

<NxCommands commands={["run @dungeon-adventure/game-ui:load:runtime-config"]} />

This command will pull down the `runtime-config.json` that is deployed and store it locally within the `packages/game-ui/public` folder.

Now we can start the dev server with the following command:

<NxCommands commands={["run @dungeon-adventure/game-ui:serve"]} />

You will be prompted to login at which time you can follow the prompts to create a new user. Once completed you should see our baseline website:

<Image src={baselineWebsitePng} alt="baseline-website.png" width="800" height="600" />

<Aside type="caution">
_We will keep the dev server running throughout the remainder of this module as it will automatically hot-reload any changes we make._
</Aside>

### Create a new '/game' route

Let's showcase the capabilities of `@tanstack/react-router` by creating a new type-safe route. To do this, simply create an empty file at the following location: `packages/game-ui/src/routes/game/index.tsx`. Pay close attention to the dev server logs:

```bash
â™»ï¸  Regenerating routes...
ðŸŸ¡ Updating /Users/dimecha/dungeon-adventure/packages/game-ui/src/routes/game/index.tsx
ðŸŸ¡ Updating /Users/dimecha/dungeon-adventure/packages/game-ui/src/routeTree.gen.ts
âœ… Processed routes in 27ms
```

The `@tanstack/react-router` automatically has configured your new route and you will notice that the file you just created is already populated with the route path:

```tsx
import { createFileRoute } from '@tanstack/react-router'

export const Route = createFileRoute('/game/')({
  component: RouteComponent,
})

function RouteComponent() {
  return <div>Hello "/game/"!</div>
}
```

Now if you navigate to `http://localhost:4200/game` you will see your new page has been rendered!

<Image src={baselineGamePng} alt="baseline-game.png" width="800" height="600" />

Let's also update the `index.tsx` file to load our new `/game` route by default. Notice how when you update the `to` field, you have a list of type-safe routes to choose from.

```tsx
// packages/game-ui/src/routes/index.tsx
import { createFileRoute, Navigate } from '@tanstack/react-router';

export const Route = createFileRoute('/')({
+  component: () => <Navigate to="/game" />,
});

```

Finally we can delete the `packages/game-ui/src/routes/welcome/` folder as this is no longer required.

### Layout updates

The default layout that is configured is more akin to a SaaS style business application than a game. We are going to re-configure the layout and re-theme it to be more akin to a dungeon style game.

Let's make the following changes to `packages/game-ui/src`:

<Tabs>
<TabItem label="config.ts">
```diff lang="typescript"
// packages/game-ui/src/config.ts
export default {
+  applicationName: 'Dungeon Adventure',
-  logo: 'data:image/svg+xml;base64,PCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KDTwhLS0gVXBsb2FkZWQgdG86IFNWRyBSZXBvLCB3d3cuc3ZncmVwby5jb20sIFRyYW5zZm9ybWVkIGJ5OiBTVkcgUmVwbyBNaXhlciBUb29scyAtLT4KPHN2ZyBmaWxsPSIjMjQ4YmFlIiB3aWR0aD0iODAwcHgiIGhlaWdodD0iODAwcHgiIHZpZXdCb3g9IjAgMCA1MTIgNTEyIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHN0cm9rZT0iIzI0OGJhZSI+Cg08ZyBpZD0iU1ZHUmVwb19iZ0NhcnJpZXIiIHN0cm9rZS13aWR0aD0iMCIvPgoNPGcgaWQ9IlNWR1JlcG9fdHJhY2VyQ2FycmllciIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cg08ZyBpZD0iU1ZHUmVwb19pY29uQ2FycmllciI+Cg08dGl0bGU+aW9uaWNvbnMtdjVfbG9nb3M8L3RpdGxlPgoNPHBhdGggZD0iTTQxMC42NiwxODAuNzJoMHEtNy42Ny0yLjYyLTE1LjQ1LTQuODgsMS4yOS01LjI1LDIuMzgtMTAuNTZjMTEuNy01Ni45LDQuMDUtMTAyLjc0LTIyLjA2LTExNy44My0yNS0xNC40OC02NiwuNjEtMTA3LjM2LDM2LjY5cS02LjEsNS4zNC0xMS45NSwxMS0zLjktMy43Ni04LTcuMzZjLTQzLjM1LTM4LjU4LTg2LjgtNTQuODMtMTEyLjg4LTM5LjY5LTI1LDE0LjUxLTMyLjQzLDU3LjYtMjEuOSwxMTEuNTNxMS41OCw4LDMuNTUsMTUuOTNjLTYuMTUsMS43NS0xMi4wOSwzLjYyLTE3Ljc3LDUuNkM0OC40NiwxOTguOSwxNiwyMjYuNzMsMTYsMjU1LjU5YzAsMjkuODIsMzQuODQsNTkuNzIsODcuNzcsNzcuODVxNi40NCwyLjE5LDEzLDQuMDdRMTE0LjY0LDM0NiwxMTMsMzU0LjY4Yy0xMCw1My0yLjIsOTUuMDcsMjIuNzUsMTA5LjQ5LDI1Ljc3LDE0Ljg5LDY5LS40MSwxMTEuMTQtMzcuMzFxNS00LjM4LDEwLTkuMjUsNi4zMiw2LjExLDEzLDExLjg2YzQwLjgsMzUuMTgsODEuMDksNDkuMzksMTA2LDM0LjkzLDI1Ljc1LTE0Ljk0LDM0LjEyLTYwLjE0LDIzLjI1LTExNS4xM3EtMS4yNS02LjMtMi44OC0xMi44Niw0LjU2LTEuMzUsOC45My0yLjc5YzU1LTE4LjI3LDkwLjgzLTQ3LjgxLDkwLjgzLTc4QzQ5NiwyMjYuNjIsNDYyLjUsMTk4LjYxLDQxMC42NiwxODAuNzJabS0xMjktODEuMDhjMzUuNDMtMzAuOTEsNjguNTUtNDMuMTEsODMuNjUtMzQuMzloMGMxNi4wNyw5LjI5LDIyLjMyLDQ2Ljc1LDEyLjIyLDk1Ljg4cS0xLDQuOC0yLjE2LDkuNTdhNDg3LjgzLDQ4Ny44MywwLDAsMC02NC4xOC0xMC4xNiw0ODEuMjcsNDgxLjI3LDAsMCwwLTQwLjU3LTUwLjc1UTI3NiwxMDQuNTcsMjgxLjY0LDk5LjY0Wk0xNTcuNzMsMjgwLjI1cTYuNTEsMTIuNiwxMy42MSwyNC44OSw3LjIzLDEyLjU0LDE1LjA3LDI0LjcxYTQzNS4yOCw0MzUuMjgsMCwwLDEtNDQuMjQtNy4xM0MxNDYuNDEsMzA5LDE1MS42MywyOTQuNzUsMTU3LjczLDI4MC4yNVptMC00OC4zM2MtNi0xNC4xOS0xMS4wOC0yOC4xNS0xNS4yNS00MS42MywxMy43LTMuMDcsMjguMy01LjU4LDQzLjUyLTcuNDhxLTcuNjUsMTEuOTQtMTQuNzIsMjQuMjNUMTU3LjcsMjMxLjkyWm0xMC45LDI0LjE3cTkuNDgtMTkuNzcsMjAuNDItMzguNzhoMHExMC45My0xOSwyMy4yNy0zNy4xM2MxNC4yOC0xLjA4LDI4LjkyLTEuNjUsNDMuNzEtMS42NXMyOS41Mi41Nyw0My43OSwxLjY2cTEyLjIxLDE4LjA5LDIzLjEzLDM3dDIwLjY5LDM4LjZRMzM0LDI3NS42MywzMjMsMjk0LjczaDBxLTEwLjkxLDE5LTIzLDM3LjI0Yy0xNC4yNSwxLTI5LDEuNTUtNDQsMS41NXMtMjkuNDctLjQ3LTQzLjQ2LTEuMzhxLTEyLjQzLTE4LjE5LTIzLjQ2LTM3LjI5VDE2OC42LDI1Ni4wOVpNMzQwLjc1LDMwNXE3LjI1LTEyLjU4LDEzLjkyLTI1LjQ5aDBhNDQwLjQxLDQ0MC40MSwwLDAsMSwxNi4xMiw0Mi4zMkE0MzQuNDQsNDM0LjQ0LDAsMCwxLDMyNiwzMjkuNDhRMzMzLjYyLDMxNy4zOSwzNDAuNzUsMzA1Wm0xMy43Mi03My4wN3EtNi42NC0xMi42NS0xMy44MS0yNWgwcS03LTEyLjE4LTE0LjU5LTI0LjA2YzE1LjMxLDEuOTQsMzAsNC41Miw0My43Nyw3LjY3QTQzOS44OSw0MzkuODksMCwwLDEsMzU0LjQ3LDIzMS45M1pNMjU2LjIzLDEyNC40OGgwYTQzOS43NSw0MzkuNzUsMCwwLDEsMjguMjUsMzQuMThxLTI4LjM1LTEuMzUtNTYuNzQsMEMyMzcuMDcsMTQ2LjMyLDI0Ni42MiwxMzQuODcsMjU2LjIzLDEyNC40OFpNMTQ1LjY2LDY1Ljg2YzE2LjA2LTkuMzIsNTEuNTcsNCw4OSwzNy4yNywyLjM5LDIuMTMsNC44LDQuMzYsNy4yLDYuNjdBNDkxLjM3LDQ5MS4zNywwLDAsMCwyMDEsMTYwLjUxYTQ5OS4xMiw0OTkuMTIsMCwwLDAtNjQuMDYsMTBxLTEuODMtNy4zNi0zLjMtMTQuODJoMEMxMjQuNTksMTA5LjQ2LDEzMC41OCw3NC42MSwxNDUuNjYsNjUuODZaTTEyMi4yNSwzMTcuNzFxLTYtMS43MS0xMS44NS0zLjcxYy0yMy40LTgtNDIuNzMtMTguNDQtNTYtMjkuODFDNDIuNTIsMjc0LDM2LjUsMjYzLjgzLDM2LjUsMjU1LjU5YzAtMTcuNTEsMjYuMDYtMzkuODUsNjkuNTItNTVxOC4xOS0yLjg1LDE2LjUyLTUuMjFhNDkzLjU0LDQ5My41NCwwLDAsMCwyMy40LDYwLjc1QTUwMi40Niw1MDIuNDYsMCwwLDAsMTIyLjI1LDMxNy43MVptMTExLjEzLDkzLjY3Yy0xOC42MywxNi4zMi0zNy4yOSwyNy44OS01My43NCwzMy43MmgwYy0xNC43OCw1LjIzLTI2LjU1LDUuMzgtMzMuNjYsMS4yNy0xNS4xNC04Ljc1LTIxLjQ0LTQyLjU0LTEyLjg1LTg3Ljg2cTEuNTMtOCwzLjUtMTZhNDgwLjg1LDQ4MC44NSwwLDAsMCw2NC42OSw5LjM5LDUwMS4yLDUwMS4yLDAsMCwwLDQxLjIsNTFDMjM5LjU0LDQwNS44MywyMzYuNDksNDA4LjY1LDIzMy4zOCw0MTEuMzhabTIzLjQyLTIzLjIyYy05LjcyLTEwLjUxLTE5LjQyLTIyLjE0LTI4Ljg4LTM0LjY0cTEzLjc5LjU0LDI4LjA4LjU0YzkuNzgsMCwxOS40Ni0uMjEsMjktLjY0QTQzOS4zMyw0MzkuMzMsMCwwLDEsMjU2LjgsMzg4LjE2Wm0xMjQuNTIsMjguNTljLTIuODYsMTUuNDQtOC42MSwyNS43NC0xNS43MiwyOS44Ni0xNS4xMyw4Ljc4LTQ3LjQ4LTIuNjMtODIuMzYtMzIuNzItNC0zLjQ0LTgtNy4xMy0xMi4wNy0xMWE0ODQuNTQsNDg0LjU0LDAsMCwwLDQwLjIzLTUxLjIsNDc3Ljg0LDQ3Ny44NCwwLDAsMCw2NS0xMC4wNXExLjQ3LDUuOTQsMi42LDExLjY0aDBDMzgzLjgxLDM3Ny41OCwzODQuNSwzOTkuNTYsMzgxLjMyLDQxNi43NVptMTcuNC0xMDIuNjRoMGMtMi42Mi44Ny01LjMyLDEuNzEtOC4wNiwyLjUzYTQ4My4yNiw0ODMuMjYsMCwwLDAtMjQuMzEtNjAuOTQsNDgxLjUyLDQ4MS41MiwwLDAsMCwyMy4zNi02MC4wNmM0LjkxLDEuNDMsOS42OCwyLjkzLDE0LjI3LDQuNTIsNDQuNDIsMTUuMzIsNzEuNTIsMzgsNzEuNTIsNTUuNDNDNDc1LjUsMjc0LjE5LDQ0Ni4yMywyOTguMzMsMzk4LjcyLDMxNC4xMVoiLz4KDTxwYXRoIGQ9Ik0yNTYsMjk4LjU1YTQzLDQzLDAsMSwwLTQyLjg2LTQzQTQyLjkxLDQyLjkxLDAsMCwwLDI1NiwyOTguNTVaIi8+Cg08L2c+Cg08L3N2Zz4=',
};
```
</TabItem>
<TabItem label="AppLayout/index.tsx">
```tsx
// packages/game-ui/src/AppLayout/index.tsx
import { useAuth } from 'react-oidc-context';
import * as React from 'react';
import Config from '../../config';
import { TopNavigation } from '@cloudscape-design/components';
import { Outlet } from '@tanstack/react-router';

/**
 * Defines the App layout and contains logic for routing.
 */
const AppLayout: React.FC = () => {
  const { user, removeUser, signoutRedirect, clearStaleState } = useAuth();

  return (
    <>
      <TopNavigation
        identity={{
          href: '/',
          title: Config.applicationName,
        }}
        utilities={[
          {
            type: 'menu-dropdown',
            text: `${user?.profile?.['cognito:username']}`,
            iconName: 'user-profile-active',
            onItemClick: (e) => {
              if (e.detail.id === 'signout') {
                removeUser();
                signoutRedirect({
                  post_logout_redirect_uri: window.location.origin,
                  extraQueryParams: {
                    redirect_uri: window.location.origin,
                    response_type: 'code',
                  },
                });
                clearStaleState();
              }
            },
            items: [{ id: 'signout', text: 'Sign out' }],
          },
        ]}
      />
      <Outlet />
    </>
  );
};
export default AppLayout;
```
</TabItem>
<TabItem label="styles.css">
```css
// packages/game-ui/src/styles.css

/* Game styles */
:root {
  --primary-color: rgba(252, 214, 112, 1);
  --secondary-color: rgba(252, 214, 112, 0.8);
  --background-dark: #161d26;
  --background-light: #2a2c3c;
  --text-light: #e1e1e6;
  --text-dark: #1f2937;
}

div#root {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

html,
body {
  margin: 0;
  padding: 0;
  min-height: 100vh;
  width: 100%;
  font-family:
    -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue',
    Arial, sans-serif;
  background: var(--background-dark);
  color: var(--text-dark);
}

/* Game container and interface */
.game-interface {
  margin: 2rem;
  min-height: 100%;
  flex-grow: 1;
  display: flex;
  flex-direction: column;
}

/* Header styles */
.game-header {
  text-align: center;
  margin-bottom: 2rem;
  padding: 1rem;
}

.game-header h1 {
  font-size: 2.5rem;
  font-weight: bold;
  background: linear-gradient(45deg, #ffd700, #ff6b6b);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
  margin: 0;
}

/* Saved games section */
.saved-games {
  margin-bottom: 2rem;
}

.saved-games h2,
.new-game h2 {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  color: var(--text-light);
}

.game-list {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.game-session {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 8px;
  padding: 1rem;
  cursor: pointer;
  transition: all 0.3s ease;
  width: 100%;
  text-align: left;
}

.game-session:hover {
  transform: translateY(-2px);
  background: rgba(255, 255, 255, 0.15);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.player-name {
  font-weight: 600;
  margin-bottom: 0.25rem;
  color: var(--text-light);
}

.genre-name {
  font-size: 0.875rem;
  color: rgba(255, 255, 255, 0.7);
}

/* New game section */
.new-game {
  margin-top: 2rem;
}

.game-setup {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

span[data-style='generating'] {
  color: rgba(252, 214, 112, 1) !important;
}

.name-input,
.action-input {
  width: 100%;
  padding: 0.75rem;
  /* background: rgba(255, 255, 255, 0.1); */
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 8px;
  /* color: var(--text-light); */
  font-size: 1rem;
}

.name-input:focus,
.action-input:focus {
  outline: none;
  border-color: var(--primary-color);
  /* background: rgba(255, 255, 255, 0.15); */
}

.genre-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 1rem;
}

.genre-button {
  background: rgba(255, 255, 255, 0.1);
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 8px;
  padding: 1rem;
  color: var(--text-light);
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
}

.genre-button:hover {
  background: rgba(252, 214, 112, 1);
  color: var(--text-dark);
  border-color: var(--primary-color);
  transform: translateY(-2px);
}

/* Messages area */
.messages-area {
  flex: 1;
  overflow-y: auto;
  margin-bottom: 1rem;
  align-content: flex-end;
}

.messages-container {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  padding: 1rem;
}

.message {
  padding: 1rem;
  border-radius: 8px;
  max-width: 80%;
  line-height: 1.5;
}

.message.assistant {
  background: var(--secondary-color);
  border-left: 4px solid var(--primary-color);
  margin-right: auto;
  word-wrap: break-word;
  white-space: pre-wrap;
  margin: 0 !important;
}

.message.user {
  background: rgba(220, 220, 220, 0.7);
  border-right: 4px solid rgba(220, 220, 220, 0.7);
  margin-left: auto;
}

/* Input area */
.input-area {
  padding: 1rem;
  position: sticky;
  bottom: 0;
}

/* Scrollbar styling */
.messages-area::-webkit-scrollbar {
  width: 6px;
}

.messages-area::-webkit-scrollbar-track {
  background: transparent;
}

.messages-area::-webkit-scrollbar-thumb {
  background-color: rgba(255, 255, 255, 0.3);
  border-radius: 3px;
}

/* For Firefox */
.messages-area {
  scrollbar-width: thin;
  scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
}
```
</TabItem>
</Tabs>

You can also delete the `packages/game-ui/src/components/AppLayout/navitems.ts` file as it is unused.

### Game pages

Let's create the Game pages which will call our APIs and finish our game implementation:

<Tabs>
<TabItem label="index.tsx">
```tsx
// packages/game-ui/src/routes/game/index.tsx
import { FormField, Spinner } from '@cloudscape-design/components';
import { useInfiniteQuery, useMutation } from '@tanstack/react-query';
import { createFileRoute, useNavigate } from '@tanstack/react-router';
import {
  createRef,
  MutableRefObject,
  useEffect,
  useMemo,
  useState,
} from 'react';
import { useGameApi } from '../../hooks/useGameApi';
import { IAction, IGame } from ':dungeon-adventure/game-api-schema';

type IGameState = Omit<IGame, 'lastUpdated'> & { actions: IAction[] };

export const Route = createFileRoute('/game/')({
  component: RouteComponent,
});

// hook to check if a ref is visible on the screen
export function useIsVisible(ref: MutableRefObject<any>) {
  const [isIntersecting, setIntersecting] = useState(false);

  useEffect(() => {
    const observer = new IntersectionObserver(([entry]) =>
      setIntersecting(entry.isIntersecting),
    );

    ref.current && observer.observe(ref.current);
    return () => {
      observer.disconnect();
    };
  }, [ref]);

  return isIntersecting;
}

function RouteComponent() {
  const [playerName, setPlayerName] = useState('');
  const navigate = useNavigate();
  const ref = createRef();
  const isLastGameVisible = useIsVisible(ref);

  const gameApi = useGameApi();
  const saveGameMutation = useMutation(gameApi.games.save.mutationOptions());

  const {
    data: gamesPages,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery(
    gameApi.games.query.infiniteQueryOptions(
      { limit: 10 },
      { getNextPageParam: ({ cursor }) => cursor },
    ),
  );
  const games = useMemo(() => {
    return gamesPages?.pages.flatMap((page) => page.items) || [];
  }, [gamesPages]);

  // Fetch more games if the last game is visible and there are more games
  useEffect(() => {
    if (isLastGameVisible && hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  }, [isFetchingNextPage, hasNextPage, fetchNextPage, isLastGameVisible]);

  const playerAlreadyExists = (playerName?: string) => {
    return !!games?.find((s) => s.playerName === playerName);
  };

  // create a new game
  const handleStartGame = async (
    playerName: string,
    genre: IGameState['genre'],
  ) => {
    if (playerAlreadyExists(playerName)) {
      return;
    }
    try {
      await saveGameMutation.mutateAsync({
        playerName,
        genre,
      });

      await handleLoadGame(playerName, genre);
    } catch (error) {
      console.error('Failed to start game:', error);
    }
  };

  // load an existing game
  const handleLoadGame = async (
    playerName: string,
    genre: IGameState['genre'],
  ) => {
    await navigate({
      to: '/game/$playerName',
      params: { playerName },
      search: { genre },
    });
  };

  return (
    <div className="game-interface">
      <header className="game-header">
        <h1>AI Dungeon Adventure</h1>
      </header>

      {/* New Game Section */}
      <div className="new-game">
        <h2>Start New Game</h2>
        <div className="game-setup">
          <FormField
            errorText={
              playerAlreadyExists(playerName)
                ? `${playerName} already exists`
                : undefined
            }
          >
            <input
              type="text"
              placeholder="Enter your name"
              className="name-input"
              onChange={(e) => setPlayerName(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === 'Enter') {
                  const input = e.currentTarget;
                  handleStartGame(input.value, 'medieval');
                }
              }}
            />
          </FormField>
          <div className="genre-grid">
            {(['zombie', 'superhero', 'medieval'] as const).map((genre) => (
              <button
                key={genre}
                className="genre-button"
                onClick={() => {
                  const playerName = document.querySelector('input')?.value;
                  if (playerName) {
                    handleStartGame(playerName, genre);
                  }
                }}
              >
                {genre.charAt(0).toUpperCase() + genre.slice(1)}
              </button>
            ))}
          </div>
        </div>
      </div>

      {/* Saved Games Section */}
      {games && games.length > 0 && (
        <div className="saved-games">
          <h2>Continue Game</h2>
          <div className="game-list">
            {games.map((game, idx) => (
              <button
                key={game.playerName}
                ref={idx === games.length - 1 ? ref : undefined}
                onClick={() => handleLoadGame(game.playerName, game.genre)}
                className="game-session"
              >
                <div className="player-name">{game.playerName}</div>
                <div className="genre-name">
                  {game.genre.charAt(0).toUpperCase() + game.genre.slice(1)}
                </div>
              </button>
            ))}
            {isFetchingNextPage && <Spinner data-style="generating" size="big" />}
          </div>
        </div>
      )}
    </div>
  );
}
```
</TabItem>
<TabItem label="$playerName.tsx">

```tsx title="packages/game-ui/src/routes/game/$playerName.tsx"
import { PromptInput, Spinner } from '@cloudscape-design/components';
import { useMutation, useQuery } from '@tanstack/react-query';
import { createFileRoute } from '@tanstack/react-router';
import { useEffect, useRef, useState } from 'react';
import { useGameApi } from '../../hooks/useGameApi';
import { useStoryApi } from '../../hooks/useStoryApi';
import type { IAction, IGame } from ':dungeon-adventure/game-api-schema';

type IGameState = Omit<IGame, 'lastUpdated'> & { actions: IAction[] };

export const Route = createFileRoute('/game/$playerName')({
  component: RouteComponent,
  validateSearch: (search: Record<string, unknown>) => {
    return {
      genre: search.genre as IGameState['genre'],
    };
  },
});

function RouteComponent() {
  const { playerName } = Route.useParams();
  const { genre } = Route.useSearch();

  const [currentInput, setCurrentInput] = useState('');
  const [streamingContent, setStreamingContent] = useState('');

  const messagesEndRef = useRef<HTMLDivElement>(null);

  const gameApi = useGameApi();
  const storyApi = useStoryApi();
  const saveActionMutation = useMutation(
    gameApi.actions.save.mutationOptions(),
  );
  const gameActionsQuery = useQuery(
    gameApi.actions.query.queryOptions({ playerName, limit: 100 }),
  );

  // no actions - therefore must be a new game - generate initial story
  useEffect(() => {
    if (
      !gameActionsQuery.isLoading &&
      gameActionsQuery.data?.items &&
      gameActionsQuery.data?.items.length === 0
    ) {
      generateStory({
        playerName,
        genre,
        actions: [],
      });
    }
  }, [gameActionsQuery.data?.items, gameActionsQuery.isLoading]);

  const generateStoryMutation = useMutation({
    mutationFn: async ({ playerName, genre, actions }: IGameState) => {
      let content = '';
      for await (const chunk of storyApi.generateStory({
        playerName,
        genre,
        actions,
      })) {
        content += chunk;
        // make chunks available to render in a streaming fashion
        setStreamingContent(content);
      }

      return content;
    },
  });

  // scroll to the last message
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  // scroll to the bottom whenever gameActionsQuery is fetched or whenever streaming content changes
  useEffect(() => {
    scrollToBottom();
  }, [streamingContent, gameActionsQuery]);

  // progress the story
  const generateStory = async ({ playerName, genre, actions }: IGameState) => {
    try {
      const content = await generateStoryMutation.mutateAsync({
        playerName,
        genre,
        actions,
      });

      // Save assistant's response
      await saveActionMutation.mutateAsync({
        playerName,
        role: 'assistant',
        content,
      });

      await gameActionsQuery.refetch();

      setStreamingContent('');
    } catch (error) {
      console.error('Failed to generate story:', error);
    }
  };

  // progress the story when the user submits input
  const handleSubmitAction = async () => {
    if (!currentInput.trim()) return;

    const userAction: IAction = {
      playerName,
      role: 'user' as const,
      content: currentInput,
      timestamp: new Date().toISOString(),
    };

    // Save user action
    await saveActionMutation.mutateAsync(userAction);
    await gameActionsQuery.refetch();

    setCurrentInput('');

    // Generate response
    await generateStory({
      genre,
      playerName,
      actions: [...(gameActionsQuery.data?.items ?? []), userAction],
    });
  };

  return (
    <div className="game-interface">
      <div className="messages-area">
        <div className="messages-container">
          {gameActionsQuery.data?.items
            .concat(
              streamingContent.length > 0
                ? [
                    {
                      playerName,
                      role: 'assistant',
                      content: streamingContent,
                      timestamp: new Date().toISOString(),
                    },
                  ]
                : [],
            )
            .map((action, i) => (
              <div
                key={i}
                className={`message ${
                  action.role === 'assistant' ? 'assistant' : 'user'
                }`}
              >
                {action.content}
              </div>
            ))}
          {generateStoryMutation.isPending && streamingContent.length === 0 && (
            <Spinner data-style="generating" size="big" />
          )}
          <div ref={messagesEndRef} />
        </div>
      </div>
      <div className="input-area">
        <PromptInput
          onChange={({ detail }) => setCurrentInput(detail.value)}
          value={currentInput}
          actionButtonAriaLabel="Send message"
          actionButtonIconName="send"
          ariaLabel="Default prompt input"
          placeholder="What do you do?"
          onAction={handleSubmitAction}
        />
      </div>
    </div>
  );
}
```

<Aside type="tip">
The `$playerName` syntax will instruct `@tanstack/react-router` to treat `playerName` as a [path param](https://tanstack.com/router/v1/docs/framework/react/guide/path-params). Additionally, we implement the `validateSearch` method which ensures that the `genre` query parameter is strongly typed to our genre enum.
</Aside>
</TabItem>
</Tabs>

Once you make these changes, your local dev server (http://localhost:4200/) should now have your game ready to play!

<Drawer title="Build and Deploy" trigger="You can also build & deploy your code to Cloudfront if you prefer also.">

To build and deploy your code, run the following commands:

<NxCommands commands={['run-many --target build --all', 'nx run @dungeon-adventure/infra:deploy infra-sandbox']} />

Once deployed, navigate to your Cloudfront url which can be found by inspecting the cdk deploy outputs.

</Drawer>

<Image src={gameSelectPng} alt="game-select.png" width="500" height="400" />
<div style="margin-top: -100px; margin-left: 100px;">
<Image src={gameConversationPng} alt="game-conversation.png" width="500" height="400" />
</div>

## Module 5: Build a Generator (Optional)

We've leveraged the power of `@aws/nx-plugin`'s generators to build our dungeon adventure game. Now it's time to try building a generator of our own!

### Check Out the Plugin

First, let's clone the plugin:

```bash
git clone git@github.com:awslabs/nx-plugin-for-aws.git
```

Next, install and build:

```bash
cd nx-plugin-for-aws
pnpm i
pnpm nx run-many --target build --all
```

### Create an Empty Generator

Let's create a new generator. Our objective will be to generate a new procedure for our tRPC API.

Let's create the new generator in `packages/nx-plugin/src/trpc/procedure`. We'll start by creating the schema, and an entry point for our generator:

<FileTree>
  - packages/nx-plugin/src/trpc/procedure
    - schema.json Defines the input for our generator
    - schema.d.ts A typescript interface which matches the schema
    - generator.ts Function which Nx runs as our generator
</FileTree>

Add the content below to each file.

<Tabs>
  <TabItem label="schema.json">
    ```json
    {
      "$schema": "https://json-schema.org/schema",
      "$id": "tRPCProcedure",
      "title": "Adds a procedure to a tRPC API",
      "type": "object",
      "properties": {
        "project": {
          "type": "string",
          "description": "tRPC API project",
          "x-prompt": "Select the tRPC API project to add the procedure to",
          "x-dropdown": "projects",
          "x-priority": "important"
        },
        "procedure": {
          "description": "The name of the new procedure",
          "type": "string",
          "x-prompt": "What would you like to call your new procedure?",
          "x-priority": "important",
        },
        "type": {
          "description": "The type of procedure to generate",
          "type": "string",
          "x-prompt": "What type of procedure would you like to generate?",
          "x-priority": "important",
          "default": "query",
          "enum": ["query", "mutation"]
        }
      },
      "required": ["project", "procedure"]
    }
    ```
  </TabItem>
  <TabItem label="schema.d.ts">
    ```ts
    export interface TrpcProcedureSchema {
      project: string;
      procedure: string;
      type: 'query' | 'mutation';
    }
    ```
  </TabItem>
  <TabItem label="generator.ts">
    ```ts
    import { Tree } from '@nx/devkit';
    import { TrpcProcedureSchema } from './schema';

    export const trpcProcedureGenerator = async (tree: Tree, options: TrpcProcedureSchema) => {

    };

    export default trpcProcedureGenerator;

    ```
  </TabItem>
</Tabs>

:::note
Notice our generator is given a `Tree` as input, as well as the options we defined in our schema. The `Tree` is essentially a virtual file system which we can read from and write to in order to create or update project files. We don't want to touch the filesystem directly, as we don't want to make any changes if users run our generator in "dry-run" mode.
:::

Next, let's hook up our generator by updating `packages/nx-plugin/generators.json`:

```json
 ...
  "generators": {
    ...
    "ts#trpc-api#procedure": {
      "factory": "./src/trpc/procedure/generator",
      "schema": "./src/trpc/procedure/schema.json",
      "description": "Adds a procedure to a tRPC API"
    }
  },
...
```

### Implement the Generator

To add a procedure to a tRPC API, we need to do two things:

1. Create a TypeScript file for the new procedure
2. Add the procedure to the router

#### Create the new Procedure

To create the TypeScript file for our new procedure, we'll use a utility called `generateFiles`. Using this, we can define an [EJS](https://ejs.co/) template which we can render in our generator with variables based on the options selected by the user.

First, we'll define our template in `packages/nx-plugin/src/trpc/procedure/files/procedures/__procedureNameKebabCase__.ts.template`:

```ts title="files/procedures/__procedureNameKebabCase__.ts.template"
import { publicProcedure } from '../init.js';
import { z } from 'zod';

export const <%- procedureNameCamelCase %> = publicProcedure
  .input(z.object({
    // TODO: define input
  }))
  .output(z.object({
    // TODO: define output
  }))
  .<%- procedureType %>(async ({ input, ctx }) => {
    // TODO: implement!
    return {};
  });
```

:::tip
When `generateFiles` consumes our template, it will replace references to `__<variable>__` in file/directory names with the values it's provided, as well as stripping the `.template` from the file name.

The template content is [EJS](https://ejs.co/), where variables are referenced using the `<% ... %>` syntax.
:::

In the template, we referenced three variables:

* `procedureNameCamelCase`
* `procedureNameKebabCase`
* `procedureType`

So we'll need to make sure we pass those to `generateFiles`, as well as the directory to generate files into, namely the location of source files (i.e. `sourceRoot`) for the tRPC project the user selected as input for our generator, which we can extract from the project configuration.

Let's update our generator to do that:

```ts title="procedure/generator.ts" {8-19}
import { generateFiles, joinPathFragments, readProjectConfiguration, Tree } from '@nx/devkit';
import { TrpcProcedureSchema } from './schema';
import { formatFilesInSubtree } from '../../utils/format';
import camelCase from 'lodash.camelcase';
import kebabCase from 'lodash.kebabcase';

export const trpcProcedureGenerator = async (tree: Tree, options: TrpcProcedureSchema) => {
  const projectConfig = readProjectConfiguration(tree, options.project);

  const procedureNameCamelCase = camelCase(options.procedure);
  const procedureNameKebabCase = kebabCase(options.procedure);

  generateFiles(tree, joinPathFragments(__dirname, 'files'), projectConfig.sourceRoot, {
    procedureNameCamelCase,
    procedureNameKebabCase,
    procedureType: options.type,
  });

  await formatFilesInSubtree(tree);
};

export default trpcProcedureGenerator;
```

:::tip
We also called `formatFilesInSubtree` at the end of the generator, which ensures that any files we create or modify are formatted according to the user's [prettier](https://prettier.io/) settings.
:::

#### Add the Procedure to the Router

Next, we want our generator to hook up our new procedure to the router. This means reading and updating the user's source code!

We use TypeScript AST manipulation to update the relevant parts of the TypeScript source file. There are some helpers called `replace` and `destructuredImport` to make this a little easier.

```ts title="procedure/generator.ts" {6, 23-33}
import { generateFiles, joinPathFragments, readProjectConfiguration, Tree } from '@nx/devkit';
import { TrpcProcedureSchema } from './schema';
import { formatFilesInSubtree } from '../../utils/format';
import camelCase from 'lodash.camelcase';
import kebabCase from 'lodash.kebabcase';
import { destructuredImport, replace } from '../../utils/ast';
import { factory, ObjectLiteralExpression } from 'typescript';

export const trpcProcedureGenerator = async (tree: Tree, options: TrpcProcedureSchema) => {
  const projectConfig = readProjectConfiguration(tree, options.project);

  const procedureNameCamelCase = camelCase(options.procedure);
  const procedureNameKebabCase = kebabCase(options.procedure);

  generateFiles(tree, joinPathFragments(__dirname, 'files'), projectConfig.sourceRoot, {
    procedureNameCamelCase,
    procedureNameKebabCase,
    procedureType: options.type,
  });

  const routerPath = joinPathFragments(projectConfig.sourceRoot, 'router.ts');

  destructuredImport(tree, routerPath, [procedureNameCamelCase], `./procedures/${procedureNameKebabCase}.js`);

  replace(
    tree,
    routerPath,
    'CallExpression[expression.name="router"] > ObjectLiteralExpression',
    (node) => factory.createObjectLiteralExpression([
      ...(node as ObjectLiteralExpression).properties,
      factory.createShorthandPropertyAssignment(procedureNameCamelCase),
    ]),
  );

  await formatFilesInSubtree(tree);
};

export default trpcProcedureGenerator;
```

:::tip
In the above code snippet, `replace` uses a [tsquery](https://github.com/phenomnomnominal/tsquery) selector to find the argument added to the `router` function.

You can use the [tsquery playground](https://tsquery-playground.firebaseapp.com/) as a useful tool to test out different selectors.
:::

Now that we've implemented our generator, let's compile it to make sure it's available for us to test it out in our dungeon adventure project.

```bash
pnpm nx run @aws/nx-plugin:compile
```

### Testing our Generator

To test our generator, we'll link our local plugin to our dungeon-adventure codebase.

In your dungeon adventure codebase, let's link our local `@aws/nx-plugin`:

```bash
cd path/to/dungeon-adventure
pnpm link path/to/nx-plugin-for-aws/dist/packages/nx-plugin
```

:::note
Notice above we linked to the compiled plugin in `dist/packages/nx-plugin` rather than the source code.
:::

Let's try our new generator:

<RunGenerator generator="ts#trpc-api#procedure" />

:::note
If you don't see the new generator in the list in VSCode, you might need to refresh the Nx workspace:

<NxCommands commands={['reset']} />
:::

If successful, we should have generated a new procedure and added the procedure to our router in `router.ts`.

### Exercises

If you've got this far and still have some time to experiment with Nx generators, here are some suggestions of features to add to the procedure generator:

#### 1. Nested Operations

In our dungeon adventure game, we made use of nested routers to group related operations. Try updating the generator to support this by:

* Accepting dot notation for the `procedure` input (e.g. `games.query`)
* Generating a procedure with a name based on reversed dot notation (e.g. `queryGames`)
* Adding the appropriate nested router (or updating it if it already exists!)

#### 2. Validation

Our generator should defend against potential issues, such as a user selecting a `project` which isn't a tRPC API. Take a look at the `api-connection` generator for an example of this.

#### 3. Unit Tests

Write some unit tests for the generator. These are quite straightforward to implement, and most follow the general flow:

1. Create an empty workspace tree using `createTreeUsingTsSolutionSetup()`
2. Add any files that should already exist in the tree (e.g. `project.json` and `src/router.ts` for a tRPC backend)
3. Run the generator under test
4. Validate the expected changes are made to the tree

#### 4. End to End Tests

At present, we have a single "smoke test" which runs all the generators and makes sure that the build succeeds. This should be updated to include the new generator.

#### 5. Contribute Back!

If nobody has contributed this generator back to `@aws/nx-plugin`, send us a pull request! If there's already one there, perhaps think of another generator you can contribute.


## Module 6: Final cleanup

<Aside type="caution">TODO: CDK destroy</Aside>

## Wrapping up

Congratulations! Youâ€™ve created a dungeon adventure game that utilizes many of the available generators found within the `@aws/nx-plugin`.  ðŸŽ‰ðŸŽ‰ðŸŽ‰

<Aside type="danger">
## TODO
Verify windows
link to other docs
</Aside>