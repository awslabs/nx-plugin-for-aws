---
title: "D√©ployer"
---



import { Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import RunGenerator from '@components/run-generator.astro';
import Link from '@components/link.astro';
import NxCommands from '@components/nx-commands.astro';
import Drawer from '@components/drawer.astro';
import InstallCommand from '@components/install-command.astro';


Maintenant que nous avons migr√© enti√®rement notre base de code, nous pouvons envisager son d√©ploiement. Deux approches sont possibles √† ce stade.

#### Ressources enti√®rement nouvelles (Simple)

L'approche la plus simple consiste √† traiter ceci comme une application enti√®rement nouvelle, ce qui signifie que nous "recommencerons" avec une nouvelle table DynamoDB et un nouveau User Pool Cognito - perdant ainsi tous les utilisateurs et leurs listes de courses. Pour cette m√©thode, il suffit de :

<Steps>

1. Supprimer la table DynamoDB nomm√©e `shopping_list`

1. D√©ployer la nouvelle application :

    <NxCommands commands={["deploy infra shopping-list-infra-sandbox/*"]} />

</Steps>

üéâ Et c'est termin√© ! üéâ

#### Migrer les ressources avec √©tat existantes sans interruption (Plus complexe)

En r√©alit√©, il est plus probable que vous souhaitiez migrer les ressources AWS existantes pour qu'elles soient g√©r√©es par la nouvelle base de code, tout en √©vitant toute interruption de service pour vos clients.

:::danger
Cette approche est plus nuanc√©e et complexe, et ceci n'√©tant qu'un exemple, il est FORTEMENT recommand√© de la pratiquer dans un environnement non productif (id√©alement en cr√©ant un nouveau sandbox) et de documenter les √©tapes exactes pour votre application. Il est √©galement conseill√© de pr√©parer des plans de repli en cas d'√©chec ou de r√©sultats inattendus.
:::

:::note
Notre application PDK de liste de courses ne d√©finissait pas de domaines personnalis√©s ou de DNS. En pratique, vous auriez probablement des domaines configur√©s pour votre site web et votre API. Pour les besoins de cette section, nous supposerons que nous avons configur√© Route53 avec des noms DNS personnalis√©s pour le site et l'API.
:::

Pour notre application de liste de courses, les ressources avec √©tat importantes sont la table DynamoDB contenant les listes des utilisateurs, et le User Pool contenant les d√©tails des utilisateurs enregistr√©s. Notre plan global sera de conserver ces deux ressources cl√©s et de les d√©placer pour qu'elles soient g√©r√©es par notre nouveau stack, puis de mettre √† jour le DNS pour pointer vers le nouveau site web (et l'API si expos√©e aux clients).

<Steps>

1. Mettez √† jour votre nouvelle application pour r√©f√©rencer les ressources existantes que vous souhaitez conserver.

    Pour l'application de liste de courses, nous faisons cela pour la table DynamoDB :

    ```diff lang="ts"
    // constructs/database.ts
    -this.shoppingListTable = new Table(this, 'ShoppingList', {
    -  ...
    +this.shoppingListTable = Table.fromTableName(
    +  this,
    +  'ShoppingList',
    +  'shopping_list',
    +);
    ```

    Et pour le User Pool Cognito :

    ```diff lang="ts"
    // packages/common/constructs/src/core/user-identity.ts
    -this.userPool = this.createUserPool();
    +this.userPool = UserPool.fromUserPoolId(
    +  this,
    +  'UserPool',
    +  '<your-user-pool-id>',
    +);
    ```

1. Construisez et d√©ployez la nouvelle application :

    <NxCommands commands={["run-many --target build"]} />

    <NxCommands commands={["deploy infra shopping-list-infra-sandbox/*"]} />

    Maintenant, notre nouvelle application est d√©ploy√©e en r√©f√©ren√ßant les ressources existantes, sans encore recevoir de trafic.

1. Effectuez des tests d'int√©gration complets pour v√©rifier le bon fonctionnement. Pour l'application de liste de courses, chargez le site et v√©rifiez que vous pouvez vous connecter et cr√©er, voir, modifier et supprimer des listes.

1. Revenez en arri√®re sur les changements r√©f√©ren√ßant les ressources existantes dans votre nouvelle application, mais ne les d√©ployez pas encore :

    ```diff lang="ts"
    // constructs/database.ts
    +this.shoppingListTable = new Table(this, 'ShoppingList', {
    +  ...
    -this.shoppingListTable = Table.fromTableName(
    -  this,
    -  'ShoppingList',
    -  'shopping_list',
    -);
    ```

    Et pour le User Pool Cognito :

    ```diff lang="ts"
    // packages/common/constructs/src/core/user-identity.ts
    +this.userPool = this.createUserPool();
    -this.userPool = UserPool.fromUserPoolId(
    -  this,
    -  'UserPool',
    -  '<your-user-pool-id>',
    -);
    ```

    Puis ex√©cutez une build :

    <NxCommands commands={["run-many --target build"]} />

1. Utilisez `cdk import` dans le dossier `packages/infra` de votre nouvelle application pour voir quelles ressources doivent √™tre import√©es :

    ```bash title="Nouvelle application"
    cd packages/infra
    pnpm exec cdk import shopping-list-infra-sandbox/Application --force
    ```

    Suivez les invites en appuyant sur Entr√©e. L'import √©chouera car les ressources sont g√©r√©es par un autre stack - c'est normal, nous voulions juste confirmer les ressources √† conserver. Vous verrez un r√©sultat comme ceci :

    ```bash wrap
    shopping-list-infra-sandbox/Application/ApplicationUserIdentity/UserPool/smsRole/Resource (AWS::IAM::Role): saisir RoleName (vide pour ignorer)
    shopping-list-infra-sandbox/Application/ApplicationUserIdentity/UserPool/Resource (AWS::Cognito::UserPool): saisir UserPoolId (vide pour ignorer)
    shopping-list-infra-sandbox/Application/Database/ShoppingList/Resource (AWS::DynamoDB::Table): importer avec TableName=shopping_list (o/n) o
    ```

    Ceci indique qu'il y a en r√©alit√© 3 ressources √† importer dans notre nouveau stack.

1. Mettez √† jour votre ancien projet PDK pour d√©finir `RemovalPolicy` sur `RETAIN` pour les ressources identifi√©es. Actuellement c'est le comportement par d√©faut pour le User Pool et la table DynamoDB, mais nous devons l'ajouter pour le r√¥le SMS d√©couvert :

    ```diff lang="ts"
    // application-stack.ts
    const userIdentity = new UserIdentity(this, `${id}UserIdentity`, {
      userPool,
    });

    +const smsRole = userIdentity.userPool.node.findAll().filter(
    +  c => CfnResource.isCfnResource(c) &&
    +    c.node.path.includes('/smsRole/'))[0] as CfnResource;
    +smsRole.applyRemovalPolicy(RemovalPolicy.RETAIN);
    ```

1. D√©ployez votre projet PDK pour appliquer les politiques de suppression :

    ```bash title="Application PDK"
    cd packages/infra
    npx projen deploy
    ```

1. Consultez la console CloudFormation et notez les valeurs demand√©es lors de l'√©tape `cdk import` :

    1. L'ID du User Pool, ex : `us-west-2_XXXXX`
    2. Le nom du r√¥le SMS, ex : `infra-sandbox-UserIdentityUserPoolsmsRoleXXXXXX`

1. Mettez √† jour votre projet PDK pour r√©f√©rencer les ressources existantes au lieu de les cr√©er :

    ```diff lang="ts"
    // constructs/database.ts
    -this.shoppingListTable = new Table(this, 'ShoppingList', {
    -  ...
    +this.shoppingListTable = Table.fromTableName(
    +  this,
    +  'ShoppingList',
    +  'shopping_list',
    +);
    ```

    Et pour le User Pool Cognito :

    ```diff lang="ts"
    // application-stack.ts
    +const userPool = UserPool.fromUserPoolId(
    +  this,
    +  'UserPool',
    +  '<your-user-pool-id>',
    +);
    const userIdentity = new UserIdentity(this, `${id}UserIdentity`, {
    +  // Le construct PDK attend un UserPool mais fonctionne avec IUserPool
    +  userPool: userPool as any,
    });
    ```

1. D√©ployez √† nouveau votre projet PDK, ce qui signifie que les ressources ne sont plus g√©r√©es par son stack CloudFormation :

    ```bash title="Application PDK"
    cd packages/infra
    npx projen deploy
    ```

1. Maintenant que les ressources ne sont plus g√©r√©es, ex√©cutez `cdk import` dans votre nouvelle application pour effectuer l'import :

    ```bash title="Nouvelle application"
    cd packages/infra
    pnpm exec cdk import shopping-list-infra-sandbox/Application --force
    ```

    Saisissez les valeurs demand√©es, l'import devrait se terminer avec succ√®s.

1. D√©ployez √† nouveau la nouvelle application pour appliquer les modifications sur ces ressources d√©sormais g√©r√©es :

    <NxCommands commands={["deploy infra shopping-list-infra-sandbox/*"]} />

1. Effectuez √† nouveau des tests complets de la nouvelle application

1. Mettez √† jour les enregistrements DNS pour pointer vers le nouveau site (et l'API si n√©cessaire).

    Nous recommandons une approche progressive avec le [Routage pond√©r√©](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-weighted.html) de Route53, en dirigeant progressivement le trafic vers la nouvelle application. Vous pouvez augmenter progressivement le poids jusqu'√† ce que tout le trafic soit bascul√©.

    Si vous n'avez pas de DNS et utilisez les domaines auto-g√©n√©r√©s, vous pouvez utiliser un proxy (comme une [origine HTTP CloudFront](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_cloudfront_origins-readme.html#from-an-http-endpoint) ou des [int√©grations HTTP API Gateway](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_apigateway.HttpIntegration.html)).

1. Surveillez les m√©triques de l'ancienne application PDK pour confirmer l'absence de trafic, puis d√©truisez son stack CloudFormation :

    ```bash
    cd packages/infra
    npx projen destroy
    ```

</Steps>

Ce processus √©tait complexe, mais nous avons migr√© nos utilisateurs de mani√®re transparente vers la nouvelle application ! üéâüéâüéâ

Nous b√©n√©ficions maintenant des avantages du Nx Plugin pour AWS par rapport au PDK :

- Builds plus rapides
- Support du d√©veloppement d'API en local
- Une base de code plus agr√©able (<Link path="/get_started/building-with-ai">essayez notre serveur MCP !</Link>)
- Un code client/serveur plus intuitif avec typage fort
- Et plus encore !