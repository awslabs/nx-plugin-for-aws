---
title: "Jeu de Donjon IA"
description: "Un guide pas à pas pour construire un jeu d'aventure de donjon alimenté par l'IA en utilisant le @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import E2EDiff from '@components/e2e-diff.astro';
import E2ECode from '@components/e2e-code.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Module 2 : Implémentation de l'API de jeu

Nous allons commencer par implémenter notre API de jeu. Pour cela, nous devons créer 4 API au total :

1. `createGame` - cela créera une nouvelle instance de jeu.
2. `queryGames` - cela retournera une liste paginée des parties précédemment sauvegardées.
3. `saveAction` - cela sauvegardera une action pour une partie donnée.
4. `queryActions` - cela retournera une liste paginée de toutes les actions liées à une partie.

### Schéma d'API

Pour définir les entrées et sorties de notre API, créons notre schéma avec [Zod](https://zod.dev/) dans le projet `packages/game-api/schema/src` comme suit :

<Tabs>
  <TabItem label="types/action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/types/action.ts.template" />
  </TabItem>
  <TabItem label="types/common.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/types/common.ts.template" />
  </TabItem>
  <TabItem label="types/game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/types/game.ts.template" />
  </TabItem>
  <TabItem label="index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/schema/index.ts.old.template" after="dungeon-adventure/2/schema/index.ts.template" />
  </TabItem>
</Tabs>

Vous pouvez également supprimer le fichier `./procedures/echo.ts` car nous ne l'utiliserons pas dans ce projet.

<Aside type="tip">
Comme vous pouvez le voir ci-dessus, pour chaque schéma défini dans Zod, nous exportons également une interface en utilisant la syntaxe `z.TypeOf`. Cela convertit notre définition Zod en une interface TypeScript sans duplication d'effort !
</Aside>

### Modélisation des entités

Le diagramme ER de notre application est le suivant :

<Image class="centered-image white-bg" src={dungeonAdventureErPng} alt="dungeon-adventure-er.png" width="400" height="300" />

Nous allons implémenter notre base de données dans DynamoDB en utilisant la bibliothèque cliente [ElectroDB](https://electrodb.dev/en/core-concepts/introduction/) pour simplifier les opérations. Pour commencer, installons d'abord `electrodb` en exécutant la commande suivante :

<InstallCommand pkg="electrodb @aws-sdk/client-dynamodb" />

<Aside>
Toutes les dépendances sont ajoutées au `package.json` racine car le `@aws/nx-plugin` suit le principe de [politique de version unique](https://nx.dev/concepts/decisions/dependency-management#single-version-policy). Pour plus d'informations, consultez le <Link path="guides/typescript-project#dependencies">guide ts#project</Link>.
</Aside>

Créons maintenant les fichiers suivants dans notre dossier `packages/game-api/backend/src/entities` pour définir nos entités ElectroDB selon le diagramme ER ci-dessus :

<Tabs>
  <TabItem label="action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/action.ts.template" />
  </TabItem>
  <TabItem label="game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/game.ts.template" />
  </TabItem>
</Tabs>

ElectroDB est très puissant et nous permet non seulement de définir nos types, mais peut aussi fournir des valeurs par défaut comme pour les horodatages ci-dessus. De plus, ElectroDB suit le [modèle de conception single-table](https://electrodb.dev/en/core-concepts/single-table-relationships/), une meilleure pratique avec DynamoDB.

<Aside>
Bien qu'ElectroDB supporte les [collections](https://electrodb.dev/en/modeling/collections/), nous avons choisi de ne pas les utiliser dans ce tutoriel pour simplifier.
</Aside>

### Ajout du client DynamoDB au contexte tRPC

Étant donné que nous avons besoin d'accéder au client DynamoDB dans chacune de nos procédures, nous voulons créer une instance unique du client que nous pouvons passer via le contexte. Pour cela, effectuez les modifications suivantes dans `packages/game-api/backend/src` :

<Tabs>
  <TabItem label="middleware/dynamodb.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/middleware/dynamodb.ts.template" />

Ce plugin permet de créer le `DynamoDBClient` et de l'injecter dans le contexte.
  </TabItem>
  <TabItem label="middleware/index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/middleware/index.ts.old.template" after="dungeon-adventure/2/middleware/index.ts.template" />

Nous enrichissons notre `IMiddlewareContext` pour ajouter le `IDynamoDBContext`.
  </TabItem>
  <TabItem label="init.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/init.ts.old.template" after="dungeon-adventure/2/init.ts.template" />

Le plugin DynamoDB est instrumenté.

<Aside>
L'API `concat` lie notre middleware aux procédures définies. Pour plus de détails, consultez le [guide concat](https://trpc.io/docs/server/middlewares#concat).
</Aside>
  </TabItem>
</Tabs>

### Définition de nos procédures

Il est temps d'implémenter les méthodes de l'API. Pour cela, effectuez les modifications suivantes dans `packages/game-api/backend/src/procedures` :

<Tabs>
  <TabItem label="query-actions.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-actions.ts.template" />
  </TabItem>
  <TabItem label="query-games.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-games.ts.template" />
  </TabItem>
  <TabItem label="save-action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/save-action.ts.template" />
  </TabItem>
  <TabItem label="save-game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/save-game.ts.template" />
  </TabItem>
</Tabs>

Vous pouvez aussi supprimer le fichier `echo.ts` (dans `packages/game-api/backend/src/procedures`) car nous ne l'utiliserons pas dans ce projet.

### Configuration du routeur

Maintenant que nos procédures sont définies, intégrons-les à notre API. Pour cela, mettez à jour le fichier suivant :

<E2EDiff lang="typescript" before="dungeon-adventure/2/router.ts.old.template" after="dungeon-adventure/2/router.ts.template" />

### Infrastructure

La dernière étape consiste à mettre à jour notre infrastructure pour créer la table DynamoDB et accorder les permissions d'opérations depuis l'API de jeu. Mettez à jour `packages/infra/src` comme suit :

<Tabs>
  <TabItem label="constructs/electrodb-table.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/constructs/electrodb-table.ts.template" />
  </TabItem>
  <TabItem label="stacks/application-stack.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/1/application-stack.ts.template" after="dungeon-adventure/2/stacks/application-stack.ts.template" />

:::note
Remarquez ici que comme chaque procédure est servie par une fonction lambda individuelle, nous pouvons appliquer le principe du moindre privilège en n'accordant que les permissions de lecture/écriture nécessaires selon l'implémentation de la procédure.
:::
  </TabItem>
</Tabs>

### Déploiement et tests

D'abord, construisons la base de code :

<NxCommands commands={['run-many --target build --all']} />

<Aside type="tip">
Si vous rencontrez des erreurs de lint, exécutez cette commande pour les corriger automatiquement :

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

Vous pouvez maintenant déployer l'application avec :

<NxCommands commands={['run @dungeon-adventure/infra:deploy dungeon-adventure-infra-sandbox']} />

Le premier déploiement prendra environ 8 minutes. Les suivants prendront environ 2 minutes.

:::tip
Pour les modifications de code des fonctions lambda, vous pouvez déployer avec le flag `--hotswap` après avoir construit la base de code pour un temps de déploiement réduit (2-3 secondes).

<NxCommands commands={['run @dungeon-adventure/infra:deploy dungeon-adventure-infra-sandbox --hotswap']} />
:::

<Drawer title="Commande de déploiement" trigger="Vous pouvez aussi déployer toutes les stacks d'un coup. Cliquez ici pour plus de détails.">

Vous pouvez déployer toutes les stacks de l'application CDK avec :

<NxCommands commands={['run @dungeon-adventure/infra:deploy --all']} />

Ceci n'est **pas recommandé** car vous pourriez souhaiter séparer vos étapes de déploiement en stacks distinctes (ex: `infra-prod`). Dans ce cas, le flag `--all` tentera de tout déployer, ce qui peut entraîner des déploiements indésirables !

</Drawer>

Une fois le déploiement terminé, vous devriez voir des sorties similaires à ceci _(certaines valeurs ont été masquées)_ :

```bash
dungeon-adventure-infra-sandbox
dungeon-adventure-infra-sandbox: deploying... [2/2]

 ✅  dungeon-adventure-infra-sandbox

✨  Temps de déploiement : 354s

Outputs:
dungeon-adventure-infra-sandbox.ElectroDbTableTableNameXXX = dungeon-adventure-infra-sandbox-ElectroDbTableXXX-YYY
dungeon-adventure-infra-sandbox.GameApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-infra-sandbox.GameUIDistributionDomainNameXXX = xxx.cloudfront.net
dungeon-adventure-infra-sandbox.StoryApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-infra-sandbox.UserIdentityUserIdentityIdentityPoolIdXXX = region:xxx
dungeon-adventure-infra-sandbox.UserIdentityUserIdentityUserPoolIdXXX = region_xxx
```

Nous pouvons tester notre API soit :
<ul>
<li>En démarrant une instance locale du backend tRPC et en appelant les API avec `curl`.</li>
<li>
<Drawer title="curl avec Sigv4 activé" trigger="Appeler l'API déployée avec curl et Sigv4">
Vous pouvez ajouter ce script à votre fichier `.bashrc` (et le `sourcer`) ou simplement le coller dans le terminal où vous exécuterez la commande.
```bash
// ~/.bashrc
acurl () {
    REGION=$1
    SERVICE=$2
    shift; shift;
    curl --aws-sigv4 "aws:amz:$REGION:$SERVICE" --user "$(aws configure get aws_access_key_id):$(aws configure get aws_secret_access_key)" -H "X-Amz-Security-Token: $(aws configure get aws_session_token)" "$@"
}
```

Exemples d'utilisation de `acurl` :

###### API Gateway
```bash
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### URL de fonction Lambda
```bash
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
</Drawer>
</li>
</ul>


<Tabs>
  <TabItem label="Local">
    Démarrez le serveur local `game-api` avec :

    <NxCommands highlights={['dungeon-adventure-infra-sandbox-ElectroDbTableXXX-YYY']} env={{TABLE_NAME:"dungeon-adventure-infra-sandbox-ElectroDbTableXXX-YYY"}} commands={["run @dungeon-adventure/game-api-backend:serve"]} />

    <Aside type="caution">
    Utilisez la valeur de sortie CDK `dungeon-adventure-infra-sandbox.ElectroDbTableTableNameXXX` pour remplacer le placeholder surligné.
    </Aside>

    Une fois le serveur actif, appelez-le avec :

    ```bash
    curl -X GET 'http://localhost:2022/games.query?input=%7B%7D'
    ```
  </TabItem>
  <TabItem label="Déployé">
```bash "https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/" "ap-southeast-2"
acurl ap-southeast-2 execute-api -X GET 'https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/games.query?input=%7B%7D'
```
    <Aside type="caution">
    Utilisez la valeur de sortie CDK `dungeon-adventure-infra-sandbox.GameApiGameApiEndpointXXX` pour remplacer le placeholder et ajustez la région.
    </Aside>
  </TabItem>
</Tabs>

:::note
Le `%7B%7D` passé à l'API est un objet JSON vide encodé (`{}`).
:::

Si la commande réussit, vous devriez voir cette réponse :

```json
{"result":{"data":{"items":[],"cursor":null}}}
```

Félicitations, vous avez construit et déployé votre première API avec tRPC ! 🎉🎉🎉