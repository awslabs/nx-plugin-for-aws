---
title: "Jeu de Donjon d'IA Agentique"
description: "Un guide pas à pas pour construire un jeu d'aventure de donjon alimenté par une IA agentique en utilisant le @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import E2EDiff from '@components/e2e-diff.astro';
import E2ECode from '@components/e2e-code.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Module 2 : Implémentation de l'API de jeu et du serveur MCP d'inventaire

Nous allons commencer par implémenter notre API de jeu. Pour cela, nous devons créer 5 API au total :

1. `saveGame` - créer ou mettre à jour une partie.
2. `queryGames` - retourner une liste paginée des parties précédemment sauvegardées.
3. `saveAction` - sauvegarder une action pour une partie donnée.
4. `queryActions` - retourner une liste paginée de toutes les actions liées à une partie.
5. `queryInventory` - retourner une liste paginée des objets dans l'inventaire d'un joueur.

### Schéma d'API

Pour définir les entrées et sorties de notre API, créons notre schéma avec [Zod](https://zod.dev/) dans le répertoire `packages/game-api/src/schema` comme suit :

<Tabs>
  <TabItem label="action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/action.ts.template" />
  </TabItem>
  <TabItem label="common.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/common.ts.template" />
  </TabItem>
  <TabItem label="game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/game.ts.template" />
  </TabItem>
  <TabItem label="inventory.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/inventory.ts.template" />
  </TabItem>
  <TabItem label="index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/schema/index.ts.old.template" after="dungeon-adventure/2/schema/index.ts.template" />
  </TabItem>
</Tabs>

Vous pouvez également supprimer le fichier `packages/game-api/src/schema/echo.ts` car nous ne l'utiliserons pas dans ce projet.

<Aside type="tip">
Comme visible ci-dessus, pour chaque schéma défini avec Zod, nous exportons également une interface en utilisant la syntaxe `z.TypeOf`. Cela convertit notre définition Zod en une interface TypeScript sans duplication d'effort !
</Aside>

### Modélisation des entités

Le diagramme entité-relation de notre application est le suivant :

<Image class="centered-image white-bg" src={dungeonAdventureErPng} alt="dungeon-adventure-er.png" width="400" height="300" />

{/* Generated from the following PlantUML: */}
{/*
@startuml Game API Entity Relationship Diagram

!theme plain

skinparam linetype ortho
skinparam roundcorner 10

entity "Game" as game {
  + playerName : string <<PK>>
  --
  genre : string
  lastUpdated : string
}

entity "Action" as action {
  + playerName : string <<PK>>
  + timestamp : string <<SK>>
  --
  role : string
  content : string
}

entity "Item" as item {
  + playerName : string <<PK>>
  + itemName : string
  --
  emoji : string (optional)
  lastUpdated : string
  quantity : number
}

game ||--o{ action
game ||--o{ item

@enduml
*/}

Nous allons implémenter notre base de données dans DynamoDB en utilisant la bibliothèque cliente [ElectroDB](https://electrodb.dev/en/core-concepts/introduction/) pour simplifier les opérations. Pour commencer, installons d'abord `electrodb` en exécutant la commande suivante :

<InstallCommand pkg="electrodb @aws-sdk/client-dynamodb" />

<Aside>
Toutes les dépendances sont ajoutées au `package.json` racine car le `@aws/nx-plugin` suit le principe de [single version policy](https://nx.dev/concepts/decisions/dependency-management#single-version-policy). Pour plus d'informations, référez-vous au <Link path="guides/typescript-project#dependencies">guide ts#project</Link>.
</Aside>

Maintenant, créons les fichiers suivants dans notre dossier `packages/game-api/src/entities` pour définir nos entités ElectroDB conformément au diagramme ER ci-dessus :

<Tabs>
  <TabItem label="action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/action.ts.template" />
  </TabItem>
  <TabItem label="game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/game.ts.template" />
  </TabItem>
  <TabItem label="inventory.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/inventory.ts.template" />
  </TabItem>
</Tabs>

ElectroDB nous permet non seulement de définir nos types, mais peut aussi fournir des valeurs par défaut pour certains champs comme les horodatages ci-dessus. De plus, ElectroDB suit le [single-table design](https://electrodb.dev/en/core-concepts/single-table-relationships/), une meilleure pratique avec DynamoDB.

<Aside>
Bien qu'ElectroDB supporte les [collections](https://electrodb.dev/en/modeling/collections/), nous avons choisi de ne pas les utiliser dans ce tutoriel pour simplifier.
</Aside>

Pour préparer l'interaction du serveur MCP avec l'inventaire, assurons-nous d'exporter l'entité d'inventaire dans `packages/game-api/src/index.ts` :

<Tabs>
<TabItem label="packages/game-api/src/index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/index.ts.old.template" after="dungeon-adventure/2/index.ts.template" />
</TabItem>
</Tabs>

:::note
La structure des packages serait améliorée si nous refactorisions les entités dans leur propre projet partagé, afin que le serveur MCP ne dépende pas de l'API.
:::

### Ajout du client DynamoDB au contexte tRPC

Étant donné que nous avons besoin d'accéder au client DynamoDB dans chacune de nos procédures, nous voulons créer une instance unique du client que nous pouvons passer via le contexte. Pour cela, effectuons les modifications suivantes dans `packages/game-api/src` :

<Tabs>
  <TabItem label="middleware/dynamodb.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/middleware/dynamodb.ts.template" />

Ce plugin est instrumenté pour créer le `DynamoDBClient` et l'injecter dans le contexte.
  </TabItem>
  <TabItem label="middleware/index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/middleware/index.ts.old.template" after="dungeon-adventure/2/middleware/index.ts.template" />

Nous augmentons notre `IMiddlewareContext` pour ajouter le `IDynamoDBContext`.
  </TabItem>
  <TabItem label="init.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/init.ts.old.template" after="dungeon-adventure/2/init.ts.template" />

Le plugin DynamoDB est instrumenté.

<Aside>
L'API `concat` lie notre middleware aux procédures définies. Pour plus de détails, référez-vous au [guide concat](https://trpc.io/docs/server/middlewares#concat).
</Aside>
  </TabItem>
</Tabs>

### Définition de nos procédures

Il est maintenant temps d'implémenter les méthodes de l'API. Pour cela, effectuons les modifications suivantes dans `packages/game-api/src/procedures` :

#### Requêtes

<Tabs>
  <TabItem label="query-actions.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-actions.ts.template" />
  </TabItem>
  <TabItem label="query-games.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-games.ts.template" />
  </TabItem>
  <TabItem label="query-inventory.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-inventory.ts.template" />
  </TabItem>
</Tabs>

#### Mutations

<Tabs>
  <TabItem label="save-action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/save-action.ts.template" />
  </TabItem>
  <TabItem label="save-game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/save-game.ts.template" />
  </TabItem>
</Tabs>

Vous pouvez également supprimer le fichier `echo.ts` (de `packages/game-api/src/procedures`) car nous ne l'utiliserons pas dans ce projet.

### Configuration du routeur

Maintenant que nos procédures sont définies, intégrons-les à notre API. Pour cela, mettons à jour le fichier suivant :

<Tabs>
  <TabItem label="packages/game-api/src/router.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/router.ts.old.template" after="dungeon-adventure/2/router.ts.template" />
</TabItem>
</Tabs>

### Serveur MCP d'inventaire

Créons maintenant un serveur MCP qui permettra à notre agent de gérer les objets dans l'inventaire d'un joueur.

Nous définirons les outils suivants pour notre Agent :

- `list-inventory-items` pour récupérer les objets actuels de l'inventaire du joueur
- `add-to-inventory` pour ajouter des objets à l'inventaire du joueur
- `remove-from-inventory` pour retirer des objets de l'inventaire du joueur

Pour gagner du temps, nous définirons tous les outils inline :

<Tabs>
  <TabItem label="packages/inventory/src/mcp-server/server.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/mcp/server.ts.old.template" after="dungeon-adventure/2/mcp/server.ts.template" />
</TabItem>
</Tabs>

Si le nombre d'outils augmente, vous pourrez les refactoriser dans des fichiers séparés.

Vous pouvez maintenant supprimer les répertoires `tools` et `resources` dans `packages/inventory/src/mcp-server` car ils ne sont pas utilisés.

### Infrastructure

La dernière étape consiste à mettre à jour notre infrastructure pour créer la table DynamoDB et accorder les permissions nécessaires à l'API de jeu. Pour cela, mettons à jour `packages/infra/src` comme suit :

<Tabs>
  <TabItem label="constructs/electrodb-table.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/constructs/electrodb-table.ts.template" />
  </TabItem>
  <TabItem label="stacks/application-stack.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/1/application-stack.ts.template" after="dungeon-adventure/2/stacks/application-stack.ts.template" />

:::note
Notez ici que comme chaque procédure est servie par une fonction lambda individuelle, nous pouvons appliquer le principe du moindre privilège et n'accorder que les permissions de lecture/écriture nécessaires selon l'implémentation de la procédure.
:::
  </TabItem>
</Tabs>

### Déploiement et tests

D'abord, construisons la base de code :

<NxCommands commands={['run-many --target build --all']} />

<Aside type="tip">
Si vous rencontrez des erreurs de lint, exécutez la commande suivante pour les corriger automatiquement :

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

Votre application peut maintenant être déployée en exécutant :

<NxCommands commands={['deploy infra dungeon-adventure-infra-sandbox/*']} />

:::caution
Vous devrez peut-être initialiser votre compte AWS avec :

<NxCommands commands={['bootstrap infra']} />
:::

Le premier déploiement prendra environ 8 minutes. Les déploiements suivants prendront environ 2 minutes.

:::tip
Si vous itérez sur des modifications de code lambda, vous pouvez déployer avec le flag `--hotswap` après avoir construit la base de code pour un temps de déploiement réduit (2-3 secondes).

<NxCommands commands={['run @dungeon-adventure/infra:deploy dungeon-adventure-infra-sandbox/* --hotswap']} />
:::

Une fois le déploiement terminé, vous devriez voir des sorties similaires à ceci _(certaines valeurs ont été masquées)_ :

```bash
dungeon-adventure-sandbox-Application
dungeon-adventure-sandbox-Application: deploying... [2/2]

 ✅  dungeon-adventure-sandbox-Application

✨  Durée du déploiement : 354s

Outputs:
dungeon-adventure-sandbox-Application.ElectroDbTableTableNameXXX = dungeon-adventure-sandbox-Application-ElectroDbTableXXX-YYY
dungeon-adventure-sandbox-Application.GameApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-sandbox-Application.GameUIDistributionDomainNameXXX = xxx.cloudfront.net
dungeon-adventure-sandbox-Application.StoryApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-sandbox-Application.UserIdentityUserIdentityIdentityPoolIdXXX = region:xxx
dungeon-adventure-sandbox-Application.UserIdentityUserIdentityUserPoolIdXXX = region_xxx
```

Nous pouvons tester notre API en :
<ul>
<li>Démarrant une instance locale du backend tRPC et en appelant les API via `curl`.</li>
<li>
<Drawer title="curl avec Sigv4 activé" trigger="Appeler l'API déployée avec curl sigv4">

<Tabs>
  <TabItem label="Bash/Linux/macOS">
Vous pouvez ajouter ce script à votre fichier `.bashrc` (et le `sourcer`) ou simplement coller ceci dans le terminal où vous exécuterez la commande.
```bash
// ~/.bashrc
acurl () {
    REGION=$1
    SERVICE=$2
    shift; shift;
    curl --aws-sigv4 "aws:amz:$REGION:$SERVICE" --user "$(aws configure get aws_access_key_id):$(aws configure get aws_secret_access_key)" -H "X-Amz-Security-Token: $(aws configure get aws_session_token)" "$@"
}
```

Exemples d'appel sigv4 :

###### API Gateway
```bash
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### URL de fonction Lambda
```bash
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
  </TabItem>
  <TabItem label="Windows PowerShell">
Ajoutez cette fonction à votre profil PowerShell ou collez-la dans la session actuelle.
```powershell
function acurl {
    param(
        [Parameter(Mandatory=$true)][string]$Region,
        [Parameter(Mandatory=$true)][string]$Service,
        [Parameter(ValueFromRemainingArguments=$true)][string[]]$CurlArgs
    )

    $AccessKey = aws configure get aws_access_key_id
    $SecretKey = aws configure get aws_secret_access_key
    $SessionToken = aws configure get aws_session_token

    & curl --aws-sigv4 "aws:amz:$Region`:$Service" --user "$AccessKey`:$SecretKey" -H "X-Amz-Security-Token: $SessionToken" @CurlArgs
}
```

Exemples d'appel sigv4 :

###### API Gateway
```powershell
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### URL de fonction Lambda
```powershell
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
  </TabItem>
</Tabs>

</Drawer>
</li>
</ul>


<Tabs>
  <TabItem label="Local">
    Démarrez le serveur `game-api` localement avec :

    <NxCommands highlights={['dungeon-adventure-infra-sandbox-Application-ElectroDbTableXXX-YYY']} env={{TABLE_NAME:"dungeon-adventure-infra-sandbox-Application-ElectroDbTableXXX-YYY"}} commands={["run @dungeon-adventure/game-api:serve"]} />

    <Aside type="caution">
    Utilisez la valeur de sortie CDK `dungeon-adventure-infra-sandbox-Application.ElectroDbTableTableNameXXX` pour remplacer le placeholder.
    </Aside>

    Une fois le serveur démarré, appelez-le avec :

    ```bash
    curl -X GET 'http://localhost:2022/games.query?input=%7B%7D'
    ```
  </TabItem>
  <TabItem label="Déployé">
```bash "https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/" "ap-southeast-2"
acurl ap-southeast-2 execute-api -X GET 'https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/games.query?input=%7B%7D'
```
    <Aside type="caution">
    Utilisez la sortie CDK `dungeon-adventure-infra-sandbox-Application.GameApiGameApiEndpointXXX` et ajustez la région.
    </Aside>
  </TabItem>
</Tabs>

:::note
Le `%7B%7D` passé dans l'URL est un objet JSON vide encodé (`{}`).
:::

Si la commande réussit, vous devriez voir cette réponse :

```json
{"result":{"data":{"items":[],"cursor":null}}}
```

Félicitations, vous avez déployé votre première API avec tRPC ! 🎉🎉🎉