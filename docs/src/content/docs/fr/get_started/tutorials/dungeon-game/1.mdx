---
title: "Configurer un monorepo"
description: "Un guide pas √† pas pour construire un jeu d'aventure de donjon aliment√© par une IA agentique en utilisant le @aws/nx-plugin."
---

import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import PackageManagerShortCommand from '@components/package-manager-short-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## T√¢che 1 : Cr√©er un monorepo

Pour cr√©er un nouveau monorepo, depuis le r√©pertoire de votre choix, ex√©cutez la commande suivante :

<CreateNxWorkspaceCommand workspace="dungeon-adventure" iacProvider="CDK" />

:::note
Nous utilisons `--iacProvider=CDK` car nous utiliserons CDK pour l'infrastructure as code dans ce tutoriel. Le plugin Nx pour AWS supporte √©galement `Terraform`.
:::

Cela configurera un monorepo NX dans le r√©pertoire `dungeon-adventure`. Lorsque vous ouvrez le r√©pertoire dans VSCode, vous verrez cette structure de fichiers :

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ c'est ici que r√©sideront vos sous-projets
- .gitignore
- .prettierignore
- .prettierrc
- nx.json configure le CLI Nx et les param√®tres par d√©faut du monorepo
- package.json toutes les d√©pendances Node sont d√©finies ici
- pnpm-lock.yaml ou bun.lock, yarn.lock, package-lock.json selon le gestionnaire de paquets
- pnpm-workspace.yaml si utilisation de pnpm
- README.md
- tsconfig.base.json tous les sous-projets Node √©tendent ce fichier
- tsconfig.json
- aws-nx-plugin.config.mts configuration du plugin Nx pour AWS
</FileTree>

Nous pouvons maintenant commencer √† cr√©er nos diff√©rents sous-projets en utilisant le `@aws/nx-plugin`.

<Aside type="tip">Il est recommand√© de s'assurer que tous vos fichiers non commit√©s sont sauvegard√©s dans Git avant d'ex√©cuter des g√©n√©rateurs. Cela vous permet de voir ce qui a chang√© apr√®s l'ex√©cution de votre g√©n√©rateur via `git diff`.</Aside>

## T√¢che 2 : Cr√©er une API de jeu

Tout d'abord, cr√©ons notre API de jeu. Pour ce faire, cr√©ez une API tRPC appel√©e `GameApi` en suivant ces √©tapes :

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

Vous verrez de nouveaux fichiers appara√Ætre dans votre arborescence de fichiers.

<Aside>
Le `package.json` racine est maintenant configur√© avec un `type` √† `module`, ce qui signifie que ESM est le type de module par d√©faut pour tous les sous-projets Node g√©n√©r√©s par le `@aws/nx-plugin`.
Pour plus de d√©tails sur le travail avec les projets TypeScript, consultez le <Link path="guides/typescript-project">guide du g√©n√©rateur ts#project</Link>.
</Aside>

<Drawer title="Fichiers modifi√©s par ts#trpc-api" trigger="Cliquez ici pour examiner ces fichiers en d√©tail.">
Voici la liste de tous les fichiers g√©n√©r√©s par le g√©n√©rateur `ts#trpc-api`. Nous allons examiner certains des fichiers cl√©s mis en √©vidence dans l'arborescence :
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK sp√©cifiques √† l'application
          - apis/
            - **game-api.ts** construct CDK pour cr√©er votre API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructs CDK g√©n√©riques
          - api/
            - rest-api.ts construct CDK de base pour une API Gateway Rest API
            - trpc-utils.ts utilitaires pour les constructs CDK d'API tRPC
            - utils.ts utilitaires pour les constructs d'API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
  - game-api/ API tRPC
    - src/
      - client/ client vanilla typiquement utilis√© pour les appels TypeScript machine √† machine
        - index.ts
      - middleware/ instrumentation Powertools
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ d√©finitions des entr√©es et sorties pour votre API
        - index.ts
        - **echo.ts** exemple de sch√©ma d'entr√©e et de sortie
        - z-async-iterable.ts wrapper sch√©ma Zod pour la sortie d'abonnement tRPC
      - procedures/ impl√©mentations sp√©cifiques pour vos proc√©dures/routes d'API
        - **echo.ts** exemple d'impl√©mentation de proc√©dure
      - index.ts
      - init.ts configure le contexte et le middleware
      - handler.ts point d'entr√©e du handler Lambda (utilise le streaming de r√©ponse pour les API REST)
      - local-server.ts utilis√© lors de l'ex√©cution du serveur tRPC localement
      - **router.ts** d√©finit le routeur tRPC et toutes les proc√©dures
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Examinons ces fichiers cl√©s :

```ts {5}
// packages/game-api/src/router.ts
import { echo } from './procedures/echo.js';
import { t } from './init.js';

export const router = t.router;

export const appRouter = router({
  echo,
});

export type AppRouter = typeof appRouter;
```
Le routeur d√©finit le routeur tRPC de votre API et c'est l'endroit o√π vous d√©clarerez toutes vos m√©thodes d'API. Comme vous pouvez le voir ci-dessus, nous avons une m√©thode appel√©e `echo` avec son impl√©mentation dans le fichier `./procedures/echo.ts`. Le point d'entr√©e du handler Lambda se trouve dans `handler.ts`, qui est configur√© automatiquement par le g√©n√©rateur.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Ce fichier est l'impl√©mentation de la m√©thode `echo` et comme vous pouvez le voir, elle est fortement typ√©e en d√©clarant ses structures de donn√©es d'entr√©e et de sortie.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Toutes les d√©finitions de sch√©ma tRPC sont d√©finies en utilisant [Zod](https://zod.dev/) et sont export√©es en tant que types TypeScript via la syntaxe `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import { Distribution } from 'aws-cdk-lib/aws-cloudfront';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
  ResponseTransferMode,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AnyPrincipal,
  IGrantable,
  Grant,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// Type d'union de cha√Ænes pour tous les noms d'op√©rations d'API
type Operations = Procedures<AppRouter>;

/**
 * Propri√©t√©s pour cr√©er un construct GameApi
 *
 * @template TIntegrations - Map des noms d'op√©rations vers leurs int√©grations
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Map des noms d'op√©rations vers leurs int√©grations API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un construct CDK qui cr√©e et configure une API REST AWS API Gateway
 * sp√©cifiquement pour GameApi.
 * @template TIntegrations - Map des noms d'op√©rations vers leurs int√©grations
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Cr√©e des int√©grations par d√©faut pour toutes les op√©rations, qui impl√©mentent chaque op√©ration en tant
   * que sa propre fonction Lambda individuelle.
   *
   * @param scope - La port√©e du construct CDK
   * @returns Un IntegrationBuilder avec des int√©grations Lambda par d√©faut
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return {
          handler,
          integration: new LambdaIntegration(handler, {
            responseTransferMode: ResponseTransferMode.STREAM,
          }),
        };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      deployOptions: {
        tracingEnabled: true,
      },
      policy: new PolicyDocument({
        statements: [
          // Ouvrir OPTIONS pour permettre aux navigateurs de faire des requ√™tes de pr√©-v√©rification non authentifi√©es
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }

  /**
   * Restreint CORS aux domaines de distribution CloudFront du site web
   *
   * Configure les domaines de distribution CloudFront comme les seules origines CORS autoris√©es
   * (autres que localhost) dans les int√©grations AWS Lambda
   *
   * Notez que cette restriction n'est pas appliqu√©e aux OPTIONS de pr√©-v√©rification
   *
   * @param websites - La distribution CloudFront √† partir de laquelle accorder CORS
   */
  public restrictCorsTo(
    ...websites: { cloudFrontDistribution: Distribution }[]
  ) {
    const allowedOrigins = websites
      .map(
        ({ cloudFrontDistribution }) =>
          `https://${cloudFrontDistribution.distributionDomainName}`,
      )
      .join(',');

    // D√©finir la variable d'environnement ALLOWED_ORIGINS pour toutes les int√©grations Lambda
    Object.values(this.integrations).forEach((integration) => {
      if ('handler' in integration && integration.handler instanceof Function) {
        integration.handler.addEnvironment('ALLOWED_ORIGINS', allowedOrigins);
      }
    });
  }

  /**
   * Accorde les permissions IAM pour invoquer n'importe quelle m√©thode sur cette API.
   *
   * @param grantee - Le principal IAM auquel accorder les permissions
   */
  public grantInvokeAccess(grantee: IGrantable) {
    // Ici, nous accordons au b√©n√©ficiaire la permission d'appeler l'API.
    // Un acc√®s machine √† machine plus fin peut √™tre d√©fini ici en utilisant des principaux
    // plus sp√©cifiques (par exemple, des r√¥les ou des utilisateurs) et des ressources (par exemple, quels chemins d'API
    // peuvent √™tre invoqu√©s par quel principal) si n√©cessaire.
    this.api.addToResourcePolicy(
      new PolicyStatement({
        effect: Effect.ALLOW,
        principals: [grantee.grantPrincipal],
        actions: ['execute-api:Invoke'],
        resources: ['execute-api:/*'],
      }),
    );

    Grant.addToPrincipal({
      grantee,
      actions: ['execute-api:Invoke'],
      resourceArns: [this.api.arnForExecuteApi('*', '/*', '*')],
    });
  }
}
```

C'est le construct CDK qui d√©finit notre `GameApi`. Il fournit une m√©thode `defaultIntegrations` qui cr√©e automatiquement une fonction Lambda pour chaque proc√©dure de notre API tRPC, pointant vers l'impl√©mentation d'API empaquet√©e. Cela signifie qu'au moment de `cdk synth`, l'empaquetage ne se produit pas (contrairement √† l'utilisation de [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) car nous l'avons d√©j√† empaquet√© dans le cadre de la cible de build du projet backend.

</Drawer>

## T√¢che 3 : Cr√©er des agents de narration

Cr√©ons maintenant nos agents de narration.

### Agent de narration : Projet Python

Pour cr√©er un projet Python :

<RunGenerator generator="py#project" requiredParameters={{name:"story"}} noInteractive />

Vous verrez de nouveaux fichiers appara√Ætre dans votre arborescence de fichiers.
<Drawer title="Fichiers modifi√©s par py#project" trigger="Cliquez ici pour examiner ces fichiers en d√©tail.">
Le g√©n√©rateur `py#project` g√©n√®re ces fichiers :

<FileTree>
- .venv/ environnement virtuel unique pour le monorepo
- packages/
  - story/
    - dungeon_adventure_story/ module Python
      - hello.py fichier Python d'exemple (nous l'ignorerons)
    - tests/
    - .python-version
    - pyproject.toml
    - project.json
- .python-version version Python uv fig√©e
- pyproject.toml
- uv.lock
</FileTree>

Cela a configur√© un projet Python et un [UV Workspace](https://docs.astral.sh/uv/concepts/projects/workspaces/) avec un environnement virtuel partag√©.

</Drawer>

### Agent de narration : Agent Strands

Pour ajouter un agent Strands au projet avec le g√©n√©rateur `py#strands-agent` :

<RunGenerator generator="py#strands-agent" requiredParameters={{project:"story"}} noInteractive />

Vous verrez de nouveaux fichiers appara√Ætre dans votre arborescence de fichiers.
<Drawer title="Fichiers modifi√©s par py#strands-agent" trigger="Cliquez ici pour examiner ces fichiers en d√©tail.">
Le g√©n√©rateur `py#strands-agent` g√©n√®re ces fichiers :

<FileTree>
- packages/
  - story/
    - dungeon_adventure_story/ module Python
      - agent/
        - init.py configure l'application FastAPI et le middleware
        - main.py point d'entr√©e pour votre agent dans Bedrock AgentCore Runtime
        - agent.py d√©finit un exemple d'agent et d'outils
        - agentcore_mcp_client.py utilitaire pour cr√©er des clients pour interagir avec les serveurs MCP
        - Dockerfile d√©finit l'image Docker pour le d√©ploiement sur AgentCore Runtime
  - common/constructs/
    - src
      - app/agents/story-agent/
        - story-agent.ts construct pour d√©ployer votre agent Story sur AgentCore Runtime
</FileTree>

Examinons certains fichiers en d√©tail :

```python
# agent/agent.py
from contextlib import contextmanager

from strands import Agent, tool
from strands_tools import current_time


# D√©finir un outil personnalis√©
@tool
def add(a: int, b: int) -> int:
    return a + b


@contextmanager
def get_agent(session_id: str):
    yield Agent(
        system_prompt="""
Vous √™tes un sorcier de l'addition.
Utilisez l'outil 'add' pour les t√¢ches d'addition.
R√©f√©rez-vous aux outils comme votre 'grimoire'.
""",
        tools=[add, current_time],
    )
```

Cela cr√©e un exemple d'agent Strands et d√©finit un outil d'addition.

```python
# agent/main.py
import uvicorn
from bedrock_agentcore.runtime.models import PingStatus
from pydantic import BaseModel

from .agent import get_agent
from .init import JsonStreamingResponse, app


class InvokeInput(BaseModel):
    prompt: str
    session_id: str


class StreamChunk(BaseModel):
    content: str


async def handle_invoke(input: InvokeInput):
    """Handler de streaming pour l'invocation de l'agent"""
    with get_agent(session_id=input.session_id) as agent:
        stream = agent.stream_async(input.prompt)
        async for event in stream:
            print(event)
            text = event.get("event", {}).get("contentBlockDelta", {}).get("delta", {}).get("text")
            if text is not None:
                yield StreamChunk(content=text)
            elif event.get("event", {}).get("messageStop") is not None:
                yield StreamChunk(content="\n")


@app.post(
    "/invocations",
    response_class=JsonStreamingResponse,
    responses={200: JsonStreamingResponse.openapi_response(StreamChunk, "Stream of agent response chunks")},
)
async def invoke(input: InvokeInput) -> JsonStreamingResponse:
    """Point d'entr√©e pour l'invocation de l'agent"""
    return JsonStreamingResponse(handle_invoke(input))


@app.get("/ping")
def ping() -> str:
    # TODO: si ex√©cution d'une t√¢che asynchrone, retourner PingStatus.HEALTHY_BUSY
    return PingStatus.HEALTHY


if __name__ == "__main__":
    uvicorn.run("dungeon_adventure_story.agent.main:app", port=8080)
```

C'est le point d'entr√©e de l'agent, configur√© comme une application FastAPI compatible avec [Amazon Bedrock AgentCore Runtime](https://github.com/aws/bedrock-agentcore-sdk-python). Il utilise le support de streaming de Strands et diffuse les √©v√©nements au client au fur et √† mesure qu'ils se produisent via JSON Lines.

```ts
// common/constructs/src/app/agents/story-agent.ts
import { Lazy, Names } from 'aws-cdk-lib';
import { Platform } from 'aws-cdk-lib/aws-ecr-assets';
import { Construct } from 'constructs';
import { execSync } from 'child_process';
import * as path from 'path';
import * as url from 'url';
import {
  AgentRuntimeArtifact,
  ProtocolType,
  Runtime,
  RuntimeProps,
} from '@aws-cdk/aws-bedrock-agentcore-alpha';

export type StoryAgentProps = Omit<
  RuntimeProps,
  'runtimeName' | 'protocolConfiguration' | 'agentRuntimeArtifact'
>;

export class StoryAgent extends Construct {
  public readonly dockerImage: AgentRuntimeArtifact;
  public readonly agentCoreRuntime: Runtime;

  constructor(scope: Construct, id: string, props?: StoryAgentProps) {
    super(scope, id);

    this.dockerImage = AgentRuntimeArtifact.fromAsset(
      path.dirname(url.fileURLToPath(new URL(import.meta.url))),
      {
        platform: Platform.LINUX_ARM64,
        extraHash: execSync(
          `docker inspect dungeon-adventure-story-agent:latest --format '{{.Id}}'`,
          { encoding: 'utf-8' },
        ).trim(),
      },
    );

    this.agentCoreRuntime = new Runtime(this, 'StoryAgent', {
      runtimeName: Lazy.string({
        produce: () =>
          Names.uniqueResourceName(this.agentCoreRuntime, { maxLength: 40 }),
      }),
      protocolConfiguration: ProtocolType.HTTP,
      agentRuntimeArtifact: this.dockerImage,
      ...props,
    });
  }
}
```

Cela configure un `AgentRuntimeArtifact` CDK qui t√©l√©charge votre image Docker d'agent vers ECR et l'h√©berge en utilisant AgentCore Runtime.

Vous remarquerez peut-√™tre un `Dockerfile` suppl√©mentaire qui r√©f√©rence l'image Docker du projet `story`, nous permettant de co-localiser le Dockerfile et le code source de l'agent.

</Drawer>

## T√¢che 4 : Configurer les outils d'inventaire

### Inventaire : Projet TypeScript

Cr√©ons un serveur MCP pour fournir des outils √† notre agent Story afin de g√©rer l'inventaire d'un joueur.

Tout d'abord, nous cr√©ons un projet TypeScript :

<RunGenerator generator="ts#project" requiredParameters={{name:"inventory"}} noInteractive />

Cela cr√©era un projet TypeScript vide.

<Drawer title="Fichiers modifi√©s par ts#project" trigger="Cliquez ici pour examiner ces fichiers en d√©tail.">
Le g√©n√©rateur `ts#project` g√©n√®re ces fichiers.

<FileTree>
- packages/
  - inventory/
    - src/
      - index.ts point d'entr√©e avec fonction d'exemple
    - project.json configuration du projet
    - eslint.config.mjs configuration du linter
    - vite.config.mts configuration des tests
    - tsconfig.json configuration TypeScript de base pour le projet
    - tsconfig.lib.json configuration TypeScript pour le projet cibl√©e pour la compilation et l'empaquetage
    - tsconfig.spec.json configuration TypeScript pour les tests
- tsconfig.base.json mis √† jour pour configurer un alias permettant aux autres projets de r√©f√©rencer celui-ci
</FileTree>

</Drawer>

### Inventaire : Serveur MCP

Ensuite, nous allons ajouter un serveur MCP √† notre projet TypeScript :

<RunGenerator generator="ts#mcp-server" requiredParameters={{project:"inventory"}} noInteractive />

Cela ajoutera un serveur MCP.
<Drawer title="Fichiers modifi√©s par ts#mcp-server" trigger="Cliquez ici pour examiner ces fichiers en d√©tail.">
Le g√©n√©rateur `ts#mcp-server` g√©n√®re ces fichiers.

<FileTree>
- packages/
  - inventory/
    - src/mcp-server/
      - index.ts barrel export
      - server.ts cr√©e le serveur MCP
      - tools/
        - add.ts outil d'exemple
      - resources/
        - sample-guidance.ts ressource d'exemple
      - stdio.ts point d'entr√©e pour MCP avec transport STDIO
      - http.ts point d'entr√©e pour MCP avec transport HTTP streamable
      - Dockerfile construit l'image pour AgentCore Runtime
    - rolldown.config.ts configuration pour empaqueter le serveur MCP pour le d√©ploiement sur AgentCore
  - common/constructs/
    - src
      - app/mcp-servers/inventory-mcp-server/
        - inventory-mcp-server.ts construct pour d√©ployer votre serveur MCP d'inventaire sur AgentCore Runtime
</FileTree>

</Drawer>

## T√¢che 5 : Cr√©er l'interface utilisateur (UI)

Dans cette t√¢che, nous allons cr√©er l'interface utilisateur qui vous permettra d'interagir avec le jeu.

### Interface utilisateur du jeu : Site web

Pour cr√©er l'interface utilisateur, cr√©ez un site web appel√© `GameUI` en suivant ces √©tapes :

<RunGenerator generator="ts#react-website" requiredParameters={{name:"GameUI"}} noInteractive />

Vous verrez de nouveaux fichiers appara√Ætre dans votre arborescence de fichiers.

<Drawer title="Fichiers modifi√©s par ts#react-website" trigger="Cliquez ici pour examiner ces fichiers en d√©tail.">
Le g√©n√©rateur `ts#react-website` g√©n√®re ces fichiers. Examinons certains des fichiers cl√©s mis en √©vidence dans l'arborescence :

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK sp√©cifiques √† l'application
          - static-websites/
            - **game-ui.ts** construct CDK pour cr√©er votre interface utilisateur du jeu
        - core/
          - static-website.ts construct g√©n√©rique de site web statique
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.tsx mise en page globale : en-t√™te, pied de page, barre lat√©rale, etc.
      - hooks/
        - useAppLayout.tsx vous permet de d√©finir dynamiquement des √©l√©ments comme les notifications, le style de page, etc.
      - routes/ routes bas√©es sur des fichiers @tanstack/react-router
        - **index.tsx** page racine '/'
        - __root.tsx toutes les pages utilisent ce composant comme base
      - config.ts
      - **main.tsx** point d'entr√©e React
      - routeTree.gen.ts automatiquement mis √† jour par @tanstack/react-router
      - styles.css
    - index.html
    - project.json
    - vite.config.mts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteName: 'GameUI',
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

C'est le construct CDK qui d√©finit notre GameUI. Il a d√©j√† configur√© le chemin de fichier vers le bundle g√©n√©r√© pour notre interface utilisateur bas√©e sur Vite. Cela signifie qu'au moment du `build`, l'empaquetage se produit dans la cible de build du projet game-ui et la sortie est utilis√©e ici.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import '@cloudscape-design/global-styles/index.css';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export type RouterProviderContext = {};

const router = createRouter({
  routeTree,
  context: {},
});

// Enregistrer l'instance du routeur pour la s√©curit√© des types
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const App = () => {
  return <RouterProvider router={router} context={{}} />;
};

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <App />
      </I18nProvider>
    </React.StrictMode>,
  );
```

C'est le point d'entr√©e o√π React est mont√©. Comme indiqu√©, il configure initialement simplement un `@tanstack/react-router` dans une configuration [`file-based-routing`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Tant que votre serveur de d√©veloppement est en cours d'ex√©cution, vous pouvez cr√©er des fichiers dans le dossier `routes` et `@tanstack/react-router` cr√©era la configuration de fichier boilerplate pour vous, ainsi que la mise √† jour du fichier `routeTree.gen.ts`. Ce fichier maintient toutes les routes de mani√®re type-safe, ce qui signifie que lorsque vous utilisez `<Link>`, l'option `to` n'affichera que les routes valides.
Pour plus d'informations, consultez la [documentation de `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new React website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un composant sera rendu lors de la navigation vers la route `/`. `@tanstack/react-router` g√©rera la `Route` pour vous chaque fois que vous cr√©ez/d√©placez ce fichier (tant que le serveur de d√©veloppement est en cours d'ex√©cution).

</Drawer>

### Interface utilisateur du jeu : Authentification

Configurons notre interface utilisateur du jeu pour exiger un acc√®s authentifi√© via Amazon Cognito en suivant ces √©tapes :

<RunGenerator generator="ts#react-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Vous verrez de nouveaux fichiers appara√Ætre/changer dans votre arborescence de fichiers.

<Drawer title="Fichiers modifi√©s par ts#react-website#auth" trigger="Cliquez ici pour examiner ces fichiers en d√©tail.">
Le g√©n√©rateur `ts#react-website#auth` met √† jour/g√©n√®re ces fichiers. Examinons certains des fichiers cl√©s mis en √©vidence dans l'arborescence :

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts construct CDK pour cr√©er des pools d'utilisateurs/d'identit√©
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx ajoute l'utilisateur connect√©/d√©connexion √† l'en-t√™te
        - CognitoAuth/
          - index.tsx g√®re la connexion √† Cognito
        - RuntimeConfig/
          - index.tsx r√©cup√®re le `runtime-config.json` et le fournit aux enfants via le contexte
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Mis √† jour pour ajouter Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import { useAuth } from 'react-oidc-context';
+import CognitoAuth from './components/CognitoAuth';
+import { useRuntimeConfig } from './hooks/useRuntimeConfig';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import '@cloudscape-design/global-styles/index.css';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
-export type RouterProviderContext = {};
+export type RouterProviderContext = {
+  runtimeConfig?: ReturnType<typeof useRuntimeConfig>;
+  auth?: ReturnType<typeof useAuth>;
+};
-const router = createRouter({
-  routeTree,
-  context: {},
-});
+const router = createRouter({
+  routeTree,
+  context: {
+    runtimeConfig: undefined,
+    auth: undefined,
+  },
+});
// Enregistrer l'instance du routeur pour la s√©curit√© des types
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
-const App = () => {
-  return <RouterProvider router={router} context={{}} />;
-};
+const App = () => {
+  const auth = useAuth();
+  const runtimeConfig = useRuntimeConfig();
+  return <RouterProvider router={router} context={{ runtimeConfig, auth }} />;
+};
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <App />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Les composants `RuntimeConfigProvider` et `CognitoAuth` ont √©t√© ajout√©s au fichier `main.tsx` via une transformation AST. Cela permet au composant `CognitoAuth` de s'authentifier avec Amazon Cognito en r√©cup√©rant le `runtime-config.json` qui contient la configuration de connexion Cognito requise pour effectuer les appels backend vers la bonne destination.

</Drawer>

### Interface utilisateur du jeu : Connexion √† l'API du jeu

Configurons notre interface utilisateur du jeu pour se connecter √† notre API GameApi cr√©√©e pr√©c√©demment.

<RunGenerator generator="connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

Vous verrez de nouveaux fichiers appara√Ætre/changer dans votre arborescence de fichiers.

<Drawer title="Fichiers modifi√©s par connection UI -> tRPC" trigger="Cliquez ici pour examiner ces fichiers en d√©tail.">
Le g√©n√©rateur `connection` g√©n√®re/met √† jour ces fichiers. Examinons certains des fichiers cl√©s mis en √©vidence dans l'arborescence :

<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx configure le client GameAPI
      - hooks/
        - **useGameApi.tsx** hooks pour appeler l'API GameApi
      - **main.tsx** injecte les fournisseurs de client tRPC
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { useContext } from 'react';
import { GameApiTRPCContext } from '../components/GameApiClientProvider';

export const useGameApi = () => {
  const container = useContext(GameApiTRPCContext);
  if (!container) {
    throw new Error('useGameApi must be used within GameApiClientProvider');
  }
  return container.optionsProxy;
};

export const useGameApiClient = () => {
  const container = useContext(GameApiTRPCContext);
  if (!container) {
    throw new Error(
      'useGameApiClient must be used within GameApiClientProvider',
    );
  }
  return container.client;
};
```

Ce hook fournit un acc√®s au client tRPC pour appeler le GameApi. Pour des exemples sur la fa√ßon d'appeler des API tRPC, consultez le <Link path="guides/connection/react-trpc#using-the-generated-code">guide d'utilisation du hook tRPC</Link>.

<Aside>
Le hook `useGameApi` est diff√©rent du hook `useStoryApi` car il ne n√©cessite pas de build pour que les changements soient refl√©t√©s gr√¢ce √† l'utilisation par tRPC de [l'inf√©rence TypeScript](https://trpc.io/docs/concepts). Cela permet aux d√©veloppeurs de faire des changements dans leur backend qui sont instantan√©ment refl√©t√©s dans leur frontend.
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import { useAuth } from 'react-oidc-context';
import CognitoAuth from './components/CognitoAuth';
import { useRuntimeConfig } from './hooks/useRuntimeConfig';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import '@cloudscape-design/global-styles/index.css';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
...
const App = () => {
  const auth = useAuth();
  const runtimeConfig = useRuntimeConfig();
  return <RouterProvider router={router} context={{ runtimeConfig, auth }} />;
};
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <App />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Le fichier `main.tsx` a √©t√© mis √† jour via une transformation AST pour injecter les fournisseurs tRPC.

</Drawer>

### Interface utilisateur du jeu : Infrastructure

Cr√©ons le sous-projet final pour l'infrastructure CDK.

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Vous verrez de nouveaux fichiers appara√Ætre/changer dans votre arborescence de fichiers.

<Drawer title="Fichiers modifi√©s par ts#infra" trigger="Cliquez ici pour examiner ces fichiers en d√©tail.">
Le g√©n√©rateur `ts#infra` g√©n√®re/met √† jour ces fichiers. Examinons certains des fichiers cl√©s mis en √©vidence dans l'arborescence :

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - checkov.ts
          - index.ts
  - infra
    - src/
      - stages/
        - **application-stage.ts** stacks CDK d√©finis ici
      - stacks/
        - **application-stack.ts** ressources CDK d√©finies ici
      - **main.ts** point d'entr√©e qui d√©finit toutes les √©tapes
    - cdk.json
    - checkov.yml
    - project.json
    - ...
  - package.json
  - tsconfig.json ajoute des r√©f√©rences
  - tsconfig.base.json ajoute un alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStage } from './stages/application-stage.js';
import { App } from ':dungeon-adventure/common-constructs';

const app = new App();

// Utilisez ceci pour d√©ployer votre propre environnement sandbox (suppose vos informations d'identification CLI)
new ApplicationStage(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
});

app.synth();
```

<Aside type="tip">Si vous voyez une erreur d'importation dans votre IDE, c'est parce que notre projet d'infrastructure n'a pas encore de r√©f√©rence TypeScript configur√©e dans le `tsconfig.json`. Nx a √©t√© [configur√©](https://nx.dev/nx-api/js/generators/typescript-sync) pour cr√©er ces r√©f√©rences *dynamiquement* chaque fois qu'un build/compilation est ex√©cut√© ou si vous ex√©cutez la commande `nx sync` manuellement. Pour plus d'informations, consultez le <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guide TypeScript</Link>.</Aside>

C'est le point d'entr√©e de votre application CDK.

```ts
// packages/infra/src/stacks/application-stack.ts
import { Stack, StackProps } from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends Stack {
  constructor(scope: Construct, id: string, props?: StackProps) {
    super(scope, id, props);

    // Le code qui d√©finit votre stack va ici
  }
}
```

Instancions nos constructs CDK pour construire notre jeu d'aventure de donjon.

</Drawer>

## T√¢che 6 : Mettre √† jour notre infrastructure

Mettons √† jour `packages/infra/src/stacks/application-stack.ts` pour instancier certains de nos constructs g√©n√©r√©s :

<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

:::note
Nous fournissons des int√©grations par d√©faut pour notre API GameApi. Par d√©faut, chaque op√©ration dans notre API est mapp√©e √† une fonction Lambda individuelle pour g√©rer cette op√©ration.
:::

## T√¢che 7 : Construire le code

<Drawer title="Commandes Nx" trigger="Il est maintenant temps de construire notre code pour la premi√®re fois">

###### Cibles uniques vs multiples

La commande `run-many` ex√©cutera une cible sur plusieurs sous-projets list√©s (`--all` les ciblera tous). Cela garantit que les d√©pendances sont ex√©cut√©es dans le bon ordre.

Vous pouvez √©galement d√©clencher un build (ou toute autre t√¢che) pour une cible de projet unique en ex√©cutant la cible directement sur le projet. Par exemple, pour construire le projet `@dungeon-adventure/infra`, ex√©cutez la commande suivante :

<NxCommands commands={['run @dungeon-adventure/infra:build']} />

Vous pouvez √©galement omettre la port√©e et utiliser la syntaxe abr√©g√©e Nx si vous pr√©f√©rez :

<NxCommands commands={['build infra']} />

###### Visualiser vos d√©pendances

Pour visualiser vos d√©pendances, ex√©cutez :

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Mise en cache

Nx s'appuie sur la [mise en cache](https://nx.dev/concepts/how-caching-works) pour que vous puissiez r√©utiliser les artefacts de builds pr√©c√©dents afin d'acc√©l√©rer le d√©veloppement. Il y a une certaine configuration requise pour que cela fonctionne correctement et il peut y avoir des cas o√π vous souhaitez effectuer un build **sans utiliser le cache**. Pour ce faire, ajoutez simplement l'argument `--skip-nx-cache` √† votre commande. Par exemple :

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Si pour une raison quelconque vous souhaitez vider votre cache (stock√© dans le dossier `.nx`), vous pouvez ex√©cuter la commande suivante :

<NxCommands commands={['reset']} />

</Drawer>

En utilisant la ligne de commande, ex√©cutez la commande suivante pour corriger d'abord les probl√®mes de lint :

<PackageManagerShortCommand commands={["lint"]} />

Ensuite, ex√©cutez la commande suivante pour un build complet :

<PackageManagerShortCommand commands={["build"]} />

Vous serez invit√© avec le message suivant :

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Certains fichiers de configuration TypeScript manquent de r√©f√©rences de projet aux projets dont ils d√©pendent ou contiennent des r√©f√©rences de projet obsol√®tes.

Cela entra√Ænera une erreur en CI.

? Souhaitez-vous synchroniser les changements identifi√©s pour mettre √† jour votre workspace ? ‚Ä¶
Oui, synchroniser les changements et ex√©cuter les t√¢ches
Non, ex√©cuter les t√¢ches sans synchroniser les changements
```

Ce message indique que NX a d√©tect√© certains fichiers qui peuvent √™tre mis √† jour automatiquement pour vous. Dans ce cas, il fait r√©f√©rence aux fichiers `tsconfig.json` qui n'ont pas de r√©f√©rences TypeScript configur√©es sur les projets r√©f√©renc√©s.

S√©lectionnez l'option **Oui, synchroniser les changements et ex√©cuter les t√¢ches** pour continuer. Vous devriez remarquer que toutes vos erreurs d'importation li√©es √† l'IDE sont automatiquement r√©solues car le g√©n√©rateur de synchronisation ajoutera automatiquement les r√©f√©rences TypeScript manquantes !

Tous les artefacts construits sont maintenant disponibles dans le dossier `dist/` situ√© √† la racine du monorepo. C'est une pratique standard lors de l'utilisation de projets g√©n√©r√©s par le `@aws/nx-plugin` car cela ne pollue pas votre arborescence de fichiers avec des fichiers g√©n√©r√©s. Si vous souhaitez nettoyer vos fichiers, supprimez le dossier `dist/` sans vous soucier des artefacts de build dispers√©s dans l'arborescence de fichiers.

F√©licitations ! Vous avez cr√©√© tous les sous-projets requis pour commencer √† impl√©menter le c≈ìur de notre jeu d'aventure de donjon IA.  üéâüéâüéâ