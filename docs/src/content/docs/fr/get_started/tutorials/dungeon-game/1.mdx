---
title: "Jeu de Donjon IA"
description: "Un guide pas √† pas pour construire un jeu d'aventure de donjon aliment√© par l'IA en utilisant le @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Module 1 : Configuration du monorepo

Nous allons commencer par cr√©er un nouveau monorepo. Depuis le r√©pertoire de votre choix, ex√©cutez la commande suivante :

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

Cela configurera un monorepo NX dans le r√©pertoire `dungeon-adventure` que vous pourrez ensuite ouvrir dans vscode. Il devrait ressembler √† ceci :

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ c'est ici que r√©sideront vos sous-projets
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configure les param√®tres par d√©faut du CLI Nx et du monorepo
- package.json toutes les d√©pendances node sont d√©finies ici
- pnpm-lock.yaml ou bun.lock, yarn.lock, package-lock.json selon le gestionnaire de paquets
- pnpm-workspace.yaml si vous utilisez pnpm
- README.md
- tsconfig.base.json tous les sous-projets bas√©s sur node √©tendent ce fichier
- tsconfig.json
</FileTree>

Maintenant, nous sommes pr√™ts √† commencer √† cr√©er nos diff√©rents sous-projets en utilisant le `@aws/nx-plugin`.

<Aside type="tip">Il est recommand√© de s'assurer que tous vos fichiers non index√©s sont commit√©s dans Git avant d'ex√©cuter des g√©n√©rateurs. Cela vous permet de voir ce qui a chang√© apr√®s l'ex√©cution du g√©n√©rateur via `git diff`</Aside>

### API du jeu

Commen√ßons par cr√©er notre API de jeu. Pour cela, cr√©ons une API tRPC appel√©e `GameApi` en suivant les √©tapes ci-dessous :

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

Vous devriez voir appara√Ætre de nouveaux fichiers dans votre arborescence.

<Aside>
Le `package.json` racine est maintenant configur√© avec un `type` `module`, ce qui signifie qu'ESM est le type de module par d√©faut pour tous les sous-projets node g√©n√©r√©s par le `@aws/nx-plugin`. Pour plus de d√©tails sur les projets TypeScript, consultez le <Link path="guides/typescript-project">guide ts#project</Link>.
</Aside>

<Drawer title="Fichiers mis √† jour par ts#trpc-api" trigger="Cliquez ici pour examiner ces fichiers plus en d√©tail.">
Voici la liste de tous les fichiers g√©n√©r√©s par le g√©n√©rateur `ts#trpc-api`. Nous allons examiner certains fichiers cl√©s mis en √©vidence dans l'arborescence :
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructions CDK sp√©cifiques √† l'application
          - apis/
            - **game-api.ts** construction CDK pour cr√©er votre API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructions CDK g√©n√©riques
          - api/
            - rest-api.ts construction CDK de base pour une API Gateway Rest
            - trpc-utils.ts utilitaires pour les constructions CDK d'API tRPC
            - utils.ts utilitaires pour les constructions d'API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ types partag√©s
      - src/
        - index.ts
        - runtime-config.ts d√©finition d'interface utilis√©e par CDK et le site web
      - project.json
      - ...
  - game-api/ API tRPC
    - src/
      - client/ client vanilla typiquement utilis√© pour les appels machine √† machine en TS
        - index.ts
        - sigv4.ts
      - middleware/ instrumentation Powertools
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ d√©finitions des entr√©es et sorties de votre API
        - **echo.ts**
      - procedures/ impl√©mentations sp√©cifiques des proc√©dures/routes de votre API
        - **echo.ts**
      - index.ts
      - init.ts configure le contexte et les middlewares
      - local-server.ts utilis√© pour ex√©cuter le serveur tRPC localement
      - **router.ts** point d'entr√©e du handler lambda qui d√©finit toutes les proc√©dures
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Examinons quelques fichiers cl√©s :

```ts {5,12}
// packages/game-api/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
Le routeur d√©finit le point d'entr√©e de votre API tRPC et est l'endroit o√π vous d√©clarez toutes vos m√©thodes d'API. Comme visible ci-dessus, nous avons une m√©thode appel√©e `echo` dont l'impl√©mentation se trouve dans le fichier `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Ce fichier contient l'impl√©mentation de la m√©thode `echo` et, comme visible, est fortement typ√© en d√©clarant ses structures de donn√©es d'entr√©e et de sortie.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Toutes les d√©finitions de sch√©ma tRPC utilisent [Zod](https://zod.dev/) et sont export√©es comme types TypeScript via la syntaxe `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// Type union pour tous les noms d'op√©rations de l'API
type Operations = Procedures<AppRouter>;

/**
 * Propri√©t√©s pour cr√©er une construction GameApi
 *
 * @template TIntegrations - Map des noms d'op√©rations vers leurs int√©grations
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Map des noms d'op√©rations vers leurs int√©grations API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Une construction CDK qui cr√©e et configure une API REST AWS API Gateway
 * sp√©cifiquement pour GameApi.
 * @template TIntegrations - Map des noms d'op√©rations vers leurs int√©grations
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Cr√©e des int√©grations par d√©faut pour toutes les op√©rations, impl√©mentant chaque op√©ration comme
   * sa propre fonction lambda individuelle.
   *
   * @param scope - La port√©e de la construction CDK
   * @returns Un IntegrationBuilder avec les int√©grations lambda par d√©faut
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Ici, nous autorisons toutes les credentials AWS du compte de d√©ploiement √† appeler l'API.
          // Un acc√®s machine √† machine granulaire peut √™tre d√©fini ici en utilisant des principaux plus sp√©cifiques (ex. r√¥les ou
          // utilisateurs) et ressources (ex. quels chemins d'API peuvent √™tre invoqu√©s par quel principal) si n√©cessaire.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Autorise OPTIONS pour permettre aux navigateurs de faire des requ√™tes preflight non authentifi√©es
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

Il s'agit de la construction CDK qui d√©finit notre GameApi. Comme visible, elle fournit une m√©thode `defaultIntegrations` qui cr√©e automatiquement une fonction lambda pour chaque proc√©dure de notre API tRPC, pointant vers l'impl√©mentation de l'API d√©j√† bundle. Cela signifie qu'au moment de `cdk synth`, le bundling ne se produit pas (contrairement √† l'utilisation de [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) car nous l'avons d√©j√† bundle dans le cadre de la cible de build du projet backend.

</Drawer>

### API de l'histoire

Maintenant, cr√©ons notre API de l'histoire. Pour cela, cr√©ons une API Fast appel√©e `StoryApi` en suivant les √©tapes ci-dessous :

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi", moduleName:"story_api"}} noInteractive />

Vous devriez voir appara√Ætre de nouveaux fichiers dans votre arborescence.
<Drawer title="Fichiers mis √† jour par py#fast-api" trigger="Cliquez ici pour examiner ces fichiers plus en d√©tail.">
Voici la liste de tous les fichiers g√©n√©r√©s par le g√©n√©rateur `py#fast-api`. Nous allons examiner certains fichiers cl√©s mis en √©vidence dans l'arborescence :
<FileTree>
- .venv/ environnement virtuel unique pour le monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructions CDK sp√©cifiques √† l'application
          - apis/
            - **story-api.ts** construction CDK pour cr√©er votre API Fast
            - index.ts mis √† jour pour exporter la nouvelle story-api
      - project.json mis √† jour pour ajouter une d√©pendance de build sur story_api
    - types/ types partag√©s
      - src/
        - **runtime-config.ts** mis √† jour pour ajouter la StoryApi
  - story_api/
    - story_api/ module Python
      - init.py configure Powertools, FastAPI et les middlewares
      - **main.py** point d'entr√©e du lambda contenant toutes les routes
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version version Python fig√©e par uv
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import {
  OPERATION_DETAILS,
  Operations,
} from '../../generated/story-api/metadata.gen.js';

/**
 * Propri√©t√©s pour cr√©er une construction StoryApi
 *
 * @template TIntegrations - Map des noms d'op√©rations vers leurs int√©grations
 */
export interface StoryApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Map des noms d'op√©rations vers leurs int√©grations API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Une construction CDK qui cr√©e et configure une API REST AWS API Gateway
 * sp√©cifiquement pour StoryApi.
 * @template TIntegrations - Map des noms d'op√©rations vers leurs int√©grations
 */
export class StoryApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Cr√©e des int√©grations par d√©faut pour toutes les op√©rations, impl√©mentant chaque op√©ration comme
   * sa propre fonction lambda individuelle.
   *
   * @param scope - La port√©e de la construction CDK
   * @returns Un IntegrationBuilder avec les int√©grations lambda par d√©faut
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: OPERATION_DETAILS,
      defaultIntegrationOptions: {
        runtime: Runtime.PYTHON_3_12,
        handler: 'story_api.main.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/story_api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `StoryApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: StoryApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'StoryApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Ici, nous autorisons toutes les credentials AWS du compte de d√©ploiement √† appeler l'API.
          // Un acc√®s machine √† machine granulaire peut √™tre d√©fini ici en utilisant des principaux plus sp√©cifiques (ex. r√¥les ou
          // utilisateurs) et ressources (ex. quels chemins d'API peuvent √™tre invoqu√©s par quel principal) si n√©cessaire.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Autorise OPTIONS pour permettre aux navigateurs de faire des requ√™tes preflight non authentifi√©es
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: OPERATION_DETAILS,
      ...props,
    });
  }
}

```

Il s'agit de la construction CDK qui d√©finit notre StoryApi. Comme visible, elle fournit une m√©thode `defaultIntegrations` qui cr√©e automatiquement une fonction lambda pour chaque op√©ration d√©finie dans notre FastAPI, pointant vers l'impl√©mentation de l'API d√©j√† bundle. Cela signifie qu'au moment de `cdk synth`, le bundling ne se produit pas (contrairement √† [PythonFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/@aws-cdk_aws-lambda-python-alpha.PythonFunction.html)) car nous l'avons d√©j√† bundle dans le cadre de la cible de build du projet backend.

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

C'est ici que toutes vos m√©thodes d'API seront d√©finies. Comme visible ici, nous avons une m√©thode `read_root` mapp√©e sur la route `GET /`. Vous pouvez utiliser [Pydantic](https://docs.pydantic.dev/latest/) pour d√©clarer les entr√©es et sorties de vos m√©thodes afin d'assurer la s√©curit√© des types.

</Drawer>

### Interface utilisateur du jeu : Site web

Maintenant, cr√©ons l'interface utilisateur qui permettra d'interagir avec le jeu. Pour cela, cr√©ons un site web appel√© `GameUI` en suivant les √©tapes ci-dessous :

<RunGenerator generator="ts#react-website" requiredParameters={{name:"GameUI"}} noInteractive />

Vous devriez voir appara√Ætre de nouveaux fichiers dans votre arborescence.

<Drawer title="Fichiers mis √† jour par ts#react-website" trigger="Cliquez ici pour examiner ces fichiers plus en d√©tail.">
Voici la liste de tous les fichiers g√©n√©r√©s par le g√©n√©rateur `ts#react-website`. Nous allons examiner certains fichiers cl√©s mis en √©vidence dans l'arborescence :
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructions CDK sp√©cifiques √† l'application
          - static-websites/
            - **game-ui.ts** construction CDK pour cr√©er votre Game UI
        - core/
          - static-website.ts construction g√©n√©rique de site web statique
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts mise en page globale : en-t√™te, pied de page, barre lat√©rale, etc
          - navitems.ts √©l√©ments de navigation de la barre lat√©rale
      - hooks/
        - useAppLayout.tsx permet de d√©finir dynamiquement des √©l√©ments comme les notifications, le style de page, etc
      - routes/ routes bas√©es sur @tanstack/react-router
        - index.tsx page racine '/' redirige vers '/welcome'
        - __root.tsx toutes les pages utilisent ce composant comme base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** point d'entr√©e React
        - routeTree.gen.ts mis √† jour automatiquement par @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Il s'agit de la construction CDK qui d√©finit notre GameUI. Comme visible, elle a d√©j√† configur√© le chemin vers le bundle g√©n√©r√© pour notre interface Vite. Cela signifie qu'au moment du `build`, le bundling se produit dans la cible de build du projet game-ui et sa sortie est utilis√©e ici.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Enregistre l'instance du routeur pour la s√©curit√© des types
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Il s'agit du point d'entr√©e o√π React est mont√©. Comme montr√©, il configure initialement un `@tanstack/react-router` dans une configuration de [`routage bas√© sur les fichiers`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Cela signifie que tant que votre serveur de d√©veloppement est en cours d'ex√©cution, vous pouvez simplement cr√©er des fichiers dans le dossier `routes` et `@tanstack/react-router` cr√©era la configuration de fichiers n√©cessaire tout en mettant √† jour le fichier `routeTree.gen.ts`. Ce fichier maintient toutes les routes de mani√®re type-safe, ce qui signifie que lorsque vous utilisez `<Link>`, l'option `to` n'affichera que les routes valides. Pour plus d'informations, consultez la [documentation de `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un composant qui sera rendu lors de la navigation vers la route `/welcome`. `@tanstack/react-router` g√©rera la `Route` pour vous lorsque vous cr√©erez/d√©placerez ce fichier (tant que le serveur de d√©veloppement est en cours d'ex√©cution). Cela sera montr√© dans une section ult√©rieure de ce tutoriel.

</Drawer>

### Interface utilisateur du jeu : Authentification

Maintenant, configurons notre Game UI pour exiger un acc√®s authentifi√© via Amazon Cognito en suivant les √©tapes ci-dessous :

<RunGenerator generator="ts#react-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Vous devriez voir appara√Ætre ou changer des fichiers dans votre arborescence.

<Drawer title="Fichiers mis √† jour par ts#react-website#auth" trigger="Cliquez ici pour examiner ces fichiers plus en d√©tail.">
Voici la liste de tous les fichiers g√©n√©r√©s/mis √† jour par le g√©n√©rateur `ts#react-website#auth`. Nous allons examiner certains fichiers cl√©s mis en √©vidence dans l'arborescence :
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts construction CDK pour cr√©er des pools d'utilisateurs/identit√©s
    - types/
      - src/
        - runtime-config.ts mis √† jour pour ajouter cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx ajoute l'utilisateur connect√©/d√©connexion √† l'en-t√™te
        - CognitoAuth/
          - index.ts g√®re la connexion √† Cognito
        - RuntimeConfig/
          - index.tsx r√©cup√®re le `runtime-config.json` et le fournit aux enfants via le contexte
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Mis √† jour pour ajouter Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Enregistre l'instance du routeur pour la s√©curit√© des types
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Les composants `RuntimeConfigProvider` et `CognitoAuth` ont √©t√© ajout√©s au fichier `main.tsx` via une transformation AST. Cela permet au composant `CognitoAuth` de s'authentifier aupr√®s d'Amazon Cognito en r√©cup√©rant le `runtime-config.json` qui contient la configuration de connexion Cognito n√©cessaire pour effectuer les appels backend vers la bonne destination.

</Drawer>

### Interface utilisateur du jeu : Connexion √† l'API de l'histoire

Maintenant, configurons notre Game UI pour se connecter √† notre API Story pr√©c√©demment cr√©√©e :

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

Vous devriez voir appara√Ætre ou changer des fichiers dans votre arborescence.

<Drawer title="Fichiers mis √† jour par la connexion UI -> FastAPI" trigger="Cliquez ici pour examiner ces fichiers plus en d√©tail.">
Voici la liste de tous les fichiers g√©n√©r√©s/mis √† jour par le g√©n√©rateur `api-connection`. Nous allons examiner certains fichiers cl√©s mis en √©vidence dans l'arborescence :
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx utilis√© par StoryApi pour signer les requ√™tes
        - useStoryApiClient.tsx hook pour construire un client StoryApi
        - useStoryApi.tsx hook pour interagir avec StoryApi via TanStack Query
      - components/
        - QueryClientProvider.tsx fournisseur du client TanStack Query
        - StoryApiProvider.tsx fournisseur du hook TanStack Query pour StoryApi
      - main.tsx Instrumente le QueryClientProvider et StoryApiProvider
    - .gitignore ignore les fichiers client g√©n√©r√©s
    - project.json mis √† jour pour ajouter des cibles de g√©n√©ration de hooks openapi
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json mis √† jour pour √©mettre un fichier openapi.json

</FileTree>

```tsx {1,12-15}
// packages/game-ui/src/hooks/useStoryApiClient.tsx
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

Ce hook peut √™tre utilis√© pour effectuer des requ√™tes API authentifi√©es vers la `StoryApi`. Comme visible dans l'impl√©mentation, il utilise le `StoryApi` g√©n√©r√© au moment du build, donc vous verrez une erreur dans votre IDE jusqu'√† ce que nous construisions notre code. Pour plus de d√©tails sur la g√©n√©ration du client ou la consommation de l'API, consultez le <Link path="guides/api-connection/react-fastapi">guide React vers FastAPI</Link>.

```tsx
// packages/game-ui/src/components/StoryApiProvider.tsx
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useStoryApiClient } from '../hooks/useStoryApiClient';
import { StoryApiOptionsProxy } from '../generated/story-api/options-proxy.gen';

export const StoryApiContext = createContext<StoryApiOptionsProxy | undefined>(
  undefined,
);

export const StoryApiProvider: FC<PropsWithChildren> = ({ children }) => {
  const client = useStoryApiClient();
  const optionsProxy = useMemo(
    () => new StoryApiOptionsProxy({ client }),
    [client],
  );

  return (
    <StoryApiContext.Provider value={optionsProxy}>
      {children}
    </StoryApiContext.Provider>
  );
};

export default StoryApiProvider;
```

Ce composant fournisseur utilise le hook `useStoryApiClient` et instancie le `StoryApiOptionsProxy`, qui est utilis√© pour construire les options des hooks TanStack Query. Vous pouvez utiliser le hook correspondant `useStoryApi` pour acc√©der √† ce proxy d'options, qui fournit une mani√®re coh√©rente d'interagir avec votre FastAPI comme avec votre API tRPC.

Comme `useStoryApiClient` nous fournit un it√©rateur asynchrone pour notre API de streaming, nous utiliserons directement le client vanilla dans ce tutoriel.

<Aside type="caution">
Les fichiers `src/generated/story-api/*.gen.ts` ne doivent jamais √™tre modifi√©s manuellement car ils seront r√©g√©n√©r√©s √† chaque build de votre API.
</Aside>

</Drawer>

### Interface utilisateur du jeu : Connexion √† l'API du jeu

Maintenant, configurons notre Game UI pour se connecter √† notre API Game pr√©c√©demment cr√©√©e :

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

Vous devriez voir appara√Ætre ou changer des fichiers dans votre arborescence.

<Drawer title="Fichiers mis √† jour par la connexion UI -> tRPC" trigger="Cliquez ici pour examiner ces fichiers plus en d√©tail.">
Voici la liste de tous les fichiers g√©n√©r√©s/mis √† jour par le g√©n√©rateur `api-connection`. Nous allons examiner certains fichiers cl√©s mis en √©vidence dans l'arborescence :
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx configure le client GameAPI
      - hooks/
        - **useGameApi.tsx** hooks pour appeler la GameApi
      - **main.tsx** injecte les fournisseurs de client trpc
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { GameApiTRCPContext } from '../components/GameApiClientProvider';

export const useGameApi = GameApiTRCPContext.useTRPC;
```

Ce hook utilise l'int√©gration [React Query](https://trpc.io/blog/introducing-tanstack-react-query-client) de tRPC, permettant aux utilisateurs d'interagir directement avec `@tanstack/react-query` sans couches d'abstraction suppl√©mentaires. Pour des exemples d'appels d'API tRPC, consultez le <Link path="guides/api-connection/react-trpc#using-the-generated-code">guide d'utilisation du hook tRPC</Link>.

<Aside>
Le hook `useGameApi` est diff√©rent du hook `useStoryApi` car il ne n√©cessite pas de build pour que les changements soient refl√©t√©s, gr√¢ce √† l'utilisation de [l'inf√©rence TypeScript](https://trpc.io/docs/concepts) par tRPC. Cela permet aux d√©veloppeurs de modifier leur backend et de voir les changements instantan√©ment dans le frontend !
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Enregistre l'instance du routeur pour la s√©curit√© des types
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <RouterProvider router={router} />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Le fichier `main.tsx` a √©t√© mis √† jour via une transformation AST pour injecter les fournisseurs tRPC.

</Drawer>

### Interface utilisateur du jeu : Infrastructure

Maintenant, le dernier sous-projet √† cr√©er est pour l'infrastructure CDK. Pour le cr√©er, suivez les √©tapes ci-dessous :

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Vous devriez voir appara√Ætre ou changer des fichiers dans votre arborescence.

<Drawer title="Fichiers mis √† jour par ts#infra" trigger="Cliquez ici pour examiner ces fichiers plus en d√©tail.">
Voici la liste de tous les fichiers g√©n√©r√©s/mis √† jour par le g√©n√©rateur `ts#infra`. Nous allons examiner certains fichiers cl√©s mis en √©vidence dans l'arborescence :
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts** ressources CDK d√©finies ici
      - index.ts
      - **main.ts** point d'entr√©e qui d√©finit toutes les stacks
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json ajoute des r√©f√©rences
  - tsconfig.base.json ajoute un alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
  App,
  CfnGuardValidator,
  RuleSet,
} from ':dungeon-adventure/common-constructs';

const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

// Utilisez ceci pour d√©ployer votre propre environnement sandbox (suppose les credentials CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

<Aside type="tip">Si vous voyez une erreur d'import dans votre IDE, c'est parce que notre projet d'infrastructure n'a pas encore de r√©f√©rence TypeScript configur√©e dans son tsconfig.json. Nx a √©t√© [configur√©](https://nx.dev/nx-api/js/generators/typescript-sync) pour cr√©er ces r√©f√©rences *dynamiquement* lors d'un build/compilation ou si vous ex√©cutez manuellement la commande `nx sync`. Pour plus d'informations, consultez le <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guide TypeScript</Link>.</Aside>

Il s'agit du point d'entr√©e de votre application CDK.

Elle est configur√©e pour utiliser [`cfn-guard`](https://github.com/cdklabs/cdk-validator-cfnguard) pour ex√©cuter la validation d'infrastructure bas√©e sur le jeu de r√®gles configur√©. Ceci est instrument√© post-synth√®se.

<Aside type="tip">
Il peut y avoir des cas o√π vous souhaitez supprimer certaines r√®gles sur des ressources. Vous pouvez le faire de deux mani√®res :

###### Supprimer une r√®gle sur une construction donn√©e

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// supprime la RULE_NAME pour la construction donn√©e.
suppressRule(construct, 'RULE_NAME');
```

###### Supprimer une r√®gle sur une construction descendante

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// Supprime la RULE_NAME pour la construction ou ses descendantes si c'est une instance de Bucket
suppressRule(construct, 'RULE_NAME', (construct) => construct instanceof Bucket);
```
</Aside>

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Le code qui d√©finit votre stack va ici
  }
}
```

C'est ici que nous instancierons nos constructions CDK pour construire notre jeu d'aventure.

</Drawer>

#### Mettre √† jour notre infrastructure

Modifions notre `packages/infra/src/stacks/application-stack.ts` pour instancier certaines de nos constructions d√©j√† g√©n√©r√©es :

<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

Notez ici que nous fournissons des int√©grations par d√©faut pour nos deux API. Par d√©faut, chaque op√©ration de notre API est mapp√©e √† une fonction lambda individuelle pour g√©rer cette op√©ration.

### Construction de notre code

<Drawer title="Commandes Nx" trigger="Il est maintenant temps de construire notre code pour la premi√®re fois">
###### Cibles uniques vs multiples

La commande `run-many` ex√©cutera une cible sur plusieurs sous-projets list√©s (`--all` les cible tous). Elle s'assure que les d√©pendances sont ex√©cut√©es dans le bon ordre.

Vous pouvez aussi d√©clencher un build (ou toute autre t√¢che) pour une cible de projet unique en ex√©cutant la cible sur le projet directement. Par exemple, si nous voulons build le projet `@dungeon-adventure/infra`, vous pouvez ex√©cuter :

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualiser vos d√©pendances

Vous pouvez aussi visualiser vos d√©pendances via :

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Cache

Nx s'appuie sur le [cache](https://nx.dev/concepts/how-caching-works) pour r√©utiliser les artefacts des builds pr√©c√©dents et acc√©l√©rer le d√©veloppement. Une configuration est n√©cessaire pour que cela fonctionne correctement, et il peut y avoir des cas o√π vous voulez effectuer un build **sans utiliser le cache**. Pour cela, ajoutez simplement l'argument `--skip-nx-cache` √† votre commande. Par exemple :

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Si jamais vous souhaitez vider votre cache (stock√© dans le dossier `.nx`), vous pouvez ex√©cuter :

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

Vous devriez voir appara√Ætre ce qui suit :

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? ‚Ä¶
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Ce message indique que NX a d√©tect√© des fichiers qui peuvent √™tre mis √† jour automatiquement. Dans ce cas, il s'agit des fichiers `tsconfig.json` qui n'ont pas de r√©f√©rences TypeScript configur√©es sur les projets r√©f√©renc√©s. S√©lectionnez l'option **Yes, sync the changes and run the tasks** pour continuer. Vous devriez voir toutes les erreurs d'import dans votre IDE se r√©soudre automatiquement car le g√©n√©rateur de synchronisation ajoutera les r√©f√©rences TypeScript manquantes !

<Aside type="tip">
Si vous rencontrez des erreurs de lint, vous pouvez ex√©cuter la commande suivante pour les corriger automatiquement.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

<Aside type="caution" title="√âchec de build sur Windows">
<Drawer trigger="Si vous √™tes sur Windows et rencontrez une erreur de build, cliquez ici." title="√âchec de build Windows">
Si vous rencontrez une erreur de build/synth pour le projet `@dungeon-adventure/infra`, c'est attendu car la biblioth√®que qui instrumente `cfn-guard` ne supporte actuellement pas Windows. Une demande de fonctionnalit√© suit cela, mais en attendant nous pouvons d√©sactiver `cfn-guard` en modifiant le fichier `packages/infra/src/main.ts` comme suit :

```diff lang="ts"
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
   App,
-  CfnGuardValidator,
-  RuleSet,
} from ':dungeon-adventure/common-constructs';
-
-const app = new App({
-  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
-});
+const app = new App();

// Utilisez ceci pour d√©ployer votre propre environnement sandbox (suppose les credentials CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```
</Drawer>
</Aside>

Tous les artefacts construits sont maintenant disponibles dans le dossier `dist/` √† la racine du monorepo. C'est une pratique standard avec les projets g√©n√©r√©s par le `@aws/nx-plugin` car cela ne pollue pas votre arborescence avec des fichiers g√©n√©r√©s. Si vous souhaitez nettoyer vos fichiers, vous pouvez simplement supprimer le dossier `dist/` sans craindre de fichiers g√©n√©r√©s √©parpill√©s.

F√©licitations ! Vous avez cr√©√© tous les sous-projets n√©cessaires pour commencer √† impl√©menter le c≈ìur de notre jeu Dunegeon Adventure.  üéâüéâüéâ