---
title: "Jeu de Donjon IA"
description: "Un guide pas à pas pour construire un jeu d'aventure de donjon alimenté par l'IA en utilisant le @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Module 1 : Configurer votre monorepo

Commencez par créer un nouveau monorepo. Un monorepo est un dépôt unique contenant plusieurs projets distincts, avec des relations bien définies.

Dans le répertoire de votre choix, exécutez la commande suivante :

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

Cela configurera un monorepo NX dans le répertoire `dungeon-adventure`.  
Ouvrez le répertoire dans VSCode. Vous verrez la structure de fichiers suivante :

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ ici résideront vos sous-projets
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configure le CLI NX et les paramètres par défaut du monorepo
- package.json toutes les dépendances Node sont définies ici
- pnpm-lock.yaml ou bun.lock, yarn.lock, package-lock.json selon le gestionnaire de paquets
- pnpm-workspace.yaml si vous utilisez pnpm
- README.md
- tsconfig.base.json étendu par tous les sous-projets basés sur Node
- tsconfig.json
</FileTree>

Avant d'ajouter des composants du `@aws/nx-plugin` dans le monorepo, nous devons l'installer comme dépendance de développement.  
Pour ce faire, exécutez la commande suivante à la racine du monorepo `dungeon-adventure` :

<InstallCommand dev pkg="@aws/nx-plugin" />

Nous sommes maintenant prêts à créer nos différents sous-projets en utilisant le `@aws/nx-plugin`.

<Aside type="tip">Nous recommandons de commiter vos fichiers non stagés dans Git avant d'exécuter des générateurs. Cela vous permet de voir les modifications via `git diff` après exécution.</Aside>

### Générer l'API du jeu

Nous commencerons par créer notre API de jeu. Cette API gère l'état du jeu.  
Pour ce faire, créez une API tRPC appelée `GameApi` en suivant ces étapes :

<RunGenerator generator="ts#trpc-api" requiredParameters={{apiName:"GameApi"}} noInteractive />

<br />

Vous verrez apparaître de nouveaux fichiers dans l'arborescence.

<Drawer title="Fichiers mis à jour par ts#trpc-api" trigger="Cliquez pour examiner ces fichiers en détail.">
Voici la liste des fichiers générés par le générateur `ts#trpc-api`. Examinons certains fichiers clés :
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK spécifiques à l'application
          - http-apis/
            - **game-api.ts** construct CDK pour créer votre API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructs CDK génériques
          - http-api.ts construct CDK de base pour une API HTTP
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ types partagés
      - src/
        - index.ts
        - runtime-config.ts définition d'interface utilisée par CDK et le site web
      - project.json
      - ...
  - game-api/
    - backend/ code d'implémentation tRPC
      - src/
        - client/ client vanilla pour appels machine à machine
          - index.ts
          - sigv4.ts
        - middleware/ instrumentation Powertools
          - error.ts
          - index.ts
          - logger.ts
          - metrics.ts
          - tracer.ts
        - procedures/ implémentations des procédures/routes de l'API
          - **echo.ts**
        - index.ts
        - init.ts configure le contexte et middleware
        - local-server.ts utilisé pour exécuter le serveur tRPC localement
        - **router.ts** point d'entrée du handler Lambda définissant toutes les procédures
      - project.json
      - ...
    - schema/
      - src/
        - procedures/
          - **echo.ts**
        - index.ts
      - project.json
      - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Examinons ces fichiers clés :

```ts {5,12}
// packages/game-api/backend/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>,
  ) => ctx,
});

export type AppRouter = typeof appRouter;
```
Le routeur définit le point d'entrée de votre API tRPC et est l'endroit où vous déclarez toutes vos méthodes API.  
Nous avons une méthode `echo` avec son implémentation dans le fichier `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/backend/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from ':dungeon-adventure/game-api-schema';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Ce fichier implémente la méthode `echo`, fortement typée en déclarant ses structures de données d'entrée/sortie. Il importe ces définitions du projet `:dungeon-adventure/game-api-schema` qui est un [alias](https://www.typescriptlang.org/tsconfig/paths.html) vers le projet de schéma.

<Aside type="tip">Si vous voyez une erreur d'import dans votre IDE, c'est peut-être car le backend n'a pas encore de référence TypeScript configurée dans son `tsconfig.json`. Nx est [configuré](https://nx.dev/nx-api/js/generators/typescript-sync) pour créer ces références *dynamiquement* lors d'un build/compilation, ou via la commande `nx sync`. Pour plus d'informations, consultez le <Link path="guides/typescript-project#importing-your-library-code-inother-projects">guide TypeScript</Link>.</Aside>

```ts
// packages/game-api/schema/src/procedures/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Tous les schémas tRPC sont définis avec [Zod](https://zod.dev/), et exportés comme types TypeScript via `z.TypeOf`.

```ts
// packages/common/constructs/src/app/http-apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import { HttpApi } from '../../core/http-api.js';
import { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';
import { Runtime } from 'aws-cdk-lib/aws-lambda';

export class GameApi extends HttpApi {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      defaultAuthorizer: new HttpIamAuthorizer(),
      apiName: 'GameApi',
      runtime: Runtime.NODEJS_LATEST,
      handler: 'index.handler',
      handlerFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-api/backend/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Ce construct CDK définit notre GameApi. Il configure le chemin du handler vers le bundle généré, évitant le bundling lors de `cdk synth` (contrairement à [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)), car le bundling est déjà effectué lors du build du projet backend.

</Drawer>

<Aside>
Le `package.json` racine est maintenant configuré avec un `type` `module`, signifiant qu'ESM est le type de module par défaut pour tous les sous-projets Node générés par `@aws/nx-plugin`. Pour plus de détails, consultez le <Link path="guides/typescript-project">guide ts#project</Link>.
</Aside>

### Générer l'API d'histoire

Créons maintenant notre API d'histoire avec le générateur FastAPI. Cette API utilise des réponses en streaming pour générer des histoires avec Amazon Bedrock.  
Pour ce faire, créez une API Fast appelée `StoryApi` :

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi"}} noInteractive />

Vous verrez apparaître de nouveaux fichiers.

<Drawer title="Fichiers mis à jour par py#fast-api" trigger="Cliquez pour examiner ces fichiers en détail.">
Voici les fichiers générés par `py#fast-api`. Examinons les fichiers clés :
<FileTree>
- .venv/ environnement virtuel unique pour le monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ 
          - http-apis/
            - **story-api.ts** construct CDK pour l'API Fast
            - index.ts mis à jour pour exporter la nouvelle API
      - project.json ajoute une dépendance de build sur story_api
    - types/
      - src/
        - **runtime-config.ts** mis à jour avec StoryApi
  - story_api/
    - story_api/ module Python
      - init.py configure Powertools, FastAPI et middleware
      - **main.py** point d'entrée Lambda contenant toutes les routes
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
- .python-version version Python figée
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/http-apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import { HttpApi } from '../../core/http-api.js';
import { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';
import { Runtime } from 'aws-cdk-lib/aws-lambda';

export class StoryApi extends HttpApi {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      defaultAuthorizer: new HttpIamAuthorizer(),
      apiName: 'StoryApi',
      runtime: Runtime.PYTHON_3_12,
      handler: 'story_api.main.handler',
      handlerFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/story_api/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Ce construct CDK définit StoryApi, configurant le chemin du handler vers le bundle généré, évitant le bundling lors de `cdk synth`.

```diff lang="ts"
// packages/common/types/src/runtime-config.ts
export type ApiUrl = string;
// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-empty-interface
export interface IRuntimeConfig {
  httpApis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

Exemple de transformation AST préservant le code existant : `StoryApi` est ajouté à `IRuntimeConfig`, assurant la sécurité des types côté frontend.

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

Point de définition des méthodes API. Utilisez [Pydantic](https://docs.pydantic.dev/latest/) pour la sécurité des types.

</Drawer>

### Ajouter l'interface utilisateur du jeu

Créez l'interface utilisateur avec le générateur CloudScape :

<RunGenerator generator="ts#cloudscape-website" requiredParameters={{name:"GameUI"}} noInteractive />

Vous verrez apparaître de nouveaux fichiers.

<Drawer title="Fichiers mis à jour par ts#cloudscape-website" trigger="Cliquez pour examiner ces fichiers en détail.">
Fichiers clés générés :
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/
          - static-websites/
            - **game-ui.ts** construct CDK pour l'UI
        - core/
          - static-website.ts construct de site statique générique
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts mise en page globale
          - navitems.ts éléments de navigation
      - hooks/
        - useAppLayout.tsx configuration dynamique
      - routes/ routage basé sur les fichiers
        - index.tsx redirige vers '/welcome'
        - __root.tsx composant de base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** entrée React
        - routeTree.gen.ts généré automatiquement
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Construct CDK pour GameUI, utilisant le bundle généré par Vite.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Point de montage React avec routage basé sur les fichiers. Consultez la [doc](https://tanstack.com/router/v1/docs/framework/react/quick-start) pour plus d'informations.

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Bienvenue sur votre nouveau site Web Cloudscape !</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Composant affiché sur la route `/welcome`.

</Drawer>

### Ajouter l'authentification à l'interface

Configurez l'authentification via Amazon Cognito :

<RunGenerator generator="ts#cloudscape-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Nouveaux fichiers générés :

<Drawer title="Fichiers mis à jour par ts#cloudscape-website#auth" trigger="Cliquez pour examiner ces fichiers en détail.">
Fichiers clés :
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts construct Cognito
    - types/
      - src/
        - runtime-config.ts ajout de cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx ajout utilisateur connecté
        - CognitoAuth/
          - index.ts gestion de la connexion
        - RuntimeConfig/
          - index.tsx récupère runtime-config.json
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** ajout Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
...
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Ajout des providers pour l'authentification Cognito.

</Drawer>

### Connecter l'interface à l'API d'histoire

Configurez la connexion à StoryApi :

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

Nouveaux fichiers générés :

<Drawer title="Fichiers mis à jour par api-connection (UI -> FastAPI)" trigger="Cliquez pour examiner ces fichiers en détail.">
Fichiers clés :
<FileTree>
- packages/game-ui/
  - src/
    - hooks/
      - useSigV4.tsx signature des requêtes
      - useStoryApiClient.tsx client StoryApi
      - useStoryApi.tsx intégration TanStack Query
    - components/
      - QueryClientProvider.tsx provider TanStack Query
      - StoryApiProvider.tsx provider des hooks
    - main.tsx injection des providers
  - .gitignore ignore les clients générés
  - project.json cibles de génération OpenAPI
</FileTree>

```tsx {1,12-15}
// packages/game-ui/src/hooks/useStoryApiClient.tsx
import { StoryApi } from '../generated/story-api/client.gen';
...
export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.httpApis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

Hook pour requêtes authentifiées vers StoryApi. Consultez le <Link path="guides/api-connection/react-fastapi">guide React-FastAPI</Link>.

```tsx
// packages/game-ui/src/components/StoryApiProvider.tsx
...
export const StoryApiProvider: FC<PropsWithChildren> = ({ children }) => {
  const client = useStoryApiClient();
  const optionsProxy = useMemo(
    () => new StoryApiOptionsProxy({ client }),
    [client],
  );

  return (
    <StoryApiContext.Provider value={optionsProxy}>
      {children}
    </StoryApiContext.Provider>
  );
};
```

Provider utilisant le client StoryApi avec TanStack Query.

<Aside type="caution">
Les fichiers `src/generated/story-api/*.gen.ts` ne doivent jamais être modifiés manuellement.
</Aside>

</Drawer>

### Connecter l'interface à l'API de jeu

Configurez la connexion à GameApi :

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api-backend"}} noInteractive />

Nouveaux fichiers générés :

<Drawer title="Fichiers mis à jour par api-connection (UI -> tRPC)" trigger="Cliquez pour examiner ces fichiers en détail.">
Fichiers clés :
<FileTree>
- packages/game-ui/
  - src/
    - components/
      - TrpcClients/
        - index.tsx
        - TrpcApis.tsx APIs tRPC configurées
        - TrpcClientProviders.tsx providers par API
        - TrpcProvider.tsx
    - hooks/
      - **useGameApi.tsx** hooks tRPC
    - **main.tsx** injection des providers
</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { TrpcApis } from '../components/TrpcClients';

export const useGameApi = () => TrpcApis.GameApi.useTRPC();
```

Hook utilisant l'intégration [React Query](https://trpc.io/blog/introducing-tanstack-react-query-client) de tRPC.

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import TrpcClientProviders from './components/TrpcClients';
+import QueryClientProvider from './components/QueryClientProvider';
...
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <TrpcClientProviders>
                <RouterProvider router={router} />
+              </TrpcClientProviders>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Injection des providers tRPC.

</Drawer>

### Créer l'infrastructure CDK

Générez le projet d'infrastructure CDK :

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Nouveaux fichiers générés :

<Drawer title="Fichiers mis à jour par ts#infra" trigger="Cliquez pour examiner ces fichiers en détail.">
Fichiers clés :
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts** ressources CDK
      - index.ts
      - **main.ts** point d'entrée CDK
    - cdk.json
    - project.json
</FileTree>

```ts
// packages/infra/src/main.ts
...
const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

Point d'entrée CDK avec validation via [cfn-guard](https://github.com/cdklabs/cdk-validator-cfnguard).

```ts
// packages/infra/src/stacks/application-stack.ts
...
export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Le code définissant votre stack va ici
  }
}
```

Endroit où instancier les constructs CDK.

</Drawer>

#### Mettre à jour l'infrastructure CDK

Mettez à jour `application-stack.ts` pour instancier les constructs :

```diff lang="ts"
+import {
+  GameApi,
+  GameUI,
+  StoryApi,
+  UserIdentity,
+} from ':dungeon-adventure/common-constructs';
...
export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

+    const userIdentity = new UserIdentity(this, 'UserIdentity');
+
+    const gameApi = new GameApi(this, 'GameApi');
+    const storyApi = new StoryApi(this, 'StoryApi');
+
+    [storyApi, gameApi].forEach((api) =>
+      api.grantInvokeAccess(userIdentity.identityPool.authenticatedRole),
+    );
+
+    new GameUI(this, 'GameUI');
  }
}
```

### Construire notre code

<Drawer title="Commandes Nx" trigger="Il est temps de construire notre code pour la première fois">
###### Cibles uniques vs multiples

La commande `run-many` exécute une cible sur plusieurs projets (`--all` pour tous). Les dépendances sont résolues automatiquement.

Pour une cible unique :

<NxCommands commands={['run @dungeon-adventure/infra:build']} />

###### Visualisation des dépendances

Visualisez les dépendances avec :

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Cache

Nx utilise le [cache](https://nx.dev/concepts/how-caching-works) pour accélérer les builds. Utilisez `--skip-nx-cache` pour ignorer le cache :

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />

Effacez le cache avec :

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

Vous serez invité à :

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Certains fichiers de configuration TypeScript manquent de références de projet.

? Souhaitez-vous synchroniser les changements identifiés ? …
Oui, synchroniser et exécuter les tâches
Non, exécuter sans synchroniser
```

Sélectionnez **Oui** pour résoudre les références TypeScript automatiquement.

<Aside type="tip">
Corrigez les erreurs de lint avec :

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

<Aside type="caution" title="Erreur de build Windows">
<Drawer trigger="Si erreur sur Windows, cliquez ici." title="Échec de build Windows">
Modifiez `packages/infra/src/main.ts` pour désactiver cfn-guard :

```diff lang="ts"
-const app = new App({
-  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
-});
+const app = new App();
```
</Drawer>
</Aside>

Les artefacts construits sont dans `dist/`. Vous pouvez supprimer ce dossier pour nettoyer.

Félicitations ! Vous avez créé tous les sous-projets nécessaires pour implémenter le cœur de votre jeu Dungeon Adventure. 🎉🎉🎉