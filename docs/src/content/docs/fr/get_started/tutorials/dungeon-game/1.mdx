---
title: "Configurer un monorepo"
description: "Un guide pas à pas pour construire un jeu d'aventure de donjon alimenté par une IA agentique en utilisant le @aws/nx-plugin."
---

import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Tâche 1 : Créer un monorepo

Pour créer un nouveau monorepo, depuis le répertoire de votre choix, exécutez la commande suivante :

<CreateNxWorkspaceCommand workspace="dungeon-adventure" iacProvider="CDK" />

:::note
Nous utilisons `--iacProvider=CDK` car nous utiliserons CDK pour l'infrastructure as code dans ce tutoriel. Le plugin Nx pour AWS supporte également `Terraform`.
:::

Cela configurera un monorepo NX dans le répertoire `dungeon-adventure`. Lorsque vous ouvrez le répertoire dans VSCode, vous verrez cette structure de fichiers :

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ c'est ici que résideront vos sous-projets
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configure le CLI Nx et les paramètres par défaut du monorepo
- package.json toutes les dépendances Node sont définies ici
- pnpm-lock.yaml ou bun.lock, yarn.lock, package-lock.json selon le gestionnaire de paquets
- pnpm-workspace.yaml si utilisation de pnpm
- README.md
- tsconfig.base.json tous les sous-projets Node étendent ce fichier
- tsconfig.json
- aws-nx-plugin.config.mts configuration du plugin Nx pour AWS
</FileTree>

Nous pouvons maintenant commencer à créer nos différents sous-projets en utilisant le `@aws/nx-plugin`.

<Aside type="tip">Il est recommandé de s'assurer que tous vos fichiers non commités sont sauvegardés dans Git avant d'exécuter des générateurs. Cela vous permet de voir ce qui a changé après l'exécution de votre générateur via `git diff`.</Aside>

## Tâche 2 : Créer une API de jeu

Tout d'abord, créons notre API de jeu. Pour ce faire, créez une API tRPC appelée `GameApi` en suivant ces étapes :

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

Vous verrez de nouveaux fichiers apparaître dans votre arborescence de fichiers.

<Aside>
Le `package.json` racine est maintenant configuré avec un `type` à `module`, ce qui signifie que ESM est le type de module par défaut pour tous les sous-projets Node générés par le `@aws/nx-plugin`. 
Pour plus de détails sur le travail avec les projets TypeScript, consultez le <Link path="guides/typescript-project">guide du générateur ts#project</Link>.
</Aside>

<Drawer title="Fichiers modifiés par ts#trpc-api" trigger="Cliquez ici pour examiner ces fichiers en détail.">
Voici la liste de tous les fichiers générés par le générateur `ts#trpc-api`. Nous allons examiner certains des fichiers clés mis en évidence dans l'arborescence :
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK spécifiques à l'application
          - apis/
            - **game-api.ts** construct CDK pour créer votre API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructs CDK génériques
          - api/
            - rest-api.ts construct CDK de base pour une API Gateway Rest API
            - trpc-utils.ts utilitaires pour les constructs CDK d'API tRPC
            - utils.ts utilitaires pour les constructs d'API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ types partagés
      - src/
        - index.ts
        - runtime-config.ts définition d'interface utilisée par CDK et le site web
      - project.json
      - ...
  - game-api/ API tRPC
    - src/
      - client/ client vanilla typiquement utilisé pour les appels TypeScript machine à machine
        - index.ts
        - sigv4.ts
      - middleware/ instrumentation Powertools
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ définitions des entrées et sorties pour votre API
        - **echo.ts**
      - procedures/ implémentations spécifiques pour vos procédures/routes d'API
        - **echo.ts**
      - index.ts
      - init.ts configure le contexte et le middleware
      - local-server.ts utilisé lors de l'exécution du serveur tRPC localement
      - **router.ts** point d'entrée pour votre handler Lambda qui définit toutes les procédures
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Examinons ces fichiers clés :

```ts {5,12}
// packages/game-api/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
Le routeur définit le point d'entrée de votre API tRPC et c'est l'endroit où vous déclarerez toutes vos méthodes d'API. Comme vous pouvez le voir ci-dessus, nous avons une méthode appelée `echo` avec son implémentation dans le fichier `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Ce fichier est l'implémentation de la méthode `echo` et comme vous pouvez le voir, elle est fortement typée en déclarant ses structures de données d'entrée et de sortie.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Toutes les définitions de schéma tRPC sont définies en utilisant [Zod](https://zod.dev/) et sont exportées en tant que types TypeScript via la syntaxe `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// Type d'union de chaînes pour tous les noms d'opérations d'API
type Operations = Procedures<AppRouter>;

/**
 * Propriétés pour créer un construct GameApi
 *
 * @template TIntegrations - Map des noms d'opérations vers leurs intégrations
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Map des noms d'opérations vers leurs intégrations API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un construct CDK qui crée et configure une API REST AWS API Gateway
 * spécifiquement pour GameApi.
 * @template TIntegrations - Map des noms d'opérations vers leurs intégrations
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crée des intégrations par défaut pour toutes les opérations, qui implémentent chaque opération en tant
   * que sa propre fonction Lambda individuelle.
   *
   * @param scope - La portée du construct CDK
   * @returns Un IntegrationBuilder avec des intégrations Lambda par défaut
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Ici, nous accordons à toutes les informations d'identification AWS du compte dans lequel le projet est déployé
          // le droit d'appeler l'API. Un accès machine à machine plus fin peut être défini ici en utilisant des principaux
          // plus spécifiques (par exemple, des rôles ou des utilisateurs) et des ressources (par exemple, quels chemins d'API
          // peuvent être invoqués par quel principal) si nécessaire.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Ouvrir OPTIONS pour permettre aux navigateurs de faire des requêtes de pré-vérification non authentifiées
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

C'est le construct CDK qui définit notre `GameApi`. Il fournit une méthode `defaultIntegrations` qui crée automatiquement une fonction Lambda pour chaque procédure de notre API tRPC, pointant vers l'implémentation d'API empaquetée. Cela signifie qu'au moment de `cdk synth`, l'empaquetage ne se produit pas (contrairement à l'utilisation de [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) car nous l'avons déjà empaqueté dans le cadre de la cible de build du projet backend.

</Drawer>

## Tâche 3 : Créer des agents de narration

Créons maintenant nos agents de narration. 

### Agent de narration : Projet Python

Pour créer un projet Python :

<RunGenerator generator="py#project" requiredParameters={{name:"story"}} noInteractive />

Vous verrez de nouveaux fichiers apparaître dans votre arborescence de fichiers.
<Drawer title="Fichiers modifiés par py#project" trigger="Cliquez ici pour examiner ces fichiers en détail.">
Le générateur `py#project` génère ces fichiers :

<FileTree>
- .venv/ environnement virtuel unique pour le monorepo
- packages/
  - story/
    - dungeon_adventure_story/ module Python
      - hello.py fichier Python d'exemple (nous l'ignorerons)
    - tests/
    - .python-version
    - pyproject.toml
    - project.json
- .python-version version Python uv figée
- pyproject.toml
- uv.lock
</FileTree>

Cela a configuré un projet Python et un [UV Workspace](https://docs.astral.sh/uv/concepts/projects/workspaces/) avec un environnement virtuel partagé.

</Drawer>

### Agent de narration : Agent Strands

Pour ajouter un agent Strands au projet avec le générateur `py#strands-agent` :

<RunGenerator generator="py#strands-agent" requiredParameters={{project:"story"}} noInteractive />

Vous verrez de nouveaux fichiers apparaître dans votre arborescence de fichiers.
<Drawer title="Fichiers modifiés par py#strands-agent" trigger="Cliquez ici pour examiner ces fichiers en détail.">
Le générateur `py#strands-agent` génère ces fichiers :

<FileTree>
- packages/
  - story/
    - dungeon_adventure_story/ module Python
      - agent/
        - main.py point d'entrée pour votre agent dans Bedrock AgentCore Runtime
        - agent.py définit un exemple d'agent et d'outils
        - agentcore_mcp_client.py utilitaire pour créer des clients pour interagir avec les serveurs MCP
        - Dockerfile définit l'image Docker pour le déploiement sur AgentCore Runtime
  - common/constructs/
    - src
      - core/agent-core/
        - runtime.ts construct générique pour le déploiement sur AgentCore Runtime
      - app/agents/story-agent/
        - story-agent.ts construct pour déployer votre agent Story sur AgentCore Runtime
</FileTree>

Examinons certains fichiers en détail :

```python
# agent/agent.py
from contextlib import contextmanager

from strands import Agent, tool
from strands_tools import current_time


# Définir un outil personnalisé
@tool
def add(a: int, b: int) -> int:
    return a + b


@contextmanager
def get_agent(session_id: str):
    yield Agent(
        system_prompt="""
Vous êtes un sorcier de l'addition.
Utilisez l'outil 'add' pour les tâches d'addition.
Référez-vous aux outils comme votre 'grimoire'.
""",
        tools=[add, current_time],
    )
```

Cela crée un exemple d'agent Strands et définit un outil d'addition.

```python
# agent/main.py
from bedrock_agentcore.runtime import BedrockAgentCoreApp

from .agent import get_agent

app = BedrockAgentCoreApp()


@app.entrypoint
async def invoke(payload, context):
    """Handler pour l'invocation de l'agent"""
    prompt = payload.get(
        "prompt", "Aucun prompt trouvé dans l'entrée, veuillez guider l'utilisateur "
        "à créer un payload JSON avec une clé prompt"
    )

    with get_agent(session_id=context.session_id) as agent:
        stream = agent.stream_async(prompt)
        async for event in stream:
            print(event)
            yield (event)


if __name__ == "__main__":
    app.run()
```

C'est le point d'entrée de l'agent, configuré en utilisant le [SDK Amazon Bedrock AgentCore](https://github.com/aws/bedrock-agentcore-sdk-python). Il utilise le support de streaming de Strands et diffuse les événements au client au fur et à mesure qu'ils se produisent.

```ts
// common/constructs/src/app/agents/story-agent.ts
import { Lazy, Names } from 'aws-cdk-lib';
import { DockerImageAsset, Platform } from 'aws-cdk-lib/aws-ecr-assets';
import { Construct } from 'constructs';
import { execSync } from 'child_process';
import * as path from 'path';
import * as url from 'url';
import {
  AgentCoreRuntime,
  AgentCoreRuntimeProps,
} from '../../../core/agent-core/runtime.js';

export type StoryAgentProps = Omit<
  AgentCoreRuntimeProps,
  'runtimeName' | 'serverProtocol' | 'containerUri'
>;

export class StoryAgent extends Construct {
  public readonly dockerImage: DockerImageAsset;
  public readonly agentCoreRuntime: AgentCoreRuntime;

  constructor(scope: Construct, id: string, props?: StoryAgentProps) {
    super(scope, id);

    this.dockerImage = new DockerImageAsset(this, 'DockerImage', {
      platform: Platform.LINUX_ARM64,
      directory: path.dirname(url.fileURLToPath(new URL(import.meta.url))),
      extraHash: execSync(
        `docker inspect dungeon-adventure-story-agent:latest --format '{{.Id}}'`,
        { encoding: 'utf-8' },
      ).trim(),
    });

    this.agentCoreRuntime = new AgentCoreRuntime(this, 'StoryAgent', {
      runtimeName: Lazy.string({
        produce: () =>
          Names.uniqueResourceName(this.agentCoreRuntime, { maxLength: 40 }),
      }),
      serverProtocol: 'HTTP',
      containerUri: this.dockerImage.imageUri,
      ...props,
    });
  }
}
```

Cela configure un `DockerImageAsset` CDK qui télécharge votre image Docker d'agent vers ECR et l'héberge en utilisant AgentCore Runtime.

Vous remarquerez peut-être un `Dockerfile` supplémentaire qui référence l'image Docker du projet `story`, nous permettant de co-localiser le Dockerfile et le code source de l'agent.

</Drawer>

## Tâche 4 : Configurer les outils d'inventaire

### Inventaire : Projet TypeScript

Créons un serveur MCP pour fournir des outils à notre agent Story afin de gérer l'inventaire d'un joueur.

Tout d'abord, nous créons un projet TypeScript :

<RunGenerator generator="ts#project" requiredParameters={{name:"inventory"}} noInteractive />

Cela créera un projet TypeScript vide.

<Drawer title="Fichiers modifiés par ts#project" trigger="Cliquez ici pour examiner ces fichiers en détail.">
Le générateur `ts#project` génère ces fichiers. 

<FileTree>
- packages/
  - inventory/
    - src/
      - index.ts point d'entrée avec fonction d'exemple
    - project.json configuration du projet
    - eslint.config.mjs configuration du linter
    - vite.config.ts configuration des tests
    - tsconfig.json configuration TypeScript de base pour le projet
    - tsconfig.lib.json configuration TypeScript pour le projet ciblée pour la compilation et l'empaquetage
    - tsconfig.spec.json configuration TypeScript pour les tests
- tsconfig.base.json mis à jour pour configurer un alias permettant aux autres projets de référencer celui-ci
</FileTree>

</Drawer>

### Inventaire : Serveur MCP

Ensuite, nous allons ajouter un serveur MCP à notre projet TypeScript :

<RunGenerator generator="ts#mcp-server" requiredParameters={{project:"inventory"}} noInteractive />

Cela ajoutera un serveur MCP.
<Drawer title="Fichiers modifiés par ts#mcp-server" trigger="Cliquez ici pour examiner ces fichiers en détail.">
Le générateur `ts#mcp-server` génère ces fichiers.

<FileTree>
- packages/
  - inventory/
    - src/mcp-server/
      - server.ts crée le serveur MCP
      - tools/
        - add.ts outil d'exemple
      - resources/
        - sample-guidance.ts ressource d'exemple
      - stdio.ts point d'entrée pour MCP avec transport STDIO
      - http.ts point d'entrée pour MCP avec transport HTTP streamable
      - Dockerfile construit l'image pour AgentCore Runtime
    - rolldown.config.ts configuration pour empaqueter le serveur MCP pour le déploiement sur AgentCore
  - common/constructs/
    - src
      - app/mcp-servers/inventory-mcp-server/
        - inventory-mcp-server.ts construct pour déployer votre serveur MCP d'inventaire sur AgentCore Runtime
</FileTree>

</Drawer>

## Tâche 5 : Créer l'interface utilisateur (UI)

Dans cette tâche, nous allons créer l'interface utilisateur qui vous permettra d'interagir avec le jeu.

### Interface utilisateur du jeu : Site web

Pour créer l'interface utilisateur, créez un site web appelé `GameUI` en suivant ces étapes :

<RunGenerator generator="ts#react-website" requiredParameters={{name:"GameUI"}} noInteractive />

Vous verrez de nouveaux fichiers apparaître dans votre arborescence de fichiers.

<Drawer title="Fichiers modifiés par ts#react-website" trigger="Cliquez ici pour examiner ces fichiers en détail.">
Le générateur `ts#react-website` génère ces fichiers. Examinons certains des fichiers clés mis en évidence dans l'arborescence :

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK spécifiques à l'application
          - static-websites/
            - **game-ui.ts** construct CDK pour créer votre interface utilisateur du jeu
        - core/
          - static-website.ts construct générique de site web statique
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts mise en page globale : en-tête, pied de page, barre latérale, etc.
          - navitems.ts éléments de navigation de la barre latérale
      - hooks/
        - useAppLayout.tsx vous permet de définir dynamiquement des éléments comme les notifications, le style de page, etc.
      - routes/ routes basées sur des fichiers @tanstack/react-router
        - index.tsx page racine '/' redirige vers '/welcome'
        - __root.tsx toutes les pages utilisent ce composant comme base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** point d'entrée React
        - routeTree.gen.ts automatiquement mis à jour par @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteName: 'GameUI',
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

C'est le construct CDK qui définit notre GameUI. Il a déjà configuré le chemin de fichier vers le bundle généré pour notre interface utilisateur basée sur Vite. Cela signifie qu'au moment du `build`, l'empaquetage se produit dans la cible de build du projet game-ui et la sortie est utilisée ici.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Enregistrer l'instance du routeur pour la sécurité des types
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

C'est le point d'entrée où React est monté. Comme indiqué, il configure initialement simplement un `@tanstack/react-router` dans une configuration [`file-based-routing`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Tant que votre serveur de développement est en cours d'exécution, vous pouvez créer des fichiers dans le dossier `routes` et `@tanstack/react-router` créera la configuration de fichier boilerplate pour vous, ainsi que la mise à jour du fichier `routeTree.gen.ts`. Ce fichier maintient toutes les routes de manière type-safe, ce qui signifie que lorsque vous utilisez `<Link>`, l'option `to` n'affichera que les routes valides. 
Pour plus d'informations, consultez la [documentation de `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un composant sera rendu lors de la navigation vers la route `/welcome`. `@tanstack/react-router` gérera la `Route` pour vous chaque fois que vous créez/déplacez ce fichier (tant que le serveur de développement est en cours d'exécution).

</Drawer>

### Interface utilisateur du jeu : Authentification

Configurons notre interface utilisateur du jeu pour exiger un accès authentifié via Amazon Cognito en suivant ces étapes :

<RunGenerator generator="ts#react-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Vous verrez de nouveaux fichiers apparaître/changer dans votre arborescence de fichiers.

<Drawer title="Fichiers modifiés par ts#react-website#auth" trigger="Cliquez ici pour examiner ces fichiers en détail.">
Le générateur `ts#react-website#auth` met à jour/génère ces fichiers. Examinons certains des fichiers clés mis en évidence dans l'arborescence :

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts construct CDK pour créer des pools d'utilisateurs/d'identité
    - types/
      - src/
        - runtime-config.ts mis à jour pour ajouter les cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx ajoute l'utilisateur connecté/déconnexion à l'en-tête
        - CognitoAuth/
          - index.ts gère la connexion à Cognito
        - RuntimeConfig/
          - index.tsx récupère le `runtime-config.json` et le fournit aux enfants via le contexte
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Mis à jour pour ajouter Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Enregistrer l'instance du routeur pour la sécurité des types
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Les composants `RuntimeConfigProvider` et `CognitoAuth` ont été ajoutés au fichier `main.tsx` via une transformation AST. Cela permet au composant `CognitoAuth` de s'authentifier avec Amazon Cognito en récupérant le `runtime-config.json` qui contient la configuration de connexion Cognito requise pour effectuer les appels backend vers la bonne destination.

</Drawer>

### Interface utilisateur du jeu : Connexion à l'API du jeu

Configurons notre interface utilisateur du jeu pour se connecter à notre API GameApi créée précédemment.

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

Vous verrez de nouveaux fichiers apparaître/changer dans votre arborescence de fichiers.

<Drawer title="Fichiers modifiés par api-connection UI -> tRPC" trigger="Cliquez ici pour examiner ces fichiers en détail.">
Le générateur `api-connection` génère/met à jour ces fichiers. Examinons certains des fichiers clés mis en évidence dans l'arborescence :

<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx configure le client GameAPI
      - hooks/
        - **useGameApi.tsx** hooks pour appeler l'API GameApi
      - **main.tsx** injecte les fournisseurs de client tRPC
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { GameApiTRCPContext } from '../components/GameApiClientProvider';

export const useGameApi = GameApiTRCPContext.useTRPC;
```

Ce hook utilise la dernière [intégration React Query](https://trpc.io/blog/introducing-tanstack-react-query-client) de tRPC permettant aux utilisateurs d'interagir avec `@tanstack/react-query` directement sans aucune couche d'abstraction supplémentaire. Pour des exemples sur la façon d'appeler des API tRPC, consultez le <Link path="guides/api-connection/react-trpc#using-the-generated-code">guide d'utilisation du hook tRPC</Link>.

<Aside>
Le hook `useGameApi` est différent du hook `useStoryApi` car il ne nécessite pas de build pour que les changements soient reflétés grâce à l'utilisation par tRPC de [l'inférence TypeScript](https://trpc.io/docs/concepts). Cela permet aux développeurs de faire des changements dans leur backend qui sont instantanément reflétés dans leur frontend.
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Enregistrer l'instance du routeur pour la sécurité des types
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <RouterProvider router={router} />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Le fichier `main.tsx` a été mis à jour via une transformation AST pour injecter les fournisseurs tRPC.

</Drawer>

### Interface utilisateur du jeu : Infrastructure

Créons le sous-projet final pour l'infrastructure CDK.

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Vous verrez de nouveaux fichiers apparaître/changer dans votre arborescence de fichiers.

<Drawer title="Fichiers modifiés par ts#infra" trigger="Cliquez ici pour examiner ces fichiers en détail.">
Le générateur `ts#infra` génère/met à jour ces fichiers. Examinons certains des fichiers clés mis en évidence dans l'arborescence :

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - checkov.ts
          - index.ts
  - infra
    - src/
      - stages/
        - **application-stage.ts** stacks CDK définis ici
      - stacks/
        - **application-stack.ts** ressources CDK définies ici
      - index.ts
      - **main.ts** point d'entrée qui définit toutes les étapes
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json ajoute des références
  - tsconfig.base.json ajoute un alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStage } from './stacks/application-stage.js';
import { App } from ':dungeon-adventure/common-constructs';

const app = new App();

// Utilisez ceci pour déployer votre propre environnement sandbox (suppose vos informations d'identification CLI)
new ApplicationStage(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
});

app.synth();
```

<Aside type="tip">Si vous voyez une erreur d'importation dans votre IDE, c'est parce que notre projet d'infrastructure n'a pas encore de référence TypeScript configurée dans le `tsconfig.json`. Nx a été [configuré](https://nx.dev/nx-api/js/generators/typescript-sync) pour créer ces références *dynamiquement* chaque fois qu'un build/compilation est exécuté ou si vous exécutez la commande `nx sync` manuellement. Pour plus d'informations, consultez le <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guide TypeScript</Link>.</Aside>

C'est le point d'entrée de votre application CDK.

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Le code qui définit votre stack va ici
  }
}
```

Instancions nos constructs CDK pour construire notre jeu d'aventure de donjon.

</Drawer>

## Tâche 6 : Mettre à jour notre infrastructure

Mettons à jour `packages/infra/src/stacks/application-stack.ts` pour instancier certains de nos constructs générés :

<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

:::note 
Nous fournissons des intégrations par défaut pour notre API GameApi. Par défaut, chaque opération dans notre API est mappée à une fonction Lambda individuelle pour gérer cette opération.
:::

## Tâche 7 : Construire le code

<Drawer title="Commandes Nx" trigger="Il est maintenant temps de construire notre code pour la première fois">

###### Cibles uniques vs multiples

La commande `run-many` exécutera une cible sur plusieurs sous-projets listés (`--all` les ciblera tous). Cela garantit que les dépendances sont exécutées dans le bon ordre.

Vous pouvez également déclencher un build (ou toute autre tâche) pour une cible de projet unique en exécutant la cible directement sur le projet. Par exemple, pour construire le projet `@dungeon-adventure/infra`, exécutez la commande suivante :

<NxCommands commands={['run @dungeon-adventure/infra:build']} />

Vous pouvez également omettre la portée et utiliser la syntaxe abrégée Nx si vous préférez :

<NxCommands commands={['build infra']} />

###### Visualiser vos dépendances

Pour visualiser vos dépendances, exécutez :

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Mise en cache

Nx s'appuie sur la [mise en cache](https://nx.dev/concepts/how-caching-works) pour que vous puissiez réutiliser les artefacts de builds précédents afin d'accélérer le développement. Il y a une certaine configuration requise pour que cela fonctionne correctement et il peut y avoir des cas où vous souhaitez effectuer un build **sans utiliser le cache**. Pour ce faire, ajoutez simplement l'argument `--skip-nx-cache` à votre commande. Par exemple :

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Si pour une raison quelconque vous souhaitez vider votre cache (stocké dans le dossier `.nx`), vous pouvez exécuter la commande suivante :

<NxCommands commands={['reset']} />

</Drawer>

En utilisant la ligne de commande, exécutez : 

<NxCommands commands={['run-many --target build --all']} />

Vous serez invité avec le message suivant :

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Certains fichiers de configuration TypeScript manquent de références de projet aux projets dont ils dépendent ou contiennent des références de projet obsolètes.

Cela entraînera une erreur en CI.

? Souhaitez-vous synchroniser les changements identifiés pour mettre à jour votre workspace ? …
Oui, synchroniser les changements et exécuter les tâches
Non, exécuter les tâches sans synchroniser les changements
```

Ce message indique que NX a détecté certains fichiers qui peuvent être mis à jour automatiquement pour vous. Dans ce cas, il fait référence aux fichiers `tsconfig.json` qui n'ont pas de références TypeScript configurées sur les projets référencés. 

Sélectionnez l'option **Oui, synchroniser les changements et exécuter les tâches** pour continuer. Vous devriez remarquer que toutes vos erreurs d'importation liées à l'IDE sont automatiquement résolues car le générateur de synchronisation ajoutera automatiquement les références TypeScript manquantes !

<Aside type="tip">
Si vous rencontrez des erreurs de lint, exécutez la commande suivante pour les corriger automatiquement.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>
Tous les artefacts construits sont maintenant disponibles dans le dossier `dist/` situé à la racine du monorepo. C'est une pratique standard lors de l'utilisation de projets générés par le `@aws/nx-plugin` car cela ne pollue pas votre arborescence de fichiers avec des fichiers générés. Si vous souhaitez nettoyer vos fichiers, supprimez le dossier `dist/` sans vous soucier des fichiers générés dispersés dans l'arborescence de fichiers.

Félicitations ! Vous avez créé tous les sous-projets requis pour commencer à implémenter le cœur de notre jeu d'aventure de donjon IA.  🎉🎉🎉