---
title: "Jeu de Donjon IA"
description: "Un guide pas à pas pour construire un jeu d'aventure de donjon alimenté par l'IA en utilisant le @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Module 1 : Configuration du monorepo

Nous allons commencer par créer un nouveau monorepo. Depuis le répertoire de votre choix, exécutez la commande suivante :

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

Cela configurera un monorepo NX dans le répertoire `dungeon-adventure` que vous pourrez ensuite ouvrir dans vscode. Il devrait ressembler à ceci :

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ c'est ici que résideront vos sous-projets
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configure les paramètres par défaut du CLI Nx et du monorepo
- package.json toutes les dépendances node sont définies ici
- pnpm-lock.yaml ou bun.lock, yarn.lock, package-lock.json selon le gestionnaire de paquets
- pnpm-workspace.yaml si vous utilisez pnpm
- README.md
- tsconfig.base.json tous les sous-projets basés sur node étendent ce fichier
- tsconfig.json
</FileTree>

Maintenant, nous sommes prêts à commencer à créer nos différents sous-projets en utilisant le `@aws/nx-plugin`.

<Aside type="tip">Il est recommandé de s'assurer que tous vos fichiers non indexés sont commités dans Git avant d'exécuter des générateurs. Cela vous permet de voir ce qui a changé après l'exécution du générateur via `git diff`</Aside>

### API du jeu

Commençons par créer notre API de jeu. Pour cela, créons une API tRPC appelée `GameApi` en suivant les étapes ci-dessous :

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

Vous devriez voir apparaître de nouveaux fichiers dans votre arborescence.

<Aside>
Le `package.json` racine est maintenant configuré avec un `type` `module`, ce qui signifie qu'ESM est le type de module par défaut pour tous les sous-projets node générés par le `@aws/nx-plugin`. Pour plus de détails sur les projets TypeScript, consultez le <Link path="guides/typescript-project">guide ts#project</Link>.
</Aside>

<Drawer title="Fichiers mis à jour par ts#trpc-api" trigger="Cliquez ici pour examiner ces fichiers plus en détail.">
Voici la liste de tous les fichiers générés par le générateur `ts#trpc-api`. Nous allons examiner certains fichiers clés mis en évidence dans l'arborescence :
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructions CDK spécifiques à l'application
          - apis/
            - **game-api.ts** construction CDK pour créer votre API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructions CDK génériques
          - api/
            - rest-api.ts construction CDK de base pour une API Gateway Rest
            - trpc-utils.ts utilitaires pour les constructions CDK d'API tRPC
            - utils.ts utilitaires pour les constructions d'API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ types partagés
      - src/
        - index.ts
        - runtime-config.ts définition d'interface utilisée par CDK et le site web
      - project.json
      - ...
  - game-api/ API tRPC
    - src/
      - client/ client vanilla typiquement utilisé pour les appels machine à machine en TS
        - index.ts
        - sigv4.ts
      - middleware/ instrumentation Powertools
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ définitions des entrées et sorties de votre API
        - **echo.ts**
      - procedures/ implémentations spécifiques des procédures/routes de votre API
        - **echo.ts**
      - index.ts
      - init.ts configure le contexte et les middlewares
      - local-server.ts utilisé pour exécuter le serveur tRPC localement
      - **router.ts** point d'entrée du handler lambda qui définit toutes les procédures
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Examinons quelques fichiers clés :

```ts {5,12}
// packages/game-api/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
Le routeur définit le point d'entrée de votre API tRPC et est l'endroit où vous déclarez toutes vos méthodes d'API. Comme visible ci-dessus, nous avons une méthode appelée `echo` dont l'implémentation se trouve dans le fichier `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Ce fichier contient l'implémentation de la méthode `echo` et, comme visible, est fortement typé en déclarant ses structures de données d'entrée et de sortie.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Toutes les définitions de schéma tRPC utilisent [Zod](https://zod.dev/) et sont exportées comme types TypeScript via la syntaxe `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// Type union pour tous les noms d'opérations de l'API
type Operations = Procedures<AppRouter>;

/**
 * Propriétés pour créer une construction GameApi
 *
 * @template TIntegrations - Map des noms d'opérations vers leurs intégrations
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Map des noms d'opérations vers leurs intégrations API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Une construction CDK qui crée et configure une API REST AWS API Gateway
 * spécifiquement pour GameApi.
 * @template TIntegrations - Map des noms d'opérations vers leurs intégrations
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crée des intégrations par défaut pour toutes les opérations, implémentant chaque opération comme
   * sa propre fonction lambda individuelle.
   *
   * @param scope - La portée de la construction CDK
   * @returns Un IntegrationBuilder avec les intégrations lambda par défaut
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Ici, nous autorisons toutes les credentials AWS du compte de déploiement à appeler l'API.
          // Un accès machine à machine granulaire peut être défini ici en utilisant des principaux plus spécifiques (ex. rôles ou
          // utilisateurs) et ressources (ex. quels chemins d'API peuvent être invoqués par quel principal) si nécessaire.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Autorise OPTIONS pour permettre aux navigateurs de faire des requêtes preflight non authentifiées
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

Il s'agit de la construction CDK qui définit notre GameApi. Comme visible, elle fournit une méthode `defaultIntegrations` qui crée automatiquement une fonction lambda pour chaque procédure de notre API tRPC, pointant vers l'implémentation de l'API déjà bundle. Cela signifie qu'au moment de `cdk synth`, le bundling ne se produit pas (contrairement à l'utilisation de [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) car nous l'avons déjà bundle dans le cadre de la cible de build du projet backend.

</Drawer>

### API de l'histoire

Maintenant, créons notre API de l'histoire. Pour cela, créons une API Fast appelée `StoryApi` en suivant les étapes ci-dessous :

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi", moduleName:"story_api"}} noInteractive />

Vous devriez voir apparaître de nouveaux fichiers dans votre arborescence.
<Drawer title="Fichiers mis à jour par py#fast-api" trigger="Cliquez ici pour examiner ces fichiers plus en détail.">
Voici la liste de tous les fichiers générés par le générateur `py#fast-api`. Nous allons examiner certains fichiers clés mis en évidence dans l'arborescence :
<FileTree>
- .venv/ environnement virtuel unique pour le monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructions CDK spécifiques à l'application
          - apis/
            - **story-api.ts** construction CDK pour créer votre API Fast
            - index.ts mis à jour pour exporter la nouvelle story-api
      - project.json mis à jour pour ajouter une dépendance de build sur story_api
    - types/ types partagés
      - src/
        - **runtime-config.ts** mis à jour pour ajouter la StoryApi
  - story_api/
    - story_api/ module Python
      - init.py configure Powertools, FastAPI et les middlewares
      - **main.py** point d'entrée du lambda contenant toutes les routes
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version version Python figée par uv
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import {
  OPERATION_DETAILS,
  Operations,
} from '../../generated/story-api/metadata.gen.js';

/**
 * Propriétés pour créer une construction StoryApi
 *
 * @template TIntegrations - Map des noms d'opérations vers leurs intégrations
 */
export interface StoryApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Map des noms d'opérations vers leurs intégrations API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Une construction CDK qui crée et configure une API REST AWS API Gateway
 * spécifiquement pour StoryApi.
 * @template TIntegrations - Map des noms d'opérations vers leurs intégrations
 */
export class StoryApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crée des intégrations par défaut pour toutes les opérations, implémentant chaque opération comme
   * sa propre fonction lambda individuelle.
   *
   * @param scope - La portée de la construction CDK
   * @returns Un IntegrationBuilder avec les intégrations lambda par défaut
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: OPERATION_DETAILS,
      defaultIntegrationOptions: {
        runtime: Runtime.PYTHON_3_12,
        handler: 'story_api.main.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/story_api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `StoryApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: StoryApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'StoryApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Ici, nous autorisons toutes les credentials AWS du compte de déploiement à appeler l'API.
          // Un accès machine à machine granulaire peut être défini ici en utilisant des principaux plus spécifiques (ex. rôles ou
          // utilisateurs) et ressources (ex. quels chemins d'API peuvent être invoqués par quel principal) si nécessaire.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Autorise OPTIONS pour permettre aux navigateurs de faire des requêtes preflight non authentifiées
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: OPERATION_DETAILS,
      ...props,
    });
  }
}

```

Il s'agit de la construction CDK qui définit notre StoryApi. Comme visible, elle fournit une méthode `defaultIntegrations` qui crée automatiquement une fonction lambda pour chaque opération définie dans notre FastAPI, pointant vers l'implémentation de l'API déjà bundle. Cela signifie qu'au moment de `cdk synth`, le bundling ne se produit pas (contrairement à [PythonFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/@aws-cdk_aws-lambda-python-alpha.PythonFunction.html)) car nous l'avons déjà bundle dans le cadre de la cible de build du projet backend.

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

C'est ici que toutes vos méthodes d'API seront définies. Comme visible ici, nous avons une méthode `read_root` mappée sur la route `GET /`. Vous pouvez utiliser [Pydantic](https://docs.pydantic.dev/latest/) pour déclarer les entrées et sorties de vos méthodes afin d'assurer la sécurité des types.

</Drawer>

### Interface utilisateur du jeu : Site web

Maintenant, créons l'interface utilisateur qui permettra d'interagir avec le jeu. Pour cela, créons un site web appelé `GameUI` en suivant les étapes ci-dessous :

<RunGenerator generator="ts#react-website" requiredParameters={{name:"GameUI"}} noInteractive />

Vous devriez voir apparaître de nouveaux fichiers dans votre arborescence.

<Drawer title="Fichiers mis à jour par ts#react-website" trigger="Cliquez ici pour examiner ces fichiers plus en détail.">
Voici la liste de tous les fichiers générés par le générateur `ts#react-website`. Nous allons examiner certains fichiers clés mis en évidence dans l'arborescence :
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructions CDK spécifiques à l'application
          - static-websites/
            - **game-ui.ts** construction CDK pour créer votre Game UI
        - core/
          - static-website.ts construction générique de site web statique
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts mise en page globale : en-tête, pied de page, barre latérale, etc
          - navitems.ts éléments de navigation de la barre latérale
      - hooks/
        - useAppLayout.tsx permet de définir dynamiquement des éléments comme les notifications, le style de page, etc
      - routes/ routes basées sur @tanstack/react-router
        - index.tsx page racine '/' redirige vers '/welcome'
        - __root.tsx toutes les pages utilisent ce composant comme base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** point d'entrée React
        - routeTree.gen.ts mis à jour automatiquement par @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Il s'agit de la construction CDK qui définit notre GameUI. Comme visible, elle a déjà configuré le chemin vers le bundle généré pour notre interface Vite. Cela signifie qu'au moment du `build`, le bundling se produit dans la cible de build du projet game-ui et sa sortie est utilisée ici.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Enregistre l'instance du routeur pour la sécurité des types
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Il s'agit du point d'entrée où React est monté. Comme montré, il configure initialement un `@tanstack/react-router` dans une configuration de [`routage basé sur les fichiers`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Cela signifie que tant que votre serveur de développement est en cours d'exécution, vous pouvez simplement créer des fichiers dans le dossier `routes` et `@tanstack/react-router` créera la configuration de fichiers nécessaire tout en mettant à jour le fichier `routeTree.gen.ts`. Ce fichier maintient toutes les routes de manière type-safe, ce qui signifie que lorsque vous utilisez `<Link>`, l'option `to` n'affichera que les routes valides. Pour plus d'informations, consultez la [documentation de `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un composant qui sera rendu lors de la navigation vers la route `/welcome`. `@tanstack/react-router` gérera la `Route` pour vous lorsque vous créerez/déplacerez ce fichier (tant que le serveur de développement est en cours d'exécution). Cela sera montré dans une section ultérieure de ce tutoriel.

</Drawer>

### Interface utilisateur du jeu : Authentification

Maintenant, configurons notre Game UI pour exiger un accès authentifié via Amazon Cognito en suivant les étapes ci-dessous :

<RunGenerator generator="ts#react-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Vous devriez voir apparaître ou changer des fichiers dans votre arborescence.

<Drawer title="Fichiers mis à jour par ts#react-website#auth" trigger="Cliquez ici pour examiner ces fichiers plus en détail.">
Voici la liste de tous les fichiers générés/mis à jour par le générateur `ts#react-website#auth`. Nous allons examiner certains fichiers clés mis en évidence dans l'arborescence :
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts construction CDK pour créer des pools d'utilisateurs/identités
    - types/
      - src/
        - runtime-config.ts mis à jour pour ajouter cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx ajoute l'utilisateur connecté/déconnexion à l'en-tête
        - CognitoAuth/
          - index.ts gère la connexion à Cognito
        - RuntimeConfig/
          - index.tsx récupère le `runtime-config.json` et le fournit aux enfants via le contexte
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Mis à jour pour ajouter Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Enregistre l'instance du routeur pour la sécurité des types
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Les composants `RuntimeConfigProvider` et `CognitoAuth` ont été ajoutés au fichier `main.tsx` via une transformation AST. Cela permet au composant `CognitoAuth` de s'authentifier auprès d'Amazon Cognito en récupérant le `runtime-config.json` qui contient la configuration de connexion Cognito nécessaire pour effectuer les appels backend vers la bonne destination.

</Drawer>

### Interface utilisateur du jeu : Connexion à l'API de l'histoire

Maintenant, configurons notre Game UI pour se connecter à notre API Story précédemment créée :

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

Vous devriez voir apparaître ou changer des fichiers dans votre arborescence.

<Drawer title="Fichiers mis à jour par la connexion UI -> FastAPI" trigger="Cliquez ici pour examiner ces fichiers plus en détail.">
Voici la liste de tous les fichiers générés/mis à jour par le générateur `api-connection`. Nous allons examiner certains fichiers clés mis en évidence dans l'arborescence :
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx utilisé par StoryApi pour signer les requêtes
        - useStoryApiClient.tsx hook pour construire un client StoryApi
        - useStoryApi.tsx hook pour interagir avec StoryApi via TanStack Query
      - components/
        - QueryClientProvider.tsx fournisseur du client TanStack Query
        - StoryApiProvider.tsx fournisseur du hook TanStack Query pour StoryApi
      - main.tsx Instrumente le QueryClientProvider et StoryApiProvider
    - .gitignore ignore les fichiers client générés
    - project.json mis à jour pour ajouter des cibles de génération de hooks openapi
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json mis à jour pour émettre un fichier openapi.json

</FileTree>

```tsx {1,12-15}
// packages/game-ui/src/hooks/useStoryApiClient.tsx
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

Ce hook peut être utilisé pour effectuer des requêtes API authentifiées vers la `StoryApi`. Comme visible dans l'implémentation, il utilise le `StoryApi` généré au moment du build, donc vous verrez une erreur dans votre IDE jusqu'à ce que nous construisions notre code. Pour plus de détails sur la génération du client ou la consommation de l'API, consultez le <Link path="guides/api-connection/react-fastapi">guide React vers FastAPI</Link>.

```tsx
// packages/game-ui/src/components/StoryApiProvider.tsx
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useStoryApiClient } from '../hooks/useStoryApiClient';
import { StoryApiOptionsProxy } from '../generated/story-api/options-proxy.gen';

export const StoryApiContext = createContext<StoryApiOptionsProxy | undefined>(
  undefined,
);

export const StoryApiProvider: FC<PropsWithChildren> = ({ children }) => {
  const client = useStoryApiClient();
  const optionsProxy = useMemo(
    () => new StoryApiOptionsProxy({ client }),
    [client],
  );

  return (
    <StoryApiContext.Provider value={optionsProxy}>
      {children}
    </StoryApiContext.Provider>
  );
};

export default StoryApiProvider;
```

Ce composant fournisseur utilise le hook `useStoryApiClient` et instancie le `StoryApiOptionsProxy`, qui est utilisé pour construire les options des hooks TanStack Query. Vous pouvez utiliser le hook correspondant `useStoryApi` pour accéder à ce proxy d'options, qui fournit une manière cohérente d'interagir avec votre FastAPI comme avec votre API tRPC.

Comme `useStoryApiClient` nous fournit un itérateur asynchrone pour notre API de streaming, nous utiliserons directement le client vanilla dans ce tutoriel.

<Aside type="caution">
Les fichiers `src/generated/story-api/*.gen.ts` ne doivent jamais être modifiés manuellement car ils seront régénérés à chaque build de votre API.
</Aside>

</Drawer>

### Interface utilisateur du jeu : Connexion à l'API du jeu

Maintenant, configurons notre Game UI pour se connecter à notre API Game précédemment créée :

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

Vous devriez voir apparaître ou changer des fichiers dans votre arborescence.

<Drawer title="Fichiers mis à jour par la connexion UI -> tRPC" trigger="Cliquez ici pour examiner ces fichiers plus en détail.">
Voici la liste de tous les fichiers générés/mis à jour par le générateur `api-connection`. Nous allons examiner certains fichiers clés mis en évidence dans l'arborescence :
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx configure le client GameAPI
      - hooks/
        - **useGameApi.tsx** hooks pour appeler la GameApi
      - **main.tsx** injecte les fournisseurs de client trpc
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { GameApiTRCPContext } from '../components/GameApiClientProvider';

export const useGameApi = GameApiTRCPContext.useTRPC;
```

Ce hook utilise l'intégration [React Query](https://trpc.io/blog/introducing-tanstack-react-query-client) de tRPC, permettant aux utilisateurs d'interagir directement avec `@tanstack/react-query` sans couches d'abstraction supplémentaires. Pour des exemples d'appels d'API tRPC, consultez le <Link path="guides/api-connection/react-trpc#using-the-generated-code">guide d'utilisation du hook tRPC</Link>.

<Aside>
Le hook `useGameApi` est différent du hook `useStoryApi` car il ne nécessite pas de build pour que les changements soient reflétés, grâce à l'utilisation de [l'inférence TypeScript](https://trpc.io/docs/concepts) par tRPC. Cela permet aux développeurs de modifier leur backend et de voir les changements instantanément dans le frontend !
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Enregistre l'instance du routeur pour la sécurité des types
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <RouterProvider router={router} />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Le fichier `main.tsx` a été mis à jour via une transformation AST pour injecter les fournisseurs tRPC.

</Drawer>

### Interface utilisateur du jeu : Infrastructure

Maintenant, le dernier sous-projet à créer est pour l'infrastructure CDK. Pour le créer, suivez les étapes ci-dessous :

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Vous devriez voir apparaître ou changer des fichiers dans votre arborescence.

<Drawer title="Fichiers mis à jour par ts#infra" trigger="Cliquez ici pour examiner ces fichiers plus en détail.">
Voici la liste de tous les fichiers générés/mis à jour par le générateur `ts#infra`. Nous allons examiner certains fichiers clés mis en évidence dans l'arborescence :
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts** ressources CDK définies ici
      - index.ts
      - **main.ts** point d'entrée qui définit toutes les stacks
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json ajoute des références
  - tsconfig.base.json ajoute un alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
  App,
  CfnGuardValidator,
  RuleSet,
} from ':dungeon-adventure/common-constructs';

const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

// Utilisez ceci pour déployer votre propre environnement sandbox (suppose les credentials CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

<Aside type="tip">Si vous voyez une erreur d'import dans votre IDE, c'est parce que notre projet d'infrastructure n'a pas encore de référence TypeScript configurée dans son tsconfig.json. Nx a été [configuré](https://nx.dev/nx-api/js/generators/typescript-sync) pour créer ces références *dynamiquement* lors d'un build/compilation ou si vous exécutez manuellement la commande `nx sync`. Pour plus d'informations, consultez le <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guide TypeScript</Link>.</Aside>

Il s'agit du point d'entrée de votre application CDK.

Elle est configurée pour utiliser [`cfn-guard`](https://github.com/cdklabs/cdk-validator-cfnguard) pour exécuter la validation d'infrastructure basée sur le jeu de règles configuré. Ceci est instrumenté post-synthèse.

<Aside type="tip">
Il peut y avoir des cas où vous souhaitez supprimer certaines règles sur des ressources. Vous pouvez le faire de deux manières :

###### Supprimer une règle sur une construction donnée

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// supprime la RULE_NAME pour la construction donnée.
suppressRule(construct, 'RULE_NAME');
```

###### Supprimer une règle sur une construction descendante

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// Supprime la RULE_NAME pour la construction ou ses descendantes si c'est une instance de Bucket
suppressRule(construct, 'RULE_NAME', (construct) => construct instanceof Bucket);
```
</Aside>

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Le code qui définit votre stack va ici
  }
}
```

C'est ici que nous instancierons nos constructions CDK pour construire notre jeu d'aventure.

</Drawer>

#### Mettre à jour notre infrastructure

Modifions notre `packages/infra/src/stacks/application-stack.ts` pour instancier certaines de nos constructions déjà générées :

<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

Notez ici que nous fournissons des intégrations par défaut pour nos deux API. Par défaut, chaque opération de notre API est mappée à une fonction lambda individuelle pour gérer cette opération.

### Construction de notre code

<Drawer title="Commandes Nx" trigger="Il est maintenant temps de construire notre code pour la première fois">
###### Cibles uniques vs multiples

La commande `run-many` exécutera une cible sur plusieurs sous-projets listés (`--all` les cible tous). Elle s'assure que les dépendances sont exécutées dans le bon ordre.

Vous pouvez aussi déclencher un build (ou toute autre tâche) pour une cible de projet unique en exécutant la cible sur le projet directement. Par exemple, si nous voulons build le projet `@dungeon-adventure/infra`, vous pouvez exécuter :

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualiser vos dépendances

Vous pouvez aussi visualiser vos dépendances via :

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Cache

Nx s'appuie sur le [cache](https://nx.dev/concepts/how-caching-works) pour réutiliser les artefacts des builds précédents et accélérer le développement. Une configuration est nécessaire pour que cela fonctionne correctement, et il peut y avoir des cas où vous voulez effectuer un build **sans utiliser le cache**. Pour cela, ajoutez simplement l'argument `--skip-nx-cache` à votre commande. Par exemple :

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Si jamais vous souhaitez vider votre cache (stocké dans le dossier `.nx`), vous pouvez exécuter :

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

Vous devriez voir apparaître ce qui suit :

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? …
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Ce message indique que NX a détecté des fichiers qui peuvent être mis à jour automatiquement. Dans ce cas, il s'agit des fichiers `tsconfig.json` qui n'ont pas de références TypeScript configurées sur les projets référencés. Sélectionnez l'option **Yes, sync the changes and run the tasks** pour continuer. Vous devriez voir toutes les erreurs d'import dans votre IDE se résoudre automatiquement car le générateur de synchronisation ajoutera les références TypeScript manquantes !

<Aside type="tip">
Si vous rencontrez des erreurs de lint, vous pouvez exécuter la commande suivante pour les corriger automatiquement.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

<Aside type="caution" title="Échec de build sur Windows">
<Drawer trigger="Si vous êtes sur Windows et rencontrez une erreur de build, cliquez ici." title="Échec de build Windows">
Si vous rencontrez une erreur de build/synth pour le projet `@dungeon-adventure/infra`, c'est attendu car la bibliothèque qui instrumente `cfn-guard` ne supporte actuellement pas Windows. Une demande de fonctionnalité suit cela, mais en attendant nous pouvons désactiver `cfn-guard` en modifiant le fichier `packages/infra/src/main.ts` comme suit :

```diff lang="ts"
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
   App,
-  CfnGuardValidator,
-  RuleSet,
} from ':dungeon-adventure/common-constructs';
-
-const app = new App({
-  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
-});
+const app = new App();

// Utilisez ceci pour déployer votre propre environnement sandbox (suppose les credentials CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```
</Drawer>
</Aside>

Tous les artefacts construits sont maintenant disponibles dans le dossier `dist/` à la racine du monorepo. C'est une pratique standard avec les projets générés par le `@aws/nx-plugin` car cela ne pollue pas votre arborescence avec des fichiers générés. Si vous souhaitez nettoyer vos fichiers, vous pouvez simplement supprimer le dossier `dist/` sans craindre de fichiers générés éparpillés.

Félicitations ! Vous avez créé tous les sous-projets nécessaires pour commencer à implémenter le cœur de notre jeu Dunegeon Adventure.  🎉🎉🎉