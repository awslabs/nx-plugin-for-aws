---
title: "Générateur de Générateur Nx"
description: "Génère un Générateur Nx"
---



import { FileTree } from '@astrojs/starlight/components';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import Drawer from '@components/drawer.astro';
import Link from '@components/link.astro';
import schema from '../../../../../packages/nx-plugin/src/ts/nx-generator/schema.json';

Ajoute un [Nx Generator](https://nx.dev/extending-nx/recipes/local-generators) à un projet TypeScript pour vous aider à automatiser des tâches répétitives comme la création de composants ou l'application de structures de projet spécifiques.

## Utilisation

### Générer un générateur

Vous pouvez générer un générateur de deux manières :

<RunGenerator generator="ts#nx-generator" />

### Options

<GeneratorParameters schema={schema} />

## Résultat du générateur

Le générateur créera les fichiers suivants dans le `pluginProject` spécifié :

<FileTree>
  - src/\<name>/
    - schema.json Schéma d'entrée pour votre générateur
    - schema.d.ts Types TypeScript pour votre schéma
    - generator.ts Implémentation squelette du générateur
    - generator.spec.ts Tests pour votre générateur
  - generators.json Configuration Nx pour définir vos générateurs
</FileTree>

## Générateurs locaux

:::tip
Nous recommandons de générer d'abord un projet TypeScript dédié pour tous vos générateurs en utilisant le générateur `ts#project`. Par exemple :

<RunGenerator generator="ts#project" requiredParameters={{ name: 'nx-plugin', directory: 'tools' }} />
:::

Sélectionnez votre projet local `nx-plugin` lors de l'exécution du générateur `ts#nx-generator`, puis spécifiez un nom ainsi qu'un répertoire et une description optionnels.

### Définition du schéma

Le fichier `schema.json` définit les options acceptées par votre générateur. Il suit le format [JSON Schema](https://json-schema.org/) avec des extensions spécifiques à Nx.

#### Structure de base

Un fichier schema.json a la structure de base suivante :

```json
{
  "$schema": "https://json-schema.org/schema",
  "$id": "YourGeneratorName",
  "title": "Your Generator Title",
  "description": "Description of what your generator does",
  "type": "object",
  "properties": {
    // Vos options de générateur vont ici
  },
  "required": ["requiredOption1", "requiredOption2"]
}
```

#### Exemple simple

Voici un exemple simple avec quelques options basiques :

```json
{
  "$schema": "https://json-schema.org/schema",
  "$id": "ComponentGenerator",
  "title": "Create a Component",
  "description": "Creates a new React component",
  "type": "object",
  "properties": {
    "name": {
      "type": "string",
      "description": "Component name",
      "x-priority": "important"
    },
    "directory": {
      "type": "string",
      "description": "Directory where the component will be created",
      "default": "src/components"
    },
    "withTests": {
      "type": "boolean",
      "description": "Whether to generate test files",
      "default": true
    }
  },
  "required": ["name"]
}
```

#### Invites interactives (CLI)

Vous pouvez personnaliser les invites affichées lors de l'exécution de votre générateur via la CLI en ajoutant la propriété `x-prompt` :

```json
"name": {
  "type": "string",
  "description": "Component name",
  "x-prompt": "What is the name of your component?"
}
```

Pour les options booléennes, utilisez une invite oui/non :

```json
"withTests": {
  "type": "boolean",
  "description": "Whether to generate test files",
  "x-prompt": "Would you like to generate test files?"
}
```

#### Sélections par menu déroulant

Pour les options avec un ensemble fixe de choix, utilisez `enum` pour permettre aux utilisateurs de sélectionner une option :

```json
"style": {
  "type": "string",
  "description": "The styling approach to use",
  "enum": ["css", "scss", "styled-components", "none"],
  "default": "css"
}
```

#### Menu déroulant de sélection de projet

Un motif courant est de permettre aux utilisateurs de sélectionner parmi les projets existants dans l'espace de travail :

```json
"project": {
  "type": "string",
  "description": "The project to add the component to",
  "x-prompt": "Which project would you like to add the component to?",
  "x-dropdown": "projects"
}
```

La propriété `x-dropdown: "projects"` indique à Nx de peupler le menu déroulant avec tous les projets de l'espace de travail.

#### Arguments positionnels

Vous pouvez configurer des options pour qu'elles soient passées comme arguments positionnels lors de l'exécution du générateur depuis la ligne de commande :

```json
"name": {
  "type": "string",
  "description": "Component name",
  "x-priority": "important",
  "$default": {
    "$source": "argv",
    "index": 0
  }
}
```

Cela permet aux utilisateurs d'exécuter votre générateur comme `nx g your-generator my-component` au lieu de `nx g your-generator --name=my-component`.

#### Définition des priorités

Utilisez la propriété `x-priority` pour indiquer les options les plus importantes :

```json
"name": {
  "type": "string",
  "description": "Component name",
  "x-priority": "important"
}
```

Les options peuvent avoir des priorités `"important"` ou `"internal"`. Cela aide Nx à ordonner les propriétés dans l'extension VSCode de Nx.

#### Valeurs par défaut

Vous pouvez fournir des valeurs par défaut pour les options :

```json
"directory": {
  "type": "string",
  "description": "Directory where the component will be created",
  "default": "src/components"
}
```

#### Plus d'informations

Pour plus de détails sur les schémas, consultez la [documentation Nx sur les options des générateurs](https://nx.dev/extending-nx/recipes/generator-options).

#### Types TypeScript avec schema.d.ts

Avec `schema.json`, le générateur crée un fichier `schema.d.ts` qui fournit des types TypeScript pour les options de votre générateur :

```typescript
export interface YourGeneratorSchema {
  name: string;
  directory?: string;
  withTests?: boolean;
}
```

Cette interface est utilisée dans votre implémentation de générateur pour fournir de la sécurité de type et de la complétion de code :

```typescript
import { YourGeneratorSchema } from './schema';

export default async function (tree: Tree, options: YourGeneratorSchema) {
  // TypeScript connaît les types de toutes vos options
  const { name, directory = 'src/components', withTests = true } = options;
  // ...
}
```

:::caution
Chaque fois que vous modifiez `schema.json`, vous devez mettre à jour `schema.d.ts` pour correspondre. Cela inclut :

- Ajout ou suppression de propriétés
- Modification des types de propriétés
- Rendre des propriétés obligatoires ou optionnelles (utilisez le suffixe `?` pour les propriétés optionnelles)

L'interface TypeScript doit refléter précisément la structure définie dans votre schéma JSON.
:::

### Implémentation d'un générateur

Après avoir créé le nouveau générateur comme ci-dessus, vous pouvez écrire son implémentation dans `generator.ts`.

Un générateur est une fonction qui modifie un système de fichiers virtuel (le `Tree`), lisant et écrivant des fichiers pour effectuer les modifications souhaitées.

Voici quelques opérations courantes que vous pourriez effectuer dans votre générateur :

#### Lecture et écriture de fichiers

```typescript
// Lire un fichier
const content = tree.read('path/to/file.ts', 'utf-8');

// Écrire un fichier
tree.write('path/to/new-file.ts', 'export const hello = "world";');

// Vérifier si un fichier existe
if (tree.exists('path/to/file.ts')) {
  // Faire quelque chose
}
```

#### Génération de fichiers à partir de modèles

```typescript
import { generateFiles, joinPathFragments } from '@nx/devkit';

// Générer des fichiers à partir de modèles
generateFiles(
  tree,
  joinPathFragments(__dirname, 'files'), // Répertoire des modèles
  'path/to/output', // Répertoire de sortie
  {
    // Variables à remplacer dans les modèles
    name: options.name,
    nameCamelCase: camelCase(options.name),
    nameKebabCase: kebabCase(options.name),
    // Ajouter plus de variables au besoin
  },
);
```

#### Manipulation d'AST TypeScript (Abstract Syntax Tree)

Nous recommandons d'installer [TSQuery](https://github.com/phenomnomnominal/tsquery) pour aider à la manipulation d'AST.

```typescript
import { tsquery } from '@phenomnomnominal/tsquery';
import * as ts from 'typescript';

// Exemple : Incrémenter un numéro de version dans un fichier

// Parser le contenu du fichier en AST TypeScript
const sourceFile = tsquery.ast(tree.read('path/to/version.ts', 'utf-8'));

// Trouver les nœuds correspondant au sélecteur
const nodes = tsquery.query(
  sourceFile,
  'VariableDeclaration:has(Identifier[name="VERSION"]) NumericLiteral',
);

if (nodes.length > 0) {
  // Obtenir le nœud du littéral numérique
  const numericNode = nodes[0] as ts.NumericLiteral;

  // Obtenir le numéro de version actuel et l'incrémenter
  const currentVersion = Number(numericNode.text);
  const newVersion = currentVersion + 1;

  // Remplacer le nœud dans l'AST
  const result = tsquery.replace(
    sourceFile,
    'VariableDeclaration:has(Identifier[name="VERSION"]) NumericLiteral',
    () => ts.factory.createNumericLiteral(newVersion),
  );

  // Écrire le contenu mis à jour dans le tree
  tree.write(
    'path/to/version.ts',
    ts
      .createPrinter({
        newLine: ts.NewLineKind.LineFeed,
      })
      .printNode(ts.EmitHint.Unspecified, result, sourceFile),
  );
}
```

:::tip
Vous pouvez tester les sélecteurs en ligne dans le [TSQuery Playground](https://tsquery-playground.firebaseapp.com/).
:::

#### Ajout de dépendances

```typescript
import { addDependenciesToPackageJson } from '@nx/devkit';

// Ajouter des dépendances à package.json
addDependenciesToPackageJson(
  tree,
  {
    'new-dependency': '^1.0.0',
  },
  {
    'new-dev-dependency': '^2.0.0',
  },
);
```

#### Formatage des fichiers générés

```typescript
import { formatFiles } from '@nx/devkit';

// Formater tous les fichiers modifiés
await formatFiles(tree);
```

#### Lecture et mise à jour de fichiers JSON

```typescript
import { readJson, updateJson } from '@nx/devkit';

// Lire un fichier JSON
const packageJson = readJson(tree, 'package.json');

// Mettre à jour un fichier JSON
updateJson(tree, 'tsconfig.json', (json) => {
  json.compilerOptions = {
    ...json.compilerOptions,
    strict: true,
  };
  return json;
});
```

### Exécution de votre générateur

Vous pouvez exécuter votre générateur de deux manières :

<RunGenerator namespace="@my-project/nx-plugin" generator="my-generator" />

:::note
Si vous ne voyez pas votre générateur dans l'interface VSCode, vous pouvez rafraîchir votre espace de travail Nx avec :

<NxCommands commands={['reset']} />
:::

### Test de votre générateur

Les tests unitaires pour les générateurs sont simples à implémenter. Voici un modèle typique :

```typescript
import { createTreeWithEmptyWorkspace } from '@nx/devkit/testing';
import { yourGenerator } from './generator';

describe('your generator', () => {
  let tree;

  beforeEach(() => {
    // Créer un arbre d'espace de travail vide
    tree = createTreeWithEmptyWorkspace();

    // Ajouter les fichiers qui devraient déjà exister
    tree.write(
      'project.json',
      JSON.stringify({
        name: 'test-project',
        sourceRoot: 'src',
      }),
    );

    tree.write('src/existing-file.ts', 'export const existing = true;');
  });

  it('should generate expected files', async () => {
    // Exécuter le générateur
    await yourGenerator(tree, {
      name: 'test',
      // Ajouter d'autres options requises
    });

    // Vérifier la création des fichiers
    expect(tree.exists('src/test/file.ts')).toBeTruthy();

    // Vérifier le contenu du fichier
    const content = tree.read('src/test/file.ts', 'utf-8');
    expect(content).toContain('export const test');

    // Vous pouvez aussi utiliser des snapshots
    expect(tree.read('src/test/file.ts', 'utf-8')).toMatchSnapshot();
  });

  it('should update existing files', async () => {
    // Exécuter le générateur
    await yourGenerator(tree, {
      name: 'test',
      // Ajouter d'autres options requises
    });

    // Vérifier la mise à jour des fichiers existants
    const content = tree.read('src/existing-file.ts', 'utf-8');
    expect(content).toContain('import { test } from');
  });

  it('should handle errors', async () => {
    // S'attendre à une erreur dans certaines conditions
    await expect(
      yourGenerator(tree, {
        name: 'invalid',
        // Ajouter des options provoquant une erreur
      }),
    ).rejects.toThrow('Expected error message');
  });
});
```

Points clés pour tester les générateurs :

- Utilisez `createTreeWithEmptyWorkspace()` pour créer un système de fichiers virtuel
- Configurez les fichiers prérequis avant d'exécuter le générateur
- Testez à la fois la création de nouveaux fichiers et la mise à jour de fichiers existants
- Utilisez des snapshots pour du contenu complexe
- Testez les conditions d'erreur pour garantir un échec gracieux

## Contribution de générateurs à @aws/nx-plugin

Vous pouvez aussi utiliser `ts#nx-generator` pour créer un générateur dans `@aws/nx-plugin`.

Lorsque ce générateur est exécuté dans notre dépôt, il générera les fichiers suivants pour vous :

<FileTree>
  - packages/nx-plugin/src/\<name>/
    - schema.json Schéma d'entrée pour votre générateur
    - schema.d.ts Types TypeScript pour votre schéma
    - generator.ts Implémentation du générateur
    - generator.spec.ts Tests pour votre générateur
  - docs/src/content/docs/guides/
    - \<name>.mdx Page de documentation pour votre générateur
  - packages/nx-plugin/generators.json Mis à jour pour inclure votre générateur
</FileTree>

Vous pouvez ensuite commencer à implémenter votre générateur.

:::tip
Pour un guide plus détaillé sur la contribution au Nx Plugin pour AWS, veuillez consulter le <Link path="get_started/tutorials/contribute-generator">tutoriel ici</Link>.
:::