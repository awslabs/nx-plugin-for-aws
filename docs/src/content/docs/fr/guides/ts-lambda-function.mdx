---
title: "Fonction Lambda TypeScript"
description: "Générer une fonction lambda TypeScript"
---



import { FileTree } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Infrastructure from '@components/infrastructure.astro';
import Snippet from '@components/snippet.astro';

Le générateur de fonction Lambda TypeScript permet d'ajouter une fonction lambda à un projet TypeScript existant.

Ce générateur crée un nouveau gestionnaire Lambda TypeScript avec une configuration d'infrastructure AWS CDK ou Terraform. Le gestionnaire généré utilise [AWS Lambda Powertools for TypeScript](https://docs.powertools.aws.dev/lambda/typescript/latest/) pour l'observabilité, incluant le logging, le tracing AWS X-Ray et les métriques CloudWatch, ainsi qu'une sécurité de type optionnelle pour les événements via le [Parser d'AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/utilities/parser/).

## Utilisation

### Générer une fonction Lambda TypeScript

Vous pouvez générer une fonction lambda de deux manières :

<RunGenerator generator="ts#lambda-function" />

### Options

<GeneratorParameters generator="ts#lambda-function" />

## Sortie du générateur

Le générateur ajoutera les fichiers suivants à votre projet :

<FileTree>

- \<project-name>
  - src/
    - \<lambda-function>.ts Implémentation de la fonction

</FileTree>

Si l'option `functionPath` est spécifiée, le générateur ajoutera le gestionnaire au chemin indiqué dans le répertoire source du projet :

<FileTree>

- \<project-name>
  - src/
    - \<custom-path>/
      - \<function-name>.ts Implémentation de la fonction

</FileTree>

### Infrastructure

<Snippet name="shared-constructs" />

Le générateur crée une infrastructure as code pour déployer votre fonction selon le `iacProvider` sélectionné :

<Infrastructure>
<Fragment slot="cdk">
Le générateur crée un construct CDK utilisable pour déployer votre fonction, situé dans le répertoire `packages/common/constructs/src/app/lambda-functions`.
</Fragment>
<Fragment slot="terraform">
Le générateur crée un module Terraform utilisable pour déployer votre fonction, situé dans le répertoire `packages/common/terraform/src/app/lambda-functions/<function-name>`.
</Fragment>
</Infrastructure>

## Implémentation de votre fonction

L'implémentation principale se trouve dans `<function-name>.ts`. Voici un exemple :

```typescript
import { parser } from '@aws-lambda-powertools/parser/middleware';
import { EventBridgeSchema } from '@aws-lambda-powertools/parser/schemas';
import middy from '@middy/core';
import { Tracer } from '@aws-lambda-powertools/tracer';
import { captureLambdaHandler } from '@aws-lambda-powertools/tracer/middleware';
import { injectLambdaContext } from '@aws-lambda-powertools/logger/middleware';
import { Logger } from '@aws-lambda-powertools/logger';
import { Metrics } from '@aws-lambda-powertools/metrics';
import { logMetrics } from '@aws-lambda-powertools/metrics/middleware';
import { z } from 'zod';

process.env.POWERTOOLS_METRICS_NAMESPACE = 'MyFunction';
process.env.POWERTOOLS_SERVICE_NAME = 'MyFunction';

const tracer = new Tracer();
const logger = new Logger();
const metrics = new Metrics();

export const myFunction = async (
  event: z.infer<typeof EventBridgeSchema>,
): Promise<void> => {
  logger.info('Received event', event);

  // TODO: implement
};

export const handler = middy()
  .use(captureLambdaHandler(tracer))
  .use(injectLambdaContext(logger))
  .use(logMetrics(metrics))
  .use(parser({ schema: EventBridgeSchema }))
  .handler(myFunction);

```

Le générateur configure automatiquement plusieurs fonctionnalités :

1. **Pile de middleware Middy** pour des fonctionnalités Lambda étendues
2. **Intégration AWS Lambda Powertools** pour l'observabilité
3. **Collecte de métriques** avec CloudWatch
4. **Sécurité de type** via le middleware parser
5. **Bundling avec esbuild** pour des packages de déploiement optimisés

### Observabilité avec AWS Lambda Powertools

#### Logging

Le générateur configure le logging structuré avec AWS Lambda Powertools et l'injection automatique de contexte via le middleware Middy.

```typescript
export const handler = middy()
  .use(injectLambdaContext(logger))
  .handler(myFunction);
```

#### Tracing

Le tracing AWS X-Ray est configuré automatiquement via le middleware `captureLambdaHandler`. Vous pouvez ajouter des sous-segments personnalisés :

```typescript
const tracer = new Tracer();

export const myFunction = async (
  event: z.infer<typeof EventBridgeSchema>,
): Promise<void> => {
  // Crée un nouveau sous-segment
  const subsegment = tracer.getSegment()?.addNewSubsegment('custom-operation');
  try {
    // Votre logique ici
  } catch (error) {
    subsegment?.addError(error as Error);
    throw error;
  } finally {
    subsegment?.close();
  }
};

export const handler = middy()
  .use(captureLambdaHandler(tracer))
  .handler(myFunction);
```

#### Métriques

Les métriques CloudWatch sont collectées automatiquement pour chaque requête via le middleware `logMetrics`. Vous pouvez ajouter des métriques personnalisées :

```typescript
const metrics = new Metrics();

export const myFunction = async (
  event: z.infer<typeof EventBridgeSchema>,
): Promise<void> => {
  metrics.addMetric("CustomMetric", MetricUnit.Count, 1);
  metrics.addMetric("ProcessingTime", MetricUnit.Milliseconds, processingTime);
};

export const handler = middy()
  .use(logMetrics(metrics))
  .handler(myFunction);
```

### Sécurité de type

Si vous avez choisi un `eventSource` lors de la génération de votre fonction Lambda, celle-ci est instrumentée avec le [middleware `parser` d'AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/utilities/parser/). Exemple :

```typescript {4}
export const myFunction = async (
  event: z.infer<typeof EventBridgeSchema>,
): Promise<void> => {
  event.detail // <- typage fort avec autocomplétion IDE
};

export const handler = middy()
  .use(parser({ schema: EventBridgeSchema }))
  .handler(myFunction);
```

Cela fournit un typage à la compilation et une validation à l'exécution pour les événements Lambda.

:::caution
Si vous ne souhaitez pas que votre gestionnaire génère une erreur lorsque l'événement ne correspond pas au schéma, vous pouvez utiliser l'option [`safeParse`](https://docs.powertools.aws.dev/lambda/typescript/latest/utilities/parser/#safe-parsing).
:::

:::tip
Si vous avez des données personnalisées imbriquées dans un événement (ex: flux DynamoDB ou événement EventBridge), vous pouvez utiliser les [Envelopes](https://docs.powertools.aws.dev/lambda/typescript/latest/utilities/parser/#envelopes) pour assurer le typage de ces données.
:::

Si vous ne souhaitez pas typer votre événement, sélectionnez `Any` pour `eventSource`, ce qui donnera un type `any` au paramètre event.

## Bundling

Le générateur configure automatiquement [esbuild](https://esbuild.github.io/) pour des packages de déploiement Lambda optimisés :

Bundlez une fonction Lambda spécifique avec :

<NxCommands commands={['run <project-name>:bundle-<function-name>']} />

Bundlez toutes les fonctions Lambda du projet avec :

<NxCommands commands={['run <project-name>:bundle']} />

## Déploiement de votre fonction

<Snippet name="lambda-function/deploying-your-function" parentHeading="Deploying your Function" />