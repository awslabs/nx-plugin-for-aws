---
title: "FastAPI"
description: "Documentation de référence pour FastAPI"
---

import { FileTree, AnchorHeading, Tabs, TabItem } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Infrastructure from '@components/infrastructure.astro';
import Snippet from '@components/snippet.astro';

[FastAPI](https://fastapi.tiangolo.com/) est un framework pour construire des APIs en Python.

Le générateur FastAPI crée une nouvelle application FastAPI avec une infrastructure AWS CDK ou Terraform. Le backend généré utilise AWS Lambda pour un déploiement serverless, exposé via une API AWS API Gateway. Il configure [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/python/latest/) pour l'observabilité, incluant la journalisation, le traçage AWS X-Ray et les métriques CloudWatch.

## Utilisation

### Générer une FastAPI

Vous pouvez générer une nouvelle application FastAPI de deux manières :

<RunGenerator generator="py#fast-api" />

### Options

<GeneratorParameters generator="py#fast-api" />

<Snippet name="api/api-choice-note" />

## Sortie du générateur

Le générateur va créer la structure de projet suivante dans le répertoire `<directory>/<api-name>` :

<FileTree>

- project.json Configuration du projet et cibles de build
- pyproject.toml Configuration du projet Python et dépendances
- \<module_name>
  - \_\_init\_\_.py Initialisation du module
  - init.py Configure l'application FastAPI et le middleware powertools
  - main.py Implémentation de l'API
- scripts
  - generate_open_api.py Script pour générer un schéma OpenAPI depuis l'app FastAPI

</FileTree>

### Infrastructure

<Snippet name="shared-constructs" />

<Snippet name="api/shared-constructs" />

## Implémentation de votre FastAPI

L'implémentation principale de l'API se trouve dans `main.py`. C'est ici que vous définissez vos routes API et leurs implémentations. Voici un exemple :

```python
from .init import app, tracer
from pydantic import BaseModel

class Item(BaseModel):
  name: str

@app.get("/items/{item_id}")
def get_item(item_id: int) -> Item:
    return Item(name=...)

@app.post("/items")
def create_item(item: Item):
    return ...
```

Le générateur configure automatiquement plusieurs fonctionnalités :

1. Intégration d'AWS Lambda Powertools pour l'observabilité
2. Middleware de gestion des erreurs
3. Corrélation des requêtes/réponses
4. Collecte de métriques
5. Handler AWS Lambda utilisant Mangum

### Observabilité avec AWS Lambda Powertools

#### Journalisation

Le générateur configure la journalisation structurée avec AWS Lambda Powertools. Vous pouvez accéder au logger dans vos gestionnaires de route :

```python
from .init import app, logger

@app.get("/items/{item_id}")
def read_item(item_id: int):
    logger.info("Fetching item", extra={"item_id": item_id})
    return {"item_id": item_id}
```

Le logger inclut automatiquement :

- Des IDs de corrélation pour le traçage des requêtes
- Le chemin et la méthode de la requête
- Les informations de contexte Lambda
- Des indicateurs de démarrage à froid

#### Traçage

Le traçage AWS X-Ray est configuré automatiquement. Vous pouvez ajouter des sous-segments personnalisés à vos traces :

```python
from .init import app, tracer

@app.get("/items/{item_id}")
@tracer.capture_method
def read_item(item_id: int):
    # Crée un nouveau sous-segment
    with tracer.provider.in_subsegment("fetch-item-details"):
        # Votre logique ici
        return {"item_id": item_id}
```

#### Métriques

Des métriques CloudWatch sont collectées automatiquement pour chaque requête. Vous pouvez ajouter des métriques personnalisées :

```python
from .init import app, metrics
from aws_lambda_powertools.metrics import MetricUnit

@app.get("/items/{item_id}")
def read_item(item_id: int):
    metrics.add_metric(name="ItemViewed", unit=MetricUnit.Count, value=1)
    return {"item_id": item_id}
```

Les métriques par défaut incluent :

- Le nombre de requêtes
- Les compteurs de succès/échec
- Les métriques de démarrage à froid
- Des métriques par route

### Gestion des erreurs

Le générateur inclut une gestion d'erreurs complète :

```python
from fastapi import HTTPException

@app.get("/items/{item_id}")
def read_item(item_id: int):
    if item_id < 0:
        raise HTTPException(status_code=400, detail="Item ID must be positive")
    return {"item_id": item_id}
```

Les exceptions non gérées sont capturées par le middleware et :

1. Journalisent l'exception complète avec la stack trace
2. Enregistrent une métrique d'échec
3. Renvoient une réponse 500 sécurisée au client
4. Préservent l'ID de corrélation

:::tip
Il est recommandé de spécifier des modèles de réponse pour vos opérations API afin de faciliter la génération de code si vous utilisez le générateur `api-connection`. <Link path="guides/api-connection/react-fastapi#errors">Voir ici pour plus de détails</Link>.
:::

### Streaming

Avec FastAPI, vous pouvez streamer une réponse au client avec le type de réponse [`StreamingResponse`](https://fastapi.tiangolo.com/reference/responses/?h=streaming#fastapi.responses.StreamingResponse).

#### Modifications de l'infrastructure

Puisque AWS API Gateway ne supporte pas les réponses streamées, vous devrez déployer votre FastAPI sur une plateforme qui le supporte. L'option la plus simple est d'utiliser une URL de fonction AWS Lambda.

<Infrastructure>
<Fragment slot="cdk">
Pour cela, vous pouvez remplacer le construct généré `common/constructs/src/app/apis/<name>-api.ts` par un qui déploie une URL de fonction.

<details>
<summary>Exemple de construct FunctionURL pour le streaming</summary>

```ts
import { Duration, Stack, CfnOutput } from 'aws-cdk-lib';
import { IGrantable, Grant } from 'aws-cdk-lib/aws-iam';
import {
  Runtime,
  Code,
  Tracing,
  LayerVersion,
  FunctionUrlAuthType,
  InvokeMode,
  Function,
} from 'aws-cdk-lib/aws-lambda';
import { Construct } from 'constructs';
import url from 'url';
import { RuntimeConfig } from '../../core/runtime-config.js';

export class MyApi extends Construct {
  public readonly handler: Function;

  constructor(scope: Construct, id: string) {
    super(scope, id);

    this.handler = new Function(this, 'Handler', {
      runtime: Runtime.PYTHON_3_12,
      handler: 'run.sh',
      code: Code.fromAsset(
        url.fileURLToPath(
          new URL(
            '../../../../../../dist/packages/my_api/bundle-x86',
            import.meta.url,
          ),
        ),
      ),
      timeout: Duration.seconds(30),
      tracing: Tracing.ACTIVE,
      environment: {
        AWS_CONNECTION_REUSE_ENABLED: '1',
      },
    });

    const stack = Stack.of(this);
    this.handler.addLayers(
      LayerVersion.fromLayerVersionArn(
        this,
        'LWALayer',
        `arn:aws:lambda:${stack.region}:753240598075:layer:LambdaAdapterLayerX86:24`,
      ),
    );
    this.handler.addEnvironment('PORT', '8000');
    this.handler.addEnvironment('AWS_LWA_INVOKE_MODE', 'response_stream');
    this.handler.addEnvironment('AWS_LAMBDA_EXEC_WRAPPER', '/opt/bootstrap');
    const functionUrl = this.handler.addFunctionUrl({
      authType: FunctionUrlAuthType.AWS_IAM,
      invokeMode: InvokeMode.RESPONSE_STREAM,
      cors: {
        allowedOrigins: ['*'],
        allowedHeaders: [
          'authorization',
          'content-type',
          'x-amz-content-sha256',
          'x-amz-date',
          'x-amz-security-token',
        ],
      },
    });

    new CfnOutput(this, 'MyApiUrl', { value: functionUrl.url });

    // Enregistre l'URL de l'API dans la configuration runtime pour la découverte client
    RuntimeConfig.ensure(this).config.apis = {
      ...RuntimeConfig.ensure(this).config.apis!,
      MyApi: functionUrl.url,
    };
  }

  public grantInvokeAccess(grantee: IGrantable) {
    Grant.addToPrincipal({
      grantee,
      actions: ['lambda:InvokeFunctionUrl'],
      resourceArns: [this.handler.functionArn],
      conditions: {
        StringEquals: {
          'lambda:FunctionUrlAuthType': 'AWS_IAM',
        },
      },
    });
  }
}

```

</details>
</Fragment>
<Fragment slot="terraform">
Pour cela avec Terraform, vous pouvez remplacer l'infrastructure API Gateway générée par une URL de fonction Lambda supportant le streaming de réponse.

<details>
<summary>Exemple de configuration Terraform pour une URL de fonction Lambda avec streaming</summary>

```hcl
# Data sources pour le contexte AWS actuel
data "aws_caller_identity" "current" {}
data "aws_region" "current" {}

# Fonction Lambda pour FastAPI en streaming
resource "aws_lambda_function" "my_api_handler" {
  filename         = "../../../../../../dist/packages/my_api/bundle.zip"
  function_name    = "my-api-handler"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "run.sh"
  runtime         = "python3.12"
  timeout         = 30
  source_code_hash = filebase64sha256("../../../../../../dist/packages/my_api/bundle.zip")

  # Activation du traçage X-Ray
  tracing_config {
    mode = "Active"
  }

  # Variables d'environnement pour Lambda Web Adapter
  environment {
    variables = {
      AWS_CONNECTION_REUSE_ENABLED = "1"
      PORT                        = "8000"
      AWS_LWA_INVOKE_MODE        = "response_stream"
      AWS_LAMBDA_EXEC_WRAPPER    = "/opt/bootstrap"
    }
  }

  # Ajout de la couche Lambda Web Adapter
  layers = [
    "arn:aws:lambda:${data.aws_region.current.name}:753240598075:layer:LambdaAdapterLayerX86:24"
  ]

  depends_on = [
    aws_iam_role_policy_attachment.lambda_logs,
    aws_cloudwatch_log_group.lambda_logs,
  ]
}

# Groupe de logs CloudWatch pour la fonction Lambda
resource "aws_cloudwatch_log_group" "lambda_logs" {
  name              = "/aws/lambda/my-api-handler"
  retention_in_days = 14
}

# Rôle IAM pour l'exécution Lambda
resource "aws_iam_role" "lambda_execution_role" {
  name = "my-api-lambda-execution-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

# Attachement de la politique d'exécution de base
resource "aws_iam_role_policy_attachment" "lambda_logs" {
  role       = aws_iam_role.lambda_execution_role.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
}

# Attachement de la politique X-Ray
resource "aws_iam_role_policy_attachment" "lambda_xray" {
  role       = aws_iam_role.lambda_execution_role.name
  policy_arn = "arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess"
}

# URL de fonction Lambda avec support du streaming
resource "aws_lambda_function_url" "my_api_url" {
  function_name      = aws_lambda_function.my_api_handler.function_name
  authorization_type = "AWS_IAM"
  invoke_mode       = "RESPONSE_STREAM"

  cors {
    allow_credentials = false
    allow_origins     = ["*"]
    allow_methods     = ["*"]
    allow_headers = [
      "authorization",
      "content-type",
      "x-amz-content-sha256",
      "x-amz-date",
      "x-amz-security-token"
    ]
    expose_headers = ["date", "keep-alive"]
    max_age       = 86400
  }
}

# Sortie de l'URL de fonction
output "my_api_url" {
  description = "URL pour la fonction Lambda FastAPI en streaming"
  value       = aws_lambda_function_url.my_api_url.function_url
}

# Optionnel : Création d'un paramètre SSM pour la configuration runtime
resource "aws_ssm_parameter" "my_api_url" {
  name  = "/runtime-config/apis/MyApi"
  type  = "String"
  value = aws_lambda_function_url.my_api_url.function_url

  tags = {
    Environment = "production"
    Service     = "my-api"
  }
}

# Politique IAM pour autoriser l'accès d'invocation
resource "aws_iam_policy" "my_api_invoke_policy" {
  name        = "my-api-invoke-policy"
  description = "Politique pour autoriser l'invocation de l'URL de fonction Lambda FastAPI en streaming"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = "lambda:InvokeFunctionUrl"
        Resource = aws_lambda_function.my_api_handler.arn
        Condition = {
          StringEquals = {
            "lambda:FunctionUrlAuthType" = "AWS_IAM"
          }
        }
      }
    ]
  })
}

# Exemple : Attachement de la politique à un rôle (décommenter et modifier si nécessaire)
# resource "aws_iam_role_policy_attachment" "my_api_invoke_access" {
#   role       = var.authenticated_role_name
#   policy_arn = aws_iam_policy.my_api_invoke_policy.arn
# }
```

</details>

</Fragment>
</Infrastructure>

#### Implémentation

Une fois l'infrastructure mise à jour pour supporter le streaming, vous pouvez implémenter une API streamée dans FastAPI. L'API doit :

- Retourner un [`StreamingResponse`](https://fastapi.tiangolo.com/reference/responses/?h=streaming#fastapi.responses.StreamingResponse)
- Déclarer le type de retour de chaque chunk de réponse
- Ajouter l'extension OpenAPI `x-streaming: true` si vous prévoyez d'utiliser <Link path="guides/api-connection/react-fastapi">API Connection</Link>.

Par exemple, si vous souhaitez streamer une série d'objets JSON depuis votre API, vous pouvez l'implémenter ainsi :

```py /return (StreamingResponse)/ /openapi_extra[^)]*/ /-> (Chunk)/
from pydantic import BaseModel
from fastapi.responses import StreamingResponse

class Chunk(BaseModel):
  message: str
  timestamp: datetime

async def stream_chunks():
  for i in range(0, 100):
    yield Chunk(message=f"This is chunk {i}", timestamp=datetime.now())

@app.get("/stream", openapi_extra={'x-streaming': True})
def my_stream() -> Chunk:
    return StreamingResponse(stream_chunks(), media_type="application/json")
```

#### Consommation

Pour consommer un flux de réponses, vous pouvez utiliser le <Link path="guides/api-connection/react-fastapi#consuming-a-stream">Générateur API Connection</Link> qui fournira une méthode typée pour itérer sur les chunks streamés.

## Déploiement de votre FastAPI

Le générateur FastAPI crée une infrastructure CDK ou Terraform en fonction du `iacProvider` sélectionné. Vous pouvez l'utiliser pour déployer votre FastAPI.

<Infrastructure>
<Fragment slot="cdk">
Le construct CDK pour déployer votre API se trouve dans le dossier `common/constructs`. Vous pouvez l'utiliser dans une application CDK :

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    // Ajoute l'API à votre stack
    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
    });
  }
}
```

Ceci configure :

1. Une fonction AWS Lambda pour chaque opération de l'application FastAPI
2. Une API Gateway HTTP/REST comme déclencheur
3. Les rôles et permissions IAM
4. Un groupe de logs CloudWatch
5. La configuration de traçage X-Ray
6. Un espace de noms pour les métriques CloudWatch

<Snippet name="api/cors-configuration-cdk-note" />

:::note
Si vous avez choisi l'authentification `Cognito`, vous devrez fournir la propriété `identity` au construct API :

```ts {9}
import { MyApi, UserIdentity } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const identity = new UserIdentity(this, 'Identity');

    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
      identity,
    });
  }
}
```

Le construct `UserIdentity` peut être généré avec le générateur <Link path="/guides/react-website-auth">`ts#react-website-auth`</Link>
:::
</Fragment>
<Fragment slot="terraform">
Les modules Terraform pour déployer votre API se trouvent dans le dossier `common/terraform`. Vous pouvez les utiliser dans une configuration Terraform :

```hcl {2}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Variables d'environnement pour la fonction Lambda
  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  # Politiques IAM supplémentaires si nécessaire
  additional_iam_policy_statements = [
    # Ajoutez les permissions supplémentaires nécessaires
  ]

  tags = local.common_tags
}
```

Ceci configure :

1. Une fonction AWS Lambda qui sert toutes les routes FastAPI
2. Une API Gateway HTTP/REST comme déclencheur
3. Les rôles et permissions IAM
4. Un groupe de logs CloudWatch
5. La configuration de traçage X-Ray
6. La configuration CORS

<Snippet name="api/cors-configuration-terraform-note" />

:::note
Si vous avez choisi l'authentification `Cognito`, vous devrez fournir la configuration Cognito :

```hcl {4-5}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  user_pool_id         = local.user_pool_id
  user_pool_client_ids = [local.client_id]

  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  tags = local.common_tags
}
```

Vous pouvez configurer le User Pool et Client Cognito en utilisant les ressources ou modules Terraform appropriés.
:::

Le module Terraform fournit plusieurs sorties utilisables :

```hcl
# Accès à l'endpoint de l'API
output "api_url" {
  value = module.my_api.stage_invoke_url
}

# Accès aux détails de la fonction Lambda
output "lambda_function_name" {
  value = module.my_api.lambda_function_name
}

# Accès au rôle IAM pour des permissions supplémentaires
output "lambda_execution_role_arn" {
  value = module.my_api.lambda_execution_role_arn
}
```

Vous pouvez personnaliser les paramètres CORS en passant des variables au module :

```hcl
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Configuration CORS personnalisée
  cors_allow_origins = ["https://myapp.com", "https://staging.myapp.com"]
  cors_allow_methods = ["GET", "POST", "PUT", "DELETE"]
  cors_allow_headers = [
    "authorization",
    "content-type",
    "x-custom-header"
  ]

  tags = local.common_tags
}
```

:::caution
Si vous avez choisi `None` pour `auth` lors de l'exécution du générateur, vous pourriez voir des échecs de vérification Checkov comme :

<Tabs syncKey="http-rest">
<TabItem label="HTTP API">
```
Check: CKV_AWS_309: "Ensure API GatewayV2 routes specify an authorization type"
 FAILED for resource: aws_apigatewayv2_route.proxy_routes["PUT"]
```
</TabItem>
<TabItem label="REST API">
```
Check: CKV_AWS_59: "Ensure there is no open access to back-end resources through API"
 FAILED for resource: aws_api_gateway_method.proxy_method
```
</TabItem>
</Tabs>

Vous pouvez [ajouter un commentaire de suppression](https://www.checkov.io/2.Basics/Suppressing%20and%20Skipping%20Policies.html) si vous souhaitez que votre API reste publique.
:::
</Fragment>
</Infrastructure>

### Intégrations

<Snippet name="api/type-safe-api-integrations" parentHeading="Intégrations" />

#### Génération de code

<Infrastructure>
<Fragment slot="cdk">
Puisque les opérations FastAPI sont définies en Python et l'infrastructure CDK en TypeScript, nous instrumentons la génération de code pour fournir des métadonnées au construct CDK afin d'offrir une interface typée pour les intégrations.

Une cible `generate:<ApiName>-metadata` est ajoutée au `project.json` des constructs communs pour faciliter cette génération, produisant un fichier comme `packages/common/constructs/src/generated/my-api/metadata.gen.ts`. Ce fichier étant généré au build, il est ignoré dans le contrôle de version.

:::note
Vous devrez exécuter un build après chaque modification de votre API pour maintenir les types consommés par le construct CDK à jour.

<NxCommands commands={["run-many --target build --all"]} />
:::

:::tip
Si vous travaillez simultanément sur l'infrastructure CDK et FastAPI, vous pouvez utiliser [`nx watch`](https://nx.dev/nx-api/nx/documents/watch) pour régénérer ces types à chaque modification :

<NxCommands
  commands={[
    'watch --projects=<FastAPIProject> -- \\ ',
    'run <InfraProject>:"generate:<ApiName>-metadata"',
  ]}
/>
:::
</Fragment>
<Fragment slot="terraform">
:::note
Nous ne supportons pas les intégrations typées pour Terraform, donc aucune cible de génération de code n'est configurée si vous avez choisi Terraform comme `iacProvider`.
:::
</Fragment>
</Infrastructure>

### Octroi d'accès (IAM uniquement)

Si vous avez choisi l'authentification `IAM`, vous pouvez utiliser la méthode `grantInvokeAccess` pour octroyer l'accès à votre API :

<Infrastructure>
<Fragment slot="cdk">
```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```
</Fragment>
<Fragment slot="terraform">
```hcl
# Crée une politique IAM pour autoriser l'invocation de l'API
resource "aws_iam_policy" "api_invoke_policy" {
  name        = "MyApiInvokePolicy"
  description = "Politique pour autoriser l'invocation de FastAPI"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = "execute-api:Invoke"
        Resource = "${module.my_api.api_execution_arn}/*/*"
      }
    ]
  })
}

# Attache la politique à un rôle IAM (ex: utilisateurs authentifiés)
resource "aws_iam_role_policy_attachment" "api_invoke_access" {
  role       = aws_iam_role.authenticated_user_role.name
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}

# Ou attache à un rôle existant par nom
resource "aws_iam_role_policy_attachment" "api_invoke_access_existing" {
  role       = "MyExistingRole"
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}
```

Les sorties clés du module API utilisables pour les politiques IAM sont :

- `module.my_api.api_execution_arn` - Pour autoriser execute-api:Invoke
- `module.my_api.api_arn` - L'ARN de l'API Gateway
- `module.my_api.lambda_function_arn` - L'ARN de la fonction Lambda
</Fragment>
</Infrastructure>

## Développement local

Le générateur configure un serveur de développement local que vous pouvez exécuter avec :

<NxCommands commands={['run my-api:serve']} />

Ceci démarre un serveur de développement FastAPI local avec :

- Rechargement automatique sur modification
- Documentation interactive de l'API sur `/docs` ou `/redoc`
- Schéma OpenAPI sur `/openapi.json`

## Invocation de votre FastAPI

Pour invoquer votre API depuis un site React, vous pouvez utiliser le générateur <Link path="guides/api-connection/react-fastapi">`api-connection`</Link>.