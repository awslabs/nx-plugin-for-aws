---
title: "API Smithy TypeScript"
description: "Documentation de référence pour l'API Smithy TypeScript"
---

import { FileTree, AnchorHeading, Tabs, TabItem } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Infrastructure from '@components/infrastructure.astro';
import Snippet from '@components/snippet.astro';

[Smithy](https://smithy.io/) est un langage de définition d'interface indépendant des protocoles pour créer des API de manière modélisée.

Le générateur d'API Smithy TypeScript crée une nouvelle API en utilisant Smithy pour la définition des services, et le [SDK serveur Smithy TypeScript](https://github.com/awslabs/smithy-typescript) pour l'implémentation. Le générateur fournit une infrastructure IaC avec CDK ou Terraform pour déployer votre service sur AWS Lambda, exposé via une API REST AWS API Gateway. Il permet un développement d'API fortement typé avec génération automatique de code à partir des modèles Smithy. Le gestionnaire généré utilise [AWS Lambda Powertools pour TypeScript](https://docs.powertools.aws.dev/lambda/typescript/latest/) pour l'observabilité, incluant la journalisation, le traçage AWS X-Ray et les métriques CloudWatch.

## Utilisation

### Générer une API Smithy TypeScript

Vous pouvez générer une nouvelle API Smithy TypeScript de deux manières :

<RunGenerator generator="ts#smithy-api" />

### Options

<GeneratorParameters generator="ts#smithy-api" />

## Sortie du générateur

Le générateur crée deux projets associés dans le répertoire `<directory>/<api-name>` :

<FileTree>

- **model/** Projet de modèle Smithy
  - project.json Configuration du projet et cibles de build
  - smithy-build.json Configuration de build Smithy
  - build.Dockerfile Configuration Docker pour la construction des artefacts Smithy
  - src/
    - main.smithy Définition principale du service
    - operations/
      - echo.smithy Exemple de définition d'opération
- **backend/** Implémentation TypeScript du backend
  - project.json Configuration du projet et cibles de build
  - rolldown.config.ts Configuration de bundle
  - src/
    - handler.ts Gestionnaire AWS Lambda
    - local-server.ts Serveur de développement local
    - service.ts Implémentation du service
    - context.ts Définition du contexte du service
    - operations/
      - echo.ts Exemple d'implémentation d'opération
    - generated/ SDK TypeScript généré (créé pendant le build)

</FileTree>

### Infrastructure

Comme ce générateur crée une infrastructure as code selon votre choix de `iacProvider`, il génère un projet dans `packages/common` incluant les constructs CDK ou modules Terraform pertinents.

Le projet d'infrastructure as code commun est structuré comme suit :

<Infrastructure>
<Fragment slot="cdk">
<FileTree>
  - packages/common/constructs
    - src
      - app/ Constructs pour l'infrastructure spécifique à un projet/générateur
        - apis/
          - \<project-name>.ts Construct CDK pour déployer votre API
      - core/ Constructs génériques réutilisés par ceux dans `app`
        - api/
          - rest-api.ts Construct CDK pour déployer une API REST
          - utils.ts Utilitaires pour les constructs d'API
      - index.ts Point d'entrée exportant les constructs de `app`
    - project.json Cibles de build et configuration du projet
</FileTree>

:::note
Ce projet est généré avec le générateur [`ts#project`](guides/typescript-project) et configure donc les mêmes cibles de build.
:::
</Fragment>
<Fragment slot="terraform">
<FileTree>
  - packages/common/terraform
    - src
      - app/ Modules Terraform pour l'infrastructure spécifique à un projet/générateur
        - apis/
          - \<project-name>/
            - \<project-name>.tf Module pour déployer votre API
      - core/ Modules génériques réutilisés par ceux dans `app`
        - api/
          - rest-api/
            - rest-api.tf Module pour déployer une API REST
    - project.json Cibles de build et configuration du projet
</FileTree>

:::note
Ce projet est généré avec le générateur [`terraform#project`](guides/terraform-project) et configure donc les mêmes cibles de build.
:::
</Fragment>
</Infrastructure>

## Implémentation de votre API Smithy

### Définition d'opérations dans Smithy

Les opérations sont définies dans des fichiers Smithy au sein du projet de modèle. La définition principale du service se trouve dans `main.smithy` :

```smithy
$version: "2.0"

namespace your.namespace

use aws.protocols#restJson1
use smithy.framework#ValidationException

@title("YourService")
@restJson1
service YourService {
    version: "1.0.0"
    operations: [
        Echo,
        // Ajoutez vos opérations ici
    ]
    errors: [
        ValidationException
    ]
}
```

Les opérations individuelles sont définies dans des fichiers séparés dans le répertoire `operations/` :

```smithy
$version: "2.0"

namespace your.namespace

@http(method: "POST", uri: "/echo")
operation Echo {
    input: EchoInput
    output: EchoOutput
}

structure EchoInput {
    @required
    message: String

    foo: Integer
    bar: String
}

structure EchoOutput {
    @required
    message: String
}
```

:::note
Vous pouvez modifier la structure des dossiers comme vous le souhaitez - tous les fichiers `.smithy` dans le dossier `src` seront inclus dans le build Smithy.
:::

:::tip
Pour plus de détails sur Smithy et sa syntaxe, consultez la [spécification Smithy](https://smithy.io/2.0/spec/index.html).
:::

### Implémentation des opérations en TypeScript

Les implémentations d'opérations se trouvent dans le répertoire `src/operations/` du projet backend. Chaque opération est implémentée en utilisant les types générés par le SDK serveur TypeScript (généré au moment du build à partir de votre modèle Smithy).

```typescript
import { ServiceContext } from '../context.js';
import { Echo as EchoOperation } from '../generated/ssdk/index.js';

export const Echo: EchoOperation<ServiceContext> = async (input) => {
  // Votre logique métier ici
  return {
    message: `Echo: ${input.message}` // fortement typé selon votre modèle Smithy
  };
};
```

Les opérations doivent être enregistrées dans la définition du service dans `src/service.ts` :

```typescript
import { ServiceContext } from './context.js';
import { YourServiceService } from './generated/ssdk/index.js';
import { Echo } from './operations/echo.js';
// Importez d'autres opérations ici

// Enregistrez les opérations dans le service ici
export const Service: YourServiceService<ServiceContext> = {
  Echo,
  // Ajoutez d'autres opérations ici
};
```

### Contexte du service

Vous pouvez définir un contexte partagé pour vos opérations dans `context.ts` :

```typescript
export interface ServiceContext {
  // Tracer, logger et metrics Powertools sont fournis par défaut
  tracer: Tracer;
  logger: Logger;
  metrics: Metrics;
  // Ajoutez des dépendances partagées, connexions DB, etc.
  dbClient: any;
  userIdentity: string;
}
```

Ce contexte est passé à toutes les implémentations d'opérations et peut être utilisé pour partager des ressources comme des connexions de base de données, de la configuration ou des utilitaires de journalisation.

:::caution
Vous devez construire le contexte vous-même dans `handler.ts` (point d'entrée Lambda) et `local-server.ts` (point d'entrée pour l'exécution locale via la cible `serve`).
:::

### Observabilité avec AWS Lambda Powertools

#### Journalisation

Le générateur configure la journalisation structurée avec AWS Lambda Powertools et l'injection automatique de contexte via un middleware Middy.

```typescript {4}
// handler.ts
export const handler = middy<APIGatewayProxyEvent, APIGatewayProxyResult>()
  .use(captureLambdaHandler(tracer))
  .use(injectLambdaContext(logger))
  .use(logMetrics(metrics))
  .handler(lambdaHandler);
```

Vous pouvez accéder au logger depuis vos implémentations d'opérations via le contexte :

```typescript {6}
// operations/echo.ts
import { ServiceContext } from '../context.js';
import { Echo as EchoOperation } from '../generated/ssdk/index.js';

export const Echo: EchoOperation<ServiceContext> = async (input, ctx) => {
  ctx.logger.info('Votre message de log');
  // ...
};
```

#### Traçage

Le traçage AWS X-Ray est configuré automatiquement via le middleware `captureLambdaHandler`.

```typescript {3}
// handler.ts
export const handler = middy<APIGatewayProxyEvent, APIGatewayProxyResult>()
  .use(captureLambdaHandler(tracer))
  .use(injectLambdaContext(logger))
  .use(logMetrics(metrics))
  .handler(lambdaHandler);
```

Vous pouvez ajouter des sous-segments personnalisés à vos traces dans vos opérations :

```typescript {7, 11, 14}
// operations/echo.ts
import { ServiceContext } from '../context.js';
import { Echo as EchoOperation } from '../generated/ssdk/index.js';

export const Echo: EchoOperation<ServiceContext> = async (input, ctx) => {
  // Crée un nouveau sous-segment
  const subsegment = ctx.tracer.getSegment()?.addNewSubsegment('custom-operation');
  try {
    // Votre logique ici
  } catch (error) {
    subsegment?.addError(error as Error);
    throw error;
  } finally {
    subsegment?.close();
  }
};
```

#### Métriques

Les métriques CloudWatch sont collectées automatiquement pour chaque requête via le middleware `logMetrics`.

```typescript {5}
// handler.ts
export const handler = middy<APIGatewayProxyEvent, APIGatewayProxyResult>()
  .use(captureLambdaHandler(tracer))
  .use(injectLambdaContext(logger))
  .use(logMetrics(metrics))
  .handler(lambdaHandler);
```

Vous pouvez ajouter des métriques personnalisées dans vos opérations :

```typescript {7}
// operations/echo.ts
import { MetricUnit } from '@aws-lambda-powertools/metrics';
import { ServiceContext } from '../context.js';
import { Echo as EchoOperation } from '../generated/ssdk/index.js';

export const Echo: EchoOperation<ServiceContext> = async (input, ctx) => {
  ctx.metrics.addMetric("CustomMetric", MetricUnit.Count, 1);
  // ...
};
```

### Gestion des erreurs

Smithy fournit une gestion d'erreurs intégrée. Vous pouvez définir des erreurs personnalisées dans votre modèle Smithy :

```smithy
@error("client")
@httpError(400)
structure InvalidRequestError {
    @required
    message: String
}
```

Et les enregistrer dans votre opération/service :

```smithy
operation MyOperation {
  ...
  errors: [InvalidRequestError]
}
```

Puis les lever dans votre implémentation TypeScript :

```typescript
import { InvalidRequestError } from '../generated/ssdk/index.js';

export const MyOperation: MyOperationHandler<ServiceContext> = async (input) => {
  if (!input.requiredField) {
    throw new InvalidRequestError({
      message: "Champ requis manquant"
    });
  }

  return { /* réponse de succès */ };
};
```

## Build et génération de code

Le projet de modèle Smithy utilise [Docker](https://www.docker.com/) pour construire les artefacts Smithy et générer le SDK serveur TypeScript :

<NxCommands commands={['run <model-project>:build']} />

Ce processus :

1. **Compile le modèle Smithy** et le valide
2. **Génère une spécification OpenAPI** à partir du modèle Smithy
3. **Crée le SDK serveur TypeScript** avec des interfaces d'opération fortement typées
4. **Produit les artefacts de build** dans `dist/<model-project>/build/`

Le projet backend copie automatiquement le SDK généré pendant la compilation :

<NxCommands commands={['run <backend-project>:copy-ssdk']} />

### Cible de bundle

<Snippet name="ts-bundle" />

## Développement local

Le générateur configure un serveur de développement local avec rechargement à chaud :

<NxCommands commands={['run <backend-project>:serve']} />

:::tip
Le serveur local recharge non seulement les modifications TypeScript de votre code backend, mais aussi les changements dans votre projet de modèle Smithy, vous permettant d'itérer simultanément sur votre modèle Smithy et votre serveur.
:::

## Déploiement de votre API Smithy

Le générateur crée une infrastructure CDK ou Terraform selon votre choix de `iacProvider`.

<Infrastructure>
<Fragment slot="cdk">
Le construct CDK pour déployer votre API se trouve dans le dossier `common/constructs` :

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    // Ajoutez l'API à votre stack
    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
    });
  }
}
```

Ceci configure :

1. Une fonction AWS Lambda pour le service Smithy
2. Une API REST API Gateway comme déclencheur
3. Les rôles et permissions IAM
4. Un groupe de logs CloudWatch
5. La configuration de traçage X-Ray

<Snippet name="api/cors-configuration-cdk-note" />

:::note
Si vous avez sélectionné l'authentification `Cognito`, vous devrez fournir la propriété `identity` au construct API :

```ts {9}
import { MyApi, UserIdentity } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const identity = new UserIdentity(this, 'Identity');

    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
      identity,
    });
  }
}
```

Le construct `UserIdentity` peut être généré avec le générateur <Link path="/guides/react-website-auth">`ts#react-website-auth`</Link>
:::
</Fragment>
<Fragment slot="terraform">
Les modules Terraform pour déployer votre API se trouvent dans le dossier `common/terraform` :

```hcl {2}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Variables d'environnement pour la fonction Lambda
  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  # Politiques IAM supplémentaires si nécessaire
  additional_iam_policy_statements = [
    # Ajoutez les permissions supplémentaires nécessaires
  ]

  tags = local.common_tags
}
```

Ceci configure :

1. Une fonction AWS Lambda servant l'API Smithy
2. Une API REST API Gateway comme déclencheur
3. Les rôles et permissions IAM
4. Un groupe de logs CloudWatch
5. La configuration de traçage X-Ray
6. La configuration CORS

<Snippet name="api/cors-configuration-terraform-note" />

:::note
Si vous avez sélectionné l'authentification `Cognito`, vous devrez fournir la configuration Cognito :

```hcl {4-5}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  user_pool_id         = local.user_pool_id
  user_pool_client_ids = [local.client_id]

  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  tags = local.common_tags
}
```
:::

Le module Terraform fournit plusieurs sorties :

```hcl
# Accéder à l'URL de l'API
output "api_url" {
  value = module.my_api.stage_invoke_url
}

# Accéder aux détails de la fonction Lambda
output "lambda_function_name" {
  value = module.my_api.lambda_function_name
}
```
</Fragment>
</Infrastructure>

### Intégrations

<Snippet name="api/type-safe-api-integrations" parentHeading="Intégrations" />

#### Génération de code

<Infrastructure>
<Fragment slot="cdk">
Comme les opérations sont définies dans Smithy, nous utilisons la génération de code pour fournir des métadonnées au construct CDK pour des intégrations fortement typées.

Une cible `generate:<ApiName>-metadata` est ajoutée au `project.json` des constructs communs pour faciliter cette génération, produisant un fichier comme `packages/common/constructs/src/generated/my-api/metadata.gen.ts`. Ce fichier étant généré au build, il est ignoré dans le contrôle de version.

:::note
Vous devrez exécuter un build après chaque modification de votre modèle Smithy pour maintenir les types consommés par le construct CDK à jour.

<NxCommands commands={["run-many --target build --all"]} />
:::

:::tip
Si vous travaillez simultanément sur l'infrastructure CDK et l'API Smithy, vous pouvez utiliser [`nx watch`](https://nx.dev/nx-api/nx/documents/watch) pour régénérer ces types à chaque modification :

<NxCommands
  commands={[
    'watch --projects=<ModelProject> -- \\ ',
    'run <InfraProject>:"generate:<ApiName>-metadata"',
  ]}
/>
:::
</Fragment>
<Fragment slot="terraform">
:::note
Nous ne prenons pas en charge les intégrations fortement typées pour Terraform, donc aucune cible de génération de code n'est configurée si vous avez choisi Terraform comme `iacProvider`.
:::
</Fragment>
</Infrastructure>

### Octroi d'accès (IAM uniquement)

Si vous avez sélectionné l'authentification `IAM`, vous pouvez utiliser la méthode `grantInvokeAccess` pour accorder l'accès à votre API :

<Infrastructure>
<Fragment slot="cdk">
```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```
</Fragment>
<Fragment slot="terraform">
```hcl
# Créer une politique IAM pour autoriser l'appel de l'API
resource "aws_iam_policy" "api_invoke_policy" {
  name        = "MyApiInvokePolicy"
  description = "Politique permettant d'invoquer l'API Smithy"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = "execute-api:Invoke"
        Resource = "${module.my_api.api_execution_arn}/*/*"
      }
    ]
  })
}

# Attacher la politique à un rôle IAM
resource "aws_iam_role_policy_attachment" "api_invoke_access" {
  role       = aws_iam_role.authenticated_user_role.name
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}
```
</Fragment>
</Infrastructure>

## Invocation de votre API Smithy

Pour invoquer votre API depuis un site React, vous pouvez utiliser le générateur <Link path="guides/connection/react-smithy">`connection`</Link>, qui fournit un client fortement typé généré à partir de votre modèle Smithy.