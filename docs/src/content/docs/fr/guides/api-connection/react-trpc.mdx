---
title: "Réagir à tRPC"
description: "Connecter un site web React à une API tRPC"
---



import { FileTree } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';

Le plugin AWS pour Nx fournit un générateur pour intégrer rapidement votre <Link path="guides/trpc">API tRPC</Link> avec un site React. Il configure tous les éléments nécessaires pour connecter vos backends tRPC, incluant le support d'authentification AWS IAM et une gestion d'erreurs appropriée. Cette intégration offre une sécurité de type de bout en bout entre votre frontend et vos backends tRPC.

## Prérequis

Avant d'utiliser ce générateur, assurez-vous que votre application React possède :

1. Un fichier `main.tsx` qui rend votre application
2. Un élément JSX `<App/>` où le provider tRPC sera injecté automatiquement
3. Un backend tRPC fonctionnel (généré via le générateur de backend tRPC)

<details>
<summary>Exemple de structure requise pour `main.tsx`</summary>

```tsx
import { StrictMode } from 'react';
import * as ReactDOM from 'react-dom/client';
import App from './app/app';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement,
);
root.render(
  <StrictMode>
    <App />
  </StrictMode>,
);
```

</details>

## Utilisation

### Exécuter le générateur

<RunGenerator generator="api-connection" />

### Options

<GeneratorParameters generator="api-connection" />

## Résultat du générateur

Le générateur crée la structure suivante dans votre application React :

<FileTree>

- src
  - components
    - TrpcClients
      - index.tsx
      - TrpcProvider.tsx Provider réutilisable pour plusieurs APIs tRPC
      - TrpcApis.tsx Objet contenant toutes vos connexions d'API tRPC
      - TrpcClientProviders.tsx Configure les clients tRPC et les liaisons avec vos schémas backend
    - QueryClientProvider.tsx Provider du client TanStack React Query
  - hooks
    - useSigV4.tsx Hook pour signer les requêtes HTTP avec SigV4 (IAM uniquement)
    - use\<ApiName>.tsx Hook dédié à l'API backend spécifiée. ApiName correspond au nom de l'API

</FileTree>

Le générateur installe également les dépendances requises :

  - `@trpc/client`
  - `@trpc/tanstack-react-query`
  - `@tanstack/react-query`
  - `aws4fetch` (si utilisation de l'authentification IAM)

## Utilisation du code généré

### Utilisation du hook tRPC

Le générateur fournit un hook `use<ApiName>` donnant accès au client tRPC typé :

```tsx {5,8,11}
import { useQuery, useMutation } from '@tanstack/react-query';
import { useMyApi } from './hooks/useMyApi';

function MyComponent() {
  const trpc = useMyApi();

  // Exemple de query
  const { data, isLoading, error } = useQuery(trpc.users.list.queryOptions());

  // Exemple de mutation
  const mutation = useMutation(trpc.users.create.mutationOptions());

  const handleCreate = () => {
    mutation.mutate({
      name: 'John Doe',
      email: 'john@example.com',
    });
  };

  if (isLoading) return <div>Loading...</div>;

  return (
    <ul>
      {data.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

### Gestion des erreurs

L'intégration inclut une gestion d'erreurs prête à l'emploi :

```tsx {4, 6}
function MyComponent() {
  const trpc = useMyApi();

  const { data, error } = useQuery(trpc.users.list.queryOptions());

  if (error) {
    return (
      <div>
        <h2>Erreur :</h2>
        <p>{error.message}</p>
        {error.data?.code && <p>Code : {error.data.code}</p>}
      </div>
    );
  }

  return (
    <ul>
      {data.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

## Bonnes pratiques

### Gestion des états de chargement

Toujours gérer les états de chargement et d'erreur pour une meilleure expérience utilisateur :

```tsx {6}
function UserList() {
  const trpc = useMyApi();

  const users = useQuery(trpc.users.list.queryOptions());

  if (users.isLoading) {
    return <LoadingSpinner />;
  }

  if (users.error) {
    return <ErrorMessage error={users.error} />;
  }

  return (
    <ul>
      {users.data.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

### Mises à jour optimistes

Utilisez les mises à jour optimistes pour améliorer l'expérience utilisateur :

```tsx {15-17,20-22,28-31}
import { useQueryClient, useQuery, useMutation } from '@tanstack/react-query';

function UserList() {
  const trpc = useMyApi();
  const users = useQuery(trpc.users.list.queryOptions());
  const queryClient = useQueryClient();

  const deleteMutation = useMutation(
    trpc.users.delete.mutationOptions({
      onMutate: async (userId) => {
        // Annule les requêtes en cours
        await queryClient.cancelQueries(trpc.users.list.queryFilter());

        // Capture l'état actuel
        const previousUsers = queryClient.getQueryData(
          trpc.users.list.queryKey(),
        );

        // Suppression optimiste
        queryClient.setQueryData(trpc.users.list.queryKey(), (old) =>
          old?.filter((user) => user.id !== userId),
        );

        return { previousUsers };
      },
      onError: (err, userId, context) => {
        // Restaure les données précédentes en cas d'erreur
        queryClient.setQueryData(
          trpc.users.list.queryKey(),
          context?.previousUsers,
        );
      },
    }),
  );

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>
          {user.name}
          <button onClick={() => deleteMutation.mutate(user.id)}>Supprimer</button>
        </li>
      ))}
    </ul>
  );
}
```

### Préchargement des données

Préchargez les données pour améliorer les performances :

```tsx {8}
function UserList() {
  const trpc = useMyApi();
  const users = useQuery(trpc.users.list.queryOptions());
  const queryClient = useQueryClient();

  // Précharge les détails au survol
  const prefetchUser = async (userId: string) => {
    await queryClient.prefetchQuery(trpc.users.getById.queryOptions(userId));
  };

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id} onMouseEnter={() => prefetchUser(user.id)}>
          <Link to={`/users/${user.id}`}>{user.name}</Link>
        </li>
      ))}
    </ul>
  );
}
```

### Requêtes infinies

Gérez la pagination avec les requêtes infinies :

```tsx {5-12}
function UserList() {
  const trpc = useMyApi();

  const { data, fetchNextPage, hasNextPage, isFetchingNextPage } =
    useInfiniteQuery(
      trpc.users.list.infiniteQueryOptions(
        { limit: 10 },
        {
          getNextPageParam: (lastPage) => lastPage.nextCursor,
        },
      ),
    );

  return (
    <div>
      {data?.pages.map((page) =>
        page.users.map((user) => <UserCard key={user.id} user={user} />),
      )}

      {hasNextPage && (
        <button onClick={() => fetchNextPage()} disabled={isFetchingNextPage}>
          {isFetchingNextPage ? 'Chargement...' : 'Charger plus'}
        </button>
      )}
    </div>
  );
}
```

Notez que les requêtes infinies ne peuvent être utilisées qu'avec des procédures possédant une propriété d'entrée nommée `cursor`.

## Sécurité de type

L'intégration fournit une sécurité de type complète de bout en bout. Votre IDE offrira l'autocomplétion et la vérification de types pour tous vos appels d'API :

```tsx
function UserForm() {
  const trpc = useMyApi();

  // ✅ L'entrée est parfaitement typée
  const createUser = trpc.users.create.useMutation();

  const handleSubmit = (data: CreateUserInput) => {
    // ✅ Erreur de type si l'entrée ne correspond pas au schéma
    createUser.mutate(data);
  };

  return <form onSubmit={handleSubmit}>{/* ... */}</form>;
}
```

Les types sont automatiquement inférés depuis les définitions de votre routeur backend, garantissant que tout changement d'API est immédiatement reflété dans votre frontend sans nécessiter de build.

## Informations complémentaires

Pour plus d'informations, consultez la [documentation tRPC TanStack React Query](https://trpc.io/docs/client/tanstack-react-query/usage).

Vous pouvez également consulter directement la [documentation TanStack Query](https://tanstack.com/query/v5).