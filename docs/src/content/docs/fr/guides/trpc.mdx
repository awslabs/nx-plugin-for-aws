---
title: "tRPC"
description: "Documentation de référence pour tRPC"
---



import { FileTree, Tabs, TabItem } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Snippet from '@components/snippet.astro';
import schema from '../../../../../../packages/nx-plugin/src/trpc/backend/schema.json';

[tRPC](https://trpc.io/) est un framework pour construire des APIs en TypeScript avec une sécurité de typage de bout en bout. Avec tRPC, les mises à jour des entrées et sorties des opérations de l'API sont immédiatement reflétées dans le code client et visibles dans votre IDE sans avoir à reconstruire votre projet.

Le générateur d'API tRPC crée une nouvelle API tRPC avec une infrastructure AWS CDK configurée. Le backend généré utilise AWS Lambda pour un déploiement serverless et inclut une validation de schéma via [Zod](https://zod.dev/). Il configure [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/) pour l'observabilité, incluant la journalisation, le tracing AWS X-Ray et les métriques CloudWatch.

## Utilisation

### Générer une API tRPC

Vous pouvez générer une nouvelle API tRPC de deux manières :

<RunGenerator generator="ts#trpc-api" />

### Options

<GeneratorParameters schema={schema} />

<Snippet name="api/api-choice-note" />

## Sortie du générateur

Le générateur créera la structure de projet suivante dans le répertoire `<directory>/<api-name>` :

<FileTree>
  - schema
    - src
      - index.ts Point d'entrée du schéma
      - procedures
        - echo.ts Définitions de schéma partagées pour la procédure "echo", utilisant Zod
    - tsconfig.json Configuration TypeScript  
    - project.json Configuration du projet et cibles de build
  - backend
    - src
      - init.ts Initialisation tRPC du backend
      - router.ts Définition du routeur tRPC (point d'entrée de l'API du gestionnaire Lambda)
      - procedures Procédures (ou opérations) exposées par votre API
        - echo.ts Exemple de procédure
      - middleware
        - error.ts Middleware de gestion d'erreurs
        - logger.ts Middleware pour configurer AWS Powertools pour la journalisation Lambda
        - tracer.ts Middleware pour configurer AWS Powertools pour le tracing Lambda  
        - metrics.ts Middleware pour configurer AWS Powertools pour les métriques Lambda
      - local-server.ts Point d'entrée de l'adaptateur standalone tRPC pour le serveur de développement local
      - client
        - index.ts Client typé pour les appels API machine-à-machine
    - tsconfig.json Configuration TypeScript
    - project.json Configuration du projet et cibles de build
</FileTree>

Le générateur créera également des constructs CDK utilisables pour déployer votre API, situés dans le répertoire `packages/common/constructs`.

## Implémentation de votre API tRPC

Comme vu ci-dessus, une API tRPC comporte deux composants principaux, [`schema`](#schema) et [`backend`](#backend), définis comme des packages distincts dans votre espace de travail.

:::tip
`schema` et `backend` sont tous deux des projets TypeScript. Vous pouvez donc consulter la <Link path="guides/typescript-project">documentation des projets TypeScript</Link> pour plus de détails sur leur utilisation générale.
:::

### Schema

Le package schema définit les types partagés entre votre code client et serveur. Ces types sont définis en utilisant [Zod](https://zod.dev/), une bibliothèque de déclaration et validation de schémas orientée TypeScript.

Un exemple de schéma pourrait ressembler à ceci :

```ts
import { z } from 'zod';

// Définition du schéma
export const UserSchema = z.object({
  name: z.string(),
  height: z.number(),
  dateOfBirth: z.string().datetime(),
});

// Type TypeScript correspondant
export type User = z.TypeOf<typeof UserSchema>;
```

Avec le schéma ci-dessus, le type `User` est équivalent au TypeScript suivant :

```ts
interface User {
  name: string;
  height: number;
  dateOfBirth: string;
}
```

Les schémas sont partagés entre le code serveur et client, fournissant un seul endroit à modifier pour les structures utilisées dans votre API.

Les schémas sont automatiquement validés par votre API tRPC à l'exécution, évitant d'avoir à écrire manuellement une logique de validation dans le backend.

Zod fournit des utilitaires puissants pour combiner ou dériver des schémas comme `.merge`, `.pick`, `.omit` et plus encore. Vous trouverez plus d'informations sur le [site de documentation Zod](https://zod.dev/?id=basic-usage).

### Backend

Le dossier `backend` contient l'implémentation de votre API, où vous définissez les opérations et leurs entrées, sorties et implémentations.

Le point d'entrée de votre API se trouve dans `src/router.ts`. Ce fichier contient le gestionnaire Lambda qui route les requêtes vers les "procédures" selon l'opération invoquée. Chaque procédure définit l'entrée attendue, la sortie et l'implémentation.

Le routeur généré comme exemple contient une seule opération appelée `echo` :

```ts
import { echo } from './procedures/echo.js';

export const appRouter = router({
  echo,
});
```

La procédure `echo` exemple est générée dans `src/procedures/echo.ts` :

```ts
export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Décomposons ce code :

- `publicProcedure` définit une méthode publique de l'API, incluant le middleware configuré dans `src/middleware`. Ce middleware inclut l'intégration d'AWS Lambda Powertools pour la journalisation, le tracing et les métriques.
- `input` accepte un schéma Zod définissant l'entrée attendue pour l'opération. Les requêtes pour cette opération sont automatiquement validées contre ce schéma.
- `output` accepte un schéma Zod définissant la sortie attendue. Vous verrez des erreurs de type dans votre implémentation si vous ne retournez pas une sortie conforme.
- `query` accepte une fonction définissant l'implémentation de l'API. Cette implémentation reçoit `opts`, qui contient l'`input` passé à l'opération, ainsi que le contexte configuré par le middleware, disponible dans `opts.ctx`. La fonction doit retourner une sortie conforme au schéma `output`.

L'utilisation de `query` indique que l'opération est non mutation. Utilisez-le pour des méthodes de récupération de données. Pour une opération mutation, utilisez plutôt `mutation`.

Si vous ajoutez une nouvelle opération, assurez-vous de l'enregistrer dans le routeur dans `src/router.ts`.

## Personnalisation de votre API tRPC

### Gestion des erreurs

Dans votre implémentation, vous pouvez retourner des erreurs aux clients en lançant une `TRPCError`. Elles acceptent un `code` indiquant le type d'erreur, par exemple :

```ts
throw new TRPCError({
  code: 'NOT_FOUND',
  message: 'La ressource demandée est introuvable',
});
```

### Organisation des opérations

Si votre API grandit, vous pouvez regrouper des opérations liées.

Utilisez des routeurs imbriqués pour grouper des opérations, par exemple :

```ts
import { getUser } from './procedures/users/get.js';
import { listUsers } from './procedures/users/list.js';

const appRouter = router({
   users: router({
      get: getUser,
      list: listUsers,
   }),
   ...
})
```

Les clients verront alors ce regroupement, par exemple invoquer `listUsers` ressemblera à :

```ts
client.users.list.query();
```

### Journalisation

Le logger AWS Lambda Powertools est configuré dans `src/middleware/logger.ts`, et accessible dans une implémentation via `opts.ctx.logger`. Utilisez-le pour journaliser dans CloudWatch Logs et contrôler les valeurs supplémentaires incluses dans chaque message de log structuré. Exemple :

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.logger.info('Opération appelée avec input', opts.input);

      return ...;
   });
```

Pour plus d'informations, consultez la [documentation AWS Lambda Powertools Logger](https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/).

### Enregistrement de métriques

Les métriques AWS Lambda Powertools sont configurées dans `src/middleware/metrics.ts`, et accessibles via `opts.ctx.metrics`. Utilisez-les pour enregistrer des métriques dans CloudWatch sans utiliser le SDK AWS, par exemple :

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.metrics.addMetric('Invocations', 'Count', 1);

      return ...;
   });
```

Plus d'informations dans la [documentation AWS Lambda Powertools Metrics](https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/).

### Ajustement du tracing X-Ray

Le tracer AWS Lambda Powertools est configuré dans `src/middleware/tracer.ts`, et accessible via `opts.ctx.tracer`. Utilisez-le pour ajouter des traces AWS X-Ray afin d'obtenir des insights détaillés sur les performances et le flux des requêtes. Exemple :

```ts {5-7}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      const subSegment = opts.ctx.tracer.getSegment()!.addNewSubsegment('MyAlgorithm');
      // ... logique de l'algorithme à tracer
      subSegment.close();

      return ...;
   });
```

Référez-vous à la [documentation AWS Lambda Powertools Tracer](https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/).

### Implémentation de middleware personnalisé

Vous pouvez ajouter des valeurs personnalisées au contexte des procédures en implémentant du middleware.

Prenons l'exemple d'un middleware pour extraire des détails sur l'utilisateur appelant depuis Cognito dans `src/middleware/identity.ts`.

D'abord, définissons ce que nous ajoutons au contexte :

```ts
export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}
```

Notez que nous définissons une propriété _optionnelle_. tRPC s'assure qu'elle est définie dans les procédures utilisant ce middleware.

Implémentons ensuite le middleware :

```ts
export const createIdentityPlugin = () => {
   const t = initTRPC.context<...>().create();
   return t.procedure.use(async (opts) => {
      // Logique exécutée avant la procédure

      const response = await opts.next(...);

      // Logique exécutée après la procédure

      return response;
   });
};
```

Dans notre cas, nous voulons extraire les détails de l'utilisateur Cognito. L'implémentation varie selon que l'événement provient d'une API REST ou HTTP :

<Tabs>
<TabItem label="REST">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEvent } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEvent>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoAuthenticationProvider = opts.ctx.event.requestContext?.identity?.cognitoAuthenticationProvider;

    let sub: string | undefined = undefined;
    if (cognitoAuthenticationProvider) {
      const providerParts = cognitoAuthenticationProvider.split(':');
      sub = providerParts[providerParts.length - 1];
    }

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `Unable to determine calling user`,
      });
    }

    const { Users } = await cognito.listUsers({
      // Suppose que l'ID du pool utilisateur est configuré dans l'environnement Lambda
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `No user found with subjectId ${sub}`,
      });
    }

    // Fournit l'identité au contexte des autres procédures
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
<TabItem label="HTTP">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoIdentity = opts.ctx.event.requestContext?.authorizer?.iam
      ?.cognitoIdentity as unknown as
      | {
          amr: string[];
        }
      | undefined;

    const sub = (cognitoIdentity?.amr ?? [])
      .flatMap((s) => (s.includes(':CognitoSignIn:') ? [s] : []))
      .map((s) => {
        const parts = s.split(':');
        return parts[parts.length - 1];
      })?.[0];

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `Unable to determine calling user`,
      });
    }

    const { Users } = await cognito.listUsers({
      // Suppose que l'ID du pool utilisateur est configuré dans l'environnement Lambda
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `No user found with subjectId ${sub}`,
      });
    }

    // Fournit l'identité au contexte des autres procédures
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
</Tabs>

## Déploiement de votre API tRPC

Le générateur crée un construct CDK pour déployer votre API dans `common/constructs`. Utilisez-le dans une application CDK :

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs`;

export class ExampleStack extends Stack {
   constructor(scope: Construct, id: string) {
      // Ajoute l'API à votre stack
      const api = new MyApi(this, 'MyApi', {
        integrations: MyApi.defaultIntegrations(this).build(),
      });
   }
}
```

Ceci configure l'infrastructure API, incluant une API Gateway REST/HTTP, des fonctions Lambda et l'authentification IAM.

### Intégrations type-safe

<Snippet name="api/type-safe-api-integrations" />

:::tip
Les ajouts/suppressions de procédures dans votre API tRPC sont immédiatement reflétés dans le construct CDK sans reconstruction.
:::

### Octroi d'accès

Utilisez `grantInvokeAccess` pour octroyer l'accès à votre API. Par exemple, pour accorder l'accès aux utilisateurs Cognito authentifiés :

```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```

## Serveur tRPC local

Utilisez la cible `serve` pour exécuter un serveur local :

<NxCommands commands={['run @my-scope/my-api-backend:serve']} />

Le point d'entrée du serveur local est `src/local-server.ts`.

## Invocation de votre API tRPC

Créez un client tRPC pour appeler votre API de manière type-safe. Pour des appels depuis un autre backend, utilisez le client dans `src/client/index.ts` :

```ts
import { createMyApiClient } from ':my-scope/my-api-backend';

const client = createMyApiClient({ url: 'https://my-api-url.example.com/' });

await client.echo.query({ message: 'Hello world!' });
```

Pour un appel depuis un site React, utilisez le générateur <Link path="guides/api-connection/react-trpc">API Connection</Link>.

## Plus d'informations

Consultez la [documentation tRPC](https://trpc.io/docs) pour en savoir plus.