---
title: "tRPC"
description: "Documentation de référence pour tRPC"
---



import { FileTree, Tabs, TabItem } from '@astrojs/starlight/components';
import AnchorHeading from '@astrojs/starlight/components/AnchorHeading.astro';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Snippet from '@components/snippet.astro';

<<<<<<< HEAD
[tRPC](https://trpc.io/) est un framework pour construire des APIs en TypeScript avec une sécurité typographique de bout en bout. Avec tRPC, les mises à jour des entrées et sorties des opérations d'API sont immédiatement reflétées dans le code client et visibles dans votre IDE sans avoir à reconstruire votre projet.
=======
[tRPC](https://trpc.io/) est un framework pour construire des APIs en TypeScript avec une sécurité de type de bout en bout. Avec tRPC, les mises à jour des entrées et sorties des opérations de l'API sont immédiatement reflétées dans le code client et visibles dans votre IDE sans avoir à reconstruire votre projet.
>>>>>>> c5375c6 (docs: update translations)

Le générateur d'API tRPC crée une nouvelle API tRPC avec une infrastructure AWS CDK configurée. Le backend généré utilise AWS Lambda pour un déploiement serverless et inclut une validation de schéma via [Zod](https://zod.dev/). Il configure [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/) pour l'observabilité, incluant le logging, le tracing AWS X-Ray et les métriques CloudWatch.

## Utilisation

### Générer une API tRPC

Vous pouvez générer une nouvelle API tRPC de deux manières :

<RunGenerator generator="ts#trpc-api" />

### Options

<GeneratorParameters generator="ts#trpc-api" />

<Snippet name="api/api-choice-note" />

## Résultat du générateur

Le générateur créera la structure de projet suivante dans le répertoire `<directory>/<api-name>` :

<FileTree>
  - src
    - init.ts Initialisation du backend tRPC
<<<<<<< HEAD
    - router.ts Définition du routeur tRPC (point d'entrée de l'API via le handler Lambda)
=======
    - router.ts Définition du routeur tRPC (point d'entrée de l'API pour le handler Lambda)
>>>>>>> c5375c6 (docs: update translations)
    - schema Définitions de schémas avec Zod
      - echo.ts Exemple de définitions pour l'entrée et la sortie de la procédure "echo"
    - procedures Procédures (ou opérations) exposées par votre API
      - echo.ts Exemple de procédure
    - middleware
<<<<<<< HEAD
      - error.ts Middleware de gestion d'erreurs
      - logger.ts Middleware de configuration de AWS Powertools pour le logging Lambda
      - tracer.ts Middleware de configuration de AWS Powertools pour le tracing Lambda
      - metrics.ts Middleware de configuration de AWS Powertools pour les métriques Lambda
=======
      - error.ts Middleware pour la gestion d'erreurs
      - logger.ts Middleware pour configurer AWS Powertools pour le logging Lambda
      - tracer.ts Middleware pour configurer AWS Powertools pour le tracing Lambda
      - metrics.ts Middleware pour configurer AWS Powertools pour les métriques Lambda
>>>>>>> c5375c6 (docs: update translations)
    - local-server.ts Point d'entrée de l'adaptateur standalone tRPC pour le serveur de développement local
    - client
      - index.ts Client typé pour les appels API machine-à-machine
  - tsconfig.json Configuration TypeScript
  - project.json Configuration du projet et cibles de build
</FileTree>

Le générateur créera également des constructs CDK pour déployer votre API, situés dans le répertoire `packages/common/constructs`.

## Implémentation de votre API tRPC

Globalement, les APIs tRPC consistent en un routeur qui délègue les requêtes à des procédures spécifiques. Chaque procédure possède une entrée et une sortie définies par un schéma Zod.

### Schéma

Le répertoire `src/schema` contient les types partagés entre votre code client et serveur. Ces types sont définis avec [Zod](https://zod.dev/), une bibliothèque de déclaration et validation de schémas orientée TypeScript.
<<<<<<< HEAD
=======

:::note
Un alias est ajouté dans `tsconfig.base.json` à la racine de votre monorepo pour résoudre Zod vers la [version 4.x](https://zod.dev/v4). Cela permet une mise à jour future vers Zod v4 sur NPM sans modifier les chemins d'import.
:::
>>>>>>> c5375c6 (docs: update translations)

Un exemple de schéma pourrait ressembler à ceci :

```ts
import { z } from 'zod/v4';

// Définition du schéma
export const UserSchema = z.object({
  name: z.string(),
  height: z.number(),
  dateOfBirth: z.string().datetime(),
});

// Type TypeScript correspondant
export type User = z.TypeOf<typeof UserSchema>;
```

<<<<<<< HEAD
Avec ce schéma, le type `User` est équivalent au TypeScript suivant :
=======
Avec ce schéma, le type `User` est équivalent à :
>>>>>>> c5375c6 (docs: update translations)

```ts
interface User {
  name: string;
  height: number;
  dateOfBirth: string;
}
```

<<<<<<< HEAD
Les schémas sont partagés entre le code client et serveur, offrant un point unique de modification pour les structures utilisées dans votre API.
=======
Les schémas sont partagés entre le code client et serveur, offrant un seul endroit à modifier pour changer les structures utilisées dans votre API.
>>>>>>> c5375c6 (docs: update translations)

Les schémas sont automatiquement validés par votre API tRPC à l'exécution, évitant d'écrire manuellement une logique de validation personnalisée.

Zod fournit des utilitaires puissants pour combiner ou dériver des schémas comme `.merge`, `.pick`, `.omit` et plus encore. Plus d'informations sur le [site de documentation Zod](https://zod.dev/?id=basic-usage).

### Routeur et Procédures

<<<<<<< HEAD
Le point d'entrée de votre API se trouve dans `src/router.ts`. Ce fichier contient le handler Lambda qui route les requêtes vers des "procédures" selon l'opération invoquée. Chaque procédure définit l'entrée attendue, la sortie et l'implémentation.
=======
Le point d'entrée de votre API se trouve dans `src/router.ts`. Ce fichier contient le handler Lambda qui achemine les requêtes vers des "procédures" basées sur l'opération invoquée. Chaque procédure définit l'entrée attendue, la sortie et l'implémentation.
>>>>>>> c5375c6 (docs: update translations)

Le routeur généré en exemple possède une seule opération appelée `echo` :

```ts
import { echo } from './procedures/echo.js';

export const appRouter = router({
  echo,
});
```

La procédure `echo` exemple est générée dans `src/procedures/echo.ts` :

```ts
export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Décomposons ce code :

- `publicProcedure` définit une méthode publique de l'API, incluant le middleware configuré dans `src/middleware`. Ce middleware inclut l'intégration AWS Lambda Powertools pour le logging, tracing et les métriques.
<<<<<<< HEAD
- `input` accepte un schéma Zod définissant l'entrée attendue. Les requêtes pour cette opération sont automatiquement validées contre ce schéma.
- `output` accepte un schéma Zod définissant la sortie attendue. Des erreurs de type apparaîtront si l'implémentation ne retourne pas une sortie conforme.
- `query` accepte une fonction définissant l'implémentation. Celle-ci reçoit `opts` contenant l'`input` passé à l'opération, ainsi que le contexte défini par le middleware disponible dans `opts.ctx`. La fonction doit retourner une sortie conforme au schéma `output`.

L'utilisation de `query` indique que l'opération est non mutation. Utilisez-le pour définir des méthodes de récupération de données. Pour une opération mutation, utilisez plutôt `mutation`.
=======
- `input` accepte un schéma Zod définissant l'entrée attendue. Les requêtes sont automatiquement validées contre ce schéma.
- `output` accepte un schéma Zod définissant la sortie attendue. Des erreurs de type apparaîtront si l'implémentation ne retourne pas une sortie conforme.
- `query` accepte une fonction définissant l'implémentation. Cette fonction reçoit `opts`, contenant l'`input` passé à l'opération, ainsi que le contexte défini par le middleware dans `opts.ctx`. La fonction doit retourner une sortie conforme au schéma `output`.

L'utilisation de `query` indique une opération non mutation. Utilisez `mutation` pour les opérations modificatrices.
>>>>>>> c5375c6 (docs: update translations)

Si vous ajoutez une nouvelle procédure, assurez-vous de l'enregistrer dans le routeur via `src/router.ts`.

## Personnalisation de votre API tRPC

### Gestion des erreurs

<<<<<<< HEAD
Dans votre implémentation, vous pouvez retourner des erreurs aux clients en lançant un `TRPCError`. Ceux-ci acceptent un `code` indiquant le type d'erreur, par exemple :
=======
Dans votre implémentation, vous pouvez retourner des erreurs aux clients en lançant un `TRPCError`. Ces erreurs acceptent un `code` indiquant le type d'erreur :
>>>>>>> c5375c6 (docs: update translations)

```ts
throw new TRPCError({
  code: 'NOT_FOUND',
  message: 'La ressource demandée est introuvable',
});
```

### Organisation des Opérations

<<<<<<< HEAD
Pour grouper des opérations liées, vous pouvez utiliser des routeurs imbriqués :
=======
Pour grouper des opérations liées, utilisez des routeurs imbriqués :
>>>>>>> c5375c6 (docs: update translations)

```ts
import { getUser } from './procedures/users/get.js';
import { listUsers } from './procedures/users/list.js';

const appRouter = router({
   users: router({
      get: getUser,
      list: listUsers,
   }),
   ...
})
```

<<<<<<< HEAD
Les clients verront alors ce regroupement, par exemple pour invoquer `listUsers` :
=======
Les clients verront ce regroupement, par exemple :
>>>>>>> c5375c6 (docs: update translations)

```ts
client.users.list.query();
```

### Journalisation

Le logger AWS Lambda Powertools est configuré dans `src/middleware/logger.ts` et accessible via `opts.ctx.logger`. Utilisez-le pour journaliser dans CloudWatch Logs :

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.logger.info('Opération appelée avec l\'entrée', opts.input);

      return ...;
   });
```

Plus d'informations dans la [documentation AWS Lambda Powertools Logger](https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/).

### Enregistrement de Métriques

<<<<<<< HEAD
Les métriques AWS Lambda Powertools sont configurées dans `src/middleware/metrics.ts` et accessibles via `opts.ctx.metrics` :
=======
Les métriques AWS Lambda Powertools sont configurées dans `src/middleware/metrics.ts` et accessibles via `opts.ctx.metrics`. Exemple :
>>>>>>> c5375c6 (docs: update translations)

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.metrics.addMetric('Invocations', 'Count', 1);

      return ...;
   });
```

Plus d'informations dans la [documentation AWS Lambda Powertools Metrics](https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/).

<<<<<<< HEAD
### Personnalisation du tracing X-Ray

Le tracer AWS Lambda Powertools est configuré dans `src/middleware/tracer.ts` et accessible via `opts.ctx.tracer` :
=======
### Ajustement du Tracing X-Ray

Le tracer AWS Lambda Powertools est configuré dans `src/middleware/tracer.ts` et accessible via `opts.ctx.tracer`. Exemple :
>>>>>>> c5375c6 (docs: update translations)

```ts {5-7}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      const subSegment = opts.ctx.tracer.getSegment()!.addNewSubsegment('MyAlgorithm');
      // ... logique à tracer
      subSegment.close();

      return ...;
   });
```

Plus d'informations dans la [documentation AWS Lambda Powertools Tracer](https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/).

### Implémentation de Middleware Personnalisé

<<<<<<< HEAD
Vous pouvez ajouter des valeurs au contexte des procédures via des middlewares.

Exemple pour extraire l'identité de l'utilisateur dans `src/middleware/identity.ts` :
=======
Vous pouvez ajouter des valeurs au contexte des procédures via un middleware.

Exemple : extraire l'identité de l'utilisateur dans `src/middleware/identity.ts`.
>>>>>>> c5375c6 (docs: update translations)

:::warning
Cet exemple suppose que `auth` est configuré sur `IAM`. Pour Cognito, l'extraction est plus directe via les claims de l'`event`.
:::

Définition du contexte :

```ts
export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}
```

Implémentation du middleware :

<Tabs>
<TabItem label="REST">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEvent } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEvent>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoAuthenticationProvider = opts.ctx.event.requestContext?.identity?.cognitoAuthenticationProvider;

    let sub: string | undefined = undefined;
    if (cognitoAuthenticationProvider) {
      const providerParts = cognitoAuthenticationProvider.split(':');
      sub = providerParts[providerParts.length - 1];
    }

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `Unable to determine calling user`,
      });
    }

    const { Users } = await cognito.listUsers({
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
<<<<<<< HEAD
        message: `No user found with subjectId ${sub}`,
=======
        message: `Aucun utilisateur trouvé avec l'ID ${sub}`,
>>>>>>> c5375c6 (docs: update translations)
      });
    }

    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
<TabItem label="HTTP">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoIdentity = opts.ctx.event.requestContext?.authorizer?.iam
      ?.cognitoIdentity as unknown as
      | {
          amr: string[];
        }
      | undefined;

    const sub = (cognitoIdentity?.amr ?? [])
      .flatMap((s) => (s.includes(':CognitoSignIn:') ? [s] : []))
      .map((s) => {
        const parts = s.split(':');
        return parts[parts.length - 1];
      })?.[0];

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `Unable to determine calling user`,
      });
    }

    const { Users } = await cognito.listUsers({
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
<<<<<<< HEAD
        message: `No user found with subjectId ${sub}`,
=======
        message: `Aucun utilisateur trouvé avec l'ID ${sub}`,
>>>>>>> c5375c6 (docs: update translations)
      });
    }

    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
</Tabs>

## Déploiement de votre API tRPC

Le générateur crée un construct CDK dans `common/constructs`. Exemple d'utilisation :

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs`;

export class ExampleStack extends Stack {
   constructor(scope: Construct, id: string) {
      const api = new MyApi(this, 'MyApi', {
        integrations: MyApi.defaultIntegrations(this).build(),
      });
   }
}
```

Ceci configure l'infrastructure API Gateway, Lambda et l'authentification selon la méthode `auth` choisie.

:::note
<<<<<<< HEAD
Pour l'authentification Cognito, fournissez la propriété `identity` :
=======
Si vous avez choisi l'authentification `Cognito`, fournissez la propriété `identity` :
>>>>>>> c5375c6 (docs: update translations)

```ts {9}
import { MyApi, UserIdentity } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const identity = new UserIdentity(this, 'Identity');

    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
      identity,
    });
  }
}
```

Le construct `UserIdentity` peut être généré via le générateur <Link path="/guides/react-website-auth">`ts#react-website-auth`</Link>
:::

<<<<<<< HEAD
### Intégrations typées

<Snippet name="api/type-safe-api-integrations" parentHeading="Intégrations typées" />

:::tip
Les modifications de procédures sont immédiatement reflétées dans le construct CDK sans reconstruction.
:::

### Attribution d'accès (IAM uniquement)

Pour l'authentification IAM, utilisez `grantInvokeAccess` :
=======
### Intégrations Type-Safe

<Snippet name="api/type-safe-api-integrations" parentHeading="Intégrations Type-Safe" />

:::tip
Les ajouts/suppressions de procédures sont reflétés immédiatement dans le construct CDK sans reconstruction.
:::

### Attribution d'Accès (IAM uniquement)

Avec l'authentification `IAM`, utilisez `grantInvokeAccess` pour accorder l'accès :
>>>>>>> c5375c6 (docs: update translations)

```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```

## Serveur tRPC Local

Utilisez la cible `serve` pour exécuter un serveur local :

<NxCommands commands={['run @my-scope/my-api:serve']} />

Le point d'entrée est `src/local-server.ts`. Le serveur se recharge automatiquement lors des modifications.

## Appel de votre API tRPC

<<<<<<< HEAD
Créez un client tRPC typé pour appeler votre API :
=======
Créez un client type-safe pour appeler votre API depuis un autre backend :
>>>>>>> c5375c6 (docs: update translations)

```ts
import { createMyApiClient } from ':my-scope/my-api';

const client = createMyApiClient({ url: 'https://my-api-url.example.com/' });

await client.echo.query({ message: 'Hello world!' });
```

<<<<<<< HEAD
Pour les sites React, utilisez le générateur <Link path="guides/api-connection/react-trpc">API Connection</Link>.
=======
Pour une intégration avec un site React, utilisez le générateur <Link path="guides/api-connection/react-trpc">API Connection</Link>.
>>>>>>> c5375c6 (docs: update translations)

## Plus d'Informations

<<<<<<< HEAD
Consultez la [documentation tRPC](https://trpc.io/docs).
=======
Consultez la [documentation tRPC](https://trpc.io/docs) pour en savoir plus.
>>>>>>> c5375c6 (docs: update translations)
