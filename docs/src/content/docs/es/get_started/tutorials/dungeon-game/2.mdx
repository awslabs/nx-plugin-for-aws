---
title: "Juego de Mazmorra de IA Agéntica"
description: "Un tutorial de cómo construir un juego de aventuras de mazmorra con IA agéntica usando @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import E2EDiff from '@components/e2e-diff.astro';
import E2ECode from '@components/e2e-code.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Módulo 2: Implementación de la API del juego y el servidor MCP de inventario

Comenzaremos implementando nuestra Game API. Para esto, necesitamos crear 5 APIs en total:

1. `createGame` - creará una nueva instancia del juego.
2. `queryGames` - devolverá una lista paginada de juegos guardados previamente.
3. `saveAction` - guardará una acción para un juego específico.
4. `queryActions` - devolverá una lista paginada de todas las acciones relacionadas con un juego.
5. `queryInventory` - devolverá una lista paginada de los items en el inventario de un jugador.

### Esquema de la API

Para definir las entradas y salidas de nuestra API, crearemos nuestro esquema usando [Zod](https://zod.dev/) en el directorio `packages/game-api/src/schema` de la siguiente manera:

<Tabs>
  <TabItem label="action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/action.ts.template" />
  </TabItem>
  <TabItem label="common.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/common.ts.template" />
  </TabItem>
  <TabItem label="game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/game.ts.template" />
  </TabItem>
  <TabItem label="inventory.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/schema/inventory.ts.template" />
  </TabItem>
  <TabItem label="index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/schema/index.ts.old.template" after="dungeon-adventure/2/schema/index.ts.template" />
  </TabItem>
</Tabs>

También puedes eliminar el archivo `packages/game-api/src/schema/echo.ts` ya que no lo usaremos en este proyecto.

<Aside type="tip">
Como puedes ver arriba, para cada esquema que definimos en Zod, también exportamos una interfaz usando la sintaxis `z.TypeOf`. ¡Esto convierte nuestra definición de Zod en una interfaz de Typescript sin duplicar esfuerzos!
</Aside>

### Modelado de entidades

El diagrama ER de nuestra aplicación es el siguiente:

<Image class="centered-image white-bg" src={dungeonAdventureErPng} alt="dungeon-adventure-er.png" width="400" height="300" />

{/* Generated from the following PlantUML: */}
{/*
@startuml Game API Entity Relationship Diagram

!theme plain

skinparam linetype ortho
skinparam roundcorner 10

entity "Game" as game {
  + playerName : string <<PK>>
  --
  genre : string
  lastUpdated : string
}

entity "Action" as action {
  + playerName : string <<PK>>
  + timestamp : string <<SK>>
  --
  role : string
  content : string
}

entity "Item" as item {
  + playerName : string <<PK>>
  + itemName : string
  --
  emoji : string (optional)
  lastUpdated : string
  quantity : number
}

game ||--o{ action
game ||--o{ item

@enduml
*/}

Implementaremos nuestra base de datos en DynamoDB usando la biblioteca cliente [ElectroDB](https://electrodb.dev/en/core-concepts/introduction/). Para comenzar, primero instala `electrodb` ejecutando el siguiente comando:

<InstallCommand pkg="electrodb @aws-sdk/client-dynamodb" />

<Aside>
Todas las dependencias se agregan al `package.json` raíz ya que `@aws/nx-plugin` sigue el principio de [política de versión única](https://nx.dev/concepts/decisions/dependency-management#single-version-policy). Para más información, consulta la <Link path="guides/typescript-project#dependencies">guía de proyectos TypeScript</Link>.
</Aside>

Ahora crea los siguientes archivos en nuestra carpeta `packages/game-api/src/entities` para definir nuestras entidades ElectroDB según el diagrama ER anterior:

<Tabs>
  <TabItem label="action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/action.ts.template" />
  </TabItem>
  <TabItem label="game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/game.ts.template" />
  </TabItem>
  <TabItem label="inventory.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/entities/inventory.ts.template" />
  </TabItem>
</Tabs>

ElectroDB es muy potente y nos permite no solo definir tipos, sino también proveer valores por defecto para ciertos campos como los timestamps. Además, ElectroDB sigue el [diseño de tabla única](https://electrodb.dev/en/core-concepts/single-table-relationships/), que es la mejor práctica con DynamoDB.

<Aside>
Aunque ElectroDB soporta [colecciones](https://electrodb.dev/en/modeling/collections/), hemos optado por no usarlas en este tutorial por simplicidad.
</Aside>

Para preparar la interacción del servidor MCP con el inventario, asegurémonos de exportar la entidad de inventario en `packages/game-api/src/index.ts`:

<Tabs>
<TabItem label="packages/game-api/src/index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/index.ts.old.template" after="dungeon-adventure/2/index.ts.template" />
</TabItem>
</Tabs>

:::note
La estructura del paquete sería mejor si refactorizamos las entidades en su propio proyecto compartido, para que el servidor MCP no dependa de la API.
:::

### Añadiendo el cliente DynamoDB al contexto de tRPC

Como necesitamos acceso al cliente DynamoDB en cada uno de nuestros procedimientos, queremos crear una única instancia del cliente que podamos pasar mediante el contexto. Para esto, realiza los siguientes cambios en `packages/game-api/src`:

<Tabs>
  <TabItem label="middleware/dynamodb.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/middleware/dynamodb.ts.template" />

Este es un plugin que instrumentamos para crear el `DynamoDBClient` e inyectarlo en el contexto.
  </TabItem>
  <TabItem label="middleware/index.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/middleware/index.ts.old.template" after="dungeon-adventure/2/middleware/index.ts.template" />

Aumentamos nuestro `IMiddlewareContext` para añadir `IDynamoDBContext`.
  </TabItem>
  <TabItem label="init.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/init.ts.old.template" after="dungeon-adventure/2/init.ts.template" />

El plugin de DynamoDB está instrumentado.

<Aside>
La API `concat` vincula nuestro middleware a los procedimientos definidos. Para más detalles, consulta la [guía de concat](https://trpc.io/docs/server/middlewares#concat).
</Aside>
  </TabItem>
</Tabs>

### Definiendo nuestros procedimientos

Ahora implementaremos los métodos de la API. Para esto, realiza los siguientes cambios en `packages/game-api/src/procedures`:

#### Consultas

<Tabs>
  <TabItem label="query-actions.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-actions.ts.template" />
  </TabItem>
  <TabItem label="query-games.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-games.ts.template" />
  </TabItem>
  <TabItem label="query-inventory.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/query-inventory.ts.template" />
  </TabItem>
</Tabs>

#### Mutaciones

<Tabs>
  <TabItem label="save-action.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/save-action.ts.template" />
  </TabItem>
  <TabItem label="save-game.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/procedures/save-game.ts.template" />
  </TabItem>
</Tabs>

También puedes eliminar el archivo `echo.ts` (de `packages/game-api/src/procedures`) ya que no lo usaremos en este proyecto.

### Configuración del router

Ahora que hemos definido nuestros procedimientos, conectémoslos a nuestra API. Para esto, actualiza el siguiente archivo:

<Tabs>
  <TabItem label="packages/game-api/src/router.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/router.ts.old.template" after="dungeon-adventure/2/router.ts.template" />
</TabItem>
</Tabs>

### Servidor MCP de inventario

Ahora creemos un servidor MCP que permita a nuestro agente gestionar items en el inventario de un jugador.

Definiremos las siguientes herramientas para nuestro Agente:

- `list-inventory-items` para obtener los items actuales del inventario del jugador
- `add-to-inventory` para añadir items al inventario del jugador
- `remove-from-inventory` para eliminar items del inventario del jugador

Para ahorrar tiempo, definiremos todas las herramientas inline:

<Tabs>
  <TabItem label="packages/inventory/src/mcp-server/server.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/2/mcp/server.ts.old.template" after="dungeon-adventure/2/mcp/server.ts.template" />
</TabItem>
</Tabs>

A medida que crezca el número de herramientas, puedes refactorizarlas en archivos separados si lo prefieres.

Ahora puedes eliminar los directorios `tools` y `resources` en `packages/inventory/src/mcp-server` ya que no se usan.

### Infraestructura

El paso final es actualizar nuestra infraestructura para crear la tabla DynamoDB y otorgar permisos para operaciones desde la Game API. Para esto, actualiza `packages/infra/src` como sigue:

<Tabs>
  <TabItem label="constructs/electrodb-table.ts">
<E2ECode lang="typescript" path="dungeon-adventure/2/constructs/electrodb-table.ts.template" />
  </TabItem>
  <TabItem label="stacks/application-stack.ts">
<E2EDiff lang="typescript" before="dungeon-adventure/1/application-stack.ts.template" after="dungeon-adventure/2/stacks/application-stack.ts.template" />

:::note
Observa que como cada procedimiento es atendido por una función lambda individual, podemos seguir el principio de mínimo privilegio y asignar solo los permisos de lectura/escritura requeridos según la implementación del procedimiento.
:::
  </TabItem>
</Tabs>

### Despliegue y pruebas

Primero, construyamos el código base:

<NxCommands commands={['run-many --target build --all']} />

<Aside type="tip">
Si encuentras errores de linting, puedes ejecutar el siguiente comando para corregirlos automáticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

Ahora puedes desplegar tu aplicación ejecutando:

<NxCommands commands={['run @dungeon-adventure/infra:deploy dungeon-adventure-infra-sandbox/*']} />

El primer despliegue tomará aproximadamente 8 minutos. Los siguientes despliegues tomarán alrededor de 2 minutos.

:::tip
Si estás iterando cambios en el código de funciones lambda, puedes desplegar con el flag `--hotswap` después de construir el código base para un tiempo de despliegue mucho menor (2-3 segundos).

<NxCommands commands={['run @dungeon-adventure/infra:deploy dungeon-adventure-infra-sandbox/* --hotswap']} />
:::

Una vez completado el despliegue, verás salidas similares a las siguientes _(algunos valores han sido omitidos)_:

```bash
dungeon-adventure-sandbox-Application
dungeon-adventure-sandbox-Application: deploying... [2/2]

 ✅  dungeon-adventure-sandbox-Application

✨  Deployment time: 354s

Outputs:
dungeon-adventure-sandbox-Application.ElectroDbTableTableNameXXX = dungeon-adventure-sandbox-Application-ElectroDbTableXXX-YYY
dungeon-adventure-sandbox-Application.GameApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-sandbox-Application.GameUIDistributionDomainNameXXX = xxx.cloudfront.net
dungeon-adventure-sandbox-Application.StoryApiEndpointXXX = https://xxx.execute-api.region.amazonaws.com/prod/
dungeon-adventure-sandbox-Application.UserIdentityUserIdentityIdentityPoolIdXXX = region:xxx
dungeon-adventure-sandbox-Application.UserIdentityUserIdentityUserPoolIdXXX = region_xxx
```

Podemos probar nuestra API de dos formas:
<ul>
<li>Iniciando una instancia local del backend tRPC e invocando las APIs con `curl`.</li>
<li>
<Drawer title="curl con Sigv4 habilitado" trigger="Llamando a la API desplegada usando curl con Sigv4">

<Tabs>
  <TabItem label="Bash/Linux/macOS">
Puedes agregar el siguiente script a tu archivo `.bashrc` (y hacer `source`) o pegarlo directamente en la terminal donde ejecutarás el comando.
```bash
// ~/.bashrc
acurl () {
    REGION=$1
    SERVICE=$2
    shift; shift;
    curl --aws-sigv4 "aws:amz:$REGION:$SERVICE" --user "$(aws configure get aws_access_key_id):$(aws configure get aws_secret_access_key)" -H "X-Amz-Security-Token: $(aws configure get aws_session_token)" "$@"
}
```

Para hacer una petición curl autenticada con sigv4, puedes invocar `acurl` como en estos ejemplos:

###### API Gateway
```bash
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### URL de función Lambda
```bash
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
  </TabItem>
  <TabItem label="Windows PowerShell">
Puedes agregar esta función a tu perfil de PowerShell o pegarla directamente en la sesión actual.
```powershell
# Perfil de PowerShell o sesión actual
function acurl {
    param(
        [Parameter(Mandatory=$true)][string]$Region,
        [Parameter(Mandatory=$true)][string]$Service,
        [Parameter(ValueFromRemainingArguments=$true)][string[]]$CurlArgs
    )

    $AccessKey = aws configure get aws_access_key_id
    $SecretKey = aws configure get aws_secret_access_key
    $SessionToken = aws configure get aws_session_token

    & curl --aws-sigv4 "aws:amz:$Region`:$Service" --user "$AccessKey`:$SecretKey" -H "X-Amz-Security-Token: $SessionToken" @CurlArgs
}
```

Para hacer una petición curl autenticada con sigv4:
###### API Gateway
```powershell
acurl ap-southeast-2 execute-api -X GET https://xxx
```

###### URL de función Lambda
```powershell
acurl ap-southeast-2 lambda -N -X POST https://xxx
```
  </TabItem>
</Tabs>

</Drawer>
</li>
</ul>


<Tabs>
  <TabItem label="Local">
    Inicia tu servidor local `game-api` ejecutando:

    <NxCommands highlights={['dungeon-adventure-infra-sandbox-Application-ElectroDbTableXXX-YYY']} env={{TABLE_NAME:"dungeon-adventure-infra-sandbox-Application-ElectroDbTableXXX-YYY"}} commands={["run @dungeon-adventure/game-api:serve"]} />

    <Aside type="caution">
    Usa el valor de salida `dungeon-adventure-infra-sandbox-Application.ElectroDbTableTableNameXXX` de CDK deploy para reemplazar el marcador de posición resaltado.
    </Aside>

    Una vez que el servidor esté en ejecución, puedes llamarlo con:

    ```bash
    curl -X GET 'http://localhost:2022/games.query?input=%7B%7D'
    ```
  </TabItem>
  <TabItem label="Desplegado">
```bash "https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/" "ap-southeast-2"
acurl ap-southeast-2 execute-api -X GET 'https://xxx.execute-api.ap-southeast-2.amazonaws.com/prod/games.query?input=%7B%7D'
```
    <Aside type="caution">
    Usa el valor de salida `dungeon-adventure-infra-sandbox-Application.GameApiGameApiEndpointXXX` de CDK deploy para reemplazar el marcador de posición y ajusta la región correspondientemente.
    </Aside>
  </TabItem>
</Tabs>

:::note
El `%7B%7D` que pasamos para probar la API es un objeto JSON vacío codificado en URI (`{}`).
:::

Si el comando se ejecuta exitosamente, verás una respuesta como:

```json
{"result":{"data":{"items":[],"cursor":null}}}
```

¡Felicidades, has construido y desplegado tu primera API usando tRPC! 🎉🎉🎉