---
title: "Juego de Mazmorra con IA"
description: "Un tutorial de cómo construir un juego de aventuras de mazmorra con IA utilizando el @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Módulo 1: Configuración del monorepo

Comenzaremos creando un nuevo monorepo. Desde el directorio deseado, ejecuta el siguiente comando:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

Esto configurará un monorepo NX dentro del directorio `dungeon-adventure` que podrás abrir en VSCode. Debería verse así:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ aquí residirán tus subproyectos
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura el CLI de Nx y los valores predeterminados del monorepo
- package.json aquí se definen todas las dependencias de Node
- pnpm-lock.yaml o bun.lock, yarn.lock, package-lock.json según el gestor de paquetes
- pnpm-workspace.yaml si usas pnpm
- README.md
- tsconfig.base.json todos los subproyectos basados en Node extienden este
- tsconfig.json
</FileTree>

Ahora estamos listos para comenzar a crear nuestros diferentes subproyectos usando el `@aws/nx-plugin`.

<Aside type="tip">Es una buena práctica asegurarse de que todos los archivos no preparados estén confirmados en Git antes de ejecutar cualquier generador. Esto te permite ver qué ha cambiado después de ejecutar el generador mediante `git diff`</Aside>

### API del juego

Primero creemos nuestra API del juego. Para esto, crearemos una API tRPC llamada `GameApi` siguiendo estos pasos:

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

Deberías ver nuevos archivos en tu árbol de directorios.

<Aside>
El `package.json` raíz ahora está configurado con un `type` de `module`, lo que significa que ESM es el tipo de módulo predeterminado para todos los subproyectos basados en Node proporcionados por el `@aws/nx-plugin`. Para más detalles sobre proyectos TypeScript, consulta la <Link path="guides/typescript-project">guía ts#project</Link>.
</Aside>

<Drawer title="Archivos actualizados de ts#trpc-api" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados por el generador `ts#trpc-api`. Examinaremos algunos archivos clave resaltados en el árbol:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK específicos de la aplicación
          - apis/
            - **game-api.ts** construct CDK para crear tu API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructs CDK genéricos
          - api/
            - rest-api.ts construct base CDK para API Gateway Rest API
            - trpc-utils.ts utilidades para constructs CDK de API tRPC
            - utils.ts utilidades para constructs de API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipos compartidos
      - src/
        - index.ts
        - runtime-config.ts definición de interfaz usada por CDK y el sitio web
      - project.json
      - ...
  - game-api/ API tRPC
    - src/
      - client/ cliente vanilla típico para llamadas máquina a máquina en TS
        - index.ts
        - sigv4.ts
      - middleware/ instrumentación con Powertools
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ definiciones de entradas y salidas de tu API
        - **echo.ts**
      - procedures/ implementaciones específicas de los procedimientos/rutas de tu API
        - **echo.ts**
      - index.ts
      - init.ts configura el contexto y middleware
      - local-server.ts usado al ejecutar el servidor tRPC localmente
      - **router.ts** punto de entrada para el handler Lambda que define todos los procedimientos
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Observemos algunos archivos clave:

```ts {5,12}
// packages/game-api/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
El router define el punto de entrada de tu API tRPC y es donde declararás todos los métodos de la API. Como se ve arriba, tenemos un método llamado `echo` con su implementación en el archivo `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Este archivo es la implementación del método `echo` y como se ve está fuertemente tipado declarando sus estructuras de datos de entrada y salida.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Todas las definiciones de esquema tRPC se definen usando [Zod](https://zod.dev/) y se exportan como tipos TypeScript mediante la sintaxis `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// Tipo unión de strings para todos los nombres de operaciones de la API
type Operations = Procedures<AppRouter>;

/**
 * Propiedades para crear un construct GameApi
 *
 * @template TIntegrations - Mapa de nombres de operación a sus integraciones
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mapa de nombres de operación a sus integraciones de API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un construct CDK que crea y configura una API REST de AWS API Gateway
 * específicamente para GameApi.
 * @template TIntegrations - Mapa de nombres de operación a sus integraciones
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integraciones predeterminadas para todas las operaciones, implementando cada operación como
   * su propia función lambda individual.
   *
   * @param scope - El alcance del construct CDK
   * @returns Un IntegrationBuilder con integraciones lambda predeterminadas
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Aquí permitimos cualquier credencial AWS de la cuenta donde se despliega el proyecto para llamar a la API.
          // Se puede definir acceso granular máquina a máquina aquí usando principios más específicos (ej. roles o
          // usuarios) y recursos (ej. qué rutas de API pueden ser invocadas por qué principio) si es necesario.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Permitimos OPTIONS para que los navegadores hagan solicitudes preflight sin autenticar
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

Este es el construct CDK que define nuestro GameApi. Como se ve, provee un método `defaultIntegrations` que crea automáticamente una función lambda para cada procedimiento en nuestra API tRPC, apuntando a la implementación empaquetada de la API. Esto significa que en el momento de `cdk synth`, no ocurre empaquetado (a diferencia de usar [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) ya que ya lo hemos empaquetado como parte del target de build del proyecto backend.

</Drawer>

### API de historia

Ahora creemos nuestra API de historia. Para esto, crearemos una API Fast llamada `StoryApi` siguiendo estos pasos:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi", moduleName:"story_api"}} noInteractive />

Deberías ver nuevos archivos en tu árbol de directorios.
<Drawer title="Archivos actualizados de py#fast-api" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados por el generador `py#fast-api`. Examinaremos algunos archivos clave resaltados en el árbol:
<FileTree>
- .venv/ entorno virtual único para el monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK específicos de la aplicación
          - apis/
            - **story-api.ts** construct CDK para crear tu API Fast
            - index.ts actualizado para exportar el nuevo story-api
      - project.json actualizado para añadir dependencia de build en story_api
    - types/ tipos compartidos
      - src/
        - **runtime-config.ts** actualizado para añadir StoryApi
  - story_api/
    - story_api/ módulo Python
      - init.py configura Powertools, FastAPI y middleware
      - **main.py** punto de entrada para el lambda que contiene todas las rutas
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version versión de Python fijada para uv
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import {
  OPERATION_DETAILS,
  Operations,
} from '../../generated/story-api/metadata.gen.js';

/**
 * Propiedades para crear un construct StoryApi
 *
 * @template TIntegrations - Mapa de nombres de operación a sus integraciones
 */
export interface StoryApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mapa de nombres de operación a sus integraciones de API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un construct CDK que crea y configura una API REST de AWS API Gateway
 * específicamente para StoryApi.
 * @template TIntegrations - Mapa de nombres de operación a sus integraciones
 */
export class StoryApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integraciones predeterminadas para todas las operaciones, implementando cada operación como
   * su propia función lambda individual.
   *
   * @param scope - El alcance del construct CDK
   * @returns Un IntegrationBuilder con integraciones lambda predeterminadas
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: OPERATION_DETAILS,
      defaultIntegrationOptions: {
        runtime: Runtime.PYTHON_3_12,
        handler: 'story_api.main.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/story_api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `StoryApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: StoryApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'StoryApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Aquí permitimos cualquier credencial AWS de la cuenta donde se despliega el proyecto para llamar a la API.
          // Se puede definir acceso granular máquina a máquina aquí usando principios más específicos (ej. roles o
          // usuarios) y recursos (ej. qué rutas de API pueden ser invocadas por qué principio) si es necesario.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Permitimos OPTIONS para que los navegadores hagan solicitudes preflight sin autenticar
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: OPERATION_DETAILS,
      ...props,
    });
  }
}

```

Este es el construct CDK que define nuestro StoryApi. Como se ve, provee un método `defaultIntegrations` que crea automáticamente una función lambda para cada operación definida en nuestra FastAPI, apuntando a la implementación empaquetada de la API. Esto significa que en el momento de `cdk synth`, no ocurre empaquetado (a diferencia de [PythonFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/@aws-cdk_aws-lambda-python-alpha.PythonFunction.html)) ya que ya lo hemos empaquetado como parte del target de build del proyecto backend.

```diff lang="ts"
// packages/common/types/src/runtime-config.ts
export type ApiUrl = string;
// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-empty-interface
export interface IRuntimeConfig {
  apis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

Aquí hay un ejemplo del generador realizando una transformación AST que preserva todo el código existente y realiza una actualización. Aquí puedes ver que `StoryApi` fue añadido a la definición `IRuntimeConfig`, lo que significa que cuando esto sea consumido por nuestro frontend, ¡impondrá seguridad de tipos!

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

Aquí es donde se definirán todos tus métodos de API. Como se ve aquí, tenemos un método `read_root` mapeado a la ruta `GET /`. Puedes usar [Pydantic](https://docs.pydantic.dev/latest/) para declarar entradas y salidas de métodos y asegurar seguridad de tipos.

</Drawer>

### Interfaz de usuario del juego: Sitio web

Ahora creemos la UI que permitirá interactuar con el juego. Para esto, creemos un sitio web llamado `GameUI` siguiendo estos pasos:

<RunGenerator generator="ts#react-website" requiredParameters={{name:"GameUI"}} noInteractive />

Deberías ver nuevos archivos en tu árbol de directorios.

<Drawer title="Archivos actualizados de ts#react-website" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados por el generador `ts#react-website`. Examinaremos algunos archivos clave resaltados en el árbol:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK específicos de la aplicación
          - static-websites/
            - **game-ui.ts** construct CDK para crear tu Game UI
        - core/
          - static-website.ts construct genérico para sitio web estático
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts diseño general de página: encabezado, pie, barra lateral, etc
          - navitems.ts elementos de navegación de la barra lateral
      - hooks/
        - useAppLayout.tsx permite configurar dinámicamente notificaciones, estilo de página, etc
      - routes/ rutas basadas en archivos con @tanstack/react-router
        - index.tsx página raíz '/' redirige a '/welcome'
        - __root.tsx todas las páginas usan este componente como base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** punto de entrada de React
        - routeTree.gen.ts este archivo se actualiza automáticamente por @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Este es el construct CDK que define nuestro GameUI. Como se ve, ya está configurada la ruta al bundle generado para nuestra UI basada en Vite. Esto significa que en el momento de `build`, el empaquetado ocurre dentro del target de build del proyecto game-ui y su salida se usa aquí.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Registra la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Este es el punto de entrada donde se monta React. Como se muestra, inicialmente solo configura un `@tanstack/react-router` en una configuración de [`enrutamiento basado en archivos`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Esto significa que, mientras el servidor de desarrollo esté ejecutándose, puedes simplemente crear archivos en la carpeta `routes` y `@tanstack/react-router` creará la configuración de archivos necesaria y actualizará el archivo `routeTree.gen.ts`. Este archivo mantiene todas las rutas de manera segura en tipos, lo que significa que cuando uses `<Link>`, la opción `to` solo mostrará rutas válidas. Para más información, consulta la [documentación de `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un componente que se renderizará al navegar a la ruta `/welcome`. `@tanstack/react-router` gestionará la `Route` por ti cuando crees/muevas este archivo (siempre que el servidor de desarrollo esté ejecutándose). Esto se mostrará en una sección posterior de este tutorial.

</Drawer>

### Interfaz de usuario del juego: Autenticación

Ahora configuremos nuestra Game UI para requerir acceso autenticado mediante Amazon Cognito siguiendo estos pasos:

<RunGenerator generator="ts#react-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Deberías ver nuevos archivos/cambios en tu árbol de directorios.

<Drawer title="Archivos actualizados de ts#react-website#auth" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `ts#react-website#auth`. Examinaremos algunos archivos clave resaltados en el árbol:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts construct CDK para crear pools de usuarios/identidad
    - types/
      - src/
        - runtime-config.ts actualizado para añadir cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx añade usuario autenticado/logout al encabezado
        - CognitoAuth/
          - index.ts gestiona el inicio de sesión en Cognito
        - RuntimeConfig/
          - index.tsx obtiene el `runtime-config.json` y lo provee a hijos mediante contexto
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Actualizado para añadir Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Los componentes `RuntimeConfigProvider` y `CognitoAuth` han sido añadidos al archivo `main.tsx` mediante una transformación AST. Esto permite que el componente `CognitoAuth` se autentique con Amazon Cognito obteniendo el `runtime-config.json` que contiene la configuración de conexión requerida para realizar llamadas al backend al destino correcto.

</Drawer>

### Interfaz de usuario del juego: Conectar a Story API

Ahora configuremos nuestra Game UI para conectarse a nuestra Story API creada previamente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

Deberías ver nuevos archivos/cambios en tu árbol de directorios.

<Drawer title="Archivos actualizados de conexión UI -> FastAPI" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `api-connection`. Examinaremos algunos archivos clave resaltados en el árbol:
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx usado por StoryApi para firmar solicitudes
        - useStoryApiClient.tsx hook para construir un cliente StoryApi
        - useStoryApi.tsx hook para interactuar con StoryApi usando TanStack Query
      - components/
        - QueryClientProvider.tsx proveedor del cliente TanStack Query
        - StoryApiProvider.tsx proveedor del hook TanStack Query para StoryApi
      - main.tsx Instrumenta QueryClientProvider y StoryApiProvider
    - .gitignore ignora archivos de cliente generados
    - project.json actualizado para añadir targets de generación de hooks openapi
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json actualizado para emitir archivo openapi.json

</FileTree>

```tsx {1,12-15}
// packages/game-ui/src/hooks/useStoryApiClient.tsx
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

Este hook puede usarse para hacer solicitudes API autenticadas a `StoryApi`. Como se ve en la implementación, usa el `StoryApi` generado en tiempo de build, por lo que verás un error en tu IDE hasta que compilemos nuestro código. Para más detalles sobre cómo se genera el cliente o cómo consumir la API, consulta la <Link path="guides/api-connection/react-fastapi">guía de React a FastAPI</Link>.

```tsx
// packages/game-ui/src/components/StoryApiProvider.tsx
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useStoryApiClient } from '../hooks/useStoryApiClient';
import { StoryApiOptionsProxy } from '../generated/story-api/options-proxy.gen';

export const StoryApiContext = createContext<StoryApiOptionsProxy | undefined>(
  undefined,
);

export const StoryApiProvider: FC<PropsWithChildren> = ({ children }) => {
  const client = useStoryApiClient();
  const optionsProxy = useMemo(
    () => new StoryApiOptionsProxy({ client }),
    [client],
  );

  return (
    <StoryApiContext.Provider value={optionsProxy}>
      {children}
    </StoryApiContext.Provider>
  );
};

export default StoryApiProvider;
```

El componente proveedor anterior usa el hook `useStoryApiClient` e instancia el `StoryApiOptionsProxy`, que se usa para construir opciones para los hooks de TanStack Query. Puedes usar el hook correspondiente `useStoryApi` para acceder a este proxy de opciones, que proporciona una forma de interactuar con tu FastAPI de manera consistente con tu API tRPC.

Dado que `useStoryApiClient` nos provee un iterador asíncrono para nuestra API de streaming, en este tutorial usaremos directamente el cliente vanilla.

<Aside type="caution">
Los archivos `src/generated/story-api/*.gen.ts` nunca deben modificarse manualmente ya que se regenerarán cada vez que construyas tu API.
</Aside>

</Drawer>

### Interfaz de usuario del juego: Conectar a Game API

Ahora configuremos nuestra Game UI para conectarse a nuestra Game API creada previamente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

Deberías ver nuevos archivos/cambios en tu árbol de directorios.

<Drawer title="Archivos actualizados de conexión UI -> tRPC" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `api-connection`. Examinaremos algunos archivos clave resaltados en el árbol:
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx configura el cliente GameAPI
      - hooks/
        - **useGameApi.tsx** hooks para llamar a GameApi
      - **main.tsx** inyecta los proveedores de cliente trpc
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { GameApiTRCPContext } from '../components/GameApiClientProvider';

export const useGameApi = GameApiTRCPContext.useTRPC;
```

Este hook usa la última [integración de React Query de tRPC](https://trpc.io/blog/introducing-tanstack-react-query-client) permitiendo a los usuarios interactuar con `@tanstack/react-query` directamente sin capas adicionales de abstracción. Para ejemplos de cómo llamar a APIs tRPC, consulta la <Link path="guides/api-connection/react-trpc#using-the-generated-code">guía de uso del hook tRPC</Link>.

<Aside>
El hook `useGameApi` es diferente al hook `useStoryApi` ya que no requiere un build para que los cambios se reflejen gracias al uso de [inferencia de Typescript](https://trpc.io/docs/concepts) por parte de tRPC. ¡Esto permite a los desarrolladores hacer cambios en su backend que se reflejen instantáneamente en su frontend!
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <RouterProvider router={router} />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

El archivo `main.tsx` ha sido actualizado mediante una transformación AST para inyectar los proveedores de tRPC.

</Drawer>

### Interfaz de usuario del juego: Infraestructura

Ahora el último subproyecto que necesitamos crear es para la infraestructura CDK. Para crearlo, sigue estos pasos:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Deberías ver nuevos archivos/cambios en tu árbol de directorios.

<Drawer title="Archivos actualizados de ts#infra" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `ts#infra`. Examinaremos algunos archivos clave resaltados en el árbol:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts** recursos CDK definidos aquí
      - index.ts
      - **main.ts** punto de entrada que define todos los stacks
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json añade referencias
  - tsconfig.base.json añade alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
  App,
  CfnGuardValidator,
  RuleSet,
} from ':dungeon-adventure/common-constructs';

const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

// Usa esto para desplegar tu propio entorno sandbox (asume credenciales CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

<Aside type="tip">Si ves un error de importación en tu IDE, es porque nuestro proyecto de infraestructura no tiene una referencia TypeScript configurada aún en su tsconfig.json. Nx ha sido [configurado](https://nx.dev/nx-api/js/generators/typescript-sync) para crear estas referencias *dinámicamente* cuando se ejecuta un build/compile o si ejecutas el comando `nx sync` manualmente. Para más información consulta la <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guía de TypeScript</Link>.</Aside>

Este es el punto de entrada para tu aplicación CDK.

Está configurado para usar [`cfn-guard`](https://github.com/cdklabs/cdk-validator-cfnguard) para ejecutar validación de infraestructura basada en el conjunto de reglas configurado. Esto se instrumenta post síntesis.

<Aside type="tip">
Puede haber casos donde quieras suprimir ciertas reglas en recursos. Puedes hacer esto de dos maneras:

###### Suprimir una regla en un construct específico

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// suprime la RULE_NAME para el construct dado
suppressRule(construct, 'RULE_NAME');
```

###### Suprimir una regla en un construct descendiente

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// Suprime la RULE_NAME para el construct o cualquiera de sus descendientes si es instancia de Bucket
suppressRule(construct, 'RULE_NAME', (construct) => construct instanceof Bucket);
```
</Aside>

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // Aquí va el código que define tu stack
  }
}
```

Aquí es donde instanciaremos nuestros constructs CDK para construir nuestro juego de aventuras.

</Drawer>

#### Actualizar nuestra infraestructura

Actualicemos nuestro `packages/infra/src/stacks/application-stack.ts` para instanciar algunos de nuestros constructs generados:

<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

Nota que aquí proveemos integraciones predeterminadas para nuestras dos APIs. Por defecto, cada operación en nuestra API está mapeada a una función lambda individual para manejar esa operación.

### Construyendo nuestro código

<Drawer title="Comandos de Nx" trigger="Ahora es momento de construir nuestro código por primera vez">
###### Targets únicos vs múltiples

El comando `run-many` ejecutará un target en múltiples subproyectos listados (`--all` los seleccionará todos). Se asegurará de que las dependencias se ejecuten en el orden correcto.

También puedes disparar un build (o cualquier otra tarea) para un target de proyecto único ejecutando el target directamente en el proyecto. Por ejemplo, si queremos construir el proyecto `@dungeon-adventure/infra`, puedes ejecutar:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualizando tus dependencias

También puedes visualizar tus dependencias mediante:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Caché

Nx depende del [caching](https://nx.dev/concepts/how-caching-works) para reutilizar artefactos de builds previos y acelerar el desarrollo. Se requiere cierta configuración para que esto funcione correctamente y puede haber casos donde quieras realizar un build **sin usar la caché**. Para eso, simplemente añade el argumento `--skip-nx-cache` a tu comando. Por ejemplo:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Si por alguna razón quisieras limpiar tu caché (almacenada en la carpeta `.nx`), puedes ejecutar:

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

Deberías ver el siguiente mensaje:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? …
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Este mensaje indica que NX detectó archivos que pueden actualizarse automáticamente. En este caso, se refiere a los archivos `tsconfig.json` que no tienen referencias TypeScript configuradas en proyectos referenciados. Selecciona la opción **Yes, sync the changes and run the tasks** para continuar. ¡Deberías notar que todos los errores de importación en tu IDE se resuelven automáticamente ya que el generador de sincronización añadirá las referencias TypeScript faltantes!

<Aside type="tip">
Si encuentras errores de lint, puedes ejecutar el siguiente comando para corregirlos automáticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

<Aside type="caution" title="Fallo de build en Windows">
<Drawer trigger="Si estás en Windows y encuentras un error de build, haz clic aquí." title="Fallo de build en Windows">
Si encuentras un error de build/synth para el proyecto `@dungeon-adventure/infra`, esto es esperado ya que la biblioteca que instrumenta `cfn-guard` actualmente no soporta Windows. Hay una solicitud de función para esto, pero mientras tanto podemos deshabilitar `cfn-guard` modificando el archivo `packages/infra/src/main.ts` como sigue:

```diff lang="ts"
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
   App,
-  CfnGuardValidator,
-  RuleSet,
} from ':dungeon-adventure/common-constructs';
-
-const app = new App({
-  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
-});
+const app = new App();

// Usa esto para desplegar tu propio entorno sandbox (asume credenciales CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```
</Drawer>
</Aside>

Todos los artefactos construidos están ahora disponibles en la carpeta `dist/` ubicada en la raíz del monorepo. Esta es una práctica estándar cuando se usan proyectos generados por el `@aws/nx-plugin` ya que no contamina tu árbol de archivos con archivos generados. Si quieres limpiar tus archivos, simplemente borra la carpeta `dist/` sin preocuparte por archivos generados dispersos.

¡Felicidades! Has creado todos los subproyectos requeridos para comenzar a implementar el núcleo de nuestro juego Dungeon Adventure.  🎉🎉🎉