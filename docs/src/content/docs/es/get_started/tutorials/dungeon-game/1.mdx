---
title: "Juego de Mazmorra con IA"
description: "Un tutorial de cómo construir un juego de aventuras de mazmorra con IA utilizando el @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Módulo 1: Configuración del monorepo

Comenzaremos creando un nuevo monorepo. Desde el directorio deseado, ejecuta el siguiente comando:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

Esto configurará un monorepo NX dentro del directorio `dungeon-adventure` que podrás abrir en vscode. Debería verse así:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ aquí residirán tus subproyectos
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura los valores predeterminados de Nx CLI y el monorepo
- package.json aquí se definen todas las dependencias de node
- pnpm-lock.yaml o bun.lock, yarn.lock, package-lock.json según el gestor de paquetes
- pnpm-workspace.yaml si usas pnpm
- README.md
- tsconfig.base.json todos los subproyectos basados en node extienden este
- tsconfig.json
</FileTree>

Ahora estamos listos para crear nuestros diferentes subproyectos usando el `@aws/nx-plugin`.

<Aside type="tip">Es una buena práctica asegurarse de que todos los archivos no preparados estén confirmados en Git antes de ejecutar cualquier generador. Esto te permite ver qué ha cambiado después de ejecutar el generador mediante `git diff`</Aside>

### API del Juego

Primero creemos nuestra API del Juego. Para esto, crearemos una API tRPC llamada `GameApi` siguiendo estos pasos:

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

Deberías ver nuevos archivos en tu árbol de directorios.

<Aside>
El `package.json` raíz ahora está configurado con un `type` de `module`, lo que significa que ESM es el tipo de módulo predeterminado para todos los subproyectos basados en node proporcionados por el `@aws/nx-plugin`. Para más detalles sobre proyectos TypeScript, consulta la <Link path="guides/typescript-project">guía ts#project</Link>.
</Aside>

<Drawer title="Archivos actualizados por ts#trpc-api" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra la lista de archivos generados por el generador `ts#trpc-api`. Examinaremos algunos archivos clave resaltados en el árbol:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK específicos de la aplicación
          - apis/
            - **game-api.ts** constructo CDK para crear tu API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructs CDK genéricos
          - api/
            - rest-api.ts constructo base para API Gateway Rest API
            - trpc-utils.ts utilidades para constructs CDK de API tRPC
            - utils.ts utilidades para constructs de API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipos compartidos
      - src/
        - index.ts
        - runtime-config.ts definición de interfaz usada por CDK y el sitio web
      - project.json
      - ...
  - game-api/ API tRPC
    - src/
      - client/ cliente vanilla para llamadas máquina a máquina
        - index.ts
        - sigv4.ts
      - middleware/ instrumentación con powertools
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ definiciones de entradas y salidas de la API
        - **echo.ts**
      - procedures/ implementaciones de los procedimientos/rutas de la API
        - **echo.ts**
      - index.ts
      - init.ts configura el contexto y middleware
      - local-server.ts usado al ejecutar el servidor tRPC localmente
      - **router.ts** punto de entrada del lambda handler que define todos los procedimientos
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Observemos algunos archivos clave:

```ts {5,12}
// packages/game-api/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
El enrutador define el punto de entrada de tu API tRPC y es donde declararás todos los métodos de la API. Como se ve arriba, tenemos un método llamado `echo` cuya implementación está en `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Este archivo implementa el método `echo` y define fuertemente los tipos mediante esquemas de entrada y salida.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Todos los esquemas tRPC se definen usando [Zod](https://zod.dev/) y se exportan como tipos TypeScript mediante `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

type Operations = Procedures<AppRouter>;

export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  integrations: TIntegrations;
}

export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

Este es el constructo CDK que define nuestra GameApi. El método `defaultIntegrations` crea automáticamente una función lambda para cada procedimiento de la API tRPC, apuntando al código ya empaquetado.

</Drawer>

### API de Historia

Ahora creemos nuestra API de Historia. Para esto, crearemos una API Fast llamada `StoryApi`:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi"}} noInteractive />

Verás nuevos archivos en tu árbol de directorios.
<Drawer title="Archivos actualizados por py#fast-api" trigger="Haz clic aquí para examinar estos archivos en detalle.">
Archivos clave generados por `py#fast-api`:
<FileTree>
- .venv/ entorno virtual único para el monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ 
          - apis/
            - **story-api.ts** constructo CDK para la API Fast
            - index.ts actualizado para exportar story-api
      - project.json actualizado con dependencia de build en story_api
    - types/
      - src/
        - **runtime-config.ts** actualizado con StoryApi
  - story_api/
    - story_api/ módulo Python
      - init.py configura powertools, FastAPI y middleware
      - **main.py** punto de entrada lambda con todas las rutas
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
- .python-version versión fijada de Python
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/apis/story-api.ts
// (Implementación similar a game-api.ts adaptada para Python)
```

Este constructo CDK define nuestra StoryApi, creando funciones lambda para cada operación de FastAPI.

```diff lang="ts"
// packages/common/types/src/runtime-config.ts
export type ApiUrl = string;
export interface IRuntimeConfig {
  apis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

El generador actualizó `IRuntimeConfig` para incluir StoryApi, asegurando seguridad de tipos en el frontend.

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

Aquí se definen los métodos de la API usando [Pydantic](https://docs.pydantic.dev/latest/) para seguridad de tipos.

</Drawer>

### Interfaz del Juego: Sitio Web

Creemos la interfaz de usuario con estos pasos:

<RunGenerator generator="ts#cloudscape-website" requiredParameters={{name:"GameUI"}} noInteractive />

Verás nuevos archivos en tu árbol.
<Drawer title="Archivos actualizados por ts#cloudscape-website" trigger="Haz clic para detalles.">
<FileTree>
- packages/
  - game-ui/
    - src/
      - routes/ 
        - welcome/
          - **index.tsx** componente para la ruta /welcome
</FileTree>

```tsx
// packages/game-ui/src/main.tsx
// Configuración de React con enrutamiento
```

Este componente se renderiza en la ruta `/welcome` usando enrutamiento basado en archivos.

</Drawer>

### Interfaz del Juego: Autenticación

Habilitemos autenticación con Cognito:

<RunGenerator generator="ts#cloudscape-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

<Drawer title="Archivos actualizados por autenticación" trigger="Detalles aquí.">
Se añadieron componentes para autenticación y proveedores de configuración.
</Drawer>

### Conexión UI a Story API

Conectemos la UI a Story API:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

<Drawer title="Conexión UI-FastAPI" trigger="Ver detalles.">
Se generaron hooks y proveedores para consumir la API usando TanStack Query.
</Drawer>

### Conexión UI a Game API

Conectemos la UI a Game API:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

<Drawer title="Conexión UI-tRPC" trigger="Detalles aquí.">
Integración de tRPC con React Query para acceso tipo-safe a la API.
</Drawer>

### Infraestructura del Juego

Creemos la infraestructura CDK:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

<Drawer title="Archivos de infraestructura" trigger="Examinar cambios.">
Configuración de stacks CDK con validación de reglas CloudFormation.
</Drawer>

#### Actualizar infraestructura

Actualicemos `application-stack.ts` para instanciar nuestros constructs:

<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

### Construir el código

<Drawer title="Comandos Nx" trigger="Instrucciones de construcción">
Usa `run-many` para construir todos los proyectos o objetivos específicos.

<NxCommands commands={['run-many --target build --all']} />

Alerta de sincronización TypeScript: selecciona **Sí** para actualizar referencias automáticamente.

<Aside type="caution" title="Error en Windows">
<Drawer trigger="Solución para Windows" title="Error de build en Windows">
Deshabilita temporalmente cfn-guard modificando `main.ts`.
</Drawer>
</Aside>
</Drawer>

¡Felicidades! Has creado todos los subproyectos necesarios para tu juego. 🎉🎉🎉