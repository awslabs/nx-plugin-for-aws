---
title: "Configurar un monorepo"
description: "Un tutorial de c√≥mo construir un juego de aventuras de mazmorra con IA ag√©ntica usando @aws/nx-plugin."
---

import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Tarea 1: Crear un monorepo

Para crear un nuevo monorepo, desde el directorio deseado, ejecuta el siguiente comando:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" iacProvider="CDK" />

:::note
Usamos `--iacProvider=CDK` ya que usaremos CDK para infraestructura como c√≥digo en este tutorial. El Nx Plugin para AWS tambi√©n soporta `Terraform`.
:::

Esto configurar√° un monorepo NX dentro del directorio `dungeon-adventure`. Cuando abras el directorio en VSCode, ver√°s esta estructura de archivos:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ aqu√≠ residir√°n tus subproyectos
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura el CLI de NX y los valores por defecto del monorepo
- package.json todas las dependencias de node se definen aqu√≠
- pnpm-lock.yaml o bun.lock, yarn.lock, package-lock.json seg√∫n el gestor de paquetes
- pnpm-workspace.yaml si usas pnpm
- README.md
- tsconfig.base.json todos los subproyectos basados en node extienden este
- tsconfig.json
- aws-nx-plugin.config.mts configuraci√≥n para el Nx Plugin para AWS
</FileTree>

Ahora podemos comenzar a crear nuestros diferentes subproyectos usando el `@aws/nx-plugin`.

<Aside type="tip">Es una buena pr√°ctica asegurar que todos tus archivos no preparados est√©n confirmados en Git antes de ejecutar cualquier generador. Esto te permite ver qu√© ha cambiado despu√©s de ejecutar tu generador mediante `git diff`.</Aside>

## Tarea 2: Crear una Game API

Primero, creemos nuestra Game API. Para esto, crea una API tRPC llamada `GameApi` usando estos pasos:

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

Ver√°s que aparecen algunos archivos nuevos en tu √°rbol de directorios.

<Aside>
El `package.json` ra√≠z ahora est√° configurado con un `type` de `module`, lo que significa que ESM es el tipo de m√≥dulo predeterminado para todos los subproyectos basados en node proporcionados por el `@aws/nx-plugin`.
Para m√°s detalles sobre c√≥mo trabajar con proyectos TypeScript, consulta la <Link path="guides/typescript-project">gu√≠a del generador ts#project</Link>.
</Aside>

<Drawer title="Archivos actualizados por ts#trpc-api" trigger="Haz clic aqu√≠ para examinar estos archivos en detalle.">
A continuaci√≥n se muestra una lista de todos los archivos generados por el generador `ts#trpc-api`. Examinaremos algunos de los archivos clave resaltados en el √°rbol de archivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK espec√≠ficos de la aplicaci√≥n
          - apis/
            - **game-api.ts** construct CDK para crear tu API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructs CDK gen√©ricos
          - api/
            - rest-api.ts construct base CDK para API Gateway Rest API
            - trpc-utils.ts utilidades para constructs CDK de API tRPC
            - utils.ts utilidades para constructs de API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipos compartidos
      - src/
        - index.ts
        - runtime-config.ts definici√≥n de interfaz usada tanto por CDK como por el sitio web
      - project.json
      - ...
  - game-api/ API tRPC
    - src/
      - client/ cliente vanilla t√≠picamente usado para llamadas m√°quina a m√°quina en TS
        - index.ts
        - sigv4.ts
      - middleware/ instrumentaci√≥n con powertools
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ definiciones de entradas y salidas para tu API
        - **echo.ts**
      - procedures/ implementaciones espec√≠ficas de tus procedimientos/rutas de la API
        - **echo.ts**
      - index.ts
      - init.ts configura el contexto y middleware
      - local-server.ts usado al ejecutar el servidor tRPC localmente
      - **router.ts** punto de entrada para tu lambda handler que define todos los procedimientos
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Veamos estos archivos clave:

```ts {5,12}
// packages/game-api/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
El router define el punto de entrada para tu API tRPC y es donde declarar√°s todos tus m√©todos de API. Como puedes ver arriba, tenemos un m√©todo llamado `echo` con su implementaci√≥n en el archivo `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Este archivo es la implementaci√≥n del m√©todo `echo` y como puedes ver est√° fuertemente tipado declarando sus estructuras de datos de entrada y salida.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Todas las definiciones de esquema tRPC se definen usando [Zod](https://zod.dev/) y se exportan como tipos TypeScript mediante la sintaxis `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// Tipo de uni√≥n de strings para todos los nombres de operaciones de la API
type Operations = Procedures<AppRouter>;

/**
 * Propiedades para crear un construct GameApi
 *
 * @template TIntegrations - Mapa de nombres de operaci√≥n a sus integraciones
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mapa de nombres de operaci√≥n a sus integraciones de API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un construct CDK que crea y configura una API REST de AWS API Gateway
 * espec√≠ficamente para GameApi.
 * @template TIntegrations - Mapa de nombres de operaci√≥n a sus integraciones
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integraciones predeterminadas para todas las operaciones, que implementan cada operaci√≥n como
   * su propia funci√≥n lambda individual.
   *
   * @param scope - El alcance del construct CDK
   * @returns Un IntegrationBuilder con integraciones lambda predeterminadas
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Aqu√≠ permitimos que cualquier credencial AWS de la cuenta donde se despliega el proyecto pueda llamar a la API.
          // Se puede definir acceso fino m√°quina a m√°quina aqu√≠ usando principios m√°s espec√≠ficos (ej. roles o
          // usuarios) y recursos (ej. qu√© rutas de API pueden ser invocadas por qu√© principal) si es necesario.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Abrimos OPTIONS para permitir que los navegadores hagan solicitudes preflight sin autenticar
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

Este es el construct CDK que define nuestro `GameApi`. Proporciona un m√©todo `defaultIntegrations` que autom√°ticamente crea una funci√≥n Lambda para cada procedimiento en nuestra API tRPC, apuntando a la implementaci√≥n de la API empaquetada. Esto significa que en el momento de `cdk synth`, no ocurre empaquetado (a diferencia de usar [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) ya que ya lo hemos empaquetado como parte del target de build del proyecto backend.

</Drawer>

## Tarea 3: Crear agentes de historia

Ahora creemos nuestros Story Agents.

### Agente de historia: Proyecto Python

Para crear un proyecto Python:

<RunGenerator generator="py#project" requiredParameters={{name:"story"}} noInteractive />

Ver√°s que aparecen algunos archivos nuevos en tu √°rbol de directorios.
<Drawer title="Archivos actualizados por py#project" trigger="Haz clic aqu√≠ para examinar estos archivos en detalle.">
El generador `py#project` genera estos archivos:

<FileTree>
- .venv/ entorno virtual √∫nico para el monorepo
- packages/
  - story/
    - dungeon_adventure_story/ m√≥dulo Python
      - hello.py archivo Python de ejemplo (lo ignoraremos)
    - tests/
    - .python-version
    - pyproject.toml
    - project.json
- .python-version versi√≥n de Python fijada para UV
- pyproject.toml
- uv.lock
</FileTree>

Esto ha configurado un proyecto Python y un [UV Workspace](https://docs.astral.sh/uv/concepts/projects/workspaces/) con entorno virtual compartido.

</Drawer>

### Agente de historia: Agente Strands

Para agregar un agente Strands al proyecto con el generador `py#strands-agent`:

<RunGenerator generator="py#strands-agent" requiredParameters={{project:"story"}} noInteractive />

Ver√°s que aparecen algunos archivos nuevos en tu √°rbol de directorios.
<Drawer title="Archivos actualizados por py#strands-agent" trigger="Haz clic aqu√≠ para examinar estos archivos en detalle.">
El generador `py#strands-agent` genera estos archivos:

<FileTree>
- packages/
  - story/
    - dungeon_adventure_story/ m√≥dulo Python
      - agent/
        - main.py punto de entrada para tu agente en Bedrock AgentCore Runtime
        - agent.py define un agente y herramientas de ejemplo
        - agentcore_mcp_client.py utilidad para crear clientes que interact√∫en con servidores MCP
        - Dockerfile define la imagen Docker para despliegue en AgentCore Runtime
  - common/constructs/
    - src
      - app/agents/story-agent/
        - story-agent.ts construct para desplegar tu agente Story en AgentCore Runtime
</FileTree>

Veamos algunos de los archivos en detalle:

```python
# agent/agent.py
from contextlib import contextmanager

from strands import Agent, tool
from strands_tools import current_time


# Define una herramienta personalizada
@tool
def add(a: int, b: int) -> int:
    return a + b


@contextmanager
def get_agent(session_id: str):
    yield Agent(
        system_prompt="""
Eres un mago de la suma.
Usa la herramienta 'add' para tareas de suma.
Refi√©rete a las herramientas como tu 'grimorio'.
""",
        tools=[add, current_time],
    )
```

Esto crea un agente Strands de ejemplo y define una herramienta de suma.

```python
# agent/main.py
from bedrock_agentcore.runtime import BedrockAgentCoreApp

from .agent import get_agent

app = BedrockAgentCoreApp()


@app.entrypoint
async def invoke(payload, context):
    """Manejador para invocaci√≥n del agente"""
    prompt = payload.get(
        "prompt", "No se encontr√≥ prompt en la entrada, por favor gu√≠a al usuario "
        "a crear un payload JSON con la clave prompt"
    )

    with get_agent(session_id=context.session_id) as agent:
        stream = agent.stream_async(prompt)
        async for event in stream:
            print(event)
            yield (event)


if __name__ == "__main__":
    app.run()
```

Este es el punto de entrada para el agente, configurado usando el [Amazon Bedrock AgentCore SDK](https://github.com/aws/bedrock-agentcore-sdk-python). Utiliza soporte de Strands para streaming y transmite eventos de vuelta al cliente a medida que ocurren.

```ts
// common/constructs/src/app/agents/story-agent.ts
import { Lazy, Names } from 'aws-cdk-lib';
import { Platform } from 'aws-cdk-lib/aws-ecr-assets';
import { Construct } from 'constructs';
import { execSync } from 'child_process';
import * as path from 'path';
import * as url from 'url';
import {
  AgentRuntimeArtifact,
  ProtocolType,
  Runtime,
  RuntimeProps,
} from '@aws-cdk/aws-bedrock-agentcore-alpha';

export type StoryAgentProps = Omit<
  RuntimeProps,
  'runtimeName' | 'protocolConfiguration' | 'agentRuntimeArtifact'
>;

export class StoryAgent extends Construct {
  public readonly dockerImage: AgentRuntimeArtifact;
  public readonly agentCoreRuntime: Runtime;

  constructor(scope: Construct, id: string, props?: StoryAgentProps) {
    super(scope, id);

    this.dockerImage = AgentRuntimeArtifact.fromAsset(
      path.dirname(url.fileURLToPath(new URL(import.meta.url))),
      {
        platform: Platform.LINUX_ARM64,
        extraHash: execSync(
          `docker inspect dungeon-adventure-story-agent:latest --format '{{.Id}}'`,
          { encoding: 'utf-8' },
        ).trim(),
      },
    );

    this.agentCoreRuntime = new Runtime(this, 'StoryAgent', {
      runtimeName: Lazy.string({
        produce: () =>
          Names.uniqueResourceName(this.agentCoreRuntime, { maxLength: 40 }),
      }),
      protocolConfiguration: ProtocolType.HTTP,
      agentRuntimeArtifact: this.dockerImage,
      ...props,
    });
  }
}
```

Esto configura un `AgentRuntimeArtifact` de CDK que sube tu imagen Docker del agente a ECR, y la aloja usando AgentCore Runtime.

Puedes notar un `Dockerfile` adicional, que referencia la imagen Docker del proyecto `story`, permiti√©ndonos ubicar conjuntamente el Dockerfile y el c√≥digo fuente del agente.

</Drawer>

## Tarea 4: Configurar herramientas de inventario

### Inventario: Proyecto TypeScript

Creemos un servidor MCP para proveer herramientas para que nuestro Story Agent gestione el inventario de un jugador.

Primero, creamos un proyecto TypeScript:

<RunGenerator generator="ts#project" requiredParameters={{name:"inventory"}} noInteractive />

Esto crear√° un proyecto TypeScript vac√≠o.

<Drawer title="Archivos actualizados por ts#project" trigger="Haz clic aqu√≠ para examinar estos archivos en detalle.">
El generador `ts#project` genera estos archivos.

<FileTree>
- packages/
  - inventory/
    - src/
      - index.ts punto de entrada con funci√≥n de ejemplo
    - project.json configuraci√≥n del proyecto
    - eslint.config.mjs configuraci√≥n de lint
    - vite.config.ts configuraci√≥n de pruebas
    - tsconfig.json configuraci√≥n base de TypeScript para el proyecto
    - tsconfig.lib.json configuraci√≥n de TypeScript para compilaci√≥n y empaquetado
    - tsconfig.spec.json configuraci√≥n de TypeScript para pruebas
- tsconfig.base.json actualizado para configurar un alias que otros proyectos usen para referenciar este
</FileTree>

</Drawer>

### Inventario: Servidor MCP

Luego, agregaremos un servidor MCP a nuestro proyecto TypeScript:

<RunGenerator generator="ts#mcp-server" requiredParameters={{project:"inventory"}} noInteractive />

Esto agregar√° un servidor MCP.
<Drawer title="Archivos actualizados por ts#mcp-server" trigger="Haz clic aqu√≠ para examinar estos archivos en detalle.">
El generador `ts#mcp-server` genera estos archivos.

<FileTree>
- packages/
  - inventory/
    - src/mcp-server/
      - server.ts crea el servidor MCP
      - tools/
        - add.ts herramienta de ejemplo
      - resources/
        - sample-guidance.ts recurso de ejemplo
      - stdio.ts punto de entrada para MCP con transporte STDIO
      - http.ts punto de entrada para MCP con transporte HTTP transmisible
      - Dockerfile construye la imagen para AgentCore Runtime
    - rolldown.config.ts configuraci√≥n para empaquetar el servidor MCP para despliegue en AgentCore
  - common/constructs/
    - src
      - app/mcp-servers/inventory-mcp-server/
        - inventory-mcp-server.ts construct para desplegar tu servidor MCP de inventario en AgentCore Runtime
</FileTree>

</Drawer>

## Tarea 5: Crear la Interfaz de Usuario (UI)

En esta tarea, crearemos la UI que te permitir√° interactuar con el juego.

### Interfaz del Juego: Sitio Web

Para crear la UI, crea un sitio web llamado `GameUI` usando estos pasos:

<RunGenerator generator="ts#react-website" requiredParameters={{name:"GameUI"}} noInteractive />

Ver√°s que aparecen algunos archivos nuevos en tu √°rbol de directorios.

<Drawer title="Archivos actualizados por ts#react-website" trigger="Haz clic aqu√≠ para examinar estos archivos en detalle.">
El generador `ts#react-website` genera estos archivos. Examinemos algunos de los archivos clave resaltados en el √°rbol de archivos:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK espec√≠ficos de la aplicaci√≥n
          - static-websites/
            - **game-ui.ts** construct CDK para crear tu Game UI
        - core/
          - static-website.ts construct gen√©rico para sitio web est√°tico
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts dise√±o general de p√°gina: encabezado, pie, barra lateral, etc
          - navitems.ts elementos de navegaci√≥n de la barra lateral
      - hooks/
        - useAppLayout.tsx permite configurar din√°micamente notificaciones, estilo de p√°gina, etc
      - routes/ rutas basadas en @tanstack/react-router
        - index.tsx p√°gina ra√≠z '/' redirige a '/welcome'
        - __root.tsx todas las p√°ginas usan este componente como base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** punto de entrada de React
        - routeTree.gen.ts este archivo se actualiza autom√°ticamente por @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteName: 'GameUI',
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Este es el construct CDK que define nuestro GameUI. Ya ha configurado la ruta al bundle generado para nuestra UI basada en Vite. Esto significa que en el momento de `build`, el empaquetado ocurre dentro del target de build del proyecto game-ui y la salida se usa aqu√≠.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Registra la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Este es el punto de entrada donde se monta React. Como se muestra, inicialmente solo configura un `@tanstack/react-router` en una configuraci√≥n de [`enrutamiento basado en archivos`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Mientras tu servidor de desarrollo est√© ejecut√°ndose, puedes crear archivos dentro de la carpeta `routes` y `@tanstack/react-router` crear√° la configuraci√≥n de archivos necesaria y actualizar√° el archivo `routeTree.gen.ts`. Este archivo mantiene todas las rutas de manera type-safe, lo que significa que cuando usas `<Link>`, la opci√≥n `to` solo mostrar√° rutas v√°lidas.
Para m√°s informaci√≥n, consulta la [documentaci√≥n de `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un componente se renderizar√° al navegar a la ruta `/welcome`. `@tanstack/react-router` gestionar√° la `Route` por ti cuando crees/muevas este archivo (siempre que el servidor de desarrollo est√© ejecut√°ndose).

</Drawer>

### Interfaz del Juego: Autenticaci√≥n

Configuremos nuestra Game UI para requerir acceso autenticado mediante Amazon Cognito usando estos pasos:

<RunGenerator generator="ts#react-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Ver√°s que aparecen/cambian algunos archivos nuevos en tu √°rbol de directorios.

<Drawer title="Archivos actualizados por ts#react-website#auth" trigger="Haz clic aqu√≠ para examinar estos archivos en detalle.">
El generador `ts#react-website#auth` actualiza/genera estos archivos. Examinemos algunos de los archivos clave resaltados en el √°rbol de archivos:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts construct CDK para crear pools de usuarios/identidad
    - types/
      - src/
        - runtime-config.ts actualizado para agregar cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx agrega el usuario conectado/cierre de sesi√≥n al encabezado
        - CognitoAuth/
          - index.ts gestiona el inicio de sesi√≥n en Cognito
        - RuntimeConfig/
          - index.tsx obtiene el `runtime-config.json` y lo provee a los hijos v√≠a contexto
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Actualizado para agregar Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Los componentes `RuntimeConfigProvider` y `CognitoAuth` han sido agregados al archivo `main.tsx` mediante una transformaci√≥n AST. Esto permite que el componente `CognitoAuth` se autentique con Amazon Cognito obteniendo el `runtime-config.json` que contiene la configuraci√≥n de conexi√≥n a Cognito necesaria para realizar las llamadas al backend al destino correcto.

</Drawer>

### Interfaz del Juego: Conectar a Game API

Configuremos nuestra Game UI para conectarse a nuestra Game API creada previamente.

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

Ver√°s que aparecen/cambian algunos archivos nuevos en tu √°rbol de directorios.

<Drawer title="Archivos actualizados por la conexi√≥n UI -> tRPC" trigger="Haz clic aqu√≠ para examinar estos archivos en detalle.">
El generador `api-connection` genera/actualiza estos archivos. Examinemos algunos de los archivos clave resaltados en el √°rbol de archivos:

<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx configura el cliente de GameAPI
      - hooks/
        - **useGameApi.tsx** hooks para llamar a la GameApi
      - **main.tsx** inyecta los proveedores del cliente trpc
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { GameApiTRCPContext } from '../components/GameApiClientProvider';

export const useGameApi = GameApiTRCPContext.useTRPC;
```

Este hook usa la √∫ltima [integraci√≥n de React Query de tRPC](https://trpc.io/blog/introducing-tanstack-react-query-client) permitiendo a los usuarios interactuar con `@tanstack/react-query` directamente sin capas adicionales de abstracci√≥n. Para ejemplos de c√≥mo llamar a APIs tRPC, consulta la <Link path="guides/api-connection/react-trpc#using-the-generated-code">gu√≠a de uso del hook tRPC</Link>.

<Aside>
El hook `useGameApi` es diferente al hook `useStoryApi` ya que no requiere un build para que los cambios se reflejen gracias al uso de [inferencia de TypeScript](https://trpc.io/docs/concepts) por parte de tRPC. Esto permite a los desarrolladores hacer cambios en su backend que se reflejan instant√°neamente en su frontend.
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <RouterProvider router={router} />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

El archivo `main.tsx` ha sido actualizado mediante una transformaci√≥n AST para inyectar los proveedores de tRPC.

</Drawer>

### Interfaz del Juego: Infraestructura

Creemos el √∫ltimo subproyecto para la infraestructura CDK.

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Ver√°s que aparecen/cambian algunos archivos nuevos en tu √°rbol de directorios.

<Drawer title="Archivos actualizados por ts#infra" trigger="Haz clic aqu√≠ para examinar estos archivos en detalle.">
El generador `ts#infra` genera/actualiza estos archivos. Examinemos algunos de los archivos clave resaltados en el √°rbol de archivos:

<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - checkov.ts
          - index.ts
  - infra
    - src/
      - stages/
        - **application-stage.ts** stacks CDK definidos aqu√≠
      - stacks/
        - **application-stack.ts** recursos CDK definidos aqu√≠
      - index.ts
      - **main.ts** punto de entrada que define todas las etapas
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json agregadas referencias
  - tsconfig.base.json agregado alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStage } from './stacks/application-stage.js';
import { App } from ':dungeon-adventure/common-constructs';

const app = new App();

// Usa esto para desplegar tu propio entorno sandbox (asume tus credenciales CLI)
new ApplicationStage(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
});

app.synth();
```

<Aside type="tip">Si ves un error de importaci√≥n en tu IDE, es porque nuestro proyecto de infraestructura a√∫n no tiene una referencia TypeScript configurada en el `tsconfig.json`. Nx ha sido [configurado](https://nx.dev/nx-api/js/generators/typescript-sync) para crear estas referencias *din√°micamente* cuando se ejecuta un build/compile o si ejecutas el comando `nx sync` manualmente. Para m√°s informaci√≥n consulta la <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">gu√≠a de TypeScript</Link>.</Aside>

Este es el punto de entrada para tu aplicaci√≥n CDK.

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // El c√≥digo que define tu stack va aqu√≠
  }
}
```

Instanciaremos nuestros constructs CDK para construir nuestro juego de aventuras.

</Drawer>

## Tarea 6: Actualizar nuestra infraestructura

Actualicemos `packages/infra/src/stacks/application-stack.ts` para instanciar algunos de nuestros constructs generados:

<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

:::note
Proveemos integraciones predeterminadas para nuestra Game API. Por defecto, cada operaci√≥n en nuestra API se mapea a una funci√≥n Lambda individual para manejar esa operaci√≥n.
:::

## Tarea 7: Construir el c√≥digo

<Drawer title="Comandos de Nx" trigger="Ahora es momento de construir nuestro c√≥digo por primera vez">

###### Targets √∫nicos vs m√∫ltiples

El comando `run-many` ejecutar√° un target en m√∫ltiples subproyectos listados (`--all` los seleccionar√° todos). Esto asegura que las dependencias se ejecuten en el orden correcto.

Tambi√©n puedes disparar un build (o cualquier otra tarea) para un target de proyecto √∫nico ejecutando el target directamente en el proyecto. Por ejemplo, para construir el proyecto `@dungeon-adventure/infra`, ejecuta el siguiente comando:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />

Tambi√©n puedes omitir el scope y usar la sintaxis abreviada de Nx si prefieres:

<NxCommands commands={['build infra']} />

###### Visualizando tus dependencias

Para visualizar tus dependencias, ejecuta:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Cach√©

Nx depende del [caching](https://nx.dev/concepts/how-caching-works) para reutilizar artefactos de builds previos y acelerar el desarrollo. Se requiere cierta configuraci√≥n para que esto funcione correctamente y puede haber casos donde quieras realizar un build **sin usar la cach√©**. Para eso, simplemente agrega el argumento `--skip-nx-cache` a tu comando. Por ejemplo:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Si por alguna raz√≥n quisieras limpiar tu cach√© (almacenada en la carpeta `.nx`), puedes ejecutar el siguiente comando:

<NxCommands commands={['reset']} />

</Drawer>

Usando la l√≠nea de comandos, ejecuta el siguiente comando para corregir primero cualquier error de lint:

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />

Luego, ejecuta el siguiente comando para un build completo:

<NxCommands commands={['run-many --target build --all']} />

Se te solicitar√° lo siguiente:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? ‚Ä¶
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Este mensaje indica que NX ha detectado algunos archivos que pueden actualizarse autom√°ticamente. En este caso, se refiere a los archivos `tsconfig.json` que no tienen referencias de proyecto configuradas en proyectos dependientes.

Selecciona la opci√≥n **Yes, sync the changes and run the tasks** para continuar. Deber√≠as notar que todos los errores de importaci√≥n en tu IDE se resuelven autom√°ticamente, ya que el generador de sync agregar√° las referencias TypeScript faltantes autom√°ticamente.

Todos los artefactos construidos est√°n ahora disponibles dentro de la carpeta `dist/` ubicada en la ra√≠z del monorepo. Esta es una pr√°ctica est√°ndar cuando se usan proyectos generados por el `@aws/nx-plugin` ya que no contamina tu √°rbol de archivos con archivos generados. En caso de que quieras limpiar tus archivos, elimina la carpeta `dist/` sin preocuparte por artefactos de build esparcidos por el √°rbol de directorios.

¬°Felicidades! Has creado todos los subproyectos requeridos para comenzar a implementar el n√∫cleo de nuestro juego AI Dungeon Adventure.  üéâüéâüéâ