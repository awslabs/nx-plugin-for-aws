---
title: "Juego de Mazmorra con IA"
description: "Un tutorial de cómo construir un juego de aventuras de mazmorra con IA utilizando el @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Módulo 1: Configurar tu Monorepositorio

Comienza creando un nuevo monorepositorio. Un monorepositorio es un único repositorio que contiene múltiples proyectos distintos, con relaciones bien definidas.

Dentro del directorio deseado, ejecuta el siguiente comando:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

Esto configurará un monorepositorio NX dentro del directorio `dungeon-adventure`.
Abre el directorio en VSCode. Verás la siguiente estructura de archivos:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ aquí residirán tus subproyectos
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura el CLI de Nx y los valores por defecto del monorepositorio
- package.json todas las dependencias de node se definen aquí
- pnpm-lock.yaml o bun.lock, yarn.lock, package-lock.json según el gestor de paquetes
- pnpm-workspace.yaml si usas pnpm
- README.md
- tsconfig.base.json todos los subproyectos basados en node extienden este
- tsconfig.json
</FileTree>

Antes de agregar componentes del `@aws/nx-plugin` al monorepositorio, debemos instalarlo como dependencia de desarrollo.
Para esto, ejecuta el siguiente comando en la raíz del monorepositorio `dungeon-adventure`:

<InstallCommand dev pkg="@aws/nx-plugin" />

Ahora estamos listos para comenzar a crear nuestros diferentes subproyectos usando el `@aws/nx-plugin`.

<Aside type="tip">Recomendamos hacer commit de tus archivos no stageados en Git antes de ejecutar cualquier generador. Esto te permite ver qué ha cambiado después de ejecutar tu generador mediante `git diff`.</Aside>

### Generar la API del Juego

Comenzaremos creando nuestra API del Juego. Esta API se usa para gestionar el estado del juego.
Para hacerlo, crea una API tRPC llamada `GameApi` siguiendo estos pasos:

<RunGenerator generator="ts#trpc-api" requiredParameters={{apiName:"GameApi"}} noInteractive />

<br />

Verás nuevos archivos aparecer en tu árbol de archivos.

<Drawer title="Archivos actualizados por ts#trpc-api" trigger="Haz clic para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados por el generador `ts#trpc-api`. Vamos a examinar algunos de los archivos clave resaltados en el árbol:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK específicos de la aplicación
          - http-apis/
            - **game-api.ts** construct CDK para crear tu API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructs CDK genéricos
          - http-api.ts construct base para una API HTTP
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipos compartidos
      - src/
        - index.ts
        - runtime-config.ts definición de interfaz usada por CDK y el sitio web
      - project.json
      - ...
  - game-api/
    - backend/ código de implementación tRPC
      - src/
        - client/ cliente vanilla típicamente usado para llamadas máquina a máquina
          - index.ts
          - sigv4.ts
        - middleware/ instrumentación powertools
          - error.ts
          - index.ts
          - logger.ts
          - metrics.ts
          - tracer.ts
        - procedures/ implementaciones específicas para tus procedimientos/rutas de API
          - **echo.ts**
        - index.ts
        - init.ts configura el contexto y middleware
        - local-server.ts usado al ejecutar el servidor tRPC localmente
        - **router.ts** punto de entrada para tu lambda handler que define todos los procedimientos
      - project.json
      - ...
    - schema/
      - src/
        - procedures/
          - **echo.ts**
        - index.ts
      - project.json
      - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Veamos estos archivos clave:

```ts {5,12}
// packages/game-api/backend/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>,
  ) => ctx,
});

export type AppRouter = typeof appRouter;
```
El router define el punto de entrada para tu API tRPC y es donde declararás todos tus métodos de API.
Tenemos un método llamado `echo` con su implementación en el archivo `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/backend/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from ':dungeon-adventure/game-api-schema';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Este archivo es la implementación del método `echo`, fuertemente tipado al declarar sus estructuras de datos de entrada y salida. Importa estas definiciones del proyecto `:dungeon-adventure/game-api-schema` que es un [alias](https://www.typescriptlang.org/tsconfig/paths.html) para el proyecto de esquema.

<Aside type="tip">Si ves un error de importación en tu IDE, puede ser porque el backend aún no tiene configurada una referencia de TypeScript en su `tsconfig.json`. Nx ha sido [configurado](https://nx.dev/nx-api/js/generators/typescript-sync) para crear estas referencias *dinámicamente* cuando se ejecuta un build/compile, o si ejecutas manualmente el comando `nx sync`. Para más información consulta la <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guía de TypeScript</Link>.</Aside>

```ts
// packages/game-api/schema/src/procedures/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Todas las definiciones de esquema tRPC se definen usando [Zod](https://zod.dev/), y se exportan como tipos TypeScript mediante la sintaxis `z.TypeOf`.

```ts
// packages/common/constructs/src/app/http-apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import { HttpApi } from '../../core/http-api.js';
import { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';
import { Runtime } from 'aws-cdk-lib/aws-lambda';

export class GameApi extends HttpApi {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      defaultAuthorizer: new HttpIamAuthorizer(),
      apiName: 'GameApi',
      runtime: Runtime.NODEJS_LATEST,
      handler: 'index.handler',
      handlerFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-api/backend/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Este es el construct CDK que define nuestro GameAPI. Ha configurado la ruta del archivo handler al bundle generado para nuestra implementación backend tRPC, para que en tiempo de `cdk synth` no ocurra bundling (a diferencia de usar [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)), ya que ya lo hemos empaquetado como parte del target build del proyecto backend.

</Drawer>

<Aside>
El `package.json` raíz ahora está configurado con un `type` de `module`, lo que significa que ESM es el tipo de módulo predeterminado para todos los subproyectos basados en node provistos por el `@aws/nx-plugin`. Para más detalles sobre trabajar con proyectos TypeScript, consulta la <Link path="guides/typescript-project">guía ts#project</Link>.
</Aside>

### Generar la API de Historia

A continuación, creemos nuestra API de Historia usando el generador FastAPI. La API de Historia se usa con respuestas en streaming para generación de historias, usando Amazon Bedrock.
Para hacerlo, crea una API Fast llamada `StoryApi` siguiendo estos pasos:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi"}} noInteractive />

Verás nuevos archivos aparecer en tu árbol de archivos.

<Drawer title="Archivos actualizados por py#fast-api" trigger="Haz clic aquí para examinar estos archivos en más detalle.">
Esta es una lista de todos los archivos generados por el generador `py#fast-api`. Examinemos algunos archivos clave resaltados en el árbol:
<FileTree>
- .venv/ entorno virtual único para el monorepositorio
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK específicos de la aplicación
          - http-apis/
            - **story-api.ts** construct CDK para crear tu API Fast
            - index.ts actualizado para exportar el nuevo story-api
      - project.json actualizado para agregar una dependencia de build en story_api
    - types/ tipos compartidos
      - src/
        - **runtime-config.ts** actualizado para agregar StoryApi
  - story_api/
    - story_api/ módulo Python
      - init.py configura powertools, FastAPI y middleware
      - **main.py** punto de entrada para la lambda que contiene todas las rutas
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version versión Python fijada por uv
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/http-apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import { HttpApi } from '../../core/http-api.js';
import { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';
import { Runtime } from 'aws-cdk-lib/aws-lambda';

export class StoryApi extends HttpApi {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      defaultAuthorizer: new HttpIamAuthorizer(),
      apiName: 'StoryApi',
      runtime: Runtime.PYTHON_3_12,
      handler: 'story_api.main.handler',
      handlerFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/story_api/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Este es el construct CDK que define nuestro StoryApi. Configura la ruta del archivo handler al bundle generado para nuestra implementación backend Fast API. Esto significa que en tiempo de `cdk synth` no ocurre bundling (a diferencia de [PythonFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/@aws-cdk_aws-lambda-python-alpha.PythonFunction.html)) ya que ya lo hemos empaquetado como parte del target build del proyecto backend.

```diff lang="ts"
// packages/common/types/src/runtime-config.ts
export type ApiUrl = string;
// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-empty-interface
export interface IRuntimeConfig {
  httpApis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

Aquí vemos un ejemplo del generador realizando una transformación AST que preserva todo el código existente y realiza una actualización. Aquí puedes ver que `StoryApi` fue agregado a la definición `IRuntimeConfig`, lo que significa que cuando esto sea consumido por nuestro frontend, ¡impondrá seguridad de tipos!

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

Aquí es donde se definirán todos tus métodos de API. Como puedes ver aquí, tenemos un método `read_root` mapeado a la ruta `GET /`. Puedes usar [Pydantic](https://docs.pydantic.dev/latest/) para declarar las entradas y salidas de tus métodos y garantizar seguridad de tipos.

</Drawer>

### Agregar la interfaz de usuario del juego

Para interactuar con el juego, crea la UI usando el generador de sitios web CloudScape.
Para hacerlo, crea un sitio web llamado `GameUI` siguiendo estos pasos:

<RunGenerator generator="ts#cloudscape-website" requiredParameters={{name:"GameUI"}} noInteractive />

Verás nuevos archivos aparecer en tu árbol de archivos.

<Drawer title="Archivos actualizados por ts#cloudscape-website" trigger="Haz clic aquí para examinar estos archivos en más detalle.">
A continuación se muestra una lista de todos los archivos generados por el generador `ts#cloudscape-website`. Examinemos algunos archivos clave resaltados en el árbol:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK específicos de la aplicación
          - static-websites/
            - **game-ui.ts** construct CDK para crear tu Game UI
        - core/
          - static-website.ts construct genérico para sitios estáticos
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts diseño general de página: encabezado, pie, barra lateral, etc.
          - navitems.ts elementos de navegación de la barra lateral
      - hooks/
        - useAppLayout.tsx permite configurar dinámicamente notificaciones, estilo de página, etc.
      - routes/ rutas basadas en archivos de @tanstack/react-router
        - index.tsx página raíz '/' redirige a '/welcome'
        - __root.tsx todas las páginas usan este componente como base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** punto de entrada de React
        - routeTree.gen.ts este archivo se actualiza automáticamente por @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Este es el construct CDK que define nuestro GameUI. Como puedes ver, ya ha configurado la ruta al bundle generado para nuestra UI basada en Vite. Esto significa que en tiempo de `build`, el bundling ocurre dentro del target build del proyecto game-ui y su salida se usa aquí.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Registrar la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Este es el punto de entrada donde se monta React. Como se muestra, inicialmente solo configura un `@tanstack/react-router` en una configuración de [`enrutamiento-basado-en-archivos`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Esto significa que, mientras tu servidor de desarrollo esté en ejecución, puedes simplemente crear archivos dentro de la carpeta `routes` y `@tanstack/react-router` creará la configuración boilerplate por ti junto con actualizar el archivo `routeTree.gen.ts`. Este archivo mantiene todas las rutas de manera type-safe, lo que significa que cuando uses `<Link>`, la opción `to` solo mostrará rutas válidas. Para más información, consulta la documentación de [`@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>¡Bienvenido a tu nuevo sitio web Cloudscape!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un componente que se renderizará al navegar a la ruta `/welcome`. `@tanstack/react-router` gestionará la `Route` por ti cuando crees/muevas este archivo (siempre que el servidor de desarrollo esté en ejecución). Esto se mostrará en una sección posterior de este tutorial.

</Drawer>

### Agregar autenticación a la interfaz de usuario

Para configurar nuestra Game UI con acceso autenticado vía Amazon Cognito, usa estos pasos:

<RunGenerator generator="ts#cloudscape-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Verás nuevos archivos aparecer en tu árbol de archivos.

<Drawer title="Archivos actualizados por ts#cloudscape-website#auth" trigger="Haz clic aquí para examinar estos archivos en más detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `ts#cloudscape-website#auth`. Examinemos algunos archivos clave resaltados en el árbol:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts construct CDK para crear pools de usuarios/identidad
    - types/
      - src/
        - runtime-config.ts actualizado para agregar cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx agrega el usuario logueado/logout al encabezado
        - CognitoAuth/
          - index.ts gestiona el login en Cognito
        - RuntimeConfig/
          - index.tsx obtiene el `runtime-config.json` y lo provee a los hijos mediante contexto
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Actualizado para agregar Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registrar la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Los componentes `RuntimeConfigProvider` y `CognitoAuth` han sido agregados al archivo `main.tsx` mediante una transformación AST. Esto permite que el componente `CognitoAuth` se autentique con Amazon Cognito obteniendo el `runtime-config.json` que contiene la configuración de conexión requerida para realizar llamadas al backend al destino correcto.

</Drawer>

### Configurar Game UI para conectarse a la API de Historia

Para configurar nuestra Game UI para conectarse a nuestra API de Historia previamente creada, usa estos pasos:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

Verás nuevos archivos aparecer en tu árbol de archivos.

<Drawer title="Archivos actualizados por la conexión UI -> FastAPI" trigger="Haz clic aquí para examinar estos archivos en más detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `api-connection`. Examinemos algunos archivos clave resaltados en el árbol:
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx usado por StoryApi para firmar requests
        - useStoryApiClient.tsx hook para construir un cliente StoryApi
        - useStoryApi.tsx hook para interactuar con StoryApi usando TanStack Query
      - components/
        - QueryClientProvider.tsx proveedor del cliente TanStack Query
        - StoryApiProvider.tsx Proveedor para el hook TanStack Query de StoryApi
      - main.tsx Instrumentar QueryClientProvider y StoryApiProvider
    - .gitignore ignorar archivos cliente generados
    - project.json actualizado para agregar targets para generar hooks openapi
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json actualizado para emitir un archivo openapi.json

</FileTree>

```tsx {1,12-15}
// packages/game-ui/src/hooks/useStoryApiClient.tsx
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.httpApis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

Puedes usar este hook para hacer requests autenticadas a la `StoryApi`. Usa el `StoryApi` que se genera en tiempo de build, y verás un error en tu IDE hasta que compilemos nuestro código. Para más detalles sobre cómo se genera el cliente o cómo consumir la API, consulta la <Link path="guides/api-connection/react-fastapi">guía de React a FastAPI</Link>.

```tsx
// packages/game-ui/src/components/StoryApiProvider.tsx
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useStoryApiClient } from '../hooks/useStoryApiClient';
import { StoryApiOptionsProxy } from '../generated/story-api/options-proxy.gen';

export const StoryApiContext = createContext<StoryApiOptionsProxy | undefined>(
  undefined,
);

export const StoryApiProvider: FC<PropsWithChildren> = ({ children }) => {
  const client = useStoryApiClient();
  const optionsProxy = useMemo(
    () => new StoryApiOptionsProxy({ client }),
    [client],
  );

  return (
    <StoryApiContext.Provider value={optionsProxy}>
      {children}
    </StoryApiContext.Provider>
  );
};

export default StoryApiProvider;
```

El componente proveedor anterior usa el hook `useStoryApiClient` e instancia el `StoryApiOptionsProxy`, que se usa para construir opciones para los hooks de TanStack Query. Puedes usar el hook correspondiente `useStoryApi` para acceder a este proxy de opciones, que proporciona una manera de interactuar con tu FastAPI de forma consistente con tu API tRPC.

Dado que `useStoryApiClient` nos provee un iterador asíncrono para nuestra API de streaming, en este tutorial simplemente usaremos el cliente vanilla directamente.

<Aside type="caution">
Los archivos `src/generated/story-api/*.gen.ts` nunca deben modificarse manualmente ya que se regenerarán cada vez que construyas tu API.
</Aside>

</Drawer>

### Configurar Game UI para conectarse a la API del Juego

Para configurar nuestra Game UI para conectarse a nuestra API del Juego, usa estos pasos:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api-backend"}} noInteractive />

Deberías ver algunos archivos nuevos haber aparecido/cambiado en tu árbol de archivos.

<Drawer title="Archivos actualizados por la conexión UI -> tRPC" trigger="Haz clic aquí para examinar estos archivos en más detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `api-connection`. Examinemos algunos archivos clave resaltados en el árbol:
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - TrpcClients/
          - index.tsx
          - TrpcApis.tsx todas las APIs tRPC configuradas
          - TrpcClientProviders.tsx crea un proveedor de cliente por API tRPC
          - TrpcProvider.tsx
      - hooks/
        - **useGameApi.tsx** hooks para llamar a la GameApi
      - **main.tsx** inyecta los proveedores de clientes trpc
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { TrpcApis } from '../components/TrpcClients';

export const useGameApi = () => TrpcApis.GameApi.useTRPC();
```

Este hook usa la última [integración React Query de tRPC](https://trpc.io/blog/introducing-tanstack-react-query-client) permitiendo a los usuarios interactuar con `@tanstack/react-query` directamente sin capas adicionales de abstracción. Para ejemplos de cómo llamar APIs tRPC, consulta la <Link path="guides/api-connection/react-trpc#using-the-generated-code">guía de uso del hook tRPC</Link>.

<Aside>
El hook `useGameApi` es diferente al hook `useStoryApi` ya que no requiere un build para que los cambios se reflejen gracias al uso de [inferencia de TypeScript](https://trpc.io/docs/concepts) por parte de tRPC. ¡Esto permite a los desarrolladores hacer cambios en su backend que se reflejan instantáneamente en su frontend!
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import TrpcClientProviders from './components/TrpcClients';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registrar la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <TrpcClientProviders>
                <RouterProvider router={router} />
+              </TrpcClientProviders>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

El archivo `main.tsx` ha sido actualizado mediante una transformación AST para inyectar los proveedores tRPC.

</Drawer>

### Crear infraestructura CDK para la interfaz de usuario

Para crear la infraestructura CDK como subproyecto final, usa estos pasos:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Deberías ver algunos archivos nuevos haber aparecido/cambiado en tu árbol de archivos.

<Drawer title="Archivos actualizados por ts#infra" trigger="Haz clic aquí para examinar estos archivos en más detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `ts#infra`. Examinemos algunos archivos clave resaltados en el árbol:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts** recursos CDK definidos aquí
      - index.ts
      - **main.ts** punto de entrada que define todos los stacks
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json agregar referencias
  - tsconfig.base.json agregar alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
  App,
  CfnGuardValidator,
  RuleSet,
} from ':dungeon-adventure/common-constructs';

const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

// Usa esto para desplegar tu propio entorno sandbox (asume tus credenciales CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

Este es el punto de entrada para tu aplicación CDK. Está configurado para usar [`cfn-guard`](https://github.com/cdklabs/cdk-validator-cfnguard) para ejecutar validación de infraestructura basada en el conjunto de reglas configurado. Esto se instrumenta post síntesis.

<Aside type="tip">
Puede haber casos donde quieras suprimir ciertas reglas en recursos. Puedes hacerlo de dos maneras:

###### Suprimir una regla en un construct dado

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// suprime la RULE_NAME para el construct dado.
suppressRule(construct, 'RULE_NAME');
```

###### Suprimir una regla en un construct descendiente

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// Suprime la RULE_NAME para el construct o cualquiera de sus descendientes si es instancia de Bucket
suppressRule(construct, 'RULE_NAME', (construct) => construct instanceof Bucket);
```
</Aside>

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // El código que define tu stack va aquí
  }
}
```

Aquí es donde instanciamos nuestros constructs CDK para construir nuestro juego de aventuras dungeon.

</Drawer>

#### Actualizar infraestructura CDK

Para instanciar algunos de nuestros constructs ya generados, actualicemos nuestro `packages/infra/src/stacks/application-stack.ts`:

```diff lang="ts"
+import {
+  GameApi,
+  GameUI,
+  StoryApi,
+  UserIdentity,
+} from ':dungeon-adventure/common-constructs';
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

-    // El código que define tu stack va aquí
+    const userIdentity = new UserIdentity(this, 'UserIdentity');
+
+    const gameApi = new GameApi(this, 'GameApi');
+    const storyApi = new StoryApi(this, 'StoryApi');
+
+    // otorgar a nuestro rol autenticado acceso para invocar nuestras APIs
+    [storyApi, gameApi].forEach((api) =>
+      api.grantInvokeAccess(userIdentity.identityPool.authenticatedRole),
+    );
+
+    // Asegurar que esto se instancie al final para que nuestro runtime-config.json se configure automáticamente
+    new GameUI(this, 'GameUI');
  }
}

```

### Construyendo nuestro código

<Drawer title="Comandos Nx" trigger="Ahora es momento de construir nuestro código por primera vez">
###### Targets únicos vs múltiples

El comando `run-many` ejecutará un target en múltiples subproyectos listados (`--all` los seleccionará todos). Se asegurará que las dependencias se ejecuten en el orden correcto.

También puedes disparar un build (o cualquier otra tarea) para un target de proyecto único ejecutando el target en el proyecto directamente. Por ejemplo, si queremos construir el proyecto `@dungeon-adventure/infra`, puedes ejecutar:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualizando tus dependencias

También puedes visualizar tus dependencias vía:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Caché

Nx depende del [caché](https://nx.dev/concepts/how-caching-works) para que puedas reutilizar artefactos de builds previos y acelerar el desarrollo. Se requiere cierta configuración para que esto funcione correctamente y puede haber casos donde quieras realizar un build **sin usar el caché**. Para eso, simplemente agrega el argumento `--skip-nx-cache` a tu comando. Por ejemplo:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Si por alguna razón quisieras borrar tu caché (almacenado en la carpeta `.nx`), puedes ejecutar:

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

Se te presentará lo siguiente:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? …
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Este mensaje indica que NX ha detectado algunos archivos que pueden actualizarse automáticamente. En este caso, se refiere a los archivos `tsconfig.json` que no tienen referencias de TypeScript configuradas en proyectos dependientes. Selecciona la opción **Yes, sync the changes and run the tasks** para proceder. Deberías notar que todos los errores de importación en tu IDE se resuelven automáticamente, ¡ya que el generador sync agregará las referencias faltantes de TypeScript!

<Aside type="tip">
Si encuentras errores de lint, puedes ejecutar el siguiente comando para corregirlos automáticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

<Aside type="caution" title="Fallo de build en Windows">
<Drawer trigger="Si estás en Windows y encuentras un error de build, haz clic aquí." title="Fallo de build en Windows">
Si encuentras un error de build/synth para el proyecto `@dungeon-adventure/infra`, esto es esperado ya que la librería que instrumenta `cfn-guard` actualmente no soporta Windows. Hay una solicitud de feature siguiendo esto, pero mientras tanto podemos simplemente deshabilitar `cfn-guard` modificando el archivo `packages/infra/src/main.ts` así:

```diff lang="ts"
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
   App,
-  CfnGuardValidator,
-  RuleSet,
} from ':dungeon-adventure/common-constructs';
-
-const app = new App({
-  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
-});
+const app = new App();

// Usa esto para desplegar tu propio entorno sandbox (asume tus credenciales CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```
</Drawer>
</Aside>

Todos los artefactos construidos están ahora disponibles dentro de la carpeta `dist/` ubicada en la raíz del monorepositorio. Esta es una práctica estándar cuando se usan proyectos generados por el `@aws/nx-plugin` para no mezclar tu árbol de archivos con archivos generados. Si quieres limpiar tus archivos, borra la carpeta `dist/` sin preocuparte por archivos generados esparcidos por todo el árbol.

¡Felicitaciones! Has creado todos los subproyectos requeridos para comenzar a implementar el núcleo de nuestro juego Dunegeon Adventure.  🎉🎉🎉