---
title: "Juego de Mazmorra con IA"
description: "Un tutorial de c√≥mo construir un juego de aventuras de mazmorra con IA utilizando el @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## M√≥dulo 1: Configurar tu Monorepositorio

Comienza creando un nuevo monorepositorio. Un monorepositorio es un √∫nico repositorio que contiene m√∫ltiples proyectos distintos, con relaciones bien definidas.

Dentro del directorio deseado, ejecuta el siguiente comando:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

Esto configurar√° un monorepositorio NX dentro del directorio `dungeon-adventure`.
Abre el directorio en VSCode. Ver√°s la siguiente estructura de archivos:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ aqu√≠ residir√°n tus subproyectos
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura el CLI de Nx y los valores por defecto del monorepositorio
- package.json todas las dependencias de node se definen aqu√≠
- pnpm-lock.yaml o bun.lock, yarn.lock, package-lock.json seg√∫n el gestor de paquetes
- pnpm-workspace.yaml si usas pnpm
- README.md
- tsconfig.base.json todos los subproyectos basados en node extienden este
- tsconfig.json
</FileTree>

Antes de agregar componentes del `@aws/nx-plugin` al monorepositorio, debemos instalarlo como dependencia de desarrollo.
Para esto, ejecuta el siguiente comando en la ra√≠z del monorepositorio `dungeon-adventure`:

<InstallCommand dev pkg="@aws/nx-plugin" />

Ahora estamos listos para comenzar a crear nuestros diferentes subproyectos usando el `@aws/nx-plugin`.

<Aside type="tip">Recomendamos hacer commit de tus archivos no stageados en Git antes de ejecutar cualquier generador. Esto te permite ver qu√© ha cambiado despu√©s de ejecutar tu generador mediante `git diff`.</Aside>

### Generar la API del Juego

Comenzaremos creando nuestra API del Juego. Esta API se usa para gestionar el estado del juego.
Para hacerlo, crea una API tRPC llamada `GameApi` siguiendo estos pasos:

<RunGenerator generator="ts#trpc-api" requiredParameters={{apiName:"GameApi"}} noInteractive />

<br />

Ver√°s nuevos archivos aparecer en tu √°rbol de archivos.

<Drawer title="Archivos actualizados por ts#trpc-api" trigger="Haz clic para examinar estos archivos en detalle.">
A continuaci√≥n se muestra una lista de todos los archivos generados por el generador `ts#trpc-api`. Vamos a examinar algunos de los archivos clave resaltados en el √°rbol:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK espec√≠ficos de la aplicaci√≥n
          - http-apis/
            - **game-api.ts** construct CDK para crear tu API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructs CDK gen√©ricos
          - http-api.ts construct base para una API HTTP
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipos compartidos
      - src/
        - index.ts
        - runtime-config.ts definici√≥n de interfaz usada por CDK y el sitio web
      - project.json
      - ...
  - game-api/
    - backend/ c√≥digo de implementaci√≥n tRPC
      - src/
        - client/ cliente vanilla t√≠picamente usado para llamadas m√°quina a m√°quina
          - index.ts
          - sigv4.ts
        - middleware/ instrumentaci√≥n powertools
          - error.ts
          - index.ts
          - logger.ts
          - metrics.ts
          - tracer.ts
        - procedures/ implementaciones espec√≠ficas para tus procedimientos/rutas de API
          - **echo.ts**
        - index.ts
        - init.ts configura el contexto y middleware
        - local-server.ts usado al ejecutar el servidor tRPC localmente
        - **router.ts** punto de entrada para tu lambda handler que define todos los procedimientos
      - project.json
      - ...
    - schema/
      - src/
        - procedures/
          - **echo.ts**
        - index.ts
      - project.json
      - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Veamos estos archivos clave:

```ts {5,12}
// packages/game-api/backend/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>,
  ) => ctx,
});

export type AppRouter = typeof appRouter;
```
El router define el punto de entrada para tu API tRPC y es donde declarar√°s todos tus m√©todos de API.
Tenemos un m√©todo llamado `echo` con su implementaci√≥n en el archivo `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/backend/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from ':dungeon-adventure/game-api-schema';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Este archivo es la implementaci√≥n del m√©todo `echo`, fuertemente tipado al declarar sus estructuras de datos de entrada y salida. Importa estas definiciones del proyecto `:dungeon-adventure/game-api-schema` que es un [alias](https://www.typescriptlang.org/tsconfig/paths.html) para el proyecto de esquema.

<Aside type="tip">Si ves un error de importaci√≥n en tu IDE, puede ser porque el backend a√∫n no tiene configurada una referencia de TypeScript en su `tsconfig.json`. Nx ha sido [configurado](https://nx.dev/nx-api/js/generators/typescript-sync) para crear estas referencias *din√°micamente* cuando se ejecuta un build/compile, o si ejecutas manualmente el comando `nx sync`. Para m√°s informaci√≥n consulta la <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">gu√≠a de TypeScript</Link>.</Aside>

```ts
// packages/game-api/schema/src/procedures/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Todas las definiciones de esquema tRPC se definen usando [Zod](https://zod.dev/), y se exportan como tipos TypeScript mediante la sintaxis `z.TypeOf`.

```ts
// packages/common/constructs/src/app/http-apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import { HttpApi } from '../../core/http-api.js';
import { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';
import { Runtime } from 'aws-cdk-lib/aws-lambda';

export class GameApi extends HttpApi {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      defaultAuthorizer: new HttpIamAuthorizer(),
      apiName: 'GameApi',
      runtime: Runtime.NODEJS_LATEST,
      handler: 'index.handler',
      handlerFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-api/backend/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Este es el construct CDK que define nuestro GameAPI. Ha configurado la ruta del archivo handler al bundle generado para nuestra implementaci√≥n backend tRPC, para que en tiempo de `cdk synth` no ocurra bundling (a diferencia de usar [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)), ya que ya lo hemos empaquetado como parte del target build del proyecto backend.

</Drawer>

<Aside>
El `package.json` ra√≠z ahora est√° configurado con un `type` de `module`, lo que significa que ESM es el tipo de m√≥dulo predeterminado para todos los subproyectos basados en node provistos por el `@aws/nx-plugin`. Para m√°s detalles sobre trabajar con proyectos TypeScript, consulta la <Link path="guides/typescript-project">gu√≠a ts#project</Link>.
</Aside>

### Generar la API de Historia

A continuaci√≥n, creemos nuestra API de Historia usando el generador FastAPI. La API de Historia se usa con respuestas en streaming para generaci√≥n de historias, usando Amazon Bedrock.
Para hacerlo, crea una API Fast llamada `StoryApi` siguiendo estos pasos:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi"}} noInteractive />

Ver√°s nuevos archivos aparecer en tu √°rbol de archivos.

<Drawer title="Archivos actualizados por py#fast-api" trigger="Haz clic aqu√≠ para examinar estos archivos en m√°s detalle.">
Esta es una lista de todos los archivos generados por el generador `py#fast-api`. Examinemos algunos archivos clave resaltados en el √°rbol:
<FileTree>
- .venv/ entorno virtual √∫nico para el monorepositorio
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK espec√≠ficos de la aplicaci√≥n
          - http-apis/
            - **story-api.ts** construct CDK para crear tu API Fast
            - index.ts actualizado para exportar el nuevo story-api
      - project.json actualizado para agregar una dependencia de build en story_api
    - types/ tipos compartidos
      - src/
        - **runtime-config.ts** actualizado para agregar StoryApi
  - story_api/
    - story_api/ m√≥dulo Python
      - init.py configura powertools, FastAPI y middleware
      - **main.py** punto de entrada para la lambda que contiene todas las rutas
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version versi√≥n Python fijada por uv
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/http-apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import { HttpApi } from '../../core/http-api.js';
import { HttpIamAuthorizer } from 'aws-cdk-lib/aws-apigatewayv2-authorizers';
import { Runtime } from 'aws-cdk-lib/aws-lambda';

export class StoryApi extends HttpApi {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      defaultAuthorizer: new HttpIamAuthorizer(),
      apiName: 'StoryApi',
      runtime: Runtime.PYTHON_3_12,
      handler: 'story_api.main.handler',
      handlerFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/story_api/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Este es el construct CDK que define nuestro StoryApi. Configura la ruta del archivo handler al bundle generado para nuestra implementaci√≥n backend Fast API. Esto significa que en tiempo de `cdk synth` no ocurre bundling (a diferencia de [PythonFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/@aws-cdk_aws-lambda-python-alpha.PythonFunction.html)) ya que ya lo hemos empaquetado como parte del target build del proyecto backend.

```diff lang="ts"
// packages/common/types/src/runtime-config.ts
export type ApiUrl = string;
// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-empty-interface
export interface IRuntimeConfig {
  httpApis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

Aqu√≠ vemos un ejemplo del generador realizando una transformaci√≥n AST que preserva todo el c√≥digo existente y realiza una actualizaci√≥n. Aqu√≠ puedes ver que `StoryApi` fue agregado a la definici√≥n `IRuntimeConfig`, lo que significa que cuando esto sea consumido por nuestro frontend, ¬°impondr√° seguridad de tipos!

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

Aqu√≠ es donde se definir√°n todos tus m√©todos de API. Como puedes ver aqu√≠, tenemos un m√©todo `read_root` mapeado a la ruta `GET /`. Puedes usar [Pydantic](https://docs.pydantic.dev/latest/) para declarar las entradas y salidas de tus m√©todos y garantizar seguridad de tipos.

</Drawer>

### Agregar la interfaz de usuario del juego

Para interactuar con el juego, crea la UI usando el generador de sitios web CloudScape.
Para hacerlo, crea un sitio web llamado `GameUI` siguiendo estos pasos:

<RunGenerator generator="ts#cloudscape-website" requiredParameters={{name:"GameUI"}} noInteractive />

Ver√°s nuevos archivos aparecer en tu √°rbol de archivos.

<Drawer title="Archivos actualizados por ts#cloudscape-website" trigger="Haz clic aqu√≠ para examinar estos archivos en m√°s detalle.">
A continuaci√≥n se muestra una lista de todos los archivos generados por el generador `ts#cloudscape-website`. Examinemos algunos archivos clave resaltados en el √°rbol:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK espec√≠ficos de la aplicaci√≥n
          - static-websites/
            - **game-ui.ts** construct CDK para crear tu Game UI
        - core/
          - static-website.ts construct gen√©rico para sitios est√°ticos
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts dise√±o general de p√°gina: encabezado, pie, barra lateral, etc.
          - navitems.ts elementos de navegaci√≥n de la barra lateral
      - hooks/
        - useAppLayout.tsx permite configurar din√°micamente notificaciones, estilo de p√°gina, etc.
      - routes/ rutas basadas en archivos de @tanstack/react-router
        - index.tsx p√°gina ra√≠z '/' redirige a '/welcome'
        - __root.tsx todas las p√°ginas usan este componente como base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** punto de entrada de React
        - routeTree.gen.ts este archivo se actualiza autom√°ticamente por @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Este es el construct CDK que define nuestro GameUI. Como puedes ver, ya ha configurado la ruta al bundle generado para nuestra UI basada en Vite. Esto significa que en tiempo de `build`, el bundling ocurre dentro del target build del proyecto game-ui y su salida se usa aqu√≠.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Registrar la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Este es el punto de entrada donde se monta React. Como se muestra, inicialmente solo configura un `@tanstack/react-router` en una configuraci√≥n de [`enrutamiento-basado-en-archivos`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Esto significa que, mientras tu servidor de desarrollo est√© en ejecuci√≥n, puedes simplemente crear archivos dentro de la carpeta `routes` y `@tanstack/react-router` crear√° la configuraci√≥n boilerplate por ti junto con actualizar el archivo `routeTree.gen.ts`. Este archivo mantiene todas las rutas de manera type-safe, lo que significa que cuando uses `<Link>`, la opci√≥n `to` solo mostrar√° rutas v√°lidas. Para m√°s informaci√≥n, consulta la documentaci√≥n de [`@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>¬°Bienvenido a tu nuevo sitio web Cloudscape!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un componente que se renderizar√° al navegar a la ruta `/welcome`. `@tanstack/react-router` gestionar√° la `Route` por ti cuando crees/muevas este archivo (siempre que el servidor de desarrollo est√© en ejecuci√≥n). Esto se mostrar√° en una secci√≥n posterior de este tutorial.

</Drawer>

### Agregar autenticaci√≥n a la interfaz de usuario

Para configurar nuestra Game UI con acceso autenticado v√≠a Amazon Cognito, usa estos pasos:

<RunGenerator generator="ts#cloudscape-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Ver√°s nuevos archivos aparecer en tu √°rbol de archivos.

<Drawer title="Archivos actualizados por ts#cloudscape-website#auth" trigger="Haz clic aqu√≠ para examinar estos archivos en m√°s detalle.">
A continuaci√≥n se muestra una lista de todos los archivos generados/actualizados por el generador `ts#cloudscape-website#auth`. Examinemos algunos archivos clave resaltados en el √°rbol:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts construct CDK para crear pools de usuarios/identidad
    - types/
      - src/
        - runtime-config.ts actualizado para agregar cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx agrega el usuario logueado/logout al encabezado
        - CognitoAuth/
          - index.ts gestiona el login en Cognito
        - RuntimeConfig/
          - index.tsx obtiene el `runtime-config.json` y lo provee a los hijos mediante contexto
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Actualizado para agregar Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registrar la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Los componentes `RuntimeConfigProvider` y `CognitoAuth` han sido agregados al archivo `main.tsx` mediante una transformaci√≥n AST. Esto permite que el componente `CognitoAuth` se autentique con Amazon Cognito obteniendo el `runtime-config.json` que contiene la configuraci√≥n de conexi√≥n requerida para realizar llamadas al backend al destino correcto.

</Drawer>

### Configurar Game UI para conectarse a la API de Historia

Para configurar nuestra Game UI para conectarse a nuestra API de Historia previamente creada, usa estos pasos:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

Ver√°s nuevos archivos aparecer en tu √°rbol de archivos.

<Drawer title="Archivos actualizados por la conexi√≥n UI -> FastAPI" trigger="Haz clic aqu√≠ para examinar estos archivos en m√°s detalle.">
A continuaci√≥n se muestra una lista de todos los archivos generados/actualizados por el generador `api-connection`. Examinemos algunos archivos clave resaltados en el √°rbol:
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx usado por StoryApi para firmar requests
        - useStoryApiClient.tsx hook para construir un cliente StoryApi
        - useStoryApi.tsx hook para interactuar con StoryApi usando TanStack Query
      - components/
        - QueryClientProvider.tsx proveedor del cliente TanStack Query
        - StoryApiProvider.tsx Proveedor para el hook TanStack Query de StoryApi
      - main.tsx Instrumentar QueryClientProvider y StoryApiProvider
    - .gitignore ignorar archivos cliente generados
    - project.json actualizado para agregar targets para generar hooks openapi
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json actualizado para emitir un archivo openapi.json

</FileTree>

```tsx {1,12-15}
// packages/game-ui/src/hooks/useStoryApiClient.tsx
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.httpApis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

Puedes usar este hook para hacer requests autenticadas a la `StoryApi`. Usa el `StoryApi` que se genera en tiempo de build, y ver√°s un error en tu IDE hasta que compilemos nuestro c√≥digo. Para m√°s detalles sobre c√≥mo se genera el cliente o c√≥mo consumir la API, consulta la <Link path="guides/api-connection/react-fastapi">gu√≠a de React a FastAPI</Link>.

```tsx
// packages/game-ui/src/components/StoryApiProvider.tsx
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useStoryApiClient } from '../hooks/useStoryApiClient';
import { StoryApiOptionsProxy } from '../generated/story-api/options-proxy.gen';

export const StoryApiContext = createContext<StoryApiOptionsProxy | undefined>(
  undefined,
);

export const StoryApiProvider: FC<PropsWithChildren> = ({ children }) => {
  const client = useStoryApiClient();
  const optionsProxy = useMemo(
    () => new StoryApiOptionsProxy({ client }),
    [client],
  );

  return (
    <StoryApiContext.Provider value={optionsProxy}>
      {children}
    </StoryApiContext.Provider>
  );
};

export default StoryApiProvider;
```

El componente proveedor anterior usa el hook `useStoryApiClient` e instancia el `StoryApiOptionsProxy`, que se usa para construir opciones para los hooks de TanStack Query. Puedes usar el hook correspondiente `useStoryApi` para acceder a este proxy de opciones, que proporciona una manera de interactuar con tu FastAPI de forma consistente con tu API tRPC.

Dado que `useStoryApiClient` nos provee un iterador as√≠ncrono para nuestra API de streaming, en este tutorial simplemente usaremos el cliente vanilla directamente.

<Aside type="caution">
Los archivos `src/generated/story-api/*.gen.ts` nunca deben modificarse manualmente ya que se regenerar√°n cada vez que construyas tu API.
</Aside>

</Drawer>

### Configurar Game UI para conectarse a la API del Juego

Para configurar nuestra Game UI para conectarse a nuestra API del Juego, usa estos pasos:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api-backend"}} noInteractive />

Deber√≠as ver algunos archivos nuevos haber aparecido/cambiado en tu √°rbol de archivos.

<Drawer title="Archivos actualizados por la conexi√≥n UI -> tRPC" trigger="Haz clic aqu√≠ para examinar estos archivos en m√°s detalle.">
A continuaci√≥n se muestra una lista de todos los archivos generados/actualizados por el generador `api-connection`. Examinemos algunos archivos clave resaltados en el √°rbol:
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - TrpcClients/
          - index.tsx
          - TrpcApis.tsx todas las APIs tRPC configuradas
          - TrpcClientProviders.tsx crea un proveedor de cliente por API tRPC
          - TrpcProvider.tsx
      - hooks/
        - **useGameApi.tsx** hooks para llamar a la GameApi
      - **main.tsx** inyecta los proveedores de clientes trpc
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { TrpcApis } from '../components/TrpcClients';

export const useGameApi = () => TrpcApis.GameApi.useTRPC();
```

Este hook usa la √∫ltima [integraci√≥n React Query de tRPC](https://trpc.io/blog/introducing-tanstack-react-query-client) permitiendo a los usuarios interactuar con `@tanstack/react-query` directamente sin capas adicionales de abstracci√≥n. Para ejemplos de c√≥mo llamar APIs tRPC, consulta la <Link path="guides/api-connection/react-trpc#using-the-generated-code">gu√≠a de uso del hook tRPC</Link>.

<Aside>
El hook `useGameApi` es diferente al hook `useStoryApi` ya que no requiere un build para que los cambios se reflejen gracias al uso de [inferencia de TypeScript](https://trpc.io/docs/concepts) por parte de tRPC. ¬°Esto permite a los desarrolladores hacer cambios en su backend que se reflejan instant√°neamente en su frontend!
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import TrpcClientProviders from './components/TrpcClients';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registrar la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <TrpcClientProviders>
                <RouterProvider router={router} />
+              </TrpcClientProviders>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

El archivo `main.tsx` ha sido actualizado mediante una transformaci√≥n AST para inyectar los proveedores tRPC.

</Drawer>

### Crear infraestructura CDK para la interfaz de usuario

Para crear la infraestructura CDK como subproyecto final, usa estos pasos:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Deber√≠as ver algunos archivos nuevos haber aparecido/cambiado en tu √°rbol de archivos.

<Drawer title="Archivos actualizados por ts#infra" trigger="Haz clic aqu√≠ para examinar estos archivos en m√°s detalle.">
A continuaci√≥n se muestra una lista de todos los archivos generados/actualizados por el generador `ts#infra`. Examinemos algunos archivos clave resaltados en el √°rbol:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts** recursos CDK definidos aqu√≠
      - index.ts
      - **main.ts** punto de entrada que define todos los stacks
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json agregar referencias
  - tsconfig.base.json agregar alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
  App,
  CfnGuardValidator,
  RuleSet,
} from ':dungeon-adventure/common-constructs';

const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

// Usa esto para desplegar tu propio entorno sandbox (asume tus credenciales CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

Este es el punto de entrada para tu aplicaci√≥n CDK. Est√° configurado para usar [`cfn-guard`](https://github.com/cdklabs/cdk-validator-cfnguard) para ejecutar validaci√≥n de infraestructura basada en el conjunto de reglas configurado. Esto se instrumenta post s√≠ntesis.

<Aside type="tip">
Puede haber casos donde quieras suprimir ciertas reglas en recursos. Puedes hacerlo de dos maneras:

###### Suprimir una regla en un construct dado

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// suprime la RULE_NAME para el construct dado.
suppressRule(construct, 'RULE_NAME');
```

###### Suprimir una regla en un construct descendiente

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// Suprime la RULE_NAME para el construct o cualquiera de sus descendientes si es instancia de Bucket
suppressRule(construct, 'RULE_NAME', (construct) => construct instanceof Bucket);
```
</Aside>

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // El c√≥digo que define tu stack va aqu√≠
  }
}
```

Aqu√≠ es donde instanciamos nuestros constructs CDK para construir nuestro juego de aventuras dungeon.

</Drawer>

#### Actualizar infraestructura CDK

Para instanciar algunos de nuestros constructs ya generados, actualicemos nuestro `packages/infra/src/stacks/application-stack.ts`:

```diff lang="ts"
+import {
+  GameApi,
+  GameUI,
+  StoryApi,
+  UserIdentity,
+} from ':dungeon-adventure/common-constructs';
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

-    // El c√≥digo que define tu stack va aqu√≠
+    const userIdentity = new UserIdentity(this, 'UserIdentity');
+
+    const gameApi = new GameApi(this, 'GameApi');
+    const storyApi = new StoryApi(this, 'StoryApi');
+
+    // otorgar a nuestro rol autenticado acceso para invocar nuestras APIs
+    [storyApi, gameApi].forEach((api) =>
+      api.grantInvokeAccess(userIdentity.identityPool.authenticatedRole),
+    );
+
+    // Asegurar que esto se instancie al final para que nuestro runtime-config.json se configure autom√°ticamente
+    new GameUI(this, 'GameUI');
  }
}

```

### Construyendo nuestro c√≥digo

<Drawer title="Comandos Nx" trigger="Ahora es momento de construir nuestro c√≥digo por primera vez">
###### Targets √∫nicos vs m√∫ltiples

El comando `run-many` ejecutar√° un target en m√∫ltiples subproyectos listados (`--all` los seleccionar√° todos). Se asegurar√° que las dependencias se ejecuten en el orden correcto.

Tambi√©n puedes disparar un build (o cualquier otra tarea) para un target de proyecto √∫nico ejecutando el target en el proyecto directamente. Por ejemplo, si queremos construir el proyecto `@dungeon-adventure/infra`, puedes ejecutar:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualizando tus dependencias

Tambi√©n puedes visualizar tus dependencias v√≠a:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Cach√©

Nx depende del [cach√©](https://nx.dev/concepts/how-caching-works) para que puedas reutilizar artefactos de builds previos y acelerar el desarrollo. Se requiere cierta configuraci√≥n para que esto funcione correctamente y puede haber casos donde quieras realizar un build **sin usar el cach√©**. Para eso, simplemente agrega el argumento `--skip-nx-cache` a tu comando. Por ejemplo:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Si por alguna raz√≥n quisieras borrar tu cach√© (almacenado en la carpeta `.nx`), puedes ejecutar:

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

Se te presentar√° lo siguiente:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? ‚Ä¶
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Este mensaje indica que NX ha detectado algunos archivos que pueden actualizarse autom√°ticamente. En este caso, se refiere a los archivos `tsconfig.json` que no tienen referencias de TypeScript configuradas en proyectos dependientes. Selecciona la opci√≥n **Yes, sync the changes and run the tasks** para proceder. Deber√≠as notar que todos los errores de importaci√≥n en tu IDE se resuelven autom√°ticamente, ¬°ya que el generador sync agregar√° las referencias faltantes de TypeScript!

<Aside type="tip">
Si encuentras errores de lint, puedes ejecutar el siguiente comando para corregirlos autom√°ticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

<Aside type="caution" title="Fallo de build en Windows">
<Drawer trigger="Si est√°s en Windows y encuentras un error de build, haz clic aqu√≠." title="Fallo de build en Windows">
Si encuentras un error de build/synth para el proyecto `@dungeon-adventure/infra`, esto es esperado ya que la librer√≠a que instrumenta `cfn-guard` actualmente no soporta Windows. Hay una solicitud de feature siguiendo esto, pero mientras tanto podemos simplemente deshabilitar `cfn-guard` modificando el archivo `packages/infra/src/main.ts` as√≠:

```diff lang="ts"
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
   App,
-  CfnGuardValidator,
-  RuleSet,
} from ':dungeon-adventure/common-constructs';
-
-const app = new App({
-  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
-});
+const app = new App();

// Usa esto para desplegar tu propio entorno sandbox (asume tus credenciales CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```
</Drawer>
</Aside>

Todos los artefactos construidos est√°n ahora disponibles dentro de la carpeta `dist/` ubicada en la ra√≠z del monorepositorio. Esta es una pr√°ctica est√°ndar cuando se usan proyectos generados por el `@aws/nx-plugin` para no mezclar tu √°rbol de archivos con archivos generados. Si quieres limpiar tus archivos, borra la carpeta `dist/` sin preocuparte por archivos generados esparcidos por todo el √°rbol.

¬°Felicitaciones! Has creado todos los subproyectos requeridos para comenzar a implementar el n√∫cleo de nuestro juego Dunegeon Adventure.  üéâüéâüéâ