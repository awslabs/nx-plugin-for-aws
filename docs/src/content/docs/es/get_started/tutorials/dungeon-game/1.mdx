---
title: "Juego de Mazmorra con IA"
description: "Un tutorial de cómo construir un juego de aventuras de mazmorra con IA utilizando el @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Módulo 1: Configuración del monorepo

Comenzaremos creando un nuevo monorepo. Desde el directorio deseado, ejecuta el siguiente comando:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" />

Esto configurará un monorepo NX dentro del directorio `dungeon-adventure` que podrás abrir en vscode. Debería verse así:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ aquí residirán tus subproyectos
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura el CLI de Nx y los valores predeterminados del monorepo
- package.json todas las dependencias de node se definen aquí
- pnpm-lock.yaml o bun.lock, yarn.lock, package-lock.json según el gestor de paquetes
- pnpm-workspace.yaml si usas pnpm
- README.md
- tsconfig.base.json todos los subproyectos basados en node extienden este
- tsconfig.json
</FileTree>

Ahora estamos listos para comenzar a crear nuestros diferentes subproyectos usando el `@aws/nx-plugin`.

<<<<<<< HEAD
<Aside type="tip">Es una mejor práctica asegurarse de que todos los archivos no preparados estén confirmados en Git antes de ejecutar cualquier generador. Esto te permite ver qué ha cambiado después de ejecutar tu generador mediante `git diff`</Aside>
=======
<Aside type="tip">Es una buena práctica asegurar que todos tus archivos no preparados estén confirmados en Git antes de ejecutar cualquier generador. Esto te permite ver qué ha cambiado después de ejecutar tu generador mediante `git diff`</Aside>
>>>>>>> c5375c6 (docs: update translations)

### API del Juego

Primero creemos nuestra API del Juego. Para esto, creemos una API tRPC llamada `GameApi` siguiendo estos pasos:

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

<<<<<<< HEAD
Deberías ver que han aparecido nuevos archivos en tu árbol de directorios.
=======
Deberías ver que han aparecido algunos archivos nuevos en tu árbol de archivos.
>>>>>>> c5375c6 (docs: update translations)

<Aside>
El `package.json` raíz ahora está configurado con un `type` de `module`, lo que significa que ESM es el tipo de módulo predeterminado para todos los subproyectos basados en node proporcionados por el `@aws/nx-plugin`. Para más detalles sobre cómo trabajar con proyectos TypeScript, consulta la <Link path="guides/typescript-project">guía ts#project</Link>.
</Aside>

<Drawer title="Archivos actualizados por ts#trpc-api" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados por el generador `ts#trpc-api`. Examinaremos algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK específicos de la aplicación
          - apis/
            - **game-api.ts** construct CDK para crear tu API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructs CDK genéricos
          - api/
<<<<<<< HEAD
            - rest-api.ts construct base CDK para una API Rest de API Gateway
=======
            - rest-api.ts construct CDK base para una API Rest de API Gateway
>>>>>>> c5375c6 (docs: update translations)
            - trpc-utils.ts utilidades para constructs CDK de API tRPC
            - utils.ts utilidades para constructs de API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipos compartidos
      - src/
        - index.ts
        - runtime-config.ts definición de interfaz usada tanto por CDK como por el sitio web
      - project.json
      - ...
  - game-api/ API tRPC
    - src/
      - client/ cliente vanilla típicamente usado para llamadas máquina a máquina en ts
        - index.ts
        - sigv4.ts
      - middleware/ instrumentación con powertools
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ definiciones de entradas y salidas para tu API
        - **echo.ts**
      - procedures/ implementaciones específicas de los procedimientos/rutas de tu API
        - **echo.ts**
      - index.ts
      - init.ts configura el contexto y middleware
      - local-server.ts usado al ejecutar el servidor tRPC localmente
      - **router.ts** punto de entrada para tu lambda handler que define todos los procedimientos
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Echemos un vistazo a algunos de los archivos clave:

```ts {5,12}
// packages/game-api/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
<<<<<<< HEAD
El router define el punto de entrada para tu API tRPC y es donde declararás todos tus métodos de API. Como puedes ver arriba, tenemos un método llamado `echo` con su implementación en el archivo `./procedures/echo.ts`.
=======
El enrutador define el punto de entrada para tu API tRPC y es donde declararás todos tus métodos de API. Como puedes ver arriba, tenemos un método llamado `echo` con su implementación en el archivo `./procedures/echo.ts`.
>>>>>>> c5375c6 (docs: update translations)

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Este archivo es la implementación del método `echo` y como puedes ver está fuertemente tipado al declarar sus estructuras de datos de entrada y salida.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod/v4';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Todas las definiciones de esquema tRPC se definen usando [Zod](https://zod.dev/) y se exportan como tipos TypeScript mediante la sintaxis `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// Tipo de unión de strings para todos los nombres de operaciones de la API
type Operations = Procedures<AppRouter>;

/**
 * Propiedades para crear un construct GameApi
 *
 * @template TIntegrations - Mapa de nombres de operación a sus integraciones
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mapa de nombres de operación a sus integraciones de API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un construct CDK que crea y configura una API REST de AWS API Gateway
 * específicamente para GameApi.
 * @template TIntegrations - Mapa de nombres de operación a sus integraciones
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integraciones predeterminadas para todas las operaciones, que implementan cada operación como
   * su propia función lambda individual.
   *
   * @param scope - El alcance del construct CDK
   * @returns Un IntegrationBuilder con integraciones lambda predeterminadas
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Aquí permitimos que cualquier credencial AWS de la cuenta donde se despliega el proyecto pueda llamar a la API.
<<<<<<< HEAD
          // Se puede definir aquí acceso granular máquina a máquina usando principios más específicos (ej. roles o
          // usuarios) y recursos (ej. qué rutas de API pueden ser invocadas por qué principal) si es necesario.
=======
          // Se puede definir acceso detallado máquina a máquina aquí usando principios más específicos (ej. roles o
          // usuarios) y recursos (ej. qué rutas de API pueden ser invocadas por qué principio) si es necesario.
>>>>>>> c5375c6 (docs: update translations)
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Abrimos OPTIONS para permitir que los navegadores hagan solicitudes preflight sin autenticar
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

<<<<<<< HEAD
Este es el construct CDK que define nuestro GameApi. Como puedes ver, proporciona un método `defaultIntegrations` que automáticamente crea una función lambda para cada procedimiento en nuestra API tRPC, apuntando a la implementación de la API empaquetada. Esto significa que en el momento de `cdk synth`, no ocurre empaquetado (a diferencia de usar [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) ya que ya lo hemos empaquetado como parte del target de build del proyecto backend.
=======
Este es el construct CDK que define nuestro GameApi. Como puedes ver, proporciona un método `defaultIntegrations` que automáticamente crea una función lambda para cada procedimiento en nuestra API tRPC, apuntando a la implementación de la API empaquetada. Esto significa que en el momento de `cdk synth`, no ocurre empaquetado (a diferencia de usar [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) ya que ya lo hemos empaquetado como parte del objetivo de build del proyecto backend.
>>>>>>> c5375c6 (docs: update translations)

</Drawer>

### API de Historia

<<<<<<< HEAD
Ahora creemos nuestra API de Historia. Para esto, creemos una API Fast llamada `StoryApi` siguiendo estos pasos:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi", moduleName:"story_api"}} noInteractive />

Deberías ver que han aparecido nuevos archivos en tu árbol de directorios.
=======
Ahora creemos nuestra API de la Historia. Para esto, creemos una API Fast llamada `StoryApi` siguiendo estos pasos:

<RunGenerator generator="py#fast-api" requiredParameters={{name:"StoryApi", moduleName:"story_api"}} noInteractive />

Deberías ver que han aparecido algunos archivos nuevos en tu árbol de archivos.
>>>>>>> c5375c6 (docs: update translations)
<Drawer title="Archivos actualizados por py#fast-api" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados por el generador `py#fast-api`. Examinaremos algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- .venv/ entorno virtual único para el monorepo
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK específicos de la aplicación
          - apis/
            - **story-api.ts** construct CDK para crear tu API Fast
            - index.ts actualizado para exportar el nuevo story-api
      - project.json actualizado para añadir una dependencia de build en story_api
    - types/ tipos compartidos
      - src/
        - **runtime-config.ts** actualizado para añadir el StoryApi
  - story_api/
<<<<<<< HEAD
    - story_api/ módulo Python
=======
    - story_api/ módulo python
>>>>>>> c5375c6 (docs: update translations)
      - init.py configura powertools, FastAPI y middleware
      - **main.py** punto de entrada para la lambda que contiene todas las rutas
    - tests/
    - .python-version
    - project.json
    - pyproject.toml
    - project.json
- .python-version versión de python fijada para uv
- pyproject.toml
- uv.lock
</FileTree>

```ts
// packages/common/constructs/src/app/apis/story-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import {
  OPERATION_DETAILS,
  Operations,
} from '../../generated/story-api/metadata.gen.js';

/**
 * Propiedades para crear un construct StoryApi
 *
 * @template TIntegrations - Mapa de nombres de operación a sus integraciones
 */
export interface StoryApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mapa de nombres de operación a sus integraciones de API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un construct CDK que crea y configura una API REST de AWS API Gateway
 * específicamente para StoryApi.
 * @template TIntegrations - Mapa de nombres de operación a sus integraciones
 */
export class StoryApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integraciones predeterminadas para todas las operaciones, que implementan cada operación como
   * su propia función lambda individual.
   *
   * @param scope - El alcance del construct CDK
   * @returns Un IntegrationBuilder con integraciones lambda predeterminadas
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: OPERATION_DETAILS,
      defaultIntegrationOptions: {
        runtime: Runtime.PYTHON_3_12,
        handler: 'story_api.main.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/story_api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `StoryApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: StoryApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'StoryApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Aquí permitimos que cualquier credencial AWS de la cuenta donde se despliega el proyecto pueda llamar a la API.
<<<<<<< HEAD
          // Se puede definir aquí acceso granular máquina a máquina usando principios más específicos (ej. roles o
          // usuarios) y recursos (ej. qué rutas de API pueden ser invocadas por qué principal) si es necesario.
=======
          // Se puede definir acceso detallado máquina a máquina aquí usando principios más específicos (ej. roles o
          // usuarios) y recursos (ej. qué rutas de API pueden ser invocadas por qué principio) si es necesario.
>>>>>>> c5375c6 (docs: update translations)
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Abrimos OPTIONS para permitir que los navegadores hagan solicitudes preflight sin autenticar
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: OPERATION_DETAILS,
      ...props,
    });
  }
}

```

<<<<<<< HEAD
Este es el construct CDK que define nuestro StoryApi. Como puedes ver, proporciona un método `defaultIntegrations` que automáticamente crea una función lambda para cada operación definida en nuestra FastAPI, apuntando a la implementación de la API empaquetada. Esto significa que en el momento de `cdk synth`, no ocurre empaquetado (a diferencia de [PythonFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/@aws-cdk_aws-lambda-python-alpha.PythonFunction.html)) ya que ya lo hemos empaquetado como parte del target de build del proyecto backend.
=======
Este es el construct CDK que define nuestro StoryApi. Como puedes ver, proporciona un método `defaultIntegrations` que automáticamente crea una función lambda para cada operación definida en nuestro FastAPI, apuntando a la implementación de la API empaquetada. Esto significa que en el momento de `cdk synth`, no ocurre empaquetado (a diferencia de [PythonFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/@aws-cdk_aws-lambda-python-alpha.PythonFunction.html)) ya que ya lo hemos empaquetado como parte del objetivo de build del proyecto backend.
>>>>>>> c5375c6 (docs: update translations)

```diff lang="ts"
// packages/common/types/src/runtime-config.ts
export type ApiUrl = string;
// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-empty-interface
export interface IRuntimeConfig {
  apis: {
    GameApi: ApiUrl;
+    StoryApi: ApiUrl;
  };
}
```

<<<<<<< HEAD
Aquí hay un ejemplo del generador realizando una transformación AST que preserva todo el código existente y realiza una actualización. Puedes ver que se añadió `StoryApi` a la definición de `IRuntimeConfig`, lo que significa que cuando esto sea consumido por nuestro frontend, ¡impondrá seguridad de tipos!
=======
Aquí hay un ejemplo del generador realizando una transformación AST que preserva todo el código existente y realiza una actualización. Aquí puedes ver que se agregó `StoryApi` a la definición de `IRuntimeConfig`, lo que significa que cuando esto sea consumido por nuestro frontend, ¡impondrá seguridad de tipos!
>>>>>>> c5375c6 (docs: update translations)

```py
// packages/story_api/story_api/main.py
from .init import app, lambda_handler, tracer

handler = lambda_handler

@app.get("/")
@tracer.capture_method
def read_root():
    return {"Hello": "World"}
```

Aquí es donde se definirán todos tus métodos de API. Como puedes ver aquí, tenemos un método `read_root` mapeado a la ruta `GET /`. Puedes usar [Pydantic](https://docs.pydantic.dev/latest/) para declarar las entradas y salidas de tus métodos y asegurar la seguridad de tipos.

</Drawer>

### Interfaz del Juego: Sitio Web

Ahora creemos la interfaz de usuario que permitirá interactuar con el juego. Para esto, creemos un sitio web llamado `GameUI` siguiendo estos pasos:

<RunGenerator generator="ts#react-website" requiredParameters={{name:"GameUI"}} noInteractive />

<<<<<<< HEAD
Deberías ver que han aparecido nuevos archivos en tu árbol de directorios.
=======
Deberías ver que han aparecido algunos archivos nuevos en tu árbol de archivos.
>>>>>>> c5375c6 (docs: update translations)

<Drawer title="Archivos actualizados por ts#react-website" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados por el generador `ts#react-website`. Examinaremos algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK específicos de la aplicación
          - static-websites/
            - **game-ui.ts** construct CDK para crear tu Game UI
        - core/
          - static-website.ts construct genérico para sitios web estáticos
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts diseño general de la página: encabezado, pie, barra lateral, etc
          - navitems.ts elementos de navegación de la barra lateral
      - hooks/
        - useAppLayout.tsx permite configurar dinámicamente notificaciones, estilo de página, etc
      - routes/ rutas basadas en archivos de @tanstack/react-router
        - index.tsx página raíz '/' redirige a '/welcome'
        - __root.tsx todos las páginas usan este componente como base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** punto de entrada de React
        - routeTree.gen.ts este archivo se actualiza automáticamente por @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

<<<<<<< HEAD
Este es el construct CDK que define nuestro GameUI. Como puedes ver, ya está configurada la ruta al bundle generado para nuestra UI basada en Vite. Esto significa que en el momento de `build`, el empaquetado ocurre dentro del target de build del proyecto game-ui y su salida se usa aquí.
=======
Este es el construct CDK que define nuestro GameUI. Como puedes ver, ya está configurada la ruta al paquete generado para nuestra UI basada en Vite. Esto significa que en el momento de `build`, el empaquetado ocurre dentro del objetivo de build del proyecto game-ui y su salida se usa aquí.
>>>>>>> c5375c6 (docs: update translations)

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Registra la instancia del enrutador para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

<<<<<<< HEAD
Este es el punto de entrada donde se monta React. Como se muestra, inicialmente solo configura un `@tanstack/react-router` en una configuración de [`enrutado basado en archivos`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Esto significa que, mientras tu servidor de desarrollo esté en ejecución, simplemente puedes crear archivos dentro de la carpeta `routes` y `@tanstack/react-router` creará la configuración de archivos necesaria y actualizará el archivo `routeTree.gen.ts`. Este archivo mantiene todas las rutas de manera segura en tipos, lo que significa que cuando uses `<Link>`, la opción `to` solo mostrará rutas válidas. Para más información, consulta la [documentación de `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).
=======
Este es el punto de entrada donde se monta React. Como se muestra, inicialmente solo configura un `@tanstack/react-router` en una configuración de [`enrutamiento basado en archivos`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Esto significa que, mientras tu servidor de desarrollo esté en ejecución, puedes simplemente crear archivos dentro de la carpeta `routes` y `@tanstack/react-router` creará la configuración de archivos necesaria y actualizará el archivo `routeTree.gen.ts`. Este archivo mantiene todas las rutas de manera segura en tipos, lo que significa que cuando uses `<Link>`, la opción `to` solo mostrará rutas válidas. Para más información, consulta la [documentación de `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).
>>>>>>> c5375c6 (docs: update translations)

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un componente que se renderizará al navegar a la ruta `/welcome`. `@tanstack/react-router` gestionará la `Route` por ti cuando crees/muevas este archivo (siempre que el servidor de desarrollo esté en ejecución). Esto se mostrará en una sección posterior de este tutorial.

</Drawer>

### Interfaz del Juego: Autenticación

Ahora configuremos nuestra Game UI para requerir acceso autenticado mediante Amazon Cognito siguiendo estos pasos:

<RunGenerator generator="ts#react-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

<<<<<<< HEAD
Deberías ver que han aparecido/cambiado nuevos archivos en tu árbol de directorios.
=======
Deberías ver que han aparecido/cambiado algunos archivos en tu árbol de archivos.
>>>>>>> c5375c6 (docs: update translations)

<Drawer title="Archivos actualizados por ts#react-website#auth" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `ts#react-website#auth`. Examinaremos algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
<<<<<<< HEAD
          - user-identity.ts construct CDK para crear pools de usuarios/identidad
=======
          - user-identity.ts construct CDK para crear grupos de usuarios/identidad
>>>>>>> c5375c6 (docs: update translations)
    - types/
      - src/
        - runtime-config.ts actualizado para añadir cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx añade el usuario conectado/cierre de sesión al encabezado
        - CognitoAuth/
          - index.ts gestiona el inicio de sesión en Cognito
        - RuntimeConfig/
          - index.tsx obtiene el `runtime-config.json` y lo provee a los hijos mediante contexto
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Actualizado para añadir Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra la instancia del enrutador para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Los componentes `RuntimeConfigProvider` y `CognitoAuth` se han añadido al archivo `main.tsx` mediante una transformación AST. Esto permite que el componente `CognitoAuth` se autentique con Amazon Cognito obteniendo el `runtime-config.json` que contiene la configuración de conexión de Cognito necesaria para realizar las llamadas al backend al destino correcto.

</Drawer>

### Interfaz del Juego: Conectar a Story API

Ahora configuremos nuestra Game UI para conectarnos a nuestra Story API creada previamente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"dungeon_adventure.story_api"}} noInteractive />

<<<<<<< HEAD
Deberías ver que han aparecido/cambiado nuevos archivos en tu árbol de directorios.
=======
Deberías ver que han aparecido/cambiado algunos archivos en tu árbol de archivos.
>>>>>>> c5375c6 (docs: update translations)

<Drawer title="Archivos actualizados por la conexión UI -> FastAPI" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `api-connection`. Examinaremos algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- packages/
  - game-ui/
    - src/
      - hooks/
        - useSigV4.tsx usado por StoryApi para firmar solicitudes
        - useStoryApiClient.tsx hook para construir un cliente StoryApi
        - useStoryApi.tsx hook para interactuar con StoryApi usando TanStack Query
      - components/
        - QueryClientProvider.tsx proveedor del cliente TanStack Query
        - StoryApiProvider.tsx Proveedor para el hook TanStack Query de StoryApi
      - main.tsx Instrumenta QueryClientProvider y StoryApiProvider
    - .gitignore ignora archivos de cliente generados
<<<<<<< HEAD
    - project.json actualizado para añadir targets para generar hooks openapi
=======
    - project.json actualizado para añadir objetivos para generar hooks openapi
>>>>>>> c5375c6 (docs: update translations)
    - ...
  - story_api/
    - scripts/
      - generate_open_api.py
    - project.json actualizado para emitir un archivo openapi.json

</FileTree>

```tsx {1,12-15}
// packages/game-ui/src/hooks/useStoryApiClient.tsx
import { StoryApi } from '../generated/story-api/client.gen';
import { useSigV4 } from './useSigV4';
import { useRuntimeConfig } from './useRuntimeConfig';
import { useMemo } from 'react';

export const useStoryApi = (): StoryApi => {
  const runtimeConfig = useRuntimeConfig();
  const apiUrl = runtimeConfig.apis.StoryApi;
  const sigv4Client = useSigV4();
  return useMemo(
    () =>
      new StoryApi({
        url: apiUrl,
        fetch: sigv4Client,
      }),
    [apiUrl, sigv4Client],
  );
};
```

<<<<<<< HEAD
Este hook puede usarse para hacer solicitudes API autenticadas a `StoryApi`. Como puedes ver en la implementación, usa el `StoryApi` que se genera en tiempo de build, por lo que verás un error en tu IDE hasta que compilemos nuestro código. Para más detalles sobre cómo se genera el cliente o cómo consumir la API, consulta la <Link path="guides/api-connection/react-fastapi">guía de React a FastAPI</Link>.
=======
Este hook puede usarse para hacer solicitudes de API autenticadas a `StoryApi`. Como puedes ver en la implementación, usa el `StoryApi` que se genera en tiempo de build, por lo que verás un error en tu IDE hasta que compilemos nuestro código. Para más detalles sobre cómo se genera el cliente o cómo consumir la API, consulta la <Link path="guides/api-connection/react-fastapi">guía de React a FastAPI</Link>.
>>>>>>> c5375c6 (docs: update translations)

```tsx
// packages/game-ui/src/components/StoryApiProvider.tsx
import { createContext, FC, PropsWithChildren, useMemo } from 'react';
import { useStoryApiClient } from '../hooks/useStoryApiClient';
import { StoryApiOptionsProxy } from '../generated/story-api/options-proxy.gen';

export const StoryApiContext = createContext<StoryApiOptionsProxy | undefined>(
  undefined,
);

export const StoryApiProvider: FC<PropsWithChildren> = ({ children }) => {
  const client = useStoryApiClient();
  const optionsProxy = useMemo(
    () => new StoryApiOptionsProxy({ client }),
    [client],
  );

  return (
    <StoryApiContext.Provider value={optionsProxy}>
      {children}
    </StoryApiContext.Provider>
  );
};

export default StoryApiProvider;
```

El componente proveedor anterior usa el hook `useStoryApiClient` e instancia el `StoryApiOptionsProxy`, que se usa para construir opciones para los hooks de TanStack Query. Puedes usar el hook correspondiente `useStoryApi` para acceder a este proxy de opciones, que proporciona una manera de interactuar con tu FastAPI de forma consistente con tu API tRPC.

Dado que `useStoryApiClient` nos provee un iterador asíncrono para nuestra API de streaming, en este tutorial simplemente usaremos el cliente vanilla directamente.

<Aside type="caution">
Los archivos `src/generated/story-api/*.gen.ts` nunca deben modificarse manualmente ya que se regenerarán cada vez que construyas tu API.
</Aside>

</Drawer>

### Interfaz del Juego: Conectar a Game API

Ahora configuremos nuestra Game UI para conectarnos a nuestra Game API creada previamente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

<<<<<<< HEAD
Deberías ver que han aparecido/cambiado nuevos archivos en tu árbol de directorios.
=======
Deberías ver que han aparecido/cambiado algunos archivos en tu árbol de archivos.
>>>>>>> c5375c6 (docs: update translations)

<Drawer title="Archivos actualizados por la conexión UI -> tRPC" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `api-connection`. Examinaremos algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx configura el cliente GameAPI
      - hooks/
        - **useGameApi.tsx** hooks para llamar a GameApi
      - **main.tsx** inyecta los proveedores de cliente trpc
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { useGameApi as useClient } from '../components/GameApiClientProvider';

export const useGameApi = useClient;
```

<<<<<<< HEAD
Este hook usa la última [integración de React Query de tRPC](https://trpc.io/blog/introducing-tanstack-react-query-client) permitiendo a los usuarios interactuar directamente con `@tanstack/react-query` sin capas adicionales de abstracción. Para ejemplos de cómo llamar a APIs tRPC, consulta la <Link path="guides/api-connection/react-trpc#using-the-generated-code">guía de uso del hook tRPC</Link>.

<Aside>
El hook `useGameApi` es diferente al hook `useStoryApi` porque no requiere un build para que los cambios se reflejen gracias al uso de [inferencia de Typescript](https://trpc.io/docs/concepts) por parte de tRPC. ¡Esto permite a los desarrolladores hacer cambios en su backend que se reflejan instantáneamente en su frontend!
=======
Este hook usa la última [integración de React Query](https://trpc.io/blog/introducing-tanstack-react-query-client) de tRPC, permitiendo a los usuarios interactuar directamente con `@tanstack/react-query` sin capas adicionales de abstracción. Para ejemplos de cómo llamar a APIs tRPC, consulta la <Link path="guides/api-connection/react-trpc#using-the-generated-code">guía de uso del hook tRPC</Link>.

<Aside>
El hook `useGameApi` es diferente al hook `useStoryApi` ya que no requiere un build para que los cambios se reflejen gracias al uso de [inferencia de TypeScript](https://trpc.io/docs/concepts) por parte de tRPC. ¡Esto permite a los desarrolladores hacer cambios en su backend que se reflejen instantáneamente en su frontend!
>>>>>>> c5375c6 (docs: update translations)
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra la instancia del enrutador para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <RouterProvider router={router} />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

El archivo `main.tsx` ha sido actualizado mediante una transformación AST para inyectar los proveedores de tRPC.

</Drawer>

<<<<<<< HEAD
### Interfaz de Usuario del Juego: Infraestructura
=======
### Interfaz del Juego: Infraestructura
>>>>>>> c5375c6 (docs: update translations)

Ahora el último subproyecto que necesitamos crear es para la infraestructura CDK. Para crear esto, sigue estos pasos:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

<<<<<<< HEAD
Deberías ver que han aparecido/cambiado nuevos archivos en tu árbol de directorios.
=======
Deberías ver que han aparecido/cambiado algunos archivos en tu árbol de archivos.
>>>>>>> c5375c6 (docs: update translations)

<Drawer title="Archivos actualizados por ts#infra" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `ts#infra`. Examinaremos algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - cfn-guard-rules/
            - *.guard
          - cfn-guard.ts
          - index.ts
  - infra
    - src/
      - stacks/
        - **application-stack.ts** recursos CDK definidos aquí
      - index.ts
      - **main.ts** punto de entrada que define todos los stacks
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json añade referencias
  - tsconfig.base.json añade alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
  App,
  CfnGuardValidator,
  RuleSet,
} from ':dungeon-adventure/common-constructs';

const app = new App({
  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
});

// Usa esto para desplegar tu propio entorno sandbox (asume credenciales CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```

<<<<<<< HEAD
<Aside type="tip">Si ves un error de importación en tu IDE, es porque nuestro proyecto de infraestructura aún no tiene una referencia de typescript configurada en su tsconfig.json. Nx ha sido [configurado](https://nx.dev/nx-api/js/generators/typescript-sync) para crear estas referencias *dinámicamente* cada vez que se ejecuta un build/compile o si ejecutas el comando `nx sync` manualmente. Para más información consulta la <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guía de Typescript</Link>.</Aside>
=======
<Aside type="tip">Si estás viendo un error de importación en tu IDE, es porque nuestro proyecto de infraestructura aún no tiene una referencia de TypeScript configurada en su tsconfig.json. Nx ha sido [configurado](https://nx.dev/nx-api/js/generators/typescript-sync) para crear estas referencias *dinámicamente* cada vez que se ejecuta un build/compile o si ejecutas el comando `nx sync` manualmente. Para más información consulta la <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guía de TypeScript</Link>.</Aside>
>>>>>>> c5375c6 (docs: update translations)

Este es el punto de entrada para tu aplicación CDK.

Está configurado para usar [`cfn-guard`](https://github.com/cdklabs/cdk-validator-cfnguard) para ejecutar validación de infraestructura basada en el conjunto de reglas configurado. Esto se instrumenta post síntesis.

<Aside type="tip">
Puede haber casos donde quieras suprimir ciertas reglas en recursos. Puedes hacer esto de dos maneras:

###### Suprimir una regla en un construct dado

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// suprime la RULE_NAME para el construct dado.
suppressRule(construct, 'RULE_NAME');
```

###### Suprimir una regla en un construct descendiente

```typescript
import { suppressRule } from ':dungeon-adventure/common-constructs';

...
// Suprime la RULE_NAME para el construct o cualquiera de sus descendientes si es una instancia de Bucket
suppressRule(construct, 'RULE_NAME', (construct) => construct instanceof Bucket);
```
</Aside>

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // El código que define tu stack va aquí
  }
}
```

<<<<<<< HEAD
Aquí es donde instanciaremos nuestros constructs CDK para construir nuestro juego de aventuras.
=======
Aquí es donde instanciaremos nuestros constructs CDK para construir nuestro juego de aventuras dungeon.
>>>>>>> c5375c6 (docs: update translations)

</Drawer>

#### Actualizar nuestra infraestructura

Hagamos una actualización en nuestro `packages/infra/src/stacks/application-stack.ts` para instanciar algunos de nuestros constructs ya generados:
<<<<<<< HEAD


<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

Nota que aquí proveemos integraciones predeterminadas para nuestras dos APIs. Por defecto, cada operación en nuestra API está mapeada a una función lambda individual para manejar esa operación.

### Construyendo nuestro código

<Drawer title="Comandos de Nx" trigger="Ahora es momento de construir nuestro código por primera vez">
###### Targets únicos vs múltiples
=======

<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

Nota aquí que proporcionamos integraciones predeterminadas para nuestras dos APIs. Por defecto, cada operación en nuestra API está mapeada a una función lambda individual para manejar esa operación.

### Construyendo nuestro código

<Drawer title="Comandos de Nx" trigger="Ahora es el momento de construir nuestro código por primera vez">
###### Objetivos únicos vs múltiples
>>>>>>> c5375c6 (docs: update translations)

El comando `run-many` ejecutará un target en múltiples subproyectos listados (`--all` los seleccionará todos). Se asegurará de que las dependencias se ejecuten en el orden correcto.

<<<<<<< HEAD
También puedes disparar un build (o cualquier otra tarea) para un target de proyecto único ejecutando el target directamente en el proyecto. Por ejemplo, si queremos construir el proyecto `@dungeon-adventure/infra`, puedes ejecutar el siguiente comando:
=======
También puedes desencadenar un build (o cualquier otra tarea) para un objetivo de proyecto único ejecutando el objetivo directamente en el proyecto. Por ejemplo, si queremos construir el proyecto `@dungeon-adventure/infra`, puedes ejecutar el siguiente comando:
>>>>>>> c5375c6 (docs: update translations)

<NxCommands commands={['run @dungeon-adventure/infra:build']} />
###### Visualizando tus dependencias

También puedes visualizar tus dependencias mediante:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Caché

<<<<<<< HEAD
Nx depende del [caching](https://nx.dev/concepts/how-caching-works) para que puedas reutilizar artefactos de builds previos y acelerar el desarrollo. Se requiere cierta configuración para que esto funcione correctamente y puede haber casos donde quieras realizar un build **sin usar la caché**. Para eso, simplemente añade el argumento `--skip-nx-cache` a tu comando. Por ejemplo:
=======
Nx depende del [caching](https://nx.dev/concepts/how-caching-works) para que puedas reutilizar artefactos de builds previos y acelerar el desarrollo. Se requiere cierta configuración para que esto funcione correctamente y puede haber casos donde quieras realizar un build **sin usar la caché**. Para hacer eso, simplemente añade el argumento `--skip-nx-cache` a tu comando. Por ejemplo:
>>>>>>> c5375c6 (docs: update translations)

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Si por alguna razón quisieras limpiar tu caché (almacenada en la carpeta `.nx`), puedes ejecutar el siguiente comando:

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

Deberías recibir el siguiente prompt:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? …
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

<<<<<<< HEAD
Este mensaje indica que NX ha detectado algunos archivos que pueden actualizarse automáticamente. En este caso, se refiere a los archivos `tsconfig.json` que no tienen referencias de Typescript configuradas en proyectos referenciados. Selecciona la opción **Yes, sync the changes and run the tasks** para proceder. ¡Deberías notar que todos los errores de importación relacionados con tu IDE se resuelven automáticamente ya que el generador de sync añadirá las referencias de typescript faltantes automáticamente!
=======
Este mensaje indica que NX ha detectado algunos archivos que pueden ser actualizados automáticamente. En este caso, se refiere a los archivos `tsconfig.json` que no tienen referencias de TypeScript configuradas en proyectos referenciados. Selecciona la opción **Yes, sync the changes and run the tasks** para proceder. ¡Deberías notar que todos los errores de importación relacionados con tu IDE se resuelven automáticamente ya que el generador de sincronización agregará las referencias de TypeScript faltantes automáticamente!
>>>>>>> c5375c6 (docs: update translations)

<Aside type="tip">
Si encuentras errores de lint, puedes ejecutar el siguiente comando para corregirlos automáticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

<<<<<<< HEAD
<Aside type="caution" title="Fallo de build en Windows">
<Drawer trigger="Si estás en Windows y encuentras un error de build, haz clic aquí." title="Fallo de build en Windows">
Si encuentras un error de build/synth para el proyecto `@dungeon-adventure/infra`, esto es esperado ya que la biblioteca que instrumenta `cfn-guard` actualmente no soporta Windows. Hay una solicitud de función rastreando esto, pero mientras tanto podemos simplemente deshabilitar `cfn-guard` modificando el archivo `packages/infra/src/main.ts` como sigue:
=======
<Aside type="caution" title="Error de build en Windows">
<Drawer trigger="Si estás en Windows y encuentras un error de build/synth, haz clic aquí." title="Error de build en Windows">
Si encuentras un error de build/synth para el proyecto `@dungeon-adventure/infra`, esto es esperado ya que la biblioteca que instrumenta `cfn-guard` actualmente no soporta Windows. Hay una solicitud de función rastreando esto, pero mientras tanto podemos simplemente deshabilitar `cfn-guard` modificando el archivo `packages/infra/src/main.ts` de la siguiente manera:
>>>>>>> c5375c6 (docs: update translations)

```diff lang="ts"
// packages/infra/src/main.ts
import { ApplicationStack } from './stacks/application-stack.js';
import {
   App,
-  CfnGuardValidator,
-  RuleSet,
} from ':dungeon-adventure/common-constructs';
-
-const app = new App({
-  policyValidationBeta1: [new CfnGuardValidator(RuleSet.AWS_PROTOTYPING)],
-});
+const app = new App();

// Usa esto para desplegar tu propio entorno sandbox (asume credenciales CLI)
new ApplicationStack(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
  crossRegionReferences: true,
});

app.synth();
```
</Drawer>
</Aside>

<<<<<<< HEAD
Todos los artefactos construidos están ahora disponibles dentro de la carpeta `dist/` ubicada en la raíz del monorepo. Esta es una práctica estándar cuando se usan proyectos generados por el `@aws/nx-plugin` ya que no contamina tu árbol de archivos con archivos generados. En caso de que quieras limpiar tus archivos, simplemente puedes borrar la carpeta `dist/` sin preocuparte de archivos generados esparcidos por el árbol de directorios.
=======
Todos los artefactos construidos están ahora disponibles dentro de la carpeta `dist/` ubicada en la raíz del monorepo. Esta es una práctica estándar cuando se usan proyectos generados por el `@aws/nx-plugin` ya que no contamina tu árbol de archivos con archivos generados. En caso de que quieras limpiar tus archivos, simplemente puedes eliminar la carpeta `dist/` sin preocuparte por archivos generados esparcidos por el árbol de archivos.
>>>>>>> c5375c6 (docs: update translations)

¡Felicidades! Has creado todos los subproyectos requeridos para comenzar a implementar el núcleo de nuestro juego Dunegeon Adventure.  🎉🎉🎉