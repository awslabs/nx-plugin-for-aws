---
title: "Juego de Mazmorra de IA Agéntica"
description: "Un tutorial de cómo construir un juego de aventuras de mazmorra con IA agéntica usando @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Link from '@components/link.astro';
import Drawer from '@components/drawer.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import E2EDiff from '@components/e2e-diff.astro';

import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Módulo 1: Configuración del monorepo

Comenzaremos creando un nuevo monorepo. Desde el directorio deseado, ejecuta el siguiente comando:

<CreateNxWorkspaceCommand workspace="dungeon-adventure" iacProvider="CDK" />

:::note
Pasamos `--iacProvider=CDK` ya que usaremos CDK para infraestructura como código en este tutorial. El Nx Plugin para AWS también soporta `Terraform`.
:::

Esto configurará un monorepo NX dentro del directorio `dungeon-adventure` que podrás abrir en VSCode. Debería verse así:

<FileTree>
- .nx/
- .vscode/
- node_modules/
- packages/ aquí residirán tus subproyectos
- .gitignore
- .npmrc
- .prettierignore
- .prettierrc
- nx.json configura el CLI de NX y los valores por defecto del monorepo
- package.json todas las dependencias de node se definen aquí
- pnpm-lock.yaml o bun.lock, yarn.lock, package-lock.json según el gestor de paquetes
- pnpm-workspace.yaml si usas pnpm
- README.md
- tsconfig.base.json todos los subproyectos basados en node extienden este
- tsconfig.json
- aws-nx-plugin.config.mts configuración para el Nx Plugin para AWS
</FileTree>

Ahora estamos listos para comenzar a crear nuestros diferentes subproyectos usando el `@aws/nx-plugin`.

<Aside type="tip">Es una buena práctica asegurar que todos tus archivos no preparados estén confirmados en Git antes de ejecutar cualquier generador. Esto te permite ver qué ha cambiado después de ejecutar tu generador mediante `git diff`</Aside>

### API del Juego

Primero creemos nuestra Game API. Para esto, crearemos una API tRPC llamada `GameApi` siguiendo estos pasos:

<RunGenerator generator="ts#trpc-api" requiredParameters={{ name: "GameApi" }} noInteractive />

<br />

Deberías ver que han aparecido algunos archivos nuevos en tu árbol de directorios.

<Aside>
El `package.json` raíz ahora está configurado con un `type` de `module`, lo que significa que ESM es el tipo de módulo predeterminado para todos los subproyectos basados en node proporcionados por el `@aws/nx-plugin`. Para más detalles sobre cómo trabajar con proyectos TypeScript, consulta la <Link path="guides/typescript-project">guía ts#project</Link>.
</Aside>

<Drawer title="Archivos actualizados por ts#trpc-api" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados por el generador `ts#trpc-api`. Vamos a examinar algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK específicos de la aplicación
          - apis/
            - **game-api.ts** construct CDK para crear tu API tRPC
            - index.ts
            - ...
          - index.ts
        - core/ constructs CDK genéricos
          - api/
            - rest-api.ts construct base CDK para API Gateway Rest API
            - trpc-utils.ts utilidades para constructs CDK de API tRPC
            - utils.ts utilidades para constructs de API
          - index.ts
          - runtime-config.ts
        - index.ts
      - project.json
      - ...
    - types/ tipos compartidos
      - src/
        - index.ts
        - runtime-config.ts definición de interfaz usada tanto por CDK como por el sitio web
      - project.json
      - ...
  - game-api/ API tRPC
    - src/
      - client/ cliente vanilla típicamente usado para llamadas máquina a máquina en TS
        - index.ts
        - sigv4.ts
      - middleware/ instrumentación con powertools
        - error.ts
        - index.ts
        - logger.ts
        - metrics.ts
        - tracer.ts
      - schema/ definiciones de entradas y salidas para tu API
        - **echo.ts**
      - procedures/ implementaciones específicas de tus procedimientos/rutas de la API
        - **echo.ts**
      - index.ts
      - init.ts configura el contexto y middleware
      - local-server.ts usado al ejecutar el servidor tRPC localmente
      - **router.ts** punto de entrada para tu lambda handler que define todos los procedimientos
    - project.json
    - ...
- eslint.config.mjs
- vitest.workspace.ts
</FileTree>

Echemos un vistazo a algunos de los archivos clave:

```ts {5,12}
// packages/game-api/src/router.ts
import {
  awsLambdaRequestHandler,
  CreateAWSLambdaContextOptions,
} from '@trpc/server/adapters/aws-lambda';
import { echo } from './procedures/echo.js';
import { t } from './init.js';
import { APIGatewayProxyEvent } from 'aws-lambda';

export const router = t.router;

export const appRouter = router({
  echo,
});

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext: (
    ctx: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>,
  ) => ctx,
  responseMeta: () => ({
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': '*',
    },
  }),
});

export type AppRouter = typeof appRouter;
```
El router define el punto de entrada para tu API tRPC y es donde declararás todos tus métodos de API. Como puedes ver arriba, tenemos un método llamado `echo` con su implementación en el archivo `./procedures/echo.ts`.

```ts {2-5}
// packages/game-api/src/procedures/echo.ts
import { publicProcedure } from '../init.js';
import {
  EchoInputSchema,
  EchoOutputSchema,
} from '../schema/echo.js';

export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Este archivo es la implementación del método `echo` y como puedes ver está fuertemente tipado declarando sus estructuras de datos de entrada y salida.

```ts
// packages/game-api/src/schema/echo.ts
import { z } from 'zod';

export const EchoInputSchema = z.object({
  message: z.string(),
});

export type IEchoInput = z.TypeOf<typeof EchoInputSchema>;

export const EchoOutputSchema = z.object({
  result: z.string(),
});

export type IEchoOutput = z.TypeOf<typeof EchoOutputSchema>;
```

Todas las definiciones de esquema tRPC se definen usando [Zod](https://zod.dev/) y se exportan como tipos TypeScript mediante la sintaxis `z.TypeOf`.

```ts
// packages/common/constructs/src/app/apis/game-api.ts
import { Construct } from 'constructs';
import * as url from 'url';
import {
  Code,
  Runtime,
  Function,
  FunctionProps,
  Tracing,
} from 'aws-cdk-lib/aws-lambda';
import {
  AuthorizationType,
  Cors,
  LambdaIntegration,
} from 'aws-cdk-lib/aws-apigateway';
import { Duration, Stack } from 'aws-cdk-lib';
import {
  PolicyDocument,
  PolicyStatement,
  Effect,
  AccountPrincipal,
  AnyPrincipal,
} from 'aws-cdk-lib/aws-iam';
import {
  IntegrationBuilder,
  RestApiIntegration,
} from '../../core/api/utils.js';
import { RestApi } from '../../core/api/rest-api.js';
import { Procedures, routerToOperations } from '../../core/api/trpc-utils.js';
import { AppRouter, appRouter } from ':dungeon-adventure/game-api';

// Tipo de unión de strings para todos los nombres de operaciones de la API
type Operations = Procedures<AppRouter>;

/**
 * Propiedades para crear un construct GameApi
 *
 * @template TIntegrations - Mapa de nombres de operación a sus integraciones
 */
export interface GameApiProps<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> {
  /**
   * Mapa de nombres de operación a sus integraciones de API Gateway
   */
  integrations: TIntegrations;
}

/**
 * Un construct CDK que crea y configura una API REST de AWS API Gateway
 * específicamente para GameApi.
 * @template TIntegrations - Mapa de nombres de operación a sus integraciones
 */
export class GameApi<
  TIntegrations extends Record<Operations, RestApiIntegration>,
> extends RestApi<Operations, TIntegrations> {
  /**
   * Crea integraciones predeterminadas para todas las operaciones, que implementan cada operación como
   * su propia función lambda individual.
   *
   * @param scope - El alcance del construct CDK
   * @returns Un IntegrationBuilder con integraciones lambda predeterminadas
   */
  public static defaultIntegrations = (scope: Construct) => {
    return IntegrationBuilder.rest({
      operations: routerToOperations(appRouter),
      defaultIntegrationOptions: {
        runtime: Runtime.NODEJS_LATEST,
        handler: 'index.handler',
        code: Code.fromAsset(
          url.fileURLToPath(
            new URL(
              '../../../../../../dist/packages/game-api/bundle',
              import.meta.url,
            ),
          ),
        ),
        timeout: Duration.seconds(30),
        tracing: Tracing.ACTIVE,
        environment: {
          AWS_CONNECTION_REUSE_ENABLED: '1',
        },
      } satisfies FunctionProps,
      buildDefaultIntegration: (op, props: FunctionProps) => {
        const handler = new Function(scope, `GameApi${op}Handler`, props);
        return { handler, integration: new LambdaIntegration(handler) };
      },
    });
  };

  constructor(
    scope: Construct,
    id: string,
    props: GameApiProps<TIntegrations>,
  ) {
    super(scope, id, {
      apiName: 'GameApi',
      defaultMethodOptions: {
        authorizationType: AuthorizationType.IAM,
      },
      defaultCorsPreflightOptions: {
        allowOrigins: Cors.ALL_ORIGINS,
        allowMethods: Cors.ALL_METHODS,
      },
      policy: new PolicyDocument({
        statements: [
          // Aquí permitimos que cualquier credencial AWS de la cuenta donde se despliega el proyecto pueda llamar a la API.
          // Se puede definir acceso fino máquina a máquina aquí usando principios más específicos (ej. roles o
          // usuarios) y recursos (ej. qué rutas de API pueden ser invocadas por qué principal) si es necesario.
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AccountPrincipal(Stack.of(scope).account)],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*'],
          }),
          // Abrimos OPTIONS para permitir que los navegadores hagan solicitudes preflight sin autenticar
          new PolicyStatement({
            effect: Effect.ALLOW,
            principals: [new AnyPrincipal()],
            actions: ['execute-api:Invoke'],
            resources: ['execute-api:/*/OPTIONS/*'],
          }),
        ],
      }),
      operations: routerToOperations(appRouter),
      ...props,
    });
  }
}
```

Este es el construct CDK que define nuestro GameApi. Como puedes ver, proporciona un método `defaultIntegrations` que automáticamente crea una función lambda para cada procedimiento en nuestra API tRPC, apuntando a la implementación de la API empaquetada. Esto significa que en el momento de `cdk synth`, no ocurre empaquetado (a diferencia de usar [NodeJsFunction](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html)) ya que ya lo hemos empaquetado como parte del target de build del proyecto backend.

</Drawer>

### Agente de Historia: Proyecto Python

Ahora creemos nuestro Story Agent. Para esto, primero creemos un proyecto Python:

<RunGenerator generator="py#project" requiredParameters={{name:"story"}} noInteractive />

Deberías ver que han aparecido algunos archivos nuevos en tu árbol de directorios.
<Drawer title="Archivos actualizados por py#project" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de archivos generados por el generador `py#project`.

<FileTree>
- .venv/ entorno virtual único para el monorepo
- packages/
  - story/
    - dungeon_adventure_story/ módulo Python
      - hello.py archivo Python de ejemplo (lo ignoraremos)
    - tests/
    - .python-version
    - pyproject.toml
    - project.json
- .python-version versión de Python fijada para UV
- pyproject.toml
- uv.lock
</FileTree>

Esto ha configurado un proyecto Python y un [UV Workspace](https://docs.astral.sh/uv/concepts/projects/workspaces/) con entorno virtual compartido.

</Drawer>

### Agente de Historia: Agente Strands

Luego, agreguemos un agente Strands al proyecto con el generador `py#strands-agent`:

<RunGenerator generator="py#strands-agent" requiredParameters={{project:"story"}} noInteractive />

Deberías ver que han aparecido algunos archivos nuevos en tu árbol de directorios.
<Drawer title="Archivos actualizados por py#strands-agent" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de archivos generados por el generador `py#strands-agent`.

<FileTree>
- packages/
  - story/
    - dungeon_adventure_story/ módulo Python
      - agent/
        - main.py punto de entrada para tu agente en Bedrock AgentCore Runtime
        - agent.py define un agente y herramientas de ejemplo
        - agentcore_mcp_client.py utilidad para crear clientes que interactúen con servidores MCP
        - Dockerfile define la imagen Docker para despliegue en AgentCore Runtime
  - common/constructs/
    - src
      - core/agent-core/
        - runtime.ts construct genérico para desplegar en AgentCore Runtime
      - app/agents/story-agent/
        - story-agent.ts construct para desplegar tu agente Story en AgentCore Runtime
</FileTree>

Examinemos algunos de los archivos en detalle:

```python
# agent/agent.py
from contextlib import contextmanager

from strands import Agent, tool
from strands_tools import current_time


# Define una herramienta personalizada
@tool
def add(a: int, b: int) -> int:
    return a + b


@contextmanager
def get_agent(session_id: str):
    yield Agent(
        system_prompt="""
Eres un mago de la suma.
Usa la herramienta 'add' para tareas de suma.
Refiérete a las herramientas como tu 'grimorio'.
""",
        tools=[add, current_time],
    )
```

Esto crea un agente Strands de ejemplo y define una herramienta de suma.

```python
# agent/main.py
from bedrock_agentcore.runtime import BedrockAgentCoreApp

from .agent import get_agent

app = BedrockAgentCoreApp()


@app.entrypoint
async def invoke(payload, context):
    """Manejador para invocación del agente"""
    prompt = payload.get(
        "prompt", "No se encontró prompt en la entrada, por favor guía al usuario "
        "a crear un payload JSON con la clave prompt"
    )

    with get_agent(session_id=context.session_id) as agent:
        stream = agent.stream_async(prompt)
        async for event in stream:
            print(event)
            yield (event)


if __name__ == "__main__":
    app.run()
```

Este es el punto de entrada para el agente, configurado usando el [Amazon Bedrock AgentCore SDK](https://github.com/aws/bedrock-agentcore-sdk-python). Utiliza soporte de Strands para streaming y transmite eventos de vuelta al cliente a medida que ocurren.

```ts
// common/constructs/src/app/agents/story-agent.ts
import { Lazy, Names } from 'aws-cdk-lib';
import { DockerImageAsset, Platform } from 'aws-cdk-lib/aws-ecr-assets';
import { Construct } from 'constructs';
import { execSync } from 'child_process';
import * as path from 'path';
import * as url from 'url';
import {
  AgentCoreRuntime,
  AgentCoreRuntimeProps,
} from '../../../core/agent-core/runtime.js';

export type StoryAgentProps = Omit<
  AgentCoreRuntimeProps,
  'runtimeName' | 'serverProtocol' | 'containerUri'
>;

export class StoryAgent extends Construct {
  public readonly dockerImage: DockerImageAsset;
  public readonly agentCoreRuntime: AgentCoreRuntime;

  constructor(scope: Construct, id: string, props?: StoryAgentProps) {
    super(scope, id);

    this.dockerImage = new DockerImageAsset(this, 'DockerImage', {
      platform: Platform.LINUX_ARM64,
      directory: path.dirname(url.fileURLToPath(new URL(import.meta.url))),
      extraHash: execSync(
        `docker inspect dungeon-adventure-story-agent:latest --format '{{.Id}}'`,
        { encoding: 'utf-8' },
      ).trim(),
    });

    this.agentCoreRuntime = new AgentCoreRuntime(this, 'StoryAgent', {
      runtimeName: Lazy.string({
        produce: () =>
          Names.uniqueResourceName(this.agentCoreRuntime, { maxLength: 40 }),
      }),
      serverProtocol: 'HTTP',
      containerUri: this.dockerImage.imageUri,
      ...props,
    });
  }
}
```

Esto configura un `DockerImageAsset` de CDK que sube tu imagen Docker del agente a ECR, y la aloja usando AgentCore Runtime.

Puedes notar un `Dockerfile` adicional - este simplemente referencia la imagen Docker del proyecto `story`, permitiéndonos ubicar conjuntamente el Dockerfile y el código fuente del agente.

</Drawer>

### Inventario: Proyecto TypeScript

Ahora creemos un servidor MCP que proveerá herramientas para que nuestro Story Agent gestione el inventario de un jugador.

Primero, creamos un proyecto TypeScript:

<RunGenerator generator="ts#project" requiredParameters={{name:"inventory"}} noInteractive />

Esto creará un proyecto TypeScript vacío.

<Drawer title="Archivos actualizados por ts#project" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de archivos generados por el generador `ts#project`.

<FileTree>
- packages/
  - inventory/
    - src/
      - index.ts punto de entrada con función de ejemplo
    - project.json configuración del proyecto
    - eslint.config.mjs configuración de lint
    - vite.config.ts configuración de pruebas
    - tsconfig.json configuración base de TypeScript para el proyecto
    - tsconfig.lib.json configuración de TypeScript para compilación y empaquetado
    - tsconfig.spec.json configuración de TypeScript para pruebas
- tsconfig.base.json actualizado para configurar un alias que otros proyectos usen para referenciar este
</FileTree>

</Drawer>

### Inventario: Servidor MCP

Luego agregaremos un servidor MCP a nuestro proyecto TypeScript:

<RunGenerator generator="ts#mcp-server" requiredParameters={{project:"inventory"}} noInteractive />

Esto agregará
<Drawer title="Archivos actualizados por ts#mcp-server" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de archivos generados por el generador `ts#mcp-server`.

<FileTree>
- packages/
  - inventory/
    - src/mcp-server/
      - server.ts crea el servidor MCP
      - tools/
        - add.ts herramienta de ejemplo
      - resources/
        - sample-guidance.ts recurso de ejemplo
      - stdio.ts punto de entrada para MCP con transporte STDIO
      - http.ts punto de entrada para MCP con transporte HTTP transmisible
      - Dockerfile construye la imagen para AgentCore Runtime
    - rolldown.config.ts configuración para empaquetar el servidor MCP para despliegue en AgentCore
  - common/constructs/
    - src
      - app/mcp-servers/inventory-mcp-server/
        - inventory-mcp-server.ts construct para desplegar tu servidor MCP de inventario en AgentCore Runtime
</FileTree>

</Drawer>

### Interfaz del Juego: Sitio Web

Ahora creemos la UI que permitirá interactuar con el juego. Para esto, creemos un sitio web llamado `GameUI` siguiendo estos pasos:

<RunGenerator generator="ts#react-website" requiredParameters={{name:"GameUI"}} noInteractive />

Deberías ver que han aparecido algunos archivos nuevos en tu árbol de directorios.

<Drawer title="Archivos actualizados por ts#react-website" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados por el generador `ts#react-website`. Examinaremos algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - app/ constructs CDK específicos de la aplicación
          - static-websites/
            - **game-ui.ts** construct CDK para crear tu Game UI
        - core/
          - static-website.ts construct genérico para sitio web estático
  - game-ui/
    - public/
    - src/
      - components/
        - AppLayout/
          - index.ts diseño general de página: encabezado, pie, barra lateral, etc
          - navitems.ts elementos de navegación de la barra lateral
      - hooks/
        - useAppLayout.tsx permite configurar dinámicamente notificaciones, estilo de página, etc
      - routes/ rutas basadas en @tanstack/react-router
        - index.tsx página raíz '/' redirige a '/welcome'
        - __root.tsx todas las páginas usan este componente como base
        - welcome/
          - **index.tsx**
        - config.ts
        - **main.tsx** punto de entrada de React
        - routeTree.gen.ts este archivo se actualiza automáticamente por @tanstack/react-router
        - styles.css
    - index.html
    - project.json
    - vite.config.ts
    - ...
</FileTree>

```ts
// packages/common/constructs/src/app/static-websites/game-ui.ts
import * as url from 'url';
import { Construct } from 'constructs';
import { StaticWebsite } from '../../core/index.js';

export class GameUI extends StaticWebsite {
  constructor(scope: Construct, id: string) {
    super(scope, id, {
      websiteName: 'GameUI',
      websiteFilePath: url.fileURLToPath(
        new URL(
          '../../../../../../dist/packages/game-ui/bundle',
          import.meta.url,
        ),
      ),
    });
  }
}
```

Este es el construct CDK que define nuestro GameUI. Como puedes ver, ya ha configurado la ruta al bundle generado para nuestra UI basada en Vite. Esto significa que en el momento de `build`, el empaquetado ocurre dentro del target de build del proyecto game-ui y su salida se usa aquí.

```tsx
// packages/game-ui/src/main.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';

import '@cloudscape-design/global-styles/index.css';

const router = createRouter({ routeTree });

// Registra la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}

const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RouterProvider router={router} />
      </I18nProvider>
    </React.StrictMode>,
  );
```

Este es el punto de entrada donde se monta React. Como se muestra, inicialmente solo configura un `@tanstack/react-router` en una configuración de [`enrutamiento basado en archivos`](https://tanstack.com/router/v1/docs/framework/react/routing/file-based-routing). Esto significa que, mientras tu servidor de desarrollo esté ejecutándose, puedes simplemente crear archivos dentro de la carpeta `routes` y `@tanstack/react-router` creará la configuración de archivos necesaria y actualizará el archivo `routeTree.gen.ts`. Este archivo mantiene todas las rutas de manera type-safe, lo que significa que cuando usas `<Link>`, la opción `to` solo mostrará rutas válidas. Para más información, consulta la [documentación de `@tanstack/react-router`](https://tanstack.com/router/v1/docs/framework/react/quick-start).

```tsx
// packages/game-ui/src/routes/welcome/index.tsx
import {
  ContentLayout,
  Header,
  SpaceBetween,
  Container,
} from '@cloudscape-design/components';
import { createFileRoute } from '@tanstack/react-router';

export const Route = createFileRoute('/welcome/')({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <ContentLayout header={<Header>Welcome</Header>}>
      <SpaceBetween size="l">
        <Container>Welcome to your new Cloudscape website!</Container>
      </SpaceBetween>
    </ContentLayout>
  );
}
```

Un componente que se renderizará al navegar a la ruta `/welcome`. `@tanstack/react-router` gestionará la `Route` por ti cuando crees/muevas este archivo (siempre que el servidor de desarrollo esté ejecutándose). Esto se mostrará en una sección posterior de este tutorial.

</Drawer>

### Interfaz del Juego: Autenticación

Ahora configuremos nuestra Game UI para requerir acceso autenticado mediante Amazon Cognito siguiendo estos pasos:

<RunGenerator generator="ts#react-website#auth" requiredParameters={{cognitoDomain:"game-ui", project:"@dungeon-adventure/game-ui", allowSignup:true}} noInteractive />

Deberías ver que han aparecido/cambiado algunos archivos nuevos en tu árbol de directorios.

<Drawer title="Archivos actualizados por ts#react-website#auth" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `ts#react-website#auth`. Examinaremos algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - user-identity.ts construct CDK para crear pools de usuarios/identidad
    - types/
      - src/
        - runtime-config.ts actualizado para agregar cognitoProps
  - game-ui/
    - src/
      - components/
        - AppLayout/
          - index.tsx agrega el usuario conectado/cierre de sesión al encabezado
        - CognitoAuth/
          - index.ts gestiona el inicio de sesión en Cognito
        - RuntimeConfig/
          - index.tsx obtiene el `runtime-config.json` y lo provee a los hijos vía contexto
      - hooks/
        - useRuntimeConfig.tsx
      - **main.tsx** Actualizado para agregar Cognito
</FileTree>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import CognitoAuth from './components/CognitoAuth';
+import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
+        <RuntimeConfigProvider>
+          <CognitoAuth>
            <RouterProvider router={router} />
+          </CognitoAuth>
+        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

Los componentes `RuntimeConfigProvider` y `CognitoAuth` han sido agregados al archivo `main.tsx` mediante una transformación AST. Esto permite que el componente `CognitoAuth` se autentique con Amazon Cognito obteniendo el `runtime-config.json` que contiene la configuración de conexión a Cognito necesaria para realizar las llamadas al backend al destino correcto.

</Drawer>

### Interfaz del Juego: Conectar a Game API

Ahora configuremos nuestra Game UI para conectarse a nuestra Game API creada previamente:

<RunGenerator generator="api-connection" requiredParameters={{sourceProject:"@dungeon-adventure/game-ui", targetProject:"@dungeon-adventure/game-api"}} noInteractive />

Deberías ver que han aparecido/cambiado algunos archivos nuevos en tu árbol de directorios.

<Drawer title="Archivos actualizados por la conexión UI -> tRPC" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `api-connection`. Examinaremos algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- packages/
  - game-ui/
    - src/
      - components/
        - GameApiClientProvider.tsx configura el cliente de GameAPI
      - hooks/
        - **useGameApi.tsx** hooks para llamar a la GameApi
      - **main.tsx** inyecta los proveedores del cliente trpc
- package.json

</FileTree>

```tsx
// packages/game-ui/src/hooks/useGameApi.tsx
import { GameApiTRCPContext } from '../components/GameApiClientProvider';

export const useGameApi = GameApiTRCPContext.useTRPC;
```

Este hook usa la última [integración de React Query de tRPC](https://trpc.io/blog/introducing-tanstack-react-query-client) permitiendo a los usuarios interactuar con `@tanstack/react-query` directamente sin capas adicionales de abstracción. Para ejemplos de cómo llamar a APIs tRPC, consulta la <Link path="guides/api-connection/react-trpc#using-the-generated-code">guía de uso del hook tRPC</Link>.

<Aside>
El hook `useGameApi` es diferente al hook `useStoryApi` ya que no requiere un build para que los cambios se reflejen gracias al uso de [inferencia de TypeScript](https://trpc.io/docs/concepts) por parte de tRPC. ¡Esto permite a los desarrolladores hacer cambios en su backend que se reflejan instantáneamente en su frontend!
</Aside>

```diff lang="tsx"
// packages/game-ui/src/main.tsx
+import GameApiClientProvider from './components/GameApiClientProvider';
+import QueryClientProvider from './components/QueryClientProvider';
import CognitoAuth from './components/CognitoAuth';
import RuntimeConfigProvider from './components/RuntimeConfig';
import React from 'react';
import { createRoot } from 'react-dom/client';
import { I18nProvider } from '@cloudscape-design/components/i18n';
import messages from '@cloudscape-design/components/i18n/messages/all.en';
import { RouterProvider, createRouter } from '@tanstack/react-router';
import { routeTree } from './routeTree.gen';
import '@cloudscape-design/global-styles/index.css';
const router = createRouter({ routeTree });
// Registra la instancia del router para seguridad de tipos
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
const root = document.getElementById('root');
root &&
  createRoot(root).render(
    <React.StrictMode>
      <I18nProvider locale="en" messages={[messages]}>
        <RuntimeConfigProvider>
          <CognitoAuth>
+            <QueryClientProvider>
+              <GameApiClientProvider>
                <RouterProvider router={router} />
+              </GameApiClientProvider>
+            </QueryClientProvider>
          </CognitoAuth>
        </RuntimeConfigProvider>
      </I18nProvider>
    </React.StrictMode>,
  );
```

El archivo `main.tsx` ha sido actualizado mediante una transformación AST para inyectar los proveedores de tRPC.

</Drawer>

### Interfaz del Juego: Infraestructura

Ahora el último subproyecto que necesitamos crear es para la infraestructura CDK. Para crearlo, sigue estos pasos:

<RunGenerator generator="ts#infra" requiredParameters={{name:"infra"}} noInteractive />

Deberías ver que han aparecido/cambiado algunos archivos nuevos en tu árbol de directorios.

<Drawer title="Archivos actualizados por ts#infra" trigger="Haz clic aquí para examinar estos archivos en detalle.">
A continuación se muestra una lista de todos los archivos generados/actualizados por el generador `ts#infra`. Examinaremos algunos de los archivos clave resaltados en el árbol de archivos:
<FileTree>
- packages/
  - common/
    - constructs/
      - src/
        - core/
          - checkov.ts
          - index.ts
  - infra
    - src/
      - stages/
        - **application-stage.ts** stacks CDK definidos aquí
      - stacks/
        - **application-stack.ts** recursos CDK definidos aquí
      - index.ts
      - **main.ts** punto de entrada que define todas las etapas
    - cdk.json
    - project.json
    - ...
  - package.json
  - tsconfig.json agregadas referencias
  - tsconfig.base.json agregado alias

</FileTree>

```ts
// packages/infra/src/main.ts
import { ApplicationStage } from './stacks/application-stage.js';
import { App } from ':dungeon-adventure/common-constructs';

const app = new App();

// Usa esto para desplegar tu propio entorno sandbox (asume tus credenciales CLI)
new ApplicationStage(app, 'dungeon-adventure-infra-sandbox', {
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
});

app.synth();
```

<Aside type="tip">Si ves un error de importación en tu IDE, es porque nuestro proyecto de infraestructura aún no tiene una referencia TypeScript configurada en su tsconfig.json. Nx ha sido [configurado](https://nx.dev/nx-api/js/generators/typescript-sync) para crear estas referencias *dinámicamente* cuando se ejecuta un build/compile o si ejecutas el comando `nx sync` manualmente. Para más información consulta la <Link path="guides/typescript-project#importing-your-library-code-in-other-projects">guía de TypeScript</Link>.</Aside>

Este es el punto de entrada para tu aplicación CDK.

```ts
// packages/infra/src/stacks/application-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';

export class ApplicationStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // El código que define tu stack va aquí
  }
}
```

Aquí es donde instanciaremos nuestros constructs CDK para construir nuestro juego de aventuras.

</Drawer>

#### Actualizar nuestra infraestructura

Hagamos una actualización en nuestro `packages/infra/src/stacks/application-stack.ts` para instanciar algunos de nuestros constructs ya generados:


<E2EDiff before="dungeon-adventure/1/application-stack.ts.original.template" after="dungeon-adventure/1/application-stack.ts.template" lang="ts" />

Nota que aquí proveemos integraciones predeterminadas para nuestra Game API. Por defecto, cada operación en nuestra API se mapea a una función lambda individual para manejar esa operación.

### Construyendo nuestro código

<Drawer title="Comandos de Nx" trigger="Ahora es momento de construir nuestro código por primera vez">
###### Targets únicos vs múltiples

El comando `run-many` ejecutará un target en múltiples subproyectos listados (`--all` los seleccionará todos). Se asegurará de que las dependencias se ejecuten en el orden correcto.

También puedes disparar un build (o cualquier otra tarea) para un target de proyecto único ejecutando el target directamente en el proyecto. Por ejemplo, si queremos construir el proyecto `@dungeon-adventure/infra`, puedes ejecutar:

<NxCommands commands={['run @dungeon-adventure/infra:build']} />

También puedes omitir el scope y usar la sintaxis abreviada de Nx si prefieres:

<NxCommands commands={['build infra']} />

###### Visualizando tus dependencias

También puedes visualizar tus dependencias mediante:

<NxCommands commands={['graph']} />
<br/>

<Image src={nxGraphPng} alt="nx-graph.png" width="800" height="600" />

###### Caché

Nx depende del [caching](https://nx.dev/concepts/how-caching-works) para reutilizar artefactos de builds previos y acelerar el desarrollo. Se requiere cierta configuración para que esto funcione correctamente y puede haber casos donde quieras realizar un build **sin usar la caché**. Para eso, simplemente agrega el argumento `--skip-nx-cache` a tu comando. Por ejemplo:

<NxCommands commands={['run @dungeon-adventure/infra:build --skip-nx-cache']} />
Si por alguna razón quisieras limpiar tu caché (almacenada en la carpeta `.nx`), puedes ejecutar:

<NxCommands commands={['reset']} />

</Drawer>

<NxCommands commands={['run-many --target build --all']} />

Deberías ver el siguiente mensaje:

```bash
 NX   The workspace is out of sync

[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date? …
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Este mensaje indica que NX ha detectado algunos archivos que pueden actualizarse automáticamente. En este caso, se refiere a los archivos `tsconfig.json` que no tienen referencias de proyecto configuradas en proyectos dependientes. Selecciona la opción **Yes, sync the changes and run the tasks** para continuar. Deberías notar que todos los errores de importación en tu IDE se resuelven automáticamente, ya que el generador de sync agregará las referencias TypeScript faltantes.

<Aside type="tip">
Si encuentras errores de lint, puedes ejecutar el siguiente comando para corregirlos automáticamente.

<NxCommands commands={['run-many --target lint --configuration=fix --all']} />
</Aside>

Todos los artefactos construidos están ahora disponibles dentro de la carpeta `dist/` ubicada en la raíz del monorepo. Esta es una práctica estándar cuando se usan proyectos generados por el `@aws/nx-plugin` ya que no contamina tu árbol de archivos con archivos generados. En caso de que quieras limpiar tus archivos, simplemente puedes eliminar la carpeta `dist/` sin preocuparte por archivos generados esparcidos por el árbol de directorios.

¡Felicidades! Has creado todos los subproyectos requeridos para comenzar a implementar el núcleo de nuestro juego Dungeon Adventure.  🎉🎉🎉