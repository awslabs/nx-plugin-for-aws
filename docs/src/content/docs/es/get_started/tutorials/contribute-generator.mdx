---
title: "Contribuir con un Generador"
description: "Un recorrido sobre cómo construir un generador usando @aws/nx-plugin."
---



import {
  Aside,
  Code,
  FileTree,
  Steps,
  Tabs,
  TabItem,
} from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Drawer from '@components/drawer.astro';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import LinkCommand from '@components/link-command.astro';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import InstallCommand from '@components/install-command.astro';
import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png';
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png';
import baselineWebsitePng from '@assets/baseline-website.png';
import baselineGamePng from '@assets/baseline-game.png';
import nxGraphPng from '@assets/nx-graph.png';
import gameSelectPng from '@assets/game-select.png';
import gameConversationPng from '@assets/game-conversation.png';

Vamos a crear un nuevo generador para contribuir a `@aws/nx-plugin`. Nuestro objetivo será generar un nuevo procedimiento para una API tRPC.

### Clona el plugin

Primero, clonemos el plugin:

```bash
git clone git@github.com:awslabs/nx-plugin-for-aws.git
```

Luego instala y construye:

```bash
cd nx-plugin-for-aws
pnpm i
pnpm nx run-many --target build --all
```

### Crea un generador vacío

Creemos el nuevo generador en `packages/nx-plugin/src/trpc/procedure`.

¡Proveemos un generador para crear nuevos generadores para que puedas estructurar rápidamente tu nuevo generador! Puedes ejecutar este generador de la siguiente manera:

<RunGenerator generator="ts#nx-generator" requiredParameters={{ pluginProject: '@aws/nx-plugin', name: 'ts#trpc-api#procedure', directory: 'trpc/procedure', description: 'Adds a procedure to a tRPC API' }} />

Notarás que se han generado los siguientes archivos:

<FileTree>
  - packages/nx-plugin/src/trpc/procedure
    - schema.json Define las entradas del generador
    - schema.d.ts Interfaz TypeScript que coincide con el schema
    - generator.ts Función que Nx ejecuta como generador
    - generator.spec.ts Pruebas para el generador
  - docs/src/content/docs/guides/
    - trpc-procedure.mdx Documentación del generador
  - packages/nx-plugin/generators.json Actualizado para incluir el generador
</FileTree>

Actualicemos el schema para agregar las propiedades que necesitaremos:

<Tabs>
  <TabItem label="schema.json">
    ```json
    {
      "$schema": "https://json-schema.org/schema",
      "$id": "tRPCProcedure",
      "title": "Adds a procedure to a tRPC API",
      "type": "object",
      "properties": {
        "project": {
          "type": "string",
          "description": "tRPC API project",
          "x-prompt": "Select the tRPC API project to add the procedure to",
          "x-dropdown": "projects",
          "x-priority": "important"
        },
        "procedure": {
          "description": "The name of the new procedure",
          "type": "string",
          "x-prompt": "What would you like to call your new procedure?",
          "x-priority": "important",
        },
        "type": {
          "description": "The type of procedure to generate",
          "type": "string",
          "x-prompt": "What type of procedure would you like to generate?",
          "x-priority": "important",
          "default": "query",
          "enum": ["query", "mutation"]
        }
      },
      "required": ["project", "procedure"]
    }
    ```
  </TabItem>
  <TabItem label="schema.d.ts">
    ```ts
    export interface TrpcProcedureSchema {
      project: string;
      procedure: string;
      type: 'query' | 'mutation';
    }
    ```
  </TabItem>
</Tabs>

:::note
Observa que el generador recibe un `Tree` como entrada, junto con las opciones definidas en nuestro schema. El `Tree` es esencialmente un sistema de archivos virtual del cual podemos leer y escribir para crear o actualizar archivos del proyecto. No queremos tocar el sistema de archivos directamente, ya que no queremos hacer cambios si los usuarios ejecutan el generador en modo "dry-run".
:::

Notarás que el generador ya ha sido registrado en `packages/nx-plugin/generators.json`:

```json
 ...
  "generators": {
    ...
    "ts#trpc-api#procedure": {
      "factory": "./src/trpc/procedure/generator",
      "schema": "./src/trpc/procedure/schema.json",
      "description": "Adds a procedure to a tRPC API"
    }
  },
...
```

### Implementa el generador

Para agregar un procedimiento a una API tRPC, necesitamos hacer dos cosas:

1. Crear un archivo TypeScript para el nuevo procedimiento
2. Agregar el procedimiento al router

#### Crea el nuevo procedimiento

Para crear el archivo TypeScript del nuevo procedimiento, usaremos una utilidad llamada `generateFiles`. Con esto, podemos definir una plantilla [EJS](https://ejs.co/) que renderizaremos en nuestro generador con variables basadas en las opciones seleccionadas por el usuario.

Primero, definiremos la plantilla en `packages/nx-plugin/src/trpc/procedure/files/procedures/__procedureNameKebabCase__.ts.template`:

```ts title="files/procedures/__procedureNameKebabCase__.ts.template"
import { publicProcedure } from '../init.js';
import { z } from 'zod';

export const <%- procedureNameCamelCase %> = publicProcedure
  .input(z.object({
    // TODO: define input
  }))
  .output(z.object({
    // TODO: define output
  }))
  .<%- procedureType %>(async ({ input, ctx }) => {
    // TODO: implement!
    return {};
  });
```

:::tip
Cuando `generateFiles` procesa la plantilla, reemplazará las referencias a `__<variable>__` en nombres de archivo/directorio con los valores proporcionados, y eliminará el `.template` del nombre del archivo.

El contenido de la plantilla es [EJS](https://ejs.co/), donde las variables se referencian usando la sintaxis `<% ... %>`.
:::

En la plantilla, hicimos referencia a tres variables:

- `procedureNameCamelCase`
- `procedureNameKebabCase`
- `procedureType`

Así que necesitamos asegurarnos de pasar esas variables a `generateFiles`, junto con el directorio donde generar los archivos, específicamente la ubicación de los archivos fuente (es decir, `sourceRoot`) para el proyecto tRPC seleccionado por el usuario como entrada del generador, que podemos extraer de la configuración del proyecto.

Actualicemos el generador para hacer esto:

```ts title="procedure/generator.ts" {8-19}
import {
  generateFiles,
  joinPathFragments,
  readProjectConfiguration,
  Tree,
} from '@nx/devkit';
import { TrpcProcedureSchema } from './schema';
import { formatFilesInSubtree } from '../../utils/format';
import camelCase from 'lodash.camelcase';
import kebabCase from 'lodash.kebabcase';

export const trpcProcedureGenerator = async (
  tree: Tree,
  options: TrpcProcedureSchema,
) => {
  const projectConfig = readProjectConfiguration(tree, options.project);

  const procedureNameCamelCase = camelCase(options.procedure);
  const procedureNameKebabCase = kebabCase(options.procedure);

  generateFiles(
    tree,
    joinPathFragments(__dirname, 'files'),
    projectConfig.sourceRoot,
    {
      procedureNameCamelCase,
      procedureNameKebabCase,
      procedureType: options.type,
    },
  );

  await formatFilesInSubtree(tree);
};

export default trpcProcedureGenerator;
```

:::tip
También llamamos a `formatFilesInSubtree` al final del generador, lo que asegura que cualquier archivo que creemos o modifiquemos se formatee según la configuración de [prettier](https://prettier.io/) del usuario.
:::

#### Agrega el procedimiento al router

Luego, queremos que el generador conecte el nuevo procedimiento al router. ¡Esto implica leer y actualizar el código fuente del usuario!

Usamos manipulación de AST de TypeScript para actualizar las partes relevantes del archivo fuente. Hay algunos helpers llamados `replace` y `destructuredImport` para facilitar esto.

```ts title="procedure/generator.ts" {6, 23-33}
import {
  generateFiles,
  joinPathFragments,
  readProjectConfiguration,
  Tree,
} from '@nx/devkit';
import { TrpcProcedureSchema } from './schema';
import { formatFilesInSubtree } from '../../utils/format';
import camelCase from 'lodash.camelcase';
import kebabCase from 'lodash.kebabcase';
import { destructuredImport, replace } from '../../utils/ast';
import { factory, ObjectLiteralExpression } from 'typescript';

export const trpcProcedureGenerator = async (
  tree: Tree,
  options: TrpcProcedureSchema,
) => {
  const projectConfig = readProjectConfiguration(tree, options.project);

  const procedureNameCamelCase = camelCase(options.procedure);
  const procedureNameKebabCase = kebabCase(options.procedure);

  generateFiles(
    tree,
    joinPathFragments(__dirname, 'files'),
    projectConfig.sourceRoot,
    {
      procedureNameCamelCase,
      procedureNameKebabCase,
      procedureType: options.type,
    },
  );

  const routerPath = joinPathFragments(projectConfig.sourceRoot, 'router.ts');

  destructuredImport(
    tree,
    routerPath,
    [procedureNameCamelCase],
    `./procedures/${procedureNameKebabCase}.js`,
  );

  replace(
    tree,
    routerPath,
    'CallExpression[expression.name="router"] > ObjectLiteralExpression',
    (node) =>
      factory.createObjectLiteralExpression([
        ...(node as ObjectLiteralExpression).properties,
        factory.createShorthandPropertyAssignment(procedureNameCamelCase),
      ]),
  );

  await formatFilesInSubtree(tree);
};

export default trpcProcedureGenerator;
```

:::tip
En el fragmento de código anterior, `replace` usa un selector [tsquery](https://github.com/phenomnomnominal/tsquery) para encontrar el argumento agregado a la función `router`.

Puedes usar el [tsquery playground](https://tsquery-playground.firebaseapp.com/) como una herramienta útil para probar diferentes selectores.
:::

Ahora que hemos implementado el generador, compilémoslo para asegurarnos de que esté disponible para probarlo en nuestro proyecto de aventura dungeon.

```bash
pnpm nx run @aws/nx-plugin:compile
```

### Probando el generador

Para probar el generador, vincularemos nuestro Nx Plugin for AWS local a una base de código existente.

#### Crea un proyecto de prueba con una API tRPC

:::note
Si has completado el <Link path="get_started/tutorials/dungeon_game/overview">tutorial de aventura dungeon</Link>, o ya tienes otro workspace Nx existente que usa una API tRPC, puedes saltar este paso.
:::

En un directorio separado, crea un nuevo workspace de prueba:

<CreateNxWorkspaceCommand workspace="trpc-generator-test" />

Luego, generemos una API tRPC para agregar el procedimiento:

<RunGenerator generator="ts#trpc-api" requiredParameters={{apiName:"test-api"}} noInteractive />

#### Vincula nuestro Nx Plugin for AWS local

En tu base de código, vinculamos nuestro `@aws/nx-plugin` local:

<LinkCommand
  dependency="@aws/nx-plugin"
  dependencyPath="path/to/nx-plugin-for-aws/dist/packages/nx-plugin"
  projectPath="path/to/trpc-generator-test"
/>

:::note
Observa que vinculamos al plugin compilado en `dist/packages/nx-plugin` en lugar del código fuente.
:::

#### Ejecuta el nuevo generador

Probemos el nuevo generador:

<RunGenerator generator="ts#trpc-api#procedure" />

:::note
Si no ves el nuevo generador en la lista en VSCode, quizás necesites refrescar el workspace Nx:

<NxCommands commands={['reset']} />
:::

Si tiene éxito, deberíamos haber generado un nuevo procedimiento y agregado el procedimiento a nuestro router en `router.ts`.

### Ejercicios

Si has llegado hasta aquí y aún tienes tiempo para experimentar con generadores Nx, aquí hay algunas sugerencias de características para agregar al generador de procedimientos:

#### 1. Operaciones anidadas

Intenta actualizar el generador para soportar routers anidados:

- Aceptando notación de puntos para la entrada `procedure` (ej. `games.query`)
- Generando un procedimiento con nombre basado en la notación de puntos invertida (ej. `queryGames`)
- ¡Agregando el router anidado apropiado (o actualizándolo si ya existe)!

#### 2. Validación

Nuestro generador debería prevenir problemas potenciales, como que un usuario seleccione un `project` que no sea una API tRPC. Mira el generador `api-connection` para ver un ejemplo de esto.

#### 3. Pruebas unitarias

Escribe algunas pruebas unitarias para el generador. Son bastante sencillas de implementar y la mayoría sigue el flujo general:

1. Crea un workspace tree vacío usando `createTreeUsingTsSolutionSetup()`
2. Agrega cualquier archivo que deba existir previamente en el tree (ej. `project.json` y `src/router.ts` para un backend tRPC)
3. Ejecuta el generador bajo prueba
4. Valida que los cambios esperados se realicen en el tree

#### 4. Pruebas end-to-end

Actualmente tenemos una sola "prueba de humo" que ejecuta todos los generadores y verifica que la construcción tenga éxito. Esto debería actualizarse para incluir el nuevo generador.