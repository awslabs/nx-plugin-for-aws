---
title: "Crear un generador"
description: "Un tutorial de cómo construir un generador usando @aws/nx-plugin."
---



import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import { Image } from 'astro:assets';
import Drawer from '@components/drawer.astro';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import InstallCommand from '@components/install-command.astro';
import dungeonAdventureArchitecturePng from '@assets/dungeon-game-architecture.png'
import dungeonAdventureErPng from '@assets/dungeon-adventure-er.png'
import baselineWebsitePng from '@assets/baseline-website.png'
import baselineGamePng from '@assets/baseline-game.png'
import nxGraphPng from '@assets/nx-graph.png'
import gameSelectPng from '@assets/game-select.png'
import gameConversationPng from '@assets/game-conversation.png'

## Crear un generador

Vamos a crear un nuevo generador. Nuestro objetivo será generar un nuevo procedimiento para nuestra API tRPC.

### Clonar el plugin

Primero, clonemos el plugin:

```bash
git clone git@github.com:awslabs/nx-plugin-for-aws.git
```

Luego, instalar y construir:

```bash
cd nx-plugin-for-aws
pnpm i
pnpm nx run-many --target build --all
```

### Crear un generador vacío

Creemos el nuevo generador en `packages/nx-plugin/src/trpc/procedure`. Comenzaremos creando el schema y un punto de entrada para nuestro generador:

<FileTree>
  - packages/nx-plugin/src/trpc/procedure
    - schema.json Define la entrada para nuestro generador
    - schema.d.ts Interfaz TypeScript que coincide con el schema
    - generator.ts Función que Nx ejecuta como nuestro generador
</FileTree>

Agrega el siguiente contenido a cada archivo.

<Tabs>
  <TabItem label="schema.json">
    ```json
    {
      "$schema": "https://json-schema.org/schema",
      "$id": "tRPCProcedure",
      "title": "Añade un procedimiento a una API tRPC",
      "type": "object",
      "properties": {
        "project": {
          "type": "string",
          "description": "Proyecto de API tRPC",
          "x-prompt": "Selecciona el proyecto de API tRPC al que añadir el procedimiento",
          "x-dropdown": "projects",
          "x-priority": "important"
        },
        "procedure": {
          "description": "Nombre del nuevo procedimiento",
          "type": "string",
          "x-prompt": "¿Cómo quieres llamar a tu nuevo procedimiento?",
          "x-priority": "important",
        },
        "type": {
          "description": "Tipo de procedimiento a generar",
          "type": "string",
          "x-prompt": "¿Qué tipo de procedimiento quieres generar?",
          "x-priority": "important",
          "default": "query",
          "enum": ["query", "mutation"]
        }
      },
      "required": ["project", "procedure"]
    }
    ```
  </TabItem>
  <TabItem label="schema.d.ts">
    ```ts
    export interface TrpcProcedureSchema {
      project: string;
      procedure: string;
      type: 'query' | 'mutation';
    }
    ```
  </TabItem>
  <TabItem label="generator.ts">
    ```ts
    import { Tree } from '@nx/devkit';
    import { TrpcProcedureSchema } from './schema';

    export const trpcProcedureGenerator = async (tree: Tree, options: TrpcProcedureSchema) => {

    };

    export default trpcProcedureGenerator;

    ```
  </TabItem>
</Tabs>

:::note
Observa que nuestro generador recibe un `Tree` como entrada, junto con las opciones definidas en nuestro schema. El `Tree` es esencialmente un sistema de archivos virtual que podemos leer y modificar para crear o actualizar archivos del proyecto. No queremos tocar el sistema de archivos directamente, ya que no debemos realizar cambios si los usuarios ejecutan nuestro generador en modo "dry-run".
:::

Ahora, conectemos nuestro generador actualizando `packages/nx-plugin/generators.json`:

```json
 ...
  "generators": {
    ...
    "ts#trpc-api#procedure": {
      "factory": "./src/trpc/procedure/generator",
      "schema": "./src/trpc/procedure/schema.json",
      "description": "Añade un procedimiento a una API tRPC"
    }
  },
...
```

### Implementar el generador

Para añadir un procedimiento a una API tRPC, necesitamos hacer dos cosas:

1. Crear un archivo TypeScript para el nuevo procedimiento
2. Añadir el procedimiento al enrutador

#### Crear el nuevo procedimiento

Para crear el archivo TypeScript, usaremos una utilidad llamada `generateFiles`. Con esta, podemos definir una plantilla [EJS](https://ejs.co/) que renderizaremos en nuestro generador con variables basadas en las opciones seleccionadas por el usuario.

Primero, definamos nuestra plantilla en `packages/nx-plugin/src/trpc/procedure/files/procedures/__procedureNameKebabCase__.ts.template`:

```ts title="files/procedures/__procedureNameKebabCase__.ts.template"
import { publicProcedure } from '../init.js';
import { z } from 'zod';

export const <%- procedureNameCamelCase %> = publicProcedure
  .input(z.object({
    // TODO: definir entrada
  }))
  .output(z.object({
    // TODO: definir salida
  }))
  .<%- procedureType %>(async ({ input, ctx }) => {
    // TODO: implementar
    return {};
  });
```

:::tip
Cuando `generateFiles` procesa nuestra plantilla, reemplazará las referencias a `__<variable>__` en nombres de archivo/directorio con los valores proporcionados, y eliminará el `.template` del nombre del archivo.

El contenido de la plantilla usa [EJS](https://ejs.co/), donde las variables se referencian usando la sintaxis `<% ... %>`.
:::

En la plantilla, usamos tres variables:

* `procedureNameCamelCase`
* `procedureNameKebabCase`
* `procedureType`

Debemos asegurarnos de pasar estas variables a `generateFiles`, junto con el directorio de destino, que será el `sourceRoot` del proyecto tRPC seleccionado por el usuario, obtenible de la configuración del proyecto.

Actualicemos nuestro generador:

```ts title="procedure/generator.ts" {8-19}
import { generateFiles, joinPathFragments, readProjectConfiguration, Tree } from '@nx/devkit';
import { TrpcProcedureSchema } from './schema';
import { formatFilesInSubtree } from '../../utils/format';
import camelCase from 'lodash.camelcase';
import kebabCase from 'lodash.kebabcase';

export const trpcProcedureGenerator = async (tree: Tree, options: TrpcProcedureSchema) => {
  const projectConfig = readProjectConfiguration(tree, options.project);

  const procedureNameCamelCase = camelCase(options.procedure);
  const procedureNameKebabCase = kebabCase(options.procedure);

  generateFiles(tree, joinPathFragments(__dirname, 'files'), projectConfig.sourceRoot, {
    procedureNameCamelCase,
    procedureNameKebabCase,
    procedureType: options.type,
  });

  await formatFilesInSubtree(tree);
};

export default trpcProcedureGenerator;
```

:::tip
También llamamos a `formatFilesInSubtree` al final del generador, lo que asegura que los archivos creados o modificados se formateen según la configuración de [prettier](https://prettier.io/) del usuario.
:::

#### Añadir el procedimiento al enrutador

Ahora queremos que el generador registre nuestro nuevo procedimiento en el enrutador. ¡Esto implica leer y modificar el código fuente del usuario!

Usamos manipulación del AST de TypeScript para actualizar las partes relevantes del archivo fuente. Hay helpers llamados `replace` y `destructuredImport` para facilitar esto.

```ts title="procedure/generator.ts" {6, 23-33}
import { generateFiles, joinPathFragments, readProjectConfiguration, Tree } from '@nx/devkit';
import { TrpcProcedureSchema } from './schema';
import { formatFilesInSubtree } from '../../utils/format';
import camelCase from 'lodash.camelcase';
import kebabCase from 'lodash.kebabcase';
import { destructuredImport, replace } from '../../utils/ast';
import { factory, ObjectLiteralExpression } from 'typescript';

export const trpcProcedureGenerator = async (tree: Tree, options: TrpcProcedureSchema) => {
  const projectConfig = readProjectConfiguration(tree, options.project);

  const procedureNameCamelCase = camelCase(options.procedure);
  const procedureNameKebabCase = kebabCase(options.procedure);

  generateFiles(tree, joinPathFragments(__dirname, 'files'), projectConfig.sourceRoot, {
    procedureNameCamelCase,
    procedureNameKebabCase,
    procedureType: options.type,
  });

  const routerPath = joinPathFragments(projectConfig.sourceRoot, 'router.ts');

  destructuredImport(tree, routerPath, [procedureNameCamelCase], `./procedures/${procedureNameKebabCase}.js`);

  replace(
    tree,
    routerPath,
    'CallExpression[expression.name="router"] > ObjectLiteralExpression',
    (node) => factory.createObjectLiteralExpression([
      ...(node as ObjectLiteralExpression).properties,
      factory.createShorthandPropertyAssignment(procedureNameCamelCase),
    ]),
  );

  await formatFilesInSubtree(tree);
};

export default trpcProcedureGenerator;
```

:::tip
En el fragmento anterior, `replace` usa un selector [tsquery](https://github.com/phenomnomnominal/tsquery) para encontrar el argumento añadido a la función `router`.

Puedes usar el [tsquery playground](https://tsquery-playground.firebaseapp.com/) como herramienta para probar diferentes selectores.
:::

Ahora que hemos implementado nuestro generador, compilémoslo para probarlo en nuestro proyecto dungeon-adventure.

```bash
pnpm nx run @aws/nx-plugin:compile
```

### Probar nuestro generador

Para probar el generador, vincularemos nuestro plugin local al código de <Link path="get_started/tutorials/dungeon-game/overview">dungeon-adventure</Link>.

::::note
No hay problema si no completaste el tutorial de dungeon adventure, esto funcionará en cualquier código base con Nx.
::::

En tu código base, vinculamos nuestro `@aws/nx-plugin` local:

```bash
cd ruta/a/dungeon-adventure
pnpm link ruta/a/nx-plugin-for-aws/dist/packages/nx-plugin
```

:::note
Observa que vinculamos al plugin compilado en `dist/packages/nx-plugin` en lugar del código fuente.
:::

Probemos nuestro nuevo generador:

<RunGenerator generator="ts#trpc-api#procedure" />

:::note
Si no ves el nuevo generador en la lista de VSCode, quizás necesites actualizar el workspace de Nx:

<NxCommands commands={['reset']} />
:::

Si tiene éxito, deberíamos haber generado un nuevo procedimiento y añadido este al enrutador en `router.ts`.

### Ejercicios

Si llegaste hasta aquí y quieres experimentar más con generadores de Nx, aquí tienes algunas sugerencias:

#### 1. Operaciones anidadas

En nuestro juego dungeon adventure usamos enrutadores anidados para agrupar operaciones relacionadas. Intenta actualizar el generador para soportar esto:

* Aceptar notación de puntos para `procedure` (ej: `games.query`)
* Generar un procedimiento con nombre basado en la notación inversa (ej: `queryGames`)
* Añadir el enrutador anidado apropiado (o actualizarlo si ya existe)

#### 2. Validación

Nuestro generador debería prevenir problemas potenciales, como seleccionar un `project` que no sea una API tRPC. Revisa el generador `api-connection` para ver un ejemplo.

#### 3. Pruebas unitarias

Escribe pruebas unitarias para el generador. Siguen un flujo simple:

1. Crear un workspace vacío con `createTreeUsingTsSolutionSetup()`
2. Añadir archivos necesarios (ej: `project.json` y `src/router.ts`)
3. Ejecutar el generador
4. Verificar los cambios en el árbol

#### 4. Pruebas end-to-end

Actualmente tenemos una "prueba de humo" que ejecuta todos los generadores. Actualízala para incluir el nuevo generador.

#### 5. ¡Contribuye!

Si nadie ha contribuido este generador a `@aws/nx-plugin`, ¡envíanos un pull request! Si ya existe, piensa en otro generador que puedas aportar.