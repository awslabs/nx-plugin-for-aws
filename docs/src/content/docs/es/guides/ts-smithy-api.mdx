---
title: "Smithy TypeScript API"
description: "Documentación de referencia para Smithy TypeScript API"
---

import { FileTree, AnchorHeading, Tabs, TabItem } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Infrastructure from '@components/infrastructure.astro';
import Snippet from '@components/snippet.astro';

[Smithy](https://smithy.io/) es un lenguaje de definición de interfaces independiente del protocolo para crear APIs de manera modelada.

El generador de API TypeScript para Smithy crea una nueva API usando Smithy para la definición del servicio y el [SDK de servidor TypeScript para Smithy](https://github.com/awslabs/smithy-typescript) para la implementación. El generador provee infraestructura como código con CDK o Terraform para desplegar tu servicio en AWS Lambda, expuesto a través de una API REST de AWS API Gateway. Ofrece desarrollo de APIs con seguridad de tipos mediante generación automática de código a partir de modelos Smithy. El manejador generado utiliza [AWS Lambda Powertools para TypeScript](https://docs.powertools.aws.dev/lambda/typescript/latest/) para observabilidad, incluyendo registro, trazado con AWS X-Ray y métricas de CloudWatch.

## Uso

### Generar una API TypeScript con Smithy

Puedes generar una nueva API TypeScript con Smithy de dos formas:

<RunGenerator generator="ts#smithy-api" />

### Opciones

<GeneratorParameters generator="ts#smithy-api" />

## Salida del Generador

El generador crea dos proyectos relacionados en el directorio `<directory>/<api-name>`:

<FileTree>

- **model/** Proyecto del modelo Smithy
  - project.json Configuración del proyecto y objetivos de build
  - smithy-build.json Configuración de build para Smithy
  - build.Dockerfile Configuración de Docker para construir artefactos Smithy
  - src/
    - main.smithy Definición principal del servicio
    - operations/
      - echo.smithy Definición de operación de ejemplo
- **backend/** Implementación del backend en TypeScript
  - project.json Configuración del proyecto y objetivos de build
  - rolldown.config.ts Configuración de bundling
  - src/
    - handler.ts Manejador de AWS Lambda
    - local-server.ts Servidor local para desarrollo
    - service.ts Implementación del servicio
    - context.ts Definición del contexto del servicio
    - operations/
      - echo.ts Implementación de operación de ejemplo
    - generated/ SDK TypeScript generado (creado durante el build)

</FileTree>

### Infraestructura

Dado que este generador crea infraestructura como código según el `iacProvider` seleccionado, generará un proyecto en `packages/common` que incluye los constructos CDK o módulos Terraform relevantes.

El proyecto común de infraestructura como código tiene la siguiente estructura:

<Infrastructure>
<Fragment slot="cdk">
<FileTree>
  - packages/common/constructs
    - src
      - app/ Constructos para infraestructura específica de un proyecto/generador
        - apis/
          - \<project-name>.ts Constructo CDK para desplegar tu API
      - core/ Constructos genéricos reutilizables por los de `app`
        - api/
          - rest-api.ts Constructo CDK para desplegar una API REST
          - utils.ts Utilidades para los constructos de API
      - index.ts Punto de entrada que exporta los constructos de `app`
    - project.json Objetivos de build y configuración del proyecto
</FileTree>

:::note
Este proyecto se genera usando el generador [`ts#project`](guides/typescript-project) y por lo tanto configura los mismos objetivos de build.
:::
</Fragment>
<Fragment slot="terraform">
<FileTree>
  - packages/common/terraform
    - src
      - app/ Módulos Terraform para infraestructura específica de un proyecto/generador
        - apis/
          - \<project-name>/
            - \<project-name>.tf Módulo para desplegar tu API
      - core/ Módulos genéricos reutilizados por los de `app`
        - api/
          - rest-api/
            - rest-api.tf Módulo para desplegar una API REST
    - project.json Objetivos de build y configuración del proyecto
</FileTree>

:::note
Este proyecto se genera usando el generador [`terraform#project`](guides/terraform-project) y por lo tanto configura los mismos objetivos de build.
:::
</Fragment>
</Infrastructure>

## Implementando tu API Smithy

### Definiendo Operaciones en Smithy

Las operaciones se definen en archivos Smithy dentro del proyecto del modelo. La definición principal del servicio está en `main.smithy`:

```smithy
$version: "2.0"

namespace your.namespace

use aws.protocols#restJson1
use smithy.framework#ValidationException

@title("YourService")
@restJson1
service YourService {
    version: "1.0.0"
    operations: [
        Echo,
        // Añade tus operaciones aquí
    ]
    errors: [
        ValidationException
    ]
}
```

Las operaciones individuales se definen en archivos separados en el directorio `operations/`:

```smithy
$version: "2.0"

namespace your.namespace

@http(method: "POST", uri: "/echo")
operation Echo {
    input: EchoInput
    output: EchoOutput
}

structure EchoInput {
    @required
    message: String

    foo: Integer
    bar: String
}

structure EchoOutput {
    @required
    message: String
}
```

:::note
Puedes cambiar la estructura de carpetas como prefieras - todos los archivos `.smithy` en la carpeta `src` se incluirán en el build de Smithy.
:::

:::tip
Para más detalles sobre Smithy y su sintaxis, consulta la [especificación de Smithy](https://smithy.io/2.0/spec/index.html).
:::

### Implementando Operaciones en TypeScript

Las implementaciones de operaciones se encuentran en el directorio `src/operations/` del proyecto backend. Cada operación se implementa usando los tipos generados del SDK de servidor TypeScript (generados en tiempo de build a partir de tu modelo Smithy).

```typescript
import { ServiceContext } from '../context.js';
import { Echo as EchoOperation } from '../generated/ssdk/index.js';

export const Echo: EchoOperation<ServiceContext> = async (input) => {
  // Tu lógica de negocio aquí
  return {
    message: `Echo: ${input.message}` // seguridad de tipos basada en tu modelo Smithy
  };
};
```

Las operaciones deben registrarse en la definición del servicio en `src/service.ts`:

```typescript
import { ServiceContext } from './context.js';
import { YourServiceService } from './generated/ssdk/index.js';
import { Echo } from './operations/echo.js';
// Importa otras operaciones aquí

// Registra las operaciones en el servicio aquí
export const Service: YourServiceService<ServiceContext> = {
  Echo,
  // Añade otras operaciones aquí
};
```

### Contexto del Servicio

Puedes definir un contexto compartido para tus operaciones en `context.ts`:

```typescript
export interface ServiceContext {
  // Tracer, logger y metrics de Powertools se proveen por defecto
  tracer: Tracer;
  logger: Logger;
  metrics: Metrics;
  // Añade dependencias compartidas, conexiones a bases de datos, etc.
  dbClient: any;
  userIdentity: string;
}
```

Este contexto se pasa a todas las implementaciones de operaciones y puede usarse para compartir recursos como conexiones a bases de datos, configuración o utilidades de registro.

:::caution
Debes construir el contexto manualmente tanto en `handler.ts` (punto de entrada de la función Lambda) como en `local-server.ts` (punto de entrada para ejecución local vía el objetivo `serve`).
:::

### Observabilidad con AWS Lambda Powertools

#### Registros

El generador configura registro estructurado usando AWS Lambda Powertools con inyección automática de contexto mediante middleware Middy.

```typescript {4}
// handler.ts
export const handler = middy<APIGatewayProxyEvent, APIGatewayProxyResult>()
  .use(captureLambdaHandler(tracer))
  .use(injectLambdaContext(logger))
  .use(logMetrics(metrics))
  .handler(lambdaHandler);
```

Puedes acceder al logger desde tus implementaciones de operaciones vía el contexto:

```typescript {6}
// operations/echo.ts
import { ServiceContext } from '../context.js';
import { Echo as EchoOperation } from '../generated/ssdk/index.js';

export const Echo: EchoOperation<ServiceContext> = async (input, ctx) => {
  ctx.logger.info('Tu mensaje de log');
  // ...
};
```

#### Trazado

El trazado con AWS X-Ray se configura automáticamente mediante el middleware `captureLambdaHandler`.

```typescript {3}
// handler.ts
export const handler = middy<APIGatewayProxyEvent, APIGatewayProxyResult>()
  .use(captureLambdaHandler(tracer))
  .use(injectLambdaContext(logger))
  .use(logMetrics(metrics))
  .handler(lambdaHandler);
```

Puedes añadir subsegmentos personalizados a tus trazas en tus operaciones:

```typescript {7, 11, 14}
// operations/echo.ts
import { ServiceContext } from '../context.js';
import { Echo as EchoOperation } from '../generated/ssdk/index.js';

export const Echo: EchoOperation<ServiceContext> = async (input, ctx) => {
  // Crea un nuevo subsegmento
  const subsegment = ctx.tracer.getSegment()?.addNewSubsegment('operacion-personalizada');
  try {
    // Tu lógica aquí
  } catch (error) {
    subsegment?.addError(error as Error);
    throw error;
  } finally {
    subsegment?.close();
  }
};
```

#### Métricas

Las métricas de CloudWatch se recopilan automáticamente para cada solicitud mediante el middleware `logMetrics`.

```typescript {5}
// handler.ts
export const handler = middy<APIGatewayProxyEvent, APIGatewayProxyResult>()
  .use(captureLambdaHandler(tracer))
  .use(injectLambdaContext(logger))
  .use(logMetrics(metrics))
  .handler(lambdaHandler);
```

Puedes añadir métricas personalizadas en tus operaciones:

```typescript {7}
// operations/echo.ts
import { MetricUnit } from '@aws-lambda-powertools/metrics';
import { ServiceContext } from '../context.js';
import { Echo as EchoOperation } from '../generated/ssdk/index.js';

export const Echo: EchoOperation<ServiceContext> = async (input, ctx) => {
  ctx.metrics.addMetric("MetricaPersonalizada", MetricUnit.Count, 1);
  // ...
};
```

### Manejo de Errores

Smithy provee manejo de errores integrado. Puedes definir errores personalizados en tu modelo Smithy:

```smithy
@error("client")
@httpError(400)
structure InvalidRequestError {
    @required
    message: String
}
```

Y registrarlos en tu operación/servicio:

```smithy
operation MyOperation {
  ...
  errors: [InvalidRequestError]
}
```

Luego lanzarlos en tu implementación TypeScript:

```typescript
import { InvalidRequestError } from '../generated/ssdk/index.js';

export const MyOperation: MyOperationHandler<ServiceContext> = async (input) => {
  if (!input.requiredField) {
    throw new InvalidRequestError({
      message: "Falta el campo requerido"
    });
  }

  return { /* respuesta exitosa */ };
};
```

## Construcción y Generación de Código

El proyecto del modelo Smithy usa [Docker](https://www.docker.com/) para construir los artefactos Smithy y generar el SDK de servidor TypeScript:

<NxCommands commands={['run <model-project>:build']} />

Este proceso:

1. **Compila el modelo Smithy** y lo valida
2. **Genera la especificación OpenAPI** a partir del modelo Smithy
3. **Crea el SDK de servidor TypeScript** con interfaces de operación con seguridad de tipos
4. **Genera artefactos de build** en `dist/<model-project>/build/`

El proyecto backend copia automáticamente el SDK generado durante la compilación:

<NxCommands commands={['run <backend-project>:copy-ssdk']} />

### Objetivo de Bundle

<Snippet name="ts-bundle" />

## Desarrollo Local

El generador configura un servidor local con recarga en caliente:

<NxCommands commands={['run <backend-project>:serve']} />

:::tip
El servidor local no solo recargará en caliente cuando hagas cambios en el código TypeScript del backend, sino que también se recargará al modificar el proyecto del modelo Smithy, permitiéndote iterar continuamente en tu modelo y servidor juntos.
:::

## Desplegando tu API Smithy

El generador crea infraestructura como código con CDK o Terraform según el `iacProvider` seleccionado.

<Infrastructure>
<Fragment slot="cdk">
El constructo CDK para desplegar tu API está en la carpeta `common/constructs`:

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    // Añade la API a tu stack
    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
    });
  }
}
```

Esto configura:

1. Una función AWS Lambda para el servicio Smithy
2. API Gateway REST API como disparador de la función
3. Roles y permisos IAM
4. Grupo de logs de CloudWatch
5. Configuración de trazado X-Ray

<Snippet name="api/cors-configuration-cdk-note" />

:::note
Si seleccionaste autenticación `Cognito`, necesitarás proveer la propiedad `identity` al constructo de la API:

```ts {9}
import { MyApi, UserIdentity } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const identity = new UserIdentity(this, 'Identity');

    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
      identity,
    });
  }
}
```

El constructo `UserIdentity` puede generarse usando el <Link path="/guides/react-website-auth">generador `ts#react-website-auth`</Link>
:::
</Fragment>
<Fragment slot="terraform">
Los módulos Terraform para desplegar tu API están en la carpeta `common/terraform`:

```hcl {2}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Variables de entorno para la función Lambda
  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  # Políticas IAM adicionales si son necesarias
  additional_iam_policy_statements = [
    # Añade permisos adicionales que necesite tu API
  ]

  tags = local.common_tags
}
```

Esto configura:

1. Una función AWS Lambda que sirve la API Smithy
2. API Gateway REST API como disparador de la función
3. Roles y permisos IAM
4. Grupo de logs de CloudWatch
5. Configuración de trazado X-Ray
6. Configuración CORS

<Snippet name="api/cors-configuration-terraform-note" />

:::note
Si seleccionaste autenticación `Cognito`, necesitarás proveer la configuración de Cognito:

```hcl {4-5}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  user_pool_id         = local.user_pool_id
  user_pool_client_ids = [local.client_id]

  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  tags = local.common_tags
}
```
:::

El módulo Terraform provee varias salidas:

```hcl
# Accede al endpoint de la API
output "api_url" {
  value = module.my_api.stage_invoke_url
}

# Accede a detalles de la función Lambda
output "lambda_function_name" {
  value = module.my_api.lambda_function_name
}
```
</Fragment>
</Infrastructure>

### Integraciones

<Snippet name="api/type-safe-api-integrations" parentHeading="Integraciones" />

#### Generación de Código

<Infrastructure>
<Fragment slot="cdk">
Dado que las operaciones se definen en Smithy, usamos generación de código para proveer metadatos al constructo CDK para integraciones con seguridad de tipos.

Se añade un objetivo `generate:<ApiName>-metadata` al `project.json` de los constructos comunes para facilitar esta generación, el cual emite un archivo como `packages/common/constructs/src/generated/my-api/metadata.gen.ts`. Como esto se genera en tiempo de build, se ignora en control de versiones.

:::note
Necesitarás ejecutar un build cada vez que cambies tu modelo Smithy para asegurar que los tipos consumidos por el constructo CDK estén actualizados.

<NxCommands commands={["run-many --target build --all"]} />
:::

:::tip
Si estás trabajando activamente en tu infraestructura CDK y API Smithy simultáneamente, puedes usar [`nx watch`](https://nx.dev/nx-api/nx/documents/watch) para regenerar estos tipos cada vez que hagas cambios en el modelo:

<NxCommands
  commands={[
    'watch --projects=<ModelProject> -- \\ ',
    'run <InfraProject>:"generate:<ApiName>-metadata"',
  ]}
/>
:::
</Fragment>
<Fragment slot="terraform">
:::note
No soportamos integraciones con seguridad de tipos para Terraform, por lo que no se configuran objetivos de generación de código si seleccionaste Terraform como tu `iacProvider`.
:::
</Fragment>
</Infrastructure>

### Otorgando Acceso (Solo IAM)

Si seleccionaste autenticación `IAM`, puedes usar el método `grantInvokeAccess` para otorgar acceso a tu API:

<Infrastructure>
<Fragment slot="cdk">
```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```
</Fragment>
<Fragment slot="terraform">
```hcl
# Crea una política IAM para permitir invocar la API
resource "aws_iam_policy" "api_invoke_policy" {
  name        = "MyApiInvokePolicy"
  description = "Política para permitir invocar la API Smithy"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = "execute-api:Invoke"
        Resource = "${module.my_api.api_execution_arn}/*/*"
      }
    ]
  })
}

# Adjunta la política a un rol IAM
resource "aws_iam_role_policy_attachment" "api_invoke_access" {
  role       = aws_iam_role.authenticated_user_role.name
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}
```
</Fragment>
</Infrastructure>

## Invocando tu API Smithy

Para invocar tu API desde un sitio web React, puedes usar el generador <Link path="guides/api-connection/react-smithy">`api-connection`</Link>, que provee generación de cliente con seguridad de tipos a partir de tu modelo Smithy.