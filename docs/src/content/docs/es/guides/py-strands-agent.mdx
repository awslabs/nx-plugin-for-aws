---
title: "Agente de Strands de Python"
description: "Generar un Agente de Strands de Python para construir agentes de IA con herramientas y desplegar en Amazon Bedrock AgentCore Runtime"
---

import { FileTree } from '@astrojs/starlight/components';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import Link from '@components/link.astro';
import Snippet from '@components/snippet.astro';
import Infrastructure from '@components/infrastructure.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import Drawer from '@components/drawer.astro';

Genera un [Agente Strands](https://strandsagents.com/) en Python para construir agentes de IA con herramientas, y opcionalmente desplegarlo en [Amazon Bedrock AgentCore Runtime](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/).

## ¿Qué es Strands?

[Strands](https://strandsagents.com/latest/documentation/docs/) es un framework Python ligero y listo para producción para construir agentes de IA. Características clave incluyen:

- **Ligero y personalizable**: Bucle de agente simple que no interfiere
- **Listo para producción**: Observabilidad completa, tracing y opciones de despliegue escalables
- **Agnóstico a modelos y proveedores**: Soporta múltiples modelos de distintos proveedores
- **Herramientas comunitarias**: Conjunto potente de herramientas contribuidas por la comunidad
- **Soporte multi-agente**: Técnicas avanzadas como equipos de agentes y agentes autónomos
- **Modos de interacción flexibles**: Soporte conversacional, streaming y no streaming

## Uso

### Generar un Agente Strands

Puedes generar un Agente Strands en Python de dos formas:

<RunGenerator generator="py#strands-agent" />

:::tip
Primero usa el generador <Link path="/guides/python-project">`py#project`</Link> para crear un proyecto donde añadir tu Agente Strands.
:::

### Opciones

<GeneratorParameters generator="py#strands-agent" />

## Salida del Generador

El generador añadirá los siguientes archivos a tu proyecto Python existente:

<FileTree>
  - your-project/
    - your_module/
      - agent/ (o nombre personalizado si se especifica)
        - \_\_init\_\_.py Inicialización del paquete Python
        - init.py Configuración de aplicación FastAPI con middleware CORS y manejo de errores
        - agent.py Definición principal del agente con herramientas de ejemplo
        - main.py Punto de entrada para Bedrock AgentCore Runtime
        - agentcore_mcp_client.py Factory de cliente útil para invocar servidores MCP alojados en Bedrock AgentCore Runtime
        - Dockerfile Punto de entrada para alojar tu agente (excluido cuando `computeType` es `None`)
    - pyproject.toml Actualizado con dependencias de Strands
    - project.json Actualizado con objetivos de servicio del agente
</FileTree>

### Infraestructura

:::note
Si seleccionaste `None` para `computeType`, el generador no proveerá infraestructura como código.
:::

<Snippet name="shared-constructs" />

Para desplegar tu Agente Strands, se generan los siguientes archivos:

<Infrastructure>
<Fragment slot="cdk">
<FileTree>
  - packages/common/constructs/src
    - app
      - agents
        - \<project-name>
          - \<project-name>.ts Constructo CDK para desplegar tu agente
          - Dockerfile Archivo Docker usado por el constructo CDK
</FileTree>
</Fragment>
<Fragment slot="terraform">
<FileTree>
  - packages/common/terraform/src
    - app
      - agents
        - \<project-name>
          - \<project-name>.tf Módulo para desplegar tu agente
    - core
      - agent-core
        - runtime.tf Módulo genérico para despliegue en Bedrock AgentCore Runtime
</FileTree>
</Fragment>
</Infrastructure>

## Trabajando con tu Agente Strands

### Añadiendo Herramientas

Las herramientas son funciones que el agente de IA puede llamar para realizar acciones. Strands usa un enfoque basado en decoradores para definirlas.

Puedes añadir nuevas herramientas en el archivo [`agent.py`](packages/nx-plugin/src/py/strands-agent/files/agent.py.template:6):

```python
from strands import Agent, tool

@tool
def calculate_sum(numbers: list[int]) -> int:
    """Calcula la suma de una lista de números"""
    return sum(numbers)

@tool
def get_weather(city: str) -> str:
    """Obtiene información meteorológica de una ciudad"""
    # Tu integración de API del tiempo aquí
    return f"Weather in {city}: Soleado, 25°C"

# Añade herramientas al agente
agent = Agent(
    system_prompt="Eres un asistente útil con acceso a varias herramientas.",
    tools=[calculate_sum, get_weather],
)
```

El framework Strands maneja automáticamente:
- Validación de tipos basada en type hints
- Generación de esquema JSON para tool calling
- Manejo de errores y formato de respuestas

### Usando Herramientas Preconstruidas

Strands provee herramientas preconstruidas a través del paquete `strands-tools`:

```python
from strands_tools import current_time, http_request, file_read

agent = Agent(
    system_prompt="Eres un asistente útil.",
    tools=[current_time, http_request, file_read],
)
```

### Configuración de Modelos

Por defecto, Strands usa Claude 4 Sonnet, pero puedes personalizar el proveedor. Consulta la [documentación de Strands sobre proveedores de modelos](https://strandsagents.com/latest/documentation/docs/user-guide/quickstart/#model-providers):

```python
from strands import Agent
from strands.models import BedrockModel

# Crea un BedrockModel
bedrock_model = BedrockModel(
    model_id="anthropic.claude-sonnet-4-20250514-v1:0",
    region_name="us-west-2",
    temperature=0.3,
)

agent = Agent(model=bedrock_model)
```

### Consumiendo Servidores MCP

Puedes [añadir herramientas de servidores MCP](https://strandsagents.com/latest/documentation/docs/user-guide/concepts/tools/mcp-tools/) a tu agente Strands.

Para consumir servidores MCP creados con los generadores <Link path="/guides/py-mcp-server">`py#mcp-server`</Link> o <Link path="/guides/ts-mcp-server">`ts#mcp-server`</Link> (u otros alojados en Bedrock AgentCore Runtime), se genera un factory de cliente en `agentcore_mcp_client.py`.

Puedes actualizar tu método `get_agent` en `agent.py` para crear clientes MCP y añadir herramientas. Este ejemplo muestra cómo hacerlo con autenticación IAM (SigV4):

```python
# agent.py
import os
from contextlib import contextmanager

import boto3
from strands import Agent

from .agentcore_mcp_client import AgentCoreMCPClient

# Obtiene región y credenciales
region = os.environ["AWS_REGION"]
boto_session = boto3.Session(region_name=region)
credentials = boto_session.get_credentials()

@contextmanager
def get_agent(session_id: str):
    mcp_client = AgentCoreMCPClient.with_iam_auth(
        agent_runtime_arn=os.environ["MCP_AGENTCORE_RUNTIME_ARN"],
        credentials=credentials,
        region=region,
        session_id=session_id,
    )

    with mcp_client:
        mcp_tools = mcp_client.list_tools_sync()

        yield Agent(
            system_prompt="..."
            tools=[*mcp_tools],
        )
```

:::tip
Si tu servidor MCP usa autenticación JWT, puedes usar el método `AgentCoreMCPClient.with_jwt_auth` en su lugar.
:::

Con el ejemplo de autenticación IAM anterior, necesitamos configurar dos cosas en nuestra infraestructura: añadir la variable de entorno para el ARN del AgentCore Runtime del servidor MCP, y otorgar permisos de invocación. Esto se logra así:

<Infrastructure>
<Fragment slot="cdk">
```ts {9, 13}
import { MyProjectAgent, MyProjectMcpServer } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const mcpServer = new MyProjectMcpServer(this, 'MyProjectMcpServer');

    const agent = new MyProjectAgent(this, 'MyProjectAgent', {
      environmentVariables: {
        MCP_AGENTCORE_RUNTIME_ARN: mcpServer.agentCoreRuntime.agentRuntimeArn,
      },
    });

    mcpServer.agentCoreRuntime.grantInvoke(agent.agentCoreRuntime);
  }
}
```
</Fragment>
<Fragment slot="terraform">
```terraform
# Servidor MCP
module "my_project_mcp_server" {
  source = "../../common/terraform/src/app/mcp-servers/my-project-mcp-server"
}

# Agente
module "my_project_agent" {
  source = "../../common/terraform/src/app/agents/my-project-agent"

  env = {
    MCP_AGENTCORE_RUNTIME_ARN = module.my_project_mcp_server.agent_core_runtime_arn
  }

  additional_iam_policy_statements = [
    {
      Effect = "Allow"
      Action = [
        "bedrock-agentcore:InvokeAgentRuntime"
      ]
      Resource = [
        module.my_project_mcp_server.agent_core_runtime_arn,
        "${module.my_project_mcp_server.agent_core_runtime_arn}/*"
      ]
    }
  ]
}
```
</Fragment>
</Infrastructure>

### Más información

Para una guía detallada sobre cómo escribir agentes Strands, consulta la [documentación de Strands](https://strandsagents.com/latest/documentation/docs/).

## Servidor FastAPI

El generador usa [FastAPI](https://fastapi.tiangolo.com/) para crear el servidor HTTP para tu Agente Strands. FastAPI proporciona un framework web moderno y rápido para construir APIs con Python, con documentación automática de API y validación de tipos.

El servidor generado incluye:
- Configuración de aplicación FastAPI con middleware CORS
- Middleware de manejo de errores
- Generación de esquema OpenAPI
- Endpoint de verificación de salud (`/ping`)
- Endpoint de invocación del agente (`/invocations`)

### Personalizando Entradas y Salidas de Invocación con Pydantic

El endpoint de invocación del agente usa modelos [Pydantic](https://docs.pydantic.dev/) para definir y validar los esquemas de solicitud y respuesta. Puedes personalizar estos modelos en `main.py` para que coincidan con los requisitos de tu agente.

#### Definiendo Modelos de Entrada

El modelo `InvokeInput` por defecto acepta un prompt y un ID de sesión.

```python
from pydantic import BaseModel

class InvokeInput(BaseModel):
    prompt: str
    session_id: str
```

Puedes extender este modelo para incluir cualquier campo adicional que tu agente necesite.

:::caution
Probablemente querrás abstraer parte o todo el ID de sesión del llamador si los usuarios van a invocar tu agente directamente. Por ejemplo, puedes usar el ID de usuario autenticado como parte del ID de sesión.

También vale la pena señalar que dependiendo de tu caso de uso, puede que necesites implementar autorización para las sesiones, por ejemplo asegurándote de que los usuarios solo puedan acceder a sus propias sesiones y no a las de otros usuarios.
:::

#### Definiendo Modelos de Salida

Para respuestas de streaming, el generador proporciona `JsonStreamingResponse` que serializa automáticamente modelos Pydantic al formato JSON Lines (`application/jsonl`). Este formato es compatible con la especificación de streaming de OpenAPI 3.2 y funciona perfectamente con el cliente TypeScript generado.

Por defecto, el agente produce objetos `StreamChunk` que contienen el texto de respuesta del agente:

```python
class StreamChunk(BaseModel):
    content: str
```

Puedes personalizar el modelo `StreamChunk` según tus necesidades:

```python
from pydantic import BaseModel

class StreamChunk(BaseModel):
    content: str
    timestamp: str
    token_count: int
```

:::note
Ten en cuenta que dado que FastAPI actualmente no soporta generar una especificación OpenAPI para respuestas de streaming, debemos establecer explícitamente el modelo de respuesta para cada operación de streaming, es decir:

```python
@app.post(
    "/invocations",
    response_class=JsonStreamingResponse,
    responses={200: JsonStreamingResponse.openapi_response(StreamChunk)},
)
async def invoke(input: InvokeInput) -> JsonStreamingResponse:
    return JsonStreamingResponse(handle_invoke(input))
```
:::

Existe una [solicitud de característica abierta para soporte nativo en FastAPI](https://github.com/fastapi/fastapi/discussions/14362).

## SDK Python de Bedrock AgentCore

El generador incluye una dependencia del [SDK Python de Bedrock AgentCore](https://github.com/aws/bedrock-agentcore-sdk-python) para las constantes `PingStatus`. Si lo deseas, es sencillo usar `BedrockAgentCoreApp` en lugar de FastAPI, sin embargo ten en cuenta que se pierde la seguridad de tipos.

Puedes encontrar detalles sobre las capacidades del SDK en su [documentación](https://aws.github.io/bedrock-agentcore-starter-toolkit/user-guide/runtime/quickstart.html).

:::note
Como el generador provee infraestructura CDK/Terraform para desplegar tu agente, no necesitas usar el `bedrock-agentcore-starter-toolkit` mencionado en los docs.
:::

## Ejecutando tu Agente Strands

### Desarrollo Local

El generador configura un target llamado `<your-agent-name>-serve` para iniciar tu agente localmente:

<NxCommands commands={['run your-project:agent-serve']} />

Este comando usa `uv run` para ejecutar tu agente con el [SDK Python de Bedrock AgentCore](https://github.com/aws/bedrock-agentcore-sdk-python).

## Desplegando tu Agente Strands a Bedrock AgentCore Runtime

<Snippet name="agent/bedrock-deployment" parentHeading="Desplegando tu Agente Strands a Bedrock AgentCore Runtime" />

### Targets de Bundle y Docker

Para construir tu agente para Bedrock AgentCore Runtime, se añade un target `bundle` que:
- Exporta dependencias Python a `requirements.txt` usando `uv export`
- Instala dependencias para la plataforma objetivo (`aarch64-manylinux2014`) con `uv pip install`

También se añade un target `docker` específico que:
- Construye una imagen Docker desde el `Dockerfile` que ejecuta tu agente según el [contrato de runtime de AgentCore](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-service-contract.html)

:::tip
La imagen Docker se construye con un tag (ej. `my-scope-my-project-agent:latest`), referenciado por tu infraestructura CDK/Terraform, permitiendo co-localizar el `Dockerfile` con tu proyecto.
:::

### Autenticación

#### IAM

Por defecto, tu agente usará autenticación IAM. Despliégalo sin argumentos:

<Infrastructure>
<Fragment slot="cdk">
```ts {5}
import { MyProjectAgent } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    new MyProjectAgent(this, 'MyProjectAgent');
  }
}
```

Puedes otorgar acceso para invocar tu agente usando `grantInvoke`:

```ts {8}
import { MyProjectAgent } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const agent = new MyProjectAgent(this, 'MyProjectAgent');
    const lambdaFunction = new Function(this, ...);

    agent.agentCoreRuntime.grantInvoke(lambdaFunction);
  }
}
```
</Fragment>
<Fragment slot="terraform">
```terraform
# Agente
module "my_project_agent" {
  # Ruta relativa al módulo generado en el proyecto common/terraform
  source = "../../common/terraform/src/app/agents/my-project-agent"
}
```

Para otorgar acceso, añade una política que referencia `module.my_project_agent.agent_core_runtime_arn`:

```terraform
{
  Effect = "Allow"
  Action = [
    "bedrock-agentcore:InvokeAgentRuntime"
  ]
  Resource = [
    module.my_project_agent.agent_core_runtime_arn,
    "${module.my_project_agent.agent_core_runtime_arn}/*"
  ]
}
```
</Fragment>
</Infrastructure>

#### Autenticación Cognito JWT

El siguiente ejemplo muestra cómo configurar autenticación Cognito:

<Infrastructure>
<Fragment slot="cdk">
Para configurar autenticación JWT usando Cognito, usa el método factory `RuntimeAuthorizerConfiguration.usingCognito()`:

```ts {13-16}
import { MyProjectAgent } from ':my-scope/common-constructs';
import { RuntimeAuthorizerConfiguration } from '@aws-cdk/aws-bedrock-agentcore-alpha';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const userPool = new UserPool(this, 'UserPool');
    const client = userPool.addClient('Client', {
      authFlows: {
        userPassword: true,
      },
    });

    new MyProjectAgent(this, 'MyProjectAgent', {
      authorizerConfiguration: RuntimeAuthorizerConfiguration.usingCognito(
        userPool,
        [client],
      ),
    });
  }
}
```

Alternativamente, para autenticación JWT personalizada con tu propio proveedor OIDC, usa `RuntimeAuthorizerConfiguration.usingJWT()`:

```ts {6-10}
import { MyProjectAgent } from ':my-scope/common-constructs';
import { RuntimeAuthorizerConfiguration } from '@aws-cdk/aws-bedrock-agentcore-alpha';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    new MyProjectAgent(this, 'MyProjectAgent', {
      authorizerConfiguration: RuntimeAuthorizerConfiguration.usingJWT(
        'https://example.com/.well-known/openid-configuration',
        ['client1', 'client2'], // IDs de Cliente Permitidos (opcional)
        ['audience1'],          // Audiencias Permitidas (opcional)
      ),
    });
  }
}
```
</Fragment>
<Fragment slot="terraform">
Para configurar autenticación JWT, edita tu módulo para configurar la variable `authorizer_configuration`:

```terraform {18-23}
# packages/common/terraform/src/app/agents/my-project-agent/my-project-agent.tf

data "aws_region" "current" {}

locals {
  aws_region = data.aws_region.current.id

  # Reemplaza con tus IDs de user pool y client o expón como variables
  user_pool_id = "xxx"
  user_pool_client_ids = ["yyy"]
}

module "agent_core_runtime" {
  source = "../../../core/agent-core"
  agent_runtime_name = "MyProjectAgent"
  docker_image_tag = "my-scope-my-project-agent:latest"
  server_protocol = "HTTP"
  authorizer_configuration = {
    custom_jwt_authorizer = {
      discovery_url = "https://cognito-idp.${local.aws_region}.amazonaws.com/${local.user_pool_id}/.well-known/openid-configuration"
      allowed_clients = local.user_pool_client_ids
    }
  }
  env = var.env
  additional_iam_policy_statements = var.additional_iam_policy_statements
  tags = var.tags
}
```
</Fragment>
</Infrastructure>

### Observabilidad

Tu agente se configura automáticamente con observabilidad usando [AWS Distro for Open Telemetry](https://aws.amazon.com/otel/) (ADOT), mediante auto-instrumentación en tu `Dockerfile`.

Puedes encontrar trazas en CloudWatch seleccionando "GenAI Observability". Para ver trazas, habilita [Transaction Search](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Transaction-Search.html).

Para más detalles, consulta la [documentación de observabilidad de AgentCore](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/observability-configure.html).

## Invocando tu Agente Strands

### Invocar el Servidor Local

Para invocar un Agente ejecutándose localmente mediante el target `<your-agent-name>-serve`, puedes enviar una simple solicitud POST a `/invocations` en el puerto donde se ejecuta tu agente local. Por ejemplo, con `curl`:

```bash
curl -N -X POST http://localhost:8081/invocations \
  -d '{"prompt": "what is 3 + 5?", "session_id": "abcdefghijklmnopqrstuvwxyz0123456789"}' \
  -H "Content-Type: application/json"
```

:::note
El argumento `-N` dado a `curl` deshabilita el buffering del flujo de salida, para que puedas ver la respuesta de streaming en tiempo real.
:::

### Invocar el Agente Desplegado

<Snippet name="agent/runtime-arn" parentHeading="Invocar el Agente Desplegado" />

#### Autenticación IAM

Para autenticación IAM, la solicitud debe firmarse usando AWS Signature Version 4 (SigV4).

```bash
acurl <region> bedrock-agentcore -N -X POST \
'https://bedrock
-agentcore.<region>.amazonaws.com/runtimes/<url-encoded-arn>/invocations' \
-d '{"prompt": "what is 3 + 5?", "session_id": "abcdefghijklmnopqrstuvwxyz0123456789"}' \
-H 'Content-Type: application/json'
```

<Drawer title="curl con Sigv4 habilitado" trigger="Haz clic aquí para más detalles sobre cómo configurar el comando acurl anterior">
<Snippet name="tools/acurl" />
</Drawer>

#### Autenticación JWT / Cognito

Para autenticación Cognito, pasa el Access Token de Cognito en el header `Authorization`:

```bash
curl -N -X POST 'https://bedrock
-agentcore.<region>.amazonaws.com/runtimes/<url-encoded-arn>/invocations' \
  -d '{"prompt": "what is 3 + 5?", "session_id": "abcdefghijklmnopqrstuvwxyz0123456789"}' \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <access-token>"
```

Puedes obtener el access token usando el comando `cognito-idp admin-initiate-auth` del AWS CLI, por ejemplo:

```bash
aws cognito-idp admin-initiate-auth \
  --user-pool-id <user-pool-id> \
  --client-id <user-pool-client-id> \
  --auth-flow ADMIN_NO_SRP_AUTH \
  --auth-parameters USERNAME=<username>,PASSWORD=<password> \
  --region <region> \
  --query 'AuthenticationResult.AccessToken' \
  --output text
```