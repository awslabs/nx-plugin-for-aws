---
title: "tRPC"
description: "Documentación de referencia para tRPC"
---



import { FileTree, Tabs, TabItem } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Snippet from '@components/snippet.astro';
import schema from '../../../../../../packages/nx-plugin/src/trpc/backend/schema.json';

[tRPC](https://trpc.io/) es un framework para construir APIs en TypeScript con seguridad de tipos de extremo a extremo. Con tRPC, las actualizaciones en las entradas y salidas de las operaciones de la API se reflejan inmediatamente en el código cliente y son visibles en tu IDE sin necesidad de reconstruir el proyecto.

El generador de API tRPC crea una nueva API tRPC con configuración de infraestructura AWS CDK. El backend generado utiliza AWS Lambda para implementación sin servidor e incluye validación de esquemas usando [Zod](https://zod.dev/). Configura [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/) para observabilidad, incluyendo logging, trazas con AWS X-Ray y métricas de CloudWatch.

## Uso

### Generar una API tRPC

Puedes generar una nueva API tRPC de dos formas:

<RunGenerator generator="ts#trpc-api" />

### Opciones

<GeneratorParameters schema={schema} />

<Snippet name="api/api-choice-note" />

## Resultado del Generador

El generador creará la siguiente estructura de proyecto en el directorio `<directory>/<api-name>`:

<FileTree>
  - schema
    - src
      - index.ts Punto de entrada del esquema
      - procedures
        - echo.ts Definiciones de esquema compartidas para el procedimiento "echo", usando Zod
    - tsconfig.json Configuración de TypeScript
    - project.json Configuración de proyecto y objetivos de build
  - backend
    - src
      - init.ts Inicialización del backend tRPC
      - router.ts Definición del router tRPC (punto de entrada del handler Lambda)
      - procedures Procedimientos (u operaciones) expuestos por tu API
        - echo.ts Procedimiento de ejemplo
      - middleware
        - error.ts Middleware para manejo de errores
        - logger.ts middleware para configurar AWS Powertools para logging en Lambda
        - tracer.ts middleware para configurar AWS Powertools para trazas en Lambda
        - metrics.ts middleware para configurar AWS Powertools para métricas en Lambda
      - local-server.ts Punto de entrada del adaptador standalone de tRPC para servidor de desarrollo local
      - client
        - index.ts Cliente tipado para llamadas máquina-a-máquina a la API
    - tsconfig.json Configuración de TypeScript
    - project.json Configuración de proyecto y objetivos de build
</FileTree>

El generador también creará constructs CDK que pueden usarse para implementar tu API, ubicados en el directorio `packages/common/constructs`.

## Implementando tu API tRPC

Como se ve arriba, hay dos componentes principales en una API tRPC: [`schema`](#schema) y [`backend`](#backend), definidos como paquetes individuales en tu workspace.

:::tip
Tanto `schema` como `backend` son proyectos TypeScript, por lo que puedes consultar la <Link path="guides/typescript-project">documentación de proyectos TypeScript</Link> para más detalles sobre su uso general.
:::

### Schema

El paquete schema define los tipos compartidos entre tu código cliente y servidor. En este paquete, estos tipos se definen usando [Zod](https://zod.dev/), una librería TypeScript-first para declaración y validación de esquemas.

Un esquema de ejemplo podría verse así:

```ts
import { z } from 'zod';

// Definición del esquema
export const UserSchema = z.object({
  name: z.string(),
  height: z.number(),
  dateOfBirth: z.string().datetime(),
});

// Tipo TypeScript correspondiente
export type User = z.TypeOf<typeof UserSchema>;
```

Dado el esquema anterior, el tipo `User` es equivalente al siguiente TypeScript:

```ts
interface User {
  name: string;
  height: number;
  dateOfBirth: string;
}
```

Los esquemas son compartidos por código servidor y cliente, proporcionando un único lugar para actualizar cuando se modifican las estructuras usadas en tu API.

Los esquemas son validados automáticamente por tu API tRPC en tiempo de ejecución, lo que evita tener que crear lógica de validación manual en el backend.

Zod proporciona utilidades poderosas para combinar o derivar esquemas como `.merge`, `.pick`, `.omit` y más. Puedes encontrar más información en el [sitio de documentación de Zod](https://zod.dev/?id=basic-usage).

### Backend

La carpeta anidada `backend` contiene tu implementación de API, donde defines las operaciones de tu API y sus entradas, salidas e implementación.

El punto de entrada de tu API está en `src/router.ts`. Este archivo contiene el handler Lambda que enruta solicitudes a "procedimientos" según la operación invocada. Cada procedimiento define la entrada esperada, salida e implementación.

El router de ejemplo generado tiene una sola operación llamada `echo`:

```ts
import { echo } from './procedures/echo.js';

export const appRouter = router({
  echo,
});
```

El procedimiento `echo` de ejemplo se genera en `src/procedures/echo.ts`:

```ts
export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Desglosando lo anterior:

- `publicProcedure` define un método público en la API, incluyendo el middleware configurado en `src/middleware`. Este middleware incluye integración con AWS Lambda Powertools para logging, tracing y métricas.
- `input` acepta un esquema Zod que define la entrada esperada para la operación. Las solicitudes para esta operación se validan automáticamente contra este esquema.
- `output` acepta un esquema Zod que define la salida esperada. Verás errores de tipo en tu implementación si no devuelves una salida que cumpla con el esquema.
- `query` acepta una función que define la implementación de tu API. Esta implementación recibe `opts`, que contiene el `input` pasado a la operación, así como otro contexto configurado por middleware, disponible en `opts.ctx`. La función pasada a `query` debe devolver una salida que cumpla con el esquema `output`.

El uso de `query` para definir la implementación indica que la operación no es mutativa. Úsalo para definir métodos de obtención de datos. Para operaciones mutativas, usa el método `mutation` en su lugar.

Si añades una nueva operación, asegúrate de registrarla añadiéndola al router en `src/router.ts`.

## Personalizando tu API tRPC

### Errores

En tu implementación, puedes devolver respuestas de error a los clientes lanzando un `TRPCError`. Estos aceptan un `code` que indica el tipo de error, por ejemplo:

```ts
throw new TRPCError({
  code: 'NOT_FOUND',
  message: 'No se pudo encontrar el recurso solicitado',
});
```

### Organizando tus Operaciones

A medida que crece tu API, puedes querer agrupar operaciones relacionadas.

Puedes agrupar operaciones usando routers anidados, por ejemplo:

```ts
import { getUser } from './procedures/users/get.js';
import { listUsers } from './procedures/users/list.js';

const appRouter = router({
   users: router({
      get: getUser,
      list: listUsers,
   }),
   ...
})
```

Los clientes luego reciben esta agrupación de operaciones, por ejemplo invocar la operación `listUsers` en este caso se vería así:

```ts
client.users.list.query();
```

### Logging

El logger de AWS Lambda Powertools se configura en `src/middleware/logger.ts`, y puede accederse en una implementación de API via `opts.ctx.logger`. Puedes usarlo para registrar en CloudWatch Logs y/o controlar valores adicionales a incluir en cada mensaje de log estructurado. Por ejemplo:

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.logger.info('Operación llamada con input', opts.input);

      return ...;
   });
```

Para más información sobre el logger, consulta la [documentación de AWS Lambda Powertools Logger](https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/).

### Registro de Métricas

Las métricas de AWS Lambda Powertools se configuran en `src/middleware/metrics.ts`, y pueden accederse en una implementación de API via `opts.ctx.metrics`. Puedes usarlas para registrar métricas en CloudWatch sin necesidad de importar y usar el AWS SDK, por ejemplo:

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.metrics.addMetric('Invocations', 'Count', 1);

      return ...;
   });
```

Para más información, consulta la [documentación de AWS Lambda Powertools Metrics](https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/).

### Ajuste Fino de Trazas X-Ray

El tracer de AWS Lambda Powertools se configura en `src/middleware/tracer.ts`, y puede accederse en una implementación de API via `opts.ctx.tracer`. Puedes usarlo para añadir trazas con AWS X-Ray y obtener insights detallados sobre el rendimiento y flujo de las solicitudes a la API. Por ejemplo:

```ts {5-7}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      const subSegment = opts.ctx.tracer.getSegment()!.addNewSubsegment('MiAlgoritmo');
      // ... lógica de mi algoritmo para capturar
      subSegment.close();

      return ...;
   });
```

Para más información, consulta la [documentación de AWS Lambda Powertools Tracer](https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/).

### Implementando Middleware Personalizado

Puedes añadir valores adicionales al contexto proporcionado a los procedimientos implementando middleware.

Como ejemplo, implementemos middleware para extraer detalles sobre el usuario que llama a nuestra API en `src/middleware/identity.ts`.

Primero, definimos lo que añadiremos al contexto:

```ts
export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}
```

Nota que definimos una propiedad adicional _opcional_ al contexto. tRPC se encarga de asegurar que esto esté definido en procedimientos que hayan configurado correctamente este middleware.

Luego, implementamos el middleware mismo. Tiene la siguiente estructura:

```ts
export const createIdentityPlugin = () => {
   const t = initTRPC.context<...>().create();
   return t.procedure.use(async (opts) => {
      // Añade lógica aquí para ejecutar antes del procedimiento

      const response = await opts.next(...);

      // Añade lógica aquí para ejecutar después del procedimiento

      return response;
   });
};
```

En nuestro caso, queremos extraer detalles del usuario de Cognito que llama. Hacemos esto extrayendo el ID de sujeto (o "sub") del usuario del evento de API Gateway, y recuperando detalles del usuario desde Cognito. La implementación varía según si el evento fue provisto por una REST API o una HTTP API:

<Tabs>
<TabItem label="REST">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEvent } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEvent>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoAuthenticationProvider = opts.ctx.event.requestContext?.identity?.cognitoAuthenticationProvider;

    let sub: string | undefined = undefined;
    if (cognitoAuthenticationProvider) {
      const providerParts = cognitoAuthenticationProvider.split(':');
      sub = providerParts[providerParts.length - 1];
    }

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `No se pudo determinar el usuario llamante`,
      });
    }

    const { Users } = await cognito.listUsers({
      // Supone que el ID del grupo de usuarios está configurado en el entorno de Lambda
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `No se encontró usuario con subjectId ${sub}`,
      });
    }

    // Provee la identidad a otros procedimientos en el contexto
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
<TabItem label="HTTP">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoIdentity = opts.ctx.event.requestContext?.authorizer?.iam
      ?.cognitoIdentity as unknown as
      | {
          amr: string[];
        }
      | undefined;

    const sub = (cognitoIdentity?.amr ?? [])
      .flatMap((s) => (s.includes(':CognitoSignIn:') ? [s] : []))
      .map((s) => {
        const parts = s.split(':');
        return parts[parts.length - 1];
      })?.[0];

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `No se pudo determinar el usuario llamante`,
      });
    }

    const { Users } = await cognito.listUsers({
      // Supone que el ID del grupo de usuarios está configurado en el entorno de Lambda
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `No se encontró usuario con subjectId ${sub}`,
      });
    }

    // Provee la identidad a otros procedimientos en el contexto
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
</Tabs>

## Implementando tu API tRPC

El generador de backend tRPC crea un construct CDK para implementar tu API en la carpeta `common/constructs`. Puedes consumirlo en una aplicación CDK, por ejemplo:

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs`;

export class ExampleStack extends Stack {
   constructor(scope: Construct, id: string) {
      // Añade la API a tu stack
      const api = new MyApi(this, 'MyApi', {
        integrations: MyApi.defaultIntegrations(this).build(),
      });
   }
}
```

Esto configura la infraestructura de tu API, incluyendo una REST API o HTTP API de AWS API Gateway, funciones AWS Lambda para lógica de negocio, y autenticación IAM.

### Integraciones Tipadas

<Snippet name="api/type-safe-api-integrations" />

:::tip
Cuando añades o eliminas un procedimiento en tu API tRPC, estos cambios se reflejarán inmediatamente en el construct CDK sin necesidad de reconstruir.
:::

### Otorgando Acceso

Puedes usar el método `grantInvokeAccess` para otorgar acceso a tu API, por ejemplo podrías querer dar acceso a usuarios autenticados de Cognito:

```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```

## Servidor Local tRPC

Puedes usar el target `serve` para ejecutar un servidor local para tu API, por ejemplo:

<NxCommands commands={['run @my-scope/my-api-backend:serve']} />

El punto de entrada para el servidor local está en `src/local-server.ts`.

## Invocando tu API tRPC

Puedes crear un cliente tRPC para invocar tu API de forma tipada. Si estás llamando a tu API tRPC desde otro backend, puedes usar el cliente en `src/client/index.ts`, por ejemplo:

```ts
import { createMyApiClient } from ':my-scope/my-api-backend';

const client = createMyApiClient({ url: 'https://my-api-url.example.com/' });

await client.echo.query({ message: '¡Hola mundo!' });
```

Si estás llamando a tu API desde un sitio React, considera usar el generador <Link path="guides/api-connection/react-trpc">Conexión API</Link> para configurar el cliente.

## Más Información

Para más información sobre tRPC, consulta la [documentación de tRPC](https://trpc.io/docs).