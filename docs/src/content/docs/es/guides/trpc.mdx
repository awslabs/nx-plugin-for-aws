---
title: "tRPC"
description: "Documentación de referencia para tRPC"
---

import { FileTree, Tabs, TabItem } from '@astrojs/starlight/components';
import AnchorHeading from '@astrojs/starlight/components/AnchorHeading.astro';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Infrastructure from '@components/infrastructure.astro';
import Snippet from '@components/snippet.astro';

[tRPC](https://trpc.io/) es un marco para construir APIs en TypeScript con seguridad de tipos de extremo a extremo. Usando tRPC, las actualizaciones en las entradas y salidas de las operaciones de la API se reflejan inmediatamente en el código del cliente y son visibles en tu IDE sin necesidad de reconstruir tu proyecto.

El generador de API tRPC crea una nueva API tRPC con configuración de infraestructura usando AWS CDK o Terraform. El backend generado utiliza AWS Lambda para despliegues serverless, expuesto a través de un API Gateway de AWS, e incluye validación de esquemas usando [Zod](https://zod.dev/). Configura [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/) para observabilidad, incluyendo logging, trazado con AWS X-Ray y métricas de CloudWatch.

## Uso

### Generar una API tRPC

Puedes generar una nueva API tRPC de dos formas:

<RunGenerator generator="ts#trpc-api" />

### Opciones

<GeneratorParameters generator="ts#trpc-api" />

<Snippet name="api/api-choice-note" />

## Resultado del generador

El generador creará la siguiente estructura de proyecto en el directorio `<directory>/<api-name>`:

<FileTree>
  - src
    - init.ts Inicialización del backend tRPC
    - router.ts Definición del router tRPC (punto de entrada del manejador Lambda)
    - schema Definiciones de esquemas usando Zod
      - echo.ts Ejemplo de definiciones para entrada y salida del procedimiento "echo"
    - procedures Procedimientos (u operaciones) expuestos por tu API
      - echo.ts Procedimiento de ejemplo
    - middleware
      - error.ts Middleware para manejo de errores
      - logger.ts Middleware para configurar AWS Powertools para logging en Lambda
      - tracer.ts Middleware para configurar AWS Powertools para trazado en Lambda
      - metrics.ts Middleware para configurar AWS Powertools para métricas en Lambda
    - local-server.ts Punto de entrada del adaptador standalone de tRPC para servidor de desarrollo local
    - client
      - index.ts Cliente con seguridad de tipos para llamadas máquina-a-máquina
  - tsconfig.json Configuración de TypeScript
  - project.json Configuración de proyecto y objetivos de build

</FileTree>

### Infraestructura

<Snippet name="shared-constructs" />

<Snippet name="api/shared-constructs" />

## Implementando tu API tRPC

A alto nivel, las APIs tRPC consisten en un router que delega solicitudes a procedimientos específicos. Cada procedimiento tiene una entrada y salida definidas como esquemas Zod.

### Esquema

El directorio `src/schema` contiene los tipos compartidos entre tu código cliente y servidor. En este paquete, estos tipos se definen usando [Zod](https://zod.dev/), una biblioteca de declaración y validación de esquemas TypeScript-first.

Un esquema de ejemplo podría verse así:

```ts
import { z } from 'zod';

// Definición del esquema
export const UserSchema = z.object({
  name: z.string(),
  height: z.number(),
  dateOfBirth: z.string().datetime(),
});

// Tipo TypeScript correspondiente
export type User = z.TypeOf<typeof UserSchema>;
```

Dado el esquema anterior, el tipo `User` es equivalente al siguiente TypeScript:

```ts
interface User {
  name: string;
  height: number;
  dateOfBirth: string;
}
```

Los esquemas son compartidos por el código del servidor y cliente, proporcionando un único lugar para actualizar cuando se realizan cambios en las estructuras usadas en tu API.

Los esquemas son validados automáticamente por tu API tRPC en tiempo de ejecución, lo que evita tener que crear lógica de validación manual en el backend.

Zod proporciona utilidades poderosas para combinar o derivar esquemas como `.merge`, `.pick`, `.omit` y más. Puedes encontrar más información en el [sitio de documentación de Zod](https://zod.dev/?id=basic-usage).

### Router y Procedimientos

El punto de entrada de tu API se encuentra en `src/router.ts`. Este archivo contiene el manejador Lambda que enruta las solicitudes a "procedimientos" basados en la operación invocada. Cada procedimiento define la entrada esperada, la salida y la implementación.

El router de ejemplo generado tiene una sola operación llamada `echo`:

```ts
import { echo } from './procedures/echo.js';

export const appRouter = router({
  echo,
});
```

El procedimiento `echo` de ejemplo se genera en `src/procedures/echo.ts`:

```ts
export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

Desglosando lo anterior:

- `publicProcedure` define un método público en la API, incluyendo el middleware configurado en `src/middleware`. Este middleware incluye integración con AWS Lambda Powertools para logging, trazado y métricas.
- `input` acepta un esquema Zod que define la entrada esperada para la operación. Las solicitudes enviadas para esta operación se validan automáticamente contra este esquema.
- `output` acepta un esquema Zod que define la salida esperada para la operación. Verás errores de tipo en tu implementación si no devuelves una salida que cumpla con el esquema.
- `query` acepta una función que define la implementación de tu API. Esta implementación recibe `opts`, que contiene el `input` pasado a tu operación, así como otro contexto configurado por el middleware, disponible en `opts.ctx`. La función pasada a `query` debe devolver una salida que cumpla con el esquema `output`.

El uso de `query` para definir la implementación indica que la operación no es mutativa. Úsalo para definir métodos de recuperación de datos. Para implementar una operación mutativa, usa el método `mutation` en su lugar.

Si agregas un nuevo procedimiento, asegúrate de registrarlo añadiéndolo al router en `src/router.ts`.

## Personalizando tu API tRPC

### Errores

En tu implementación, puedes devolver respuestas de error a los clientes lanzando un `TRPCError`. Estos aceptan un `code` que indica el tipo de error, por ejemplo:

```ts
throw new TRPCError({
  code: 'NOT_FOUND',
  message: 'No se pudo encontrar el recurso solicitado',
});
```

### Organizando tus Operaciones

A medida que tu API crece, puedes querer agrupar operaciones relacionadas.

Puedes agrupar operaciones usando routers anidados, por ejemplo:

```ts
import { getUser } from './procedures/users/get.js';
import { listUsers } from './procedures/users/list.js';

const appRouter = router({
   users: router({
      get: getUser,
      list: listUsers,
   }),
   ...
})
```

Los clientes entonces reciben esta agrupación de operaciones, por ejemplo, invocar la operación `listUsers` en este caso se vería así:

```ts
client.users.list.query();
```

### Logging

El logger de AWS Lambda Powertools se configura en `src/middleware/logger.ts`, y se puede acceder a él en una implementación de API vía `opts.ctx.logger`. Puedes usarlo para registrar en CloudWatch Logs, y/o controlar valores adicionales a incluir en cada mensaje de log estructurado. Por ejemplo:

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.logger.info('Operación llamada con entrada', opts.input);

      return ...;
   });
```

Para más información sobre el logger, consulta la [documentación de AWS Lambda Powertools Logger](https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/).

### Registro de Métricas

Las métricas de AWS Lambda Powertools se configuran en `src/middleware/metrics.ts`, y se puede acceder a ellas en una implementación de API vía `opts.ctx.metrics`. Puedes usarlas para registrar métricas en CloudWatch sin necesidad de importar y usar el SDK de AWS, por ejemplo:

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.metrics.addMetric('Invocations', 'Count', 1);

      return ...;
   });
```

Para más información, consulta la [documentación de AWS Lambda Powertools Metrics](https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/).

### Ajuste Fino de Trazado con X-Ray

El tracer de AWS Lambda Powertools se configura en `src/middleware/tracer.ts`, y se puede acceder a él en una implementación de API vía `opts.ctx.tracer`. Puedes usarlo para agregar trazas con AWS X-Ray y obtener insights detallados sobre el rendimiento y flujo de las solicitudes de API. Por ejemplo:

```ts {5-7}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      const subSegment = opts.ctx.tracer.getSegment()!.addNewSubsegment('MyAlgorithm');
      // ... lógica de mi algoritmo para capturar
      subSegment.close();

      return ...;
   });
```

Para más información, consulta la [documentación de AWS Lambda Powertools Tracer](https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/).

### Implementando Middleware Personalizado

Puedes agregar valores adicionales al contexto proporcionado a los procedimientos implementando middleware.

Como ejemplo, implementemos un middleware para extraer detalles sobre el usuario que llama a nuestra API en `src/middleware/identity.ts`.

:::warning
Este ejemplo asume que `auth` se configuró como `IAM`. Para autenticación con Cognito, el middleware de identidad es más directo, extrayendo las claims relevantes del `event`.
:::

Primero, definimos lo que agregaremos al contexto:

```ts
export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}
```

Nota que definimos una propiedad adicional _opcional_ al contexto. tRPC se encarga de asegurar que esto esté definido en procedimientos que hayan configurado correctamente este middleware.

Luego, implementamos el middleware mismo. Tiene la siguiente estructura:

```ts
export const createIdentityPlugin = () => {
   const t = initTRPC.context<...>().create();
   return t.procedure.use(async (opts) => {
      // Agrega lógica aquí para ejecutar antes del procedimiento

      const response = await opts.next(...);

      // Agrega lógica aquí para ejecutar después del procedimiento

      return response;
   });
};
```

En nuestro caso, queremos extraer detalles del usuario de Cognito que llama. Hacemos esto extrayendo el ID de sujeto (o "sub") del usuario del evento de API Gateway, y recuperando detalles del usuario de Cognito. La implementación varía ligeramente dependiendo de si el evento fue proporcionado por una REST API o una HTTP API:

<Tabs>
<TabItem label="REST">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEvent } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEvent>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoAuthenticationProvider = opts.ctx.event.requestContext?.identity?.cognitoAuthenticationProvider;

    let sub: string | undefined = undefined;
    if (cognitoAuthenticationProvider) {
      const providerParts = cognitoAuthenticationProvider.split(':');
      sub = providerParts[providerParts.length - 1];
    }

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `No se pudo determinar el usuario llamante`,
      });
    }

    const { Users } = await cognito.listUsers({
      // Asume que el ID del user pool está configurado en el entorno de Lambda
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `No se encontró usuario con subjectId ${sub}`,
      });
    }

    // Proporciona la identidad a otros procedimientos en el contexto
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
<TabItem label="HTTP">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoIdentity = opts.ctx.event.requestContext?.authorizer?.iam
      ?.cognitoIdentity as unknown as
      | {
          amr: string[];
        }
      | undefined;

    const sub = (cognitoIdentity?.amr ?? [])
      .flatMap((s) => (s.includes(':CognitoSignIn:') ? [s] : []))
      .map((s) => {
        const parts = s.split(':');
        return parts[parts.length - 1];
      })?.[0];

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `No se pudo determinar el usuario llamante`,
      });
    }

    const { Users } = await cognito.listUsers({
      // Asume que el ID del user pool está configurado en el entorno de Lambda
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `No se encontró usuario con subjectId ${sub}`,
      });
    }

    // Proporciona la identidad a otros procedimientos en el contexto
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
</Tabs>

## Desplegando tu API tRPC

El generador de API tRPC crea infraestructura como código con CDK o Terraform basado en tu `iacProvider` seleccionado. Puedes usar esto para desplegar tu API tRPC.

<Infrastructure>
<Fragment slot="cdk">
El constructo CDK para desplegar tu API está en la carpeta `common/constructs`. Puedes consumirlo en una aplicación CDK, por ejemplo:

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs`;

export class ExampleStack extends Stack {
   constructor(scope: Construct, id: string) {
      // Agrega la API a tu stack
      const api = new MyApi(this, 'MyApi', {
        integrations: MyApi.defaultIntegrations(this).build(),
      });
   }
}
```

Esto configura la infraestructura de tu API, incluyendo un AWS API Gateway REST o HTTP API, funciones AWS Lambda para lógica de negocio, y autenticación basada en tu método `auth` elegido.

<Snippet name="api/cors-configuration-cdk-note" />

:::note
Si seleccionaste usar autenticación `Cognito`, necesitarás proporcionar la propiedad `identity` al constructo de la API:

```ts {9}
import { MyApi, UserIdentity } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const identity = new UserIdentity(this, 'Identity');

    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
      identity,
    });
  }
}
```

El constructo `UserIdentity` puede generarse usando el <Link path="/guides/react-website-auth">generador `ts#react-website-auth`</Link>
:::
</Fragment>
<Fragment slot="terraform">
Los módulos de Terraform para desplegar tu API están en la carpeta `common/terraform`. Puedes usarlos en una configuración de Terraform:

```hcl {6-8}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Variables de entorno para la función Lambda
  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  # Políticas IAM adicionales si son necesarias
  additional_iam_policy_statements = [
    # Agrega cualquier permiso adicional que necesite tu API
  ]

  tags = local.common_tags
}
```

Esto configura:

1. Una función AWS Lambda que sirve todos los procedimientos tRPC
2. API Gateway HTTP/REST API como trigger de la función
3. Roles y permisos IAM
4. Grupo de logs de CloudWatch
5. Configuración de trazado X-Ray
6. Configuración CORS

<Snippet name="api/cors-configuration-terraform-note" />

:::note
Si seleccionaste usar autenticación `Cognito`, necesitarás proporcionar la configuración de Cognito:

```hcl {4-5}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  user_pool_id         = local.user_pool_id
  user_pool_client_ids = [local.client_id]

  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  tags = local.common_tags
}
```

Puedes configurar User Pool y Client de Cognito usando los recursos o módulos de Terraform apropiados.
:::

El módulo de Terraform proporciona varias salidas que puedes usar:

```hcl
# Accede al endpoint de la API
output "api_url" {
  value = module.my_api.stage_invoke_url
}

# Accede a detalles de la función Lambda
output "lambda_function_name" {
  value = module.my_api.lambda_function_name
}

# Accede al rol IAM para otorgar permisos adicionales
output "lambda_execution_role_arn" {
  value = module.my_api.lambda_execution_role_arn
}
```

Puedes personalizar la configuración CORS pasando variables al módulo:

```hcl
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Configuración CORS personalizada
  cors_allow_origins = ["https://myapp.com", "https://staging.myapp.com"]
  cors_allow_methods = ["GET", "POST", "PUT", "DELETE"]
  cors_allow_headers = [
    "authorization",
    "content-type",
    "x-custom-header"
  ]

  tags = local.common_tags
}
```

:::caution
Si seleccionaste `None` para `auth` al ejecutar el generador, puedes ver fallos en los checks de Checkov como:

<Tabs syncKey="http-rest">
<TabItem label="HTTP API">
```
Check: CKV_AWS_309: "Ensure API GatewayV2 routes specify an authorization type"
 FAILED for resource: aws_apigatewayv2_route.proxy_routes["PUT"]
```
</TabItem>
<TabItem label="REST API">
```
Check: CKV_AWS_59: "Ensure there is no open access to back-end resources through API"
 FAILED for resource: aws_api_gateway_method.proxy_method
```
</TabItem>
</Tabs>

Puedes [agregar un comentario de supresión](https://www.checkov.io/2.Basics/Suppressing%20and%20Skipping%20Policies.html) si estás seguro de que deseas que tu API sea pública.
:::
</Fragment>
</Infrastructure>

### Integraciones

<Snippet name="api/type-safe-api-integrations" parentHeading="Integraciones" />

:::tip
Si seleccionaste CDK como tu `iacProvider`, cuando agregues o quites un procedimiento en tu API tRPC, estos cambios se reflejarán inmediatamente en el constructo CDK sin necesidad de reconstruir.
:::

### Otorgando Acceso (Solo IAM)

Si seleccionaste usar autenticación `IAM`, puedes otorgar acceso a tu API:

<Infrastructure>
<Fragment slot="cdk">
```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```
</Fragment>
<Fragment slot="terraform">
```hcl
# Crea una política IAM para permitir invocar la API
resource "aws_iam_policy" "api_invoke_policy" {
  name        = "MyApiInvokePolicy"
  description = "Política para permitir invocar la API tRPC"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = "execute-api:Invoke"
        Resource = "${module.my_api.api_execution_arn}/*/*"
      }
    ]
  })
}

# Adjunta la política a un rol IAM (ej. para usuarios autenticados)
resource "aws_iam_role_policy_attachment" "api_invoke_access" {
  role       = aws_iam_role.authenticated_user_role.name
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}

# O adjunta a un rol existente por nombre
resource "aws_iam_role_policy_attachment" "api_invoke_access_existing" {
  role       = "MyExistingRole"
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}
```

Las salidas clave del módulo de API que puedes usar para políticas IAM son:

- `module.my_api.api_execution_arn` - Para otorgar permisos execute-api:Invoke
- `module.my_api.api_arn` - El ARN de API Gateway
- `module.my_api.lambda_function_arn` - El ARN de la función Lambda
</Fragment>
</Infrastructure>

### Objetivo de Bundle

<Snippet name="ts-bundle" />

## Servidor tRPC Local

Puedes usar el objetivo `serve` para ejecutar un servidor local para tu API, por ejemplo:

<NxCommands commands={['run @my-scope/my-api:serve']} />

El punto de entrada para el servidor local es `src/local-server.ts`.

Esto recargará automáticamente cuando realices cambios en tu API.

## Invocando tu API tRPC

Puedes crear un cliente tRPC para invocar tu API de manera type-safe. Si estás llamando a tu API tRPC desde otro backend, puedes usar el cliente en `src/client/index.ts`, por ejemplo:

```ts
import { createMyApiClient } from ':my-scope/my-api';

const client = createMyApiClient({ url: 'https://my-api-url.example.com/' });

await client.echo.query({ message: 'Hello world!' });
```

Si estás llamando a tu API desde un sitio web React, considera usar el generador <Link path="guides/api-connection/react-trpc">Conexión de API</Link> para configurar el cliente.

## Más Información

Para más información sobre tRPC, consulta la [documentación de tRPC](https://trpc.io/docs).