---
title: "Proyectos de TypeScript"
description: "Documentación de referencia para proyectos de TypeScript"
---

import { FileTree } from '@astrojs/starlight/components';
import RunGenerator from '@components/run-generator.astro';
import InstallCommand from '@components/install-command.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import PackageManagerShortCommand from '@components/package-manager-short-command.astro';
import Link from '@components/link.astro';

El generador de proyectos TypeScript se puede utilizar para crear una biblioteca o aplicación moderna [TypeScript](https://www.typescriptlang.org/) configurada con mejores prácticas como [Módulos ECMAScript (ESM)](https://www.typescriptlang.org/docs/handbook/modules/reference.html), [referencias de proyecto](https://www.typescriptlang.org/docs/handbook/project-references.html) de TypeScript, [Vitest](https://vitest.dev/) para ejecutar pruebas y [ESLint](https://eslint.org/) para análisis estático.

## Uso

### Generar un proyecto de TypeScript

Puedes generar un nuevo proyecto TypeScript de dos formas:

<RunGenerator generator="ts#project" />

### Opciones

<GeneratorParameters generator="ts#project" />

## Salida del generador

El generador creará la siguiente estructura de proyecto en el directorio `<directory>/<name>`:

<FileTree>

  - src Código fuente TypeScript
    - index.ts
  - project.json Configuración del proyecto y objetivos de compilación
  - tsconfig.json Configuración base de TypeScript para este proyecto (extiende tsconfig.base.json del workspace)
  - tsconfig.lib.json Configuración TypeScript para tu biblioteca (código en tiempo de ejecución o empaquetado)
  - tsconfig.spec.json Configuración TypeScript para tus pruebas
  - vitest.config.mts Configuración para Vitest
  - eslint.config.mjs Configuración para ESLint

</FileTree>

:::tip
¡Observa que no se crea ningún archivo `package.json` para este proyecto! Puedes descubrir por qué [abajo](#dependencies).
:::

También notarás cambios en los siguientes archivos en la raíz de tu workspace:

<FileTree>

  - nx.json La configuración de Nx se actualiza para configurar el plugin @nx/js/typescript para tu proyecto
  - tsconfig.base.json Se configura un alias TypeScript para tu proyecto permitiendo su importación desde otros proyectos
  - tsconfig.json Se añade una referencia de proyecto TypeScript para tu proyecto

</FileTree>

## Escribiendo código TypeScript

Añade tu código TypeScript en el directorio `src`.

### Sintaxis de importación ESM

Como tu proyecto TypeScript es un Módulo ES, asegúrate de escribir tus sentencias de importación con la sintaxis ESM correcta, referenciando explícitamente la extensión del archivo:

```ts title="index.ts" ".js"
import { sayHello } from './hello.js';
```

:::note
Aunque estemos usando TypeScript, y `sayHello` esté definido en `hello.ts`, usamos la extensión `.js` en nuestra importación. Puedes leer más sobre esto [aquí](https://www.typescriptlang.org/docs/handbook/modules/reference.html).
:::

### Exportando para otros proyectos TypeScript

El punto de entrada de tu proyecto TypeScript es `src/index.ts`. Puedes añadir exports aquí para cualquier elemento que quieras que otros proyectos puedan importar:

```ts title="src/index.ts"
export { sayHello } from './hello.js';
export * from './algorithms/index.js';
```

### Importando tu biblioteca en otros proyectos

Los [alias de TypeScript](https://www.typescriptlang.org/docs/handbook/modules/reference.html#paths) para tu proyecto están configurados en el `tsconfig.base.json` del workspace, permitiéndote referenciar tu proyecto TypeScript desde otros proyectos:

```ts title="packages/my-other-project/src/index.ts"
import { sayHello } from ':my-scope/my-library';
```

:::note
Los alias para proyectos TypeScript comienzan con `:` en lugar del tradicional `@`, evitando posibles conflictos de nombres entre paquetes locales en tu workspace y paquetes remotos en [NPM](https://www.npmjs.com/).
:::

Cuando añadas una sentencia de importación para un nuevo proyecto en tu workspace por primera vez, probablemente verás un error en tu IDE similar a este:

<details>
<summary>Error de importación</summary>

```bash wrap
File '/path/to/my/workspace/packages/my-library/src/index.ts' is not under 'rootDir' '/path/to/my/workspace/packages/my-consumer'. 'rootDir' is expected to contain all source files.
  File is ECMAScript module because '/path/to/my/workspace/package.json' has field "type" with value "module" ts(6059)
File '/path/to/my/workspace/packages/my-library/src/index.ts' is not listed within the file list of project '/path/to/my/workspace/packages/my-consumer/tsconfig.lib.json'. Projects must list all files or use an 'include' pattern.
  File is ECMAScript module because '/path/to/my/workspace/package.json' has field "type" with value "module" ts(6307)
```

</details>

Esto ocurre porque no se ha configurado una [referencia de proyecto](https://www.typescriptlang.org/docs/handbook/project-references.html).

Los proyectos TypeScript vienen configurados con el generador de sincronización de TypeScript de Nx, evitando que necesites configurar manualmente las referencias. Simplemente ejecuta el siguiente comando y Nx añadirá la configuración requerida:

<NxCommands commands={['sync']} />

Después de esto, el error en tu IDE debería desaparecer y estarás listo para usar tu biblioteca.

:::tip
También puedes simplemente construir tu proyecto y verás un mensaje como:

```bash wrap
[@nx/js:typescript-sync]: Some TypeScript configuration files are missing project references to the projects they depend on or contain outdated project references.

This will result in an error in CI.

? Would you like to sync the identified changes to get your workspace up to date?
Yes, sync the changes and run the tasks
No, run the tasks without syncing the changes
```

Selecciona `Yes` para permitir que Nx actualice tus referencias de proyecto.
:::

### Manteniendo los alias de rutas sincronizados

Si añades entradas personalizadas de `compilerOptions.paths` en el `tsconfig.json` de un proyecto, TypeScript deja de heredar los alias del workspace definidos en `tsconfig.base.json`. El generador oculto `ts#sync` se ejecuta antes del objetivo `compile` (configurado en `nx.json`) para copiar cualquier alias base faltante en los archivos `tsconfig.json`, `tsconfig.lib.json` y `tsconfig.app.json` que ya declaren `paths`. Para desactivar esta funcionalidad, elimina `@aws/nx-plugin:ts#sync` de `targetDefaults.compile.syncGenerators` en `nx.json`.

### Dependencias

Notarás que tu proyecto TypeScript no tiene archivo `package.json`, lo cual puede ser inesperado si estás acostumbrado a monorepos TypeScript tradicionales.

Para añadir una dependencia para cualquier paquete TypeScript en tu monorepo, simplemente añádela al `package.json` en la raíz de tu workspace. Puedes hacer esto vía línea de comandos para tu gestor de paquetes:

<InstallCommand pkg="some-npm-package" />

La dependencia estará entonces disponible para cualquier proyecto TypeScript en tu workspace.

#### Código en tiempo de ejecución

Cuando uses tu proyecto TypeScript como código en tiempo de ejecución (por ejemplo como handler para una función AWS Lambda), se recomienda usar una herramienta como [Rolldown](https://rolldown.rs/) para empaquetar tu proyecto, ya que puede realizar [tree-shake](https://rolldown.rs/guide/in-depth/why-bundlers) para incluir solo las dependencias realmente usadas.

Puedes lograr esto añadiendo un objetivo como el siguiente en tu archivo `project.json`:

```json
{
  ...
  "targets": {
    ...
    "bundle": {
      "cache": true,
      "executor": "nx:run-commands",
      "outputs": ["{workspaceRoot}/dist/packages/my-library/bundle"],
      "options": {
        "command": "rolldown -c rolldown.config.ts"
      }
    },
  },
}
```

Y añadiendo el archivo `rolldown.config.ts` de la siguiente forma:

```ts
// rolldown.config.ts
import { defineConfig } from 'rolldown';

export default defineConfig([
  {
    input: 'src/index.ts',
    output: {
      file: '../../dist/packages/my-library/bundle/index.js',
      format: 'cjs',
      inlineDynamicImports: true,
    },
  },
]);
```

:::note
Nota que en el objetivo anterior elegimos `src/index.ts` como punto de entrada para el bundle, lo que significa que el código exportado desde este archivo se incluirá en el bundle junto con todas sus dependencias.
:::

:::tip
Si estás construyendo una función AWS Lambda, revisa el generador <Link path="/guides/ts-lambda-function">`ts#lambda-function`</Link> ya que configura el empaquetado automáticamente, además de generar infraestructura y añadir observabilidad y type-safety.
:::

#### Publicación en NPM

Si vas a publicar tu proyecto TypeScript en NPM, debes crear un archivo `package.json` para él.

Este debe declarar las dependencias que tu proyecto utiliza. Dado que en tiempo de compilación tu proyecto resuelve dependencias instaladas vía el `package.json` raíz del workspace, se recomienda configurar el [Plugin ESLint de Verificación de Dependencias de Nx](https://nx.dev/nx-api/eslint-plugin/documents/dependency-checks) para asegurar que el `package.json` publicado incluye todas las dependencias usadas.

### Compilación

Tu proyecto TypeScript está configurado con un objetivo `build` (definido en `project.json`), que puedes ejecutar mediante:

<NxCommands commands={['run <project-name>:build']} />

Donde `<project-name>` es el nombre completo de tu proyecto.

El objetivo `build` compilará, linteará y probará tu proyecto.

La salida de compilación se encuentra en la carpeta `dist` raíz de tu workspace, dentro de un directorio para tu paquete y objetivo, por ejemplo `dist/packages/<my-library>/tsc`

Para construir todos los proyectos en tu workspace, ejecuta:

<NxCommands commands={['run-many --target build']} />

O usa el comando abreviado:

<PackageManagerShortCommand commands={["build"]} />

## Pruebas

[Vitest](https://vitest.dev/) está configurado para probar tu proyecto.

### Escribiendo pruebas

Las pruebas deben escribirse en archivos `.spec.ts` o `.test.ts`, ubicados junto al código en la carpeta `src` de tu proyecto.

Por ejemplo:

<FileTree>
  - src
    - hello.ts Código fuente de la biblioteca
    - hello.spec.ts Pruebas para hello.ts
</FileTree>

Vitest proporciona una sintaxis similar a Jest para definir pruebas, con utilidades como `describe`, `it`, `test` y `expect`.

```ts title="hello.spec.ts"
import { sayHello } from './hello.js';

describe('sayHello', () => {

  it('debe saludar al llamador', () => {
    expect(sayHello('Darth Vader')).toBe('Hello, Darth Vader!');
  });

});

```

Para más detalles sobre cómo escribir pruebas y características como mock de dependencias, consulta la [documentación de Vitest](https://vitest.dev/guide/#writing-tests)

### Ejecutando pruebas

Las pruebas se ejecutarán como parte del objetivo `build` de tu proyecto, pero también puedes ejecutarlas por separado mediante el objetivo `test`:

<NxCommands commands={['run <project-name>:test']} />

Puedes ejecutar una prueba individual o un conjunto de pruebas usando el flag `-t`:

<NxCommands commands={["run <project-name>:test -t 'sayHello'"]} />

:::tip
Si usas VSCode, recomendamos instalar la extensión [Vitest Runner for VSCode that actually works](https://marketplace.visualstudio.com/items?itemName=rluvaton.vscode-vitest), que permite ejecutar, monitorizar o depurar pruebas directamente desde tu IDE.
:::

## Linting

Los proyectos TypeScript usan [ESLint](https://eslint.org/) para linting junto con [Prettier](https://prettier.io/) para formateo.

Recomendamos configurar ESLint en el archivo `eslint.config.mjs` raíz del workspace, ya que los cambios aquí aplicarán a todos los proyectos TypeScript y asegurarán consistencia.

Igualmente, puedes configurar Prettier en el archivo `.prettierrc` raíz.

### Ejecutando el linter

Para invocar el linter y verificar tu proyecto, ejecuta el objetivo `lint`:

<NxCommands commands={["run <project-name>:lint"]} />

### Corrigiendo problemas de lint

La mayoría de problemas de lint o formateo pueden corregirse automáticamente. Puedes indicar a ESLint que corrija los problemas ejecutando con el argumento `--configuration=fix`:

<NxCommands commands={["run <project-name>:lint --configuration=fix"]} />

Similarmente, si quieres corregir todos los problemas de lint en todos los paquetes de tu workspace, puedes ejecutar:

<NxCommands commands={["run-many --target lint --all --configuration=fix"]} />

:::tip
Esto tiene un comando abreviado desde la raíz de tu workspace:

<PackageManagerShortCommand commands={["lint"]} />
:::

### Omitiendo problemas de lint

Para evitar que los problemas de lint te ralenticen durante el desarrollo (particularmente si tienes problemas no auto-corregibles en tu proyecto), puedes ejecutar una compilación con la configuración `skip-lint`:

<NxCommands commands={["run-many --target build --configuration=skip-lint"]} />

Esto seguirá ejecutando ESLint como parte de la compilación, pero el objetivo lint siempre se considerará exitoso.

:::tip
Esto tiene un comando abreviado desde la raíz de tu workspace:

<PackageManagerShortCommand commands={["build:skip-lint"]} />
:::