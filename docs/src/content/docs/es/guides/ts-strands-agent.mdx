---
title: "Agente Strands de TypeScript"
description: "Genera un Agente Strands de TypeScript para construir agentes de IA con herramientas y despliega en Amazon Bedrock AgentCore Runtime"
---

import { FileTree } from '@astrojs/starlight/components';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import Link from '@components/link.astro';
import Snippet from '@components/snippet.astro';
import Infrastructure from '@components/infrastructure.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import PackageManagerExecCommand from '@components/package-manager-exec-command.astro';

Genera un TypeScript [Strands Agent](https://strandsagents.com/) para construir agentes de IA con herramientas, y opcionalmente despliégalo en [Amazon Bedrock AgentCore Runtime](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/). El generador utiliza [tRPC](https://trpc.io/) sobre WebSocket para aprovechar el [soporte de streaming bidireccional de AgentCore](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-get-started-websocket.html) para comunicación en tiempo real y con seguridad de tipos.

## ¿Qué es Strands?

[Strands](https://strandsagents.com/latest/documentation/docs/) es un framework ligero para construir agentes de IA. Las características clave incluyen:

- **Ligero y personalizable**: Bucle de agente simple que no se interpone en tu camino
- **Listo para producción**: Observabilidad completa, rastreo y opciones de despliegue para escalar
- **Agnóstico de modelo y proveedor**: Soporta muchos modelos diferentes de varios proveedores
- **Herramientas impulsadas por la comunidad**: Conjunto poderoso de herramientas contribuidas por la comunidad
- **Soporte multi-agente**: Técnicas avanzadas como equipos de agentes y agentes autónomos
- **Modos de interacción flexibles**: Soporte conversacional, streaming y no-streaming

## Uso

### Generar un Strands Agent

Puedes generar un TypeScript Strands Agent de dos maneras:

<RunGenerator generator="ts#strands-agent" />

:::tip
Primero usa el generador <Link path="/guides/typescript-project">`ts#project`</Link> para crear un proyecto al que agregar tu Strands Agent.
:::

### Opciones

<GeneratorParameters generator="ts#strands-agent" />

## Salida del Generador

El generador agregará los siguientes archivos a tu proyecto TypeScript existente:

<FileTree>
  - your-project/
    - src/
      - agent/ (o nombre personalizado si se especifica)
        - index.ts Punto de entrada para Bedrock AgentCore Runtime
        - init.ts Inicialización de tRPC
        - router.ts Router de tRPC con procedimientos del agente
        - agent.ts Definición principal del agente con herramientas de ejemplo
        - client.ts Cliente provisto para invocar tu agente
        - agent-core-trpc-client.ts Fábrica de cliente para conectar a agentes en AgentCore Runtime
        - agent-core-mcp-client.ts Fábrica de cliente para conectar a servidores MCP en AgentCore Runtime
        - Dockerfile Punto de entrada para alojar tu agente (excluido cuando `computeType` está establecido en `None`)
    - package.json Actualizado con dependencias de Strands
    - project.json Actualizado con targets de servicio del agente
</FileTree>

### Infraestructura

:::note
Si seleccionaste `None` para `computeType`, el generador no proveerá ninguna infraestructura como código.
:::

<Snippet name="shared-constructs" />

Para desplegar tu Strands Agent, se generan los siguientes archivos:

<Infrastructure>
<Fragment slot="cdk">
<FileTree>
  - packages/common/constructs/src
    - app
      - agents
        - \<project-name>
          - \<project-name>.ts Constructo CDK para desplegar tu agente
          - Dockerfile Archivo docker de paso utilizado por el constructo CDK
</FileTree>
</Fragment>
<Fragment slot="terraform">
<FileTree>
  - packages/common/terraform/src
    - app
      - agents
        - \<project-name>
          - \<project-name>.tf Módulo para desplegar tu agente
    - core
      - agent-core
        - runtime.tf Módulo genérico para desplegar en Bedrock AgentCore Runtime
</FileTree>
</Fragment>
</Infrastructure>

## Trabajar con tu Strands Agent

### tRPC sobre WebSocket

El TypeScript Strands Agent utiliza [tRPC](https://trpc.io/) sobre WebSocket, aprovechando el [soporte de streaming bidireccional de AgentCore](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-get-started-websocket.html) para habilitar comunicación en tiempo real y con seguridad de tipos entre clientes y tu agente.

Dado que tRPC soporta procedimientos Query, Mutation y Subscription sobre WebSocket, puedes definir cualquier número de procedimientos. Por defecto, se define un único procedimiento de suscripción llamado `invoke` en `router.ts`.

### Agregar Herramientas

Las herramientas son funciones que el agente de IA puede llamar para realizar acciones. Puedes agregar nuevas herramientas en el archivo `agent.ts`:

```typescript
import { Agent, tool } from '@strands-agents/sdk';
import z from 'zod';

const letterCounter = tool({
  name: 'letter_counter',
  description: 'Count occurrences of a specific letter in a word',
  inputSchema: z.object({
    word: z.string().describe('The input word to search in'),
    letter: z.string().length(1).describe('The specific letter to count'),
  }),
  callback: (input) => {
    const { word, letter } = input;
    const count = word.toLowerCase().split(letter.toLowerCase()).length - 1;
    return `The letter '${letter}' appears ${count} time(s) in '${word}'`;
  },
});

// Add tools to your agent
export const agent = new Agent({
  systemPrompt: 'You are a helpful assistant with access to various tools.',
  tools: [letterCounter],
});
```

El framework Strands maneja automáticamente:
- Validación de entrada usando esquemas Zod
- Generación de esquema JSON para llamadas a herramientas
- Manejo de errores y formateo de respuestas

### Configuración de Modelo

Por defecto, los agentes Strands usan Claude 4 Sonnet, pero puedes cambiar fácilmente entre proveedores de modelos:

```typescript
import { Agent } from '@strands-agents/sdk';
import { BedrockModel } from '@strands-agents/sdk/models/bedrock';
import { OpenAIModel } from '@strands-agents/sdk/models/openai';

// Use Bedrock
const bedrockModel = new BedrockModel({
  modelId: 'anthropic.claude-sonnet-4-20250514-v1:0',
});
let agent = new Agent({ model: bedrockModel });
let response = await agent.invoke('What can you help me with?');

// Alternatively, use OpenAI by just switching model provider
const openaiModel = new OpenAIModel({
  apiKey: process.env.OPENAI_API_KEY,
  modelId: 'gpt-4o',
});
agent = new Agent({ model: openaiModel });
response = await agent.invoke('What can you help me with?');
```

Consulta la [documentación de Strands sobre proveedores de modelos](https://strandsagents.com/latest/documentation/docs/user-guide/quickstart/#model-providers) para más opciones de configuración.

### Consumir Servidores MCP

Puedes [agregar herramientas desde servidores MCP](https://strandsagents.com/latest/documentation/docs/user-guide/concepts/tools/mcp-tools/) a tu agente Strands.

Para consumir Servidores MCP que has creado usando los generadores <Link path="/guides/py-mcp-server">`py#mcp-server`</Link> o <Link path="/guides/ts-mcp-server">`ts#mcp-server`</Link> (u otros alojados en Bedrock AgentCore Runtime), se genera una fábrica de cliente para ti en `agent-core-mcp-client.ts`.

Puedes actualizar la inicialización de tu agente en `agent.ts` para crear clientes MCP y agregar herramientas. El siguiente ejemplo muestra cómo realizar esto con autenticación IAM (SigV4):

```typescript
// agent.ts
import { Agent } from '@strands-agents/sdk';
import { AgentCoreMcpClient } from './agent-core-mcp-client.js';

const mcpClient = AgentCoreMcpClient.withIamAuth({
  agentRuntimeArn: process.env.MCP_AGENTCORE_RUNTIME_ARN!,
  region: process.env.AWS_REGION || 'us-west-2',
  sessionId: 'my-session-id',
});

export const agent = new Agent({
  systemPrompt: '...',
  tools: [mcpClient],
});
```

:::tip
Si tu servidor MCP objetivo usa autenticación JWT, puedes usar el método `AgentCoreMcpClient.withJwtAuth` para crear el cliente en su lugar.
:::

Con el ejemplo de autenticación IAM anterior, necesitamos configurar dos cosas en nuestra infraestructura. Primero, necesitamos agregar la variable de entorno que nuestro agente está consumiendo para el ARN de AgentCore Runtime de nuestro servidor MCP, y segundo necesitamos otorgar permisos a nuestro agente para invocar el servidor MCP. Esto se puede lograr de la siguiente manera:

<Infrastructure>
<Fragment slot="cdk">
```ts {9, 13}
import { MyProjectAgent, MyProjectMcpServer } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const mcpServer = new MyProjectMcpServer(this, 'MyProjectMcpServer');

    const agent = new MyProjectAgent(this, 'MyProjectAgent', {
      environmentVariables: {
        MCP_AGENTCORE_RUNTIME_ARN: mcpServer.agentCoreRuntime.agentRuntimeArn,
      },
    });

    mcpServer.agentCoreRuntime.grantInvoke(agent.agentCoreRuntime);
  }
}
```
</Fragment>
<Fragment slot="terraform">
```terraform
# MCP Server
module "my_project_mcp_server" {
  source = "../../common/terraform/src/app/mcp-servers/my-project-mcp-server"
}

# Agent
module "my_project_agent" {
  source = "../../common/terraform/src/app/agents/my-project-agent"

  env = {
    MCP_AGENTCORE_RUNTIME_ARN = module.my_project_mcp_server.agent_core_runtime_arn
  }

  additional_iam_policy_statements = [
    {
      Effect = "Allow"
      Action = [
        "bedrock-agentcore:InvokeAgentRuntime"
      ]
      Resource = [
        module.my_project_mcp_server.agent_core_runtime_arn,
        "${module.my_project_mcp_server.agent_core_runtime_arn}/*"
      ]
    }
  ]
}
```
</Fragment>
</Infrastructure>

### Más

Para una guía más profunda sobre cómo escribir agentes Strands, consulta la [documentación de Strands](https://strandsagents.com/latest/documentation/docs/).

## Ejecutar tu Strands Agent

### Desarrollo Local

El generador configura un target llamado `<your-agent-name>-serve`, que inicia tu Strands Agent localmente para desarrollo y pruebas.

<NxCommands commands={['run your-project:agent-serve']} />

Este comando usa `tsx --watch` para reiniciar automáticamente el servidor cuando cambian los archivos. El agente estará disponible en `http://localhost:8081` (o el puerto asignado si tienes múltiples agentes).

## Desplegar tu Strands Agent en Bedrock AgentCore Runtime

<Snippet name="agent/bedrock-deployment" parentHeading="Desplegar tu Strands Agent en Bedrock AgentCore Runtime" />

### Target Bundle

<Snippet name="ts-bundle" />

El target bundle usa `index.ts` como punto de entrada para el servidor WebSocket para alojar en Bedrock AgentCore Runtime.

### Target Docker

El generador configura un target `<your-agent-name>-docker` que ejecuta el servidor WebSocket empaquetado en el puerto `8080` según el [contrato de runtime de AgentCore](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-service-contract.html).

:::tip
La imagen docker se construye usando una etiqueta (por ejemplo `my-scope-my-project-agent:latest`), que es referenciada por tu infraestructura CDK o Terraform, permitiendo que tu `Dockerfile` esté co-ubicado con tu proyecto Strands Agent.
:::

También se genera un target `docker` que ejecuta la construcción docker para todos los agentes si tienes múltiples definidos.

### Observabilidad

Tu agente está configurado automáticamente con observabilidad usando el [AWS Distro for Open Telemetry](https://aws.amazon.com/otel/) (ADOT), configurando auto-instrumentación en tu `Dockerfile`.

Puedes encontrar trazas en la Consola AWS CloudWatch, seleccionando "GenAI Observability" en el menú. Ten en cuenta que para que las trazas se completen necesitarás habilitar [Transaction Search](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Transaction-Search.html).

Para más detalles, consulta la [documentación de AgentCore sobre observabilidad](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/observability-configure.html).

## Invocar tu Strands Agent

La comunicación del agente se transmite vía tRPC sobre WebSocket. Como tal, se recomienda usar la fábrica de cliente con seguridad de tipos generada en `client.ts`.

### Invocar el Servidor Local

Puedes invocar un agente ejecutándose localmente usando el método de fábrica `.local` de la fábrica de cliente.

Puedes, por ejemplo, crear un archivo llamado `scripts/test.ts` en tu workspace que importe el cliente:

```typescript
// scripts/test.ts
import { AgentClient } from '../packages/<project>/src/agent/client.js';

const client = AgentClient.local({ url: 'http://localhost:8081/ws' });

client.invoke.subscribe({ message: 'what is 1 plus 1?' }, { onData: console.log });
```

:::tip
Ejecuta con `tsx` como una forma rápida de probar tu agente.

<PackageManagerExecCommand commands={['tsx scripts/test.ts']} />
:::

### Invocar el Agente Desplegado

<Snippet name="agent/runtime-arn" parentHeading="Invocar el Agente Desplegado" />

#### NodeJS

El archivo `client.ts` generado incluye una fábrica de cliente con seguridad de tipos que puede usarse para invocar tu agente desplegado.

:::caution
La fábrica de cliente usa encabezados HTTP en el handshake de WebSocket para autenticar solicitudes a Bedrock AgentCore Runtime. Esto no es posible en un navegador, y por lo tanto este cliente no es adecuado para entornos de navegador. Consulta la sección "Browser" a continuación para detalles sobre la invocación desde un navegador.
:::

##### Autenticación IAM

Puedes invocar tu agente desplegado pasando su ARN al método de fábrica `withIamAuth`:

```typescript
import { AgentClient } from './agent/client.js';

const client = AgentClient.withIamAuth({
  agentRuntimeArn: 'arn:aws:bedrock-agentcore:us-west-2:123456789012:runtime/my-agent',
});

client.invoke.subscribe({ message: 'what is 1 plus 1?' }, {
  onData: (message) => console.log(message),
  onError: (error) => console.error(error),
  onComplete: () => console.log('Done'),
});
```

:::note
Esto usará la cadena de proveedores de credenciales AWS predeterminada para autenticar solicitudes, por lo que el entorno en el que se ejecuta lo anterior debe tener credenciales AWS configuradas, con acceso para invocar el runtime.
:::

##### Autenticación JWT / Cognito

Usa el método de fábrica `withJwtAuth` para autenticar con el token de acceso JWT / Cognito.

```typescript
const client = AgentClient.withJwtAuth({
  agentRuntimeArn: 'arn:aws:bedrock-agentcore:us-west-2:123456789012:runtime/my-agent',
  accessTokenProvider: async () => `<access-token>`,
});

client.invoke.subscribe({ message: 'what is 1 plus 1?' }, {
  onData: console.log,
});
```

El `accessTokenProvider` debe devolver el token usado para autenticar la solicitud. Puedes, por ejemplo, obtener un token dentro de este método para asegurar que las credenciales frescas se reutilicen cuando tRPC reinicie una conexión WebSocket. Lo siguiente demuestra usar el AWS SDK para obtener el token de Cognito:

```typescript
import { CognitoIdentityProvider } from "@aws-sdk/client-cognito-identity-provider";

const cognito = new CognitoIdentityProvider();

const jwtClient = AgentClient.withJwtAuth({
  agentRuntimeArn: 'arn:aws:bedrock-agentcore:us-west-2:123456789012:runtime/my-agent',
  accessTokenProvider: async () => {
    const response = await cognito.adminInitiateAuth({
      UserPoolId: '<user-pool-id>',
      ClientId: '<user-pool-client-id>',
      AuthFlow: 'ADMIN_NO_SRP_AUTH',
      AuthParameters: {
        USERNAME: '<username>',
        PASSWORD: '<password>',
      },
    });
    return response.AuthenticationResult!.AccessToken!;
  },
});
```

#### Browser

Los WebSockets en el navegador no soportan especificar encabezados (aparte de `Sec-WebSocket-Protocol`), y por lo tanto la fábrica de cliente generada en `client.ts` no puede usarse en un navegador (esto en realidad resultará en un error de compilación ya que el constructor `WebSocket` no acepta encabezados como lo hace en NodeJS).

##### Autenticación JWT / Cognito

:::caution
Al momento de escribir esto, Bedrock AgentCore Runtime requiere que los tokens JWT se pasen en el encabezado `Authorization`, y por lo tanto los navegadores no pueden autenticarse con Bedrock AgentCore Runtime usando autenticación JWT. Solo se soporta la autenticación AWS Signature Version 4 (SigV4) vía URLs prefirmadas.

Nos esforzaremos por actualizar esta documentación si se agrega soporte en el futuro.
:::

##### Autenticación IAM

Para invocar tu agente desde un navegador, necesitas crear una URL WebSocket prefirmada usando AWS SigV4.

El siguiente ejemplo muestra un flujo de extremo a extremo de obtención de credenciales, creación de una URL prefirmada e invocación del agente:

```typescript
import { createTRPCClient, createWSClient, wsLink } from '@trpc/client';
import { AwsClient } from 'aws4fetch';
import { CognitoIdentityClient } from '@aws-sdk/client-cognito-identity';
import { fromCognitoIdentityPool } from '@aws-sdk/credential-provider-cognito-identity';
import type { AppRouter } from './your-agent/router';

// Build a presigned WebSocket URL
async function buildSignedUrl(
  agentRuntimeArn: string,
  idToken: string,
  region: string = 'us-west-2'
): Promise<string> {
  // Get credentials from a Cognito Identity Pool (or other source)
  const credentials = fromCognitoIdentityPool({
    client: new CognitoIdentityClient({ region }),
    identityPoolId: 'us-west-2:xxxxx',
    logins: {
      [`cognito-idp.${region}.amazonaws.com/us-west-2_xxxxx`]: idToken,
    },
  });

  const cognitoIdentity = new CognitoIdentityClient({ credentials });
  const credential = await cognitoIdentity.config.credentials();

  // Create AWS SigV4 client
  const awsClient = new AwsClient({
    ...credential,
    service: 'bedrock-agentcore',
  });

  // Build WebSocket URL from ARN
  const wsUrl = `wss://bedrock-agentcore.${region}.amazonaws.com/runtimes/${agentRuntimeArn.replace(/:/g, '%3A').replace(/\//g, '%2F')}/ws`;

  // Create presigned URL
  const signedRequest = await awsClient.sign(wsUrl, {
    method: 'GET',
    aws: { signQuery: true },
  });

  return signedRequest.url;
}

// Create tRPC client with presigned WebSocket URL
const agentRuntimeArn = 'arn:aws:bedrock-agentcore:us-west-2:123456789012:runtime/my-agent';
const idToken = '<your-id-token>';

const wsClient = createWSClient({
  url: async () => buildSignedUrl(agentRuntimeArn, idToken),
});

const trpcClient = createTRPCClient<AppRouter>({
  links: [wsLink({ client: wsClient })],
});

// Invoke the agent
trpcClient.invoke.subscribe({ message: 'what is 1 plus 1?' }, {
  onData: (message) => console.log(message),
});
```

:::tip
Si deseas una experiencia similar al <Link path="/guides/connection">generador de conexión API</Link> para agentes, por favor +1 [este issue de GitHub](https://github.com/awslabs/nx-plugin-for-aws/issues/326).
:::