---
title: "FastAPI"
description: "Documentación de referencia para FastAPI"
---



import { FileTree, AnchorHeading, Tabs, TabItem } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Infrastructure from '@components/infrastructure.astro';
import Snippet from '@components/snippet.astro';

[FastAPI](https://fastapi.tiangolo.com/) es un framework para construir APIs en Python.

El generador de FastAPI crea una nueva API FastAPI con configuración de infraestructura usando AWS CDK o Terraform. El backend generado utiliza AWS Lambda para despliegue serverless, expuesto a través de una API de AWS API Gateway. Configura [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/python/latest/) para observabilidad, incluyendo registro, trazado con AWS X-Ray y métricas de CloudWatch.

## Uso

### Generar una API FastAPI

Puedes generar una nueva API FastAPI de dos maneras:

<RunGenerator generator="py#fast-api" />

### Opciones

<GeneratorParameters generator="py#fast-api" />

<Snippet name="api/api-choice-note" />

## Salida del generador

El generador creará la siguiente estructura de proyecto en el directorio `<directory>/<api-name>`:

<FileTree>

- project.json Configuración del proyecto y objetivos de build
- pyproject.toml Configuración del proyecto Python y dependencias
- \<module_name>
  - \_\_init\_\_.py Inicialización del módulo
  - init.py Configura la aplicación FastAPI y el middleware de powertools
  - main.py Implementación de la API
- scripts
  - generate_open_api.py Script para generar un esquema OpenAPI desde la app FastAPI

</FileTree>

### Infraestructura

<Snippet name="shared-constructs" />

<Snippet name="api/shared-constructs" />

## Implementando tu API FastAPI

La implementación principal de la API está en `main.py`. Aquí es donde defines las rutas de tu API y sus implementaciones. Aquí un ejemplo:

```python
from .init import app, tracer
from pydantic import BaseModel

class Item(BaseModel):
  name: str

@app.get("/items/{item_id}")
def get_item(item_id: int) -> Item:
    return Item(name=...)

@app.post("/items")
def create_item(item: Item):
    return ...
```

El generador configura automáticamente varias características:

1. Integración de AWS Lambda Powertools para observabilidad
2. Middleware de manejo de errores
3. Correlación de solicitudes/respuestas
4. Recolección de métricas
5. Manejador de AWS Lambda usando Mangum

### Observabilidad con AWS Lambda Powertools

#### Registro

El generador configura registro estructurado usando AWS Lambda Powertools. Puedes acceder al logger en tus manejadores de rutas:

```python
from .init import app, logger

@app.get("/items/{item_id}")
def read_item(item_id: int):
    logger.info("Fetching item", extra={"item_id": item_id})
    return {"item_id": item_id}
```

El logger incluye automáticamente:

- IDs de correlación para trazado de solicitudes
- Ruta y método de la solicitud
- Información del contexto de Lambda
- Indicadores de inicio en frío

#### Seguimiento

El trazado con AWS X-Ray se configura automáticamente. Puedes añadir subsegmentos personalizados a tus trazas:

```python
from .init import app, tracer

@app.get("/items/{item_id}")
@tracer.capture_method
def read_item(item_id: int):
    # Crea un nuevo subsegmento
    with tracer.provider.in_subsegment("fetch-item-details"):
        # Tu lógica aquí
        return {"item_id": item_id}
```

#### Métricas

Las métricas de CloudWatch se recopilan automáticamente para cada solicitud. Puedes añadir métricas personalizadas:

```python
from .init import app, metrics
from aws_lambda_powertools.metrics import MetricUnit

@app.get("/items/{item_id}")
def read_item(item_id: int):
    metrics.add_metric(name="ItemViewed", unit=MetricUnit.Count, value=1)
    return {"item_id": item_id}
```

Las métricas por defecto incluyen:

- Conteo de solicitudes
- Conteos de éxito/fallo
- Métricas de inicio en frío
- Métricas por ruta

### Manejo de errores

El generador incluye manejo de errores completo:

```python
from fastapi import HTTPException

@app.get("/items/{item_id}")
def read_item(item_id: int):
    if item_id < 0:
        raise HTTPException(status_code=400, detail="Item ID must be positive")
    return {"item_id": item_id}
```

Las excepciones no manejadas son capturadas por el middleware y:

1. Registran la excepción completa con stack trace
2. Registran una métrica de fallo
3. Devuelven una respuesta segura 500 al cliente
4. Preservan el ID de correlación

:::tip
Se recomienda especificar modelos de respuesta para tus operaciones API si planeas usar el generador `api-connection`. <Link path="guides/api-connection/react-fastapi#errors">Consulta aquí para más detalles</Link>.
:::

### Streaming

Con FastAPI, puedes transmitir una respuesta al cliente usando el tipo de respuesta [`StreamingResponse`](https://fastapi.tiangolo.com/reference/responses/?h=streaming#fastapi.responses.StreamingResponse).

#### Cambios en la infraestructura

Dado que AWS API Gateway no soporta respuestas en streaming, necesitarás desplegar tu FastAPI en una plataforma que lo soporte. La opción más simple es usar una URL de función de AWS Lambda.

<Infrastructure>
<Fragment slot="cdk">
Para esto, puedes reemplazar el constructo generado `common/constructs/src/app/apis/<name>-api.ts` por uno que despliegue una Function URL.

<details>
<summary>Ejemplo de constructo FunctionURL para streaming</summary>

```ts
import { Duration, Stack, CfnOutput } from 'aws-cdk-lib';
import { IGrantable, Grant } from 'aws-cdk-lib/aws-iam';
import {
  Runtime,
  Code,
  Tracing,
  LayerVersion,
  FunctionUrlAuthType,
  InvokeMode,
  Function,
} from 'aws-cdk-lib/aws-lambda';
import { Construct } from 'constructs';
import url from 'url';
import { RuntimeConfig } from '../../core/runtime-config.js';

export class MyApi extends Construct {
  public readonly handler: Function;

  constructor(scope: Construct, id: string) {
    super(scope, id);

    this.handler = new Function(this, 'Handler', {
      runtime: Runtime.PYTHON_3_12,
      handler: 'run.sh',
      code: Code.fromAsset(
        url.fileURLToPath(
          new URL(
            '../../../../../../dist/packages/my_api/bundle-x86',
            import.meta.url,
          ),
        ),
      ),
      timeout: Duration.seconds(30),
      tracing: Tracing.ACTIVE,
      environment: {
        AWS_CONNECTION_REUSE_ENABLED: '1',
      },
    });

    const stack = Stack.of(this);
    this.handler.addLayers(
      LayerVersion.fromLayerVersionArn(
        this,
        'LWALayer',
        `arn:aws:lambda:${stack.region}:753240598075:layer:LambdaAdapterLayerX86:24`,
      ),
    );
    this.handler.addEnvironment('PORT', '8000');
    this.handler.addEnvironment('AWS_LWA_INVOKE_MODE', 'response_stream');
    this.handler.addEnvironment('AWS_LAMBDA_EXEC_WRAPPER', '/opt/bootstrap');
    const functionUrl = this.handler.addFunctionUrl({
      authType: FunctionUrlAuthType.AWS_IAM,
      invokeMode: InvokeMode.RESPONSE_STREAM,
      cors: {
        allowedOrigins: ['*'],
        allowedHeaders: [
          'authorization',
          'content-type',
          'x-amz-content-sha256',
          'x-amz-date',
          'x-amz-security-token',
        ],
      },
    });

    new CfnOutput(this, 'MyApiUrl', { value: functionUrl.url });

    // Registrar la URL en la configuración para descubrimiento de clientes
    RuntimeConfig.ensure(this).config.apis = {
      ...RuntimeConfig.ensure(this).config.apis!,
      MyApi: functionUrl.url,
    };
  }

  public grantInvokeAccess(grantee: IGrantable) {
    Grant.addToPrincipal({
      grantee,
      actions: ['lambda:InvokeFunctionUrl'],
      resourceArns: [this.handler.functionArn],
      conditions: {
        StringEquals: {
          'lambda:FunctionUrlAuthType': 'AWS_IAM',
        },
      },
    });
  }
}

```

</details>
</Fragment>
<Fragment slot="terraform">
Para esto con Terraform, puedes reemplazar la infraestructura generada de API Gateway por una Lambda Function URL que soporte streaming.

<details>
<summary>Ejemplo de configuración de Lambda Function URL para streaming</summary>

```hcl
# Data sources para contexto AWS actual
data "aws_caller_identity" "current" {}
data "aws_region" "current" {}

# Función Lambda para FastAPI con streaming
resource "aws_lambda_function" "my_api_handler" {
  filename         = "../../../../../../dist/packages/my_api/bundle.zip"
  function_name    = "my-api-handler"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "run.sh"
  runtime         = "python3.12"
  timeout         = 30
  source_code_hash = filebase64sha256("../../../../../../dist/packages/my_api/bundle.zip")

  # Habilitar X-Ray
  tracing_config {
    mode = "Active"
  }

  # Variables de entorno para Lambda Web Adapter
  environment {
    variables = {
      AWS_CONNECTION_REUSE_ENABLED = "1"
      PORT                        = "8000"
      AWS_LWA_INVOKE_MODE        = "response_stream"
      AWS_LAMBDA_EXEC_WRAPPER    = "/opt/bootstrap"
    }
  }

  # Capa de Lambda Web Adapter
  layers = [
    "arn:aws:lambda:${data.aws_region.current.name}:753240598075:layer:LambdaAdapterLayerX86:24"
  ]

  depends_on = [
    aws_iam_role_policy_attachment.lambda_logs,
    aws_cloudwatch_log_group.lambda_logs,
  ]
}

# Grupo de logs de CloudWatch
resource "aws_cloudwatch_log_group" "lambda_logs" {
  name              = "/aws/lambda/my-api-handler"
  retention_in_days = 14
}

# Rol IAM para ejecución de Lambda
resource "aws_iam_role" "lambda_execution_role" {
  name = "my-api-lambda-execution-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

# Adjuntar política básica de ejecución
resource "aws_iam_role_policy_attachment" "lambda_logs" {
  role       = aws_iam_role.lambda_execution_role.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
}

# Adjuntar política de X-Ray
resource "aws_iam_role_policy_attachment" "lambda_xray" {
  role       = aws_iam_role.lambda_execution_role.name
  policy_arn = "arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess"
}

# Lambda Function URL con soporte para streaming
resource "aws_lambda_function_url" "my_api_url" {
  function_name      = aws_lambda_function.my_api_handler.function_name
  authorization_type = "AWS_IAM"
  invoke_mode       = "RESPONSE_STREAM"

  cors {
    allow_credentials = false
    allow_origins     = ["*"]
    allow_methods     = ["*"]
    allow_headers = [
      "authorization",
      "content-type",
      "x-amz-content-sha256",
      "x-amz-date",
      "x-amz-security-token"
    ]
    expose_headers = ["date", "keep-alive"]
    max_age       = 86400
  }
}

# Output de la URL
output "my_api_url" {
  description = "URL para la función Lambda de FastAPI con streaming"
  value       = aws_lambda_function_url.my_api_url.function_url
}

# Opcional: Crear parámetro SSM para configuración
resource "aws_ssm_parameter" "my_api_url" {
  name  = "/runtime-config/apis/MyApi"
  type  = "String"
  value = aws_lambda_function_url.my_api_url.function_url

  tags = {
    Environment = "production"
    Service     = "my-api"
  }
}

# Política IAM para conceder acceso de invocación
resource "aws_iam_policy" "my_api_invoke_policy" {
  name        = "my-api-invoke-policy"
  description = "Política para permitir invocar la función Lambda con streaming"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = "lambda:InvokeFunctionUrl"
        Resource = aws_lambda_function.my_api_handler.arn
        Condition = {
          StringEquals = {
            "lambda:FunctionUrlAuthType" = "AWS_IAM"
          }
        }
      }
    ]
  })
}

# Ejemplo: Adjuntar política a un rol (descomentar y modificar)
# resource "aws_iam_role_policy_attachment" "my_api_invoke_access" {
#   role       = var.authenticated_role_name
#   policy_arn = aws_iam_policy.my_api_invoke_policy.arn
# }
```

</details>

</Fragment>
</Infrastructure>

#### Implementación

Una vez actualizada la infraestructura para soportar streaming, puedes implementar una API de streaming en FastAPI. La API debe:

- Devolver un [`StreamingResponse`](https://fastapi.tiangolo.com/reference/responses/?h=streaming#fastapi.responses.StreamingResponse)
- Declarar el tipo de cada fragmento de respuesta
- Añadir la extensión OpenAPI `x-streaming: true` si planeas usar <Link path="guides/api-connection/react-fastapi">API Connection</Link>.

Por ejemplo, para transmitir una serie de objetos JSON:

```py /return (StreamingResponse)/ /openapi_extra[^)]*/ /-> (Chunk)/
from pydantic import BaseModel
from fastapi.responses import StreamingResponse

class Chunk(BaseModel):
  message: str
  timestamp: datetime

async def stream_chunks():
  for i in range(0, 100):
    yield Chunk(message=f"This is chunk {i}", timestamp=datetime.now())

@app.get("/stream", openapi_extra={'x-streaming': True})
def my_stream() -> Chunk:
    return StreamingResponse(stream_chunks(), media_type="application/json")
```

#### Consumo

Para consumir un stream de respuestas, puedes usar el <Link path="guides/api-connection/react-fastapi#consuming-a-stream">generador API Connection</Link> que provee un método tipado para iterar sobre los fragmentos.

## Desplegando tu API FastAPI

El generador crea código de infraestructura CDK o Terraform según tu `iacProvider`. Puedes usarlo para desplegar tu API.

<Infrastructure>
<Fragment slot="cdk">
El constructo CDK para desplegar tu API está en `common/constructs`. Puedes usarlo en una aplicación CDK:

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    // Añadir la API al stack
    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
    });
  }
}
```

Esto configura:

1. Una función AWS Lambda por cada operación
2. API Gateway HTTP/REST API como trigger
3. Roles y permisos IAM
4. Grupo de logs de CloudWatch
5. Configuración de trazado X-Ray
6. Namespace de métricas CloudWatch

:::note
Si seleccionaste autenticación `Cognito`, debes proveer la propiedad `identity`:

```ts {9}
import { MyApi, UserIdentity } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const identity = new UserIdentity(this, 'Identity');

    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
      identity,
    });
  }
}
```

El constructo `UserIdentity` puede generarse con el <Link path="/guides/react-website-auth">generador `ts#react-website-auth`</Link>
:::
</Fragment>
<Fragment slot="terraform">
Los módulos Terraform para desplegar tu API están en `common/terraform`. Puedes usarlos en una configuración Terraform:

```hcl {2}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Variables de entorno para Lambda
  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  # Políticas IAM adicionales
  additional_iam_policy_statements = [
    # Permisos adicionales necesarios
  ]

  tags = local.common_tags
}
```

Esto configura:

1. Función Lambda que sirve todas las rutas
2. API Gateway HTTP/REST API como trigger
3. Roles y permisos IAM
4. Grupo de logs CloudWatch
5. Configuración de trazado X-Ray
6. Configuración CORS

:::note
Si seleccionaste autenticación `Cognito`, debes proveer su configuración:

```hcl {4-5}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  user_pool_id         = local.user_pool_id
  user_pool_client_ids = [local.client_id]

  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  tags = local.common_tags
}
```

Puedes configurar Cognito User Pool y Client usando recursos Terraform.
:::

El módulo Terraform provee varios outputs:

```hcl
# Acceder al endpoint
output "api_url" {
  value = module.my_api.stage_invoke_url
}

# Detalles de la función Lambda
output "lambda_function_name" {
  value = module.my_api.lambda_function_name
}

# Rol IAM para permisos adicionales
output "lambda_execution_role_arn" {
  value = module.my_api.lambda_execution_role_arn
}
```

Puedes personalizar CORS:

```hcl
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Configuración CORS personalizada
  cors_allow_origins = ["https://myapp.com", "https://staging.myapp.com"]
  cors_allow_methods = ["GET", "POST", "PUT", "DELETE"]
  cors_allow_headers = [
    "authorization",
    "content-type",
    "x-custom-header"
  ]

  tags = local.common_tags
}
```

:::caution
Si seleccionaste `None` para `auth`, puedes ver fallos en checks de Checkov:

<Tabs syncKey="http-rest">
<TabItem label="HTTP API">
```
Check: CKV_AWS_309: "Ensure API GatewayV2 routes specify an authorization type"
 FAILED for resource: aws_apigatewayv2_route.proxy_routes["PUT"]
```
</TabItem>
<TabItem label="REST API">
```
Check: CKV_AWS_59: "Ensure there is no open access to back-end resources through API"
 FAILED for resource: aws_api_gateway_method.proxy_method
```
</TabItem>
</Tabs>

Puedes [añadir un comentario de supresión](https://www.checkov.io/2.Basics/Suppressing%20and%20Skipping%20Policies.html) si deseas que tu API sea pública.
:::
</Fragment>
</Infrastructure>

### Integraciones

<Snippet name="api/type-safe-api-integrations" parentHeading="Integraciones" />

#### Generación de código

<Infrastructure>
<Fragment slot="cdk">
Dado que las operaciones en FastAPI se definen en Python y la infraestructura CDK en TypeScript, instrumentamos generación de código para proveer metadatos al constructo CDK.

Se añade un target `generate:<ApiName>-metadata` al `project.json` de los constructos para generar código que emite archivos como `packages/common/constructs/src/generated/my-api/metadata.gen.ts`. Este archivo se ignora en control de versiones.

:::note
Debes ejecutar un build tras cambiar tu API para actualizar los tipos:

<NxCommands commands={["run-many --target build --all"]} />
:::

:::tip
Si trabajas simultáneamente en CDK y FastAPI, puedes usar [`nx watch`](https://nx.dev/nx-api/nx/documents/watch) para regenerar tipos automáticamente:

<NxCommands
  commands={[
    'watch --projects=<FastAPIProject> -- \\ ',
    'run <InfraProject>:"generate:<ApiName>-metadata"',
  ]}
/>
:::
</Fragment>
<Fragment slot="terraform">
:::note
No soportamos integraciones tipadas para Terraform, por lo que no se configuran targets de generación de código si seleccionaste Terraform como `iacProvider`.
:::
</Fragment>
</Infrastructure>

### Concediendo acceso (solo IAM)

Si seleccionaste autenticación `IAM`, puedes usar el método `grantInvokeAccess`:

<Infrastructure>
<Fragment slot="cdk">
```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```
</Fragment>
<Fragment slot="terraform">
```hcl
# Crear política IAM para invocar la API
resource "aws_iam_policy" "api_invoke_policy" {
  name        = "MyApiInvokePolicy"
  description = "Política para invocar la API FastAPI"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = "execute-api:Invoke"
        Resource = "${module.my_api.api_execution_arn}/*/*"
      }
    ]
  })
}

# Adjuntar política a un rol IAM
resource "aws_iam_role_policy_attachment" "api_invoke_access" {
  role       = aws_iam_role.authenticated_user_role.name
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}

# O adjuntar a un rol existente
resource "aws_iam_role_policy_attachment" "api_invoke_access_existing" {
  role       = "MyExistingRole"
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}
```

Outputs clave del módulo API:

- `module.my_api.api_execution_arn` - Para permisos execute-api:Invoke
- `module.my_api.api_arn` - ARN de API Gateway
- `module.my_api.lambda_function_arn` - ARN de la función Lambda
</Fragment>
</Infrastructure>

## Desarrollo local

El generador configura un servidor de desarrollo local que puedes ejecutar con:

<NxCommands commands={['run my-api:serve']} />

Esto inicia un servidor de desarrollo FastAPI con:

- Recarga automática
- Documentación interactiva en `/docs` o `/redoc`
- Esquema OpenAPI en `/openapi.json`

## Invocando tu API FastAPI

Para invocar tu API desde un sitio React, puedes usar el <Link path="guides/api-connection/react-fastapi">generador `api-connection`</Link>.