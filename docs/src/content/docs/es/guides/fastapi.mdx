---
title: "FastAPI"
description: "Documentación de referencia para FastAPI"
---

import { FileTree, AnchorHeading, Tabs, TabItem } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Infrastructure from '@components/infrastructure.astro';
import Snippet from '@components/snippet.astro';

[FastAPI](https://fastapi.tiangolo.com/) es un framework para construir APIs en Python.

El generador de FastAPI crea una nueva API FastAPI con configuración de infraestructura usando AWS CDK o Terraform. El backend generado utiliza AWS Lambda para despliegue serverless, expuesto a través de una API de AWS API Gateway. Configura [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/python/latest/) para observabilidad, incluyendo registro, trazado con AWS X-Ray y métricas de CloudWatch.

## Uso

### Generar una API FastAPI

Puedes generar una nueva API FastAPI de dos maneras:

<RunGenerator generator="py#fast-api" />

### Opciones

<GeneratorParameters generator="py#fast-api" />

<Snippet name="api/api-choice-note" />

## Salida del generador

El generador creará la siguiente estructura de proyecto en el directorio `<directory>/<api-name>`:

<FileTree>

- project.json Configuración del proyecto y objetivos de build
- pyproject.toml Configuración del proyecto Python y dependencias
- \<module_name>
  - \_\_init\_\_.py Inicialización del módulo
  - init.py Configura la aplicación FastAPI y el middleware de powertools
  - main.py Implementación de la API
- scripts
  - generate_open_api.py Script para generar un esquema OpenAPI desde la app FastAPI

</FileTree>

### Infraestructura

<Snippet name="shared-constructs" />

<Snippet name="api/shared-constructs" />

## Implementando tu API FastAPI

La implementación principal de la API está en `main.py`. Aquí es donde defines las rutas de tu API y sus implementaciones. Aquí un ejemplo:

```python
from .init import app, tracer
from pydantic import BaseModel

class Item(BaseModel):
  name: str

@app.get("/items/{item_id}")
def get_item(item_id: int) -> Item:
    return Item(name=...)

@app.post("/items")
def create_item(item: Item):
    return ...
```

El generador configura automáticamente varias características:

1. Integración de AWS Lambda Powertools para observabilidad
2. Middleware de manejo de errores
3. Correlación de solicitudes/respuestas
4. Recolección de métricas
5. Manejador de AWS Lambda usando Mangum

### Observabilidad con AWS Lambda Powertools

#### Registro

El generador configura registro estructurado usando AWS Lambda Powertools. Puedes acceder al logger en tus manejadores de rutas:

```python
from .init import app, logger

@app.get("/items/{item_id}")
def read_item(item_id: int):
    logger.info("Fetching item", extra={"item_id": item_id})
    return {"item_id": item_id}
```

El logger incluye automáticamente:

- IDs de correlación para trazado de solicitudes
- Ruta y método de la solicitud
- Información del contexto de Lambda
- Indicadores de inicio en frío

#### Seguimiento

El trazado con AWS X-Ray se configura automáticamente. Puedes añadir subsegmentos personalizados a tus trazas:

```python
from .init import app, tracer

@app.get("/items/{item_id}")
@tracer.capture_method
def read_item(item_id: int):
    # Crea un nuevo subsegmento
    with tracer.provider.in_subsegment("fetch-item-details"):
        # Tu lógica aquí
        return {"item_id": item_id}
```

#### Métricas

Las métricas de CloudWatch se recopilan automáticamente para cada solicitud. Puedes añadir métricas personalizadas:

```python
from .init import app, metrics
from aws_lambda_powertools.metrics import MetricUnit

@app.get("/items/{item_id}")
def read_item(item_id: int):
    metrics.add_metric(name="ItemViewed", unit=MetricUnit.Count, value=1)
    return {"item_id": item_id}
```

Las métricas por defecto incluyen:

- Conteo de solicitudes
- Conteos de éxito/fallo
- Métricas de inicio en frío
- Métricas por ruta

### Manejo de errores

El generador incluye manejo de errores completo:

```python
from fastapi import HTTPException

@app.get("/items/{item_id}")
def read_item(item_id: int):
    if item_id < 0:
        raise HTTPException(status_code=400, detail="Item ID must be positive")
    return {"item_id": item_id}
```

Las excepciones no manejadas son capturadas por el middleware y:

1. Registran la excepción completa con stack trace
2. Registran una métrica de fallo
3. Devuelven una respuesta segura 500 al cliente
4. Preservan el ID de correlación

:::tip
Se recomienda especificar modelos de respuesta para tus operaciones API si planeas usar el generador `api-connection`. <Link path="guides/api-connection/react-fastapi#errors">Consulta aquí para más detalles</Link>.
:::

### Streaming

Con FastAPI, puedes transmitir una respuesta al cliente usando el tipo de respuesta [`StreamingResponse`](https://fastapi.tiangolo.com/reference/responses/?h=streaming#fastapi.responses.StreamingResponse).

#### Cambios en la infraestructura

Dado que AWS API Gateway no soporta respuestas en streaming, necesitarás desplegar tu FastAPI en una plataforma que lo soporte. La opción más simple es usar una URL de función de AWS Lambda.

<Infrastructure>
<Fragment slot="cdk">
Para esto, puedes reemplazar el constructo generado `common/constructs/src/app/apis/<name>-api.ts` por uno que despliegue una Function URL.

<details>
<summary>Ejemplo de constructo FunctionURL para streaming</summary>

```ts
import { Duration, Stack, CfnOutput } from 'aws-cdk-lib';
import { IGrantable, Grant } from 'aws-cdk-lib/aws-iam';
import {
  Runtime,
  Code,
  Tracing,
  LayerVersion,
  FunctionUrlAuthType,
  InvokeMode,
  Function,
} from 'aws-cdk-lib/aws-lambda';
import { Construct } from 'constructs';
import url from 'url';
import { RuntimeConfig } from '../../core/runtime-config.js';

export class MyApi extends Construct {
  public readonly handler: Function;

  constructor(scope: Construct, id: string) {
    super(scope, id);

    this.handler = new Function(this, 'Handler', {
      runtime: Runtime.PYTHON_3_12,
      handler: 'run.sh',
      code: Code.fromAsset(
        url.fileURLToPath(
          new URL(
            '../../../../../../dist/packages/my_api/bundle-x86',
            import.meta.url,
          ),
        ),
      ),
      timeout: Duration.seconds(30),
      tracing: Tracing.ACTIVE,
      environment: {
        AWS_CONNECTION_REUSE_ENABLED: '1',
      },
    });

    const stack = Stack.of(this);
    this.handler.addLayers(
      LayerVersion.fromLayerVersionArn(
        this,
        'LWALayer',
        `arn:aws:lambda:${stack.region}:753240598075:layer:LambdaAdapterLayerX86:24`,
      ),
    );
    this.handler.addEnvironment('PORT', '8000');
    this.handler.addEnvironment('AWS_LWA_INVOKE_MODE', 'response_stream');
    this.handler.addEnvironment('AWS_LAMBDA_EXEC_WRAPPER', '/opt/bootstrap');
    const functionUrl = this.handler.addFunctionUrl({
      authType: FunctionUrlAuthType.AWS_IAM,
      invokeMode: InvokeMode.RESPONSE_STREAM,
      cors: {
        allowedOrigins: ['*'],
        allowedHeaders: [
          'authorization',
          'content-type',
          'x-amz-content-sha256',
          'x-amz-date',
          'x-amz-security-token',
        ],
      },
    });

    new CfnOutput(this, 'MyApiUrl', { value: functionUrl.url });

    // Registrar la URL de la API en la configuración de runtime para descubrimiento del cliente
    RuntimeConfig.ensure(this).config.apis = {
      ...RuntimeConfig.ensure(this).config.apis!,
      MyApi: functionUrl.url,
    };
  }

  public grantInvokeAccess(grantee: IGrantable) {
    Grant.addToPrincipal({
      grantee,
      actions: ['lambda:InvokeFunctionUrl'],
      resourceArns: [this.handler.functionArn],
      conditions: {
        StringEquals: {
          'lambda:FunctionUrlAuthType': 'AWS_IAM',
        },
      },
    });
  }
}

```

</details>
</Fragment>
<Fragment slot="terraform">
Para esto con Terraform, puedes reemplazar la infraestructura generada de API Gateway por una Lambda Function URL que soporte streaming.

<details>
<summary>Ejemplo de configuración de Lambda Function URL para streaming</summary>

```hcl
# Data sources para contexto AWS actual
data "aws_caller_identity" "current" {}
data "aws_region" "current" {}

# Función Lambda para FastAPI con streaming
resource "aws_lambda_function" "my_api_handler" {
  filename         = "../../../../../../dist/packages/my_api/bundle.zip"
  function_name    = "my-api-handler"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "run.sh"
  runtime         = "python3.12"
  timeout         = 30
  source_code_hash = filebase64sha256("../../../../../../dist/packages/my_api/bundle.zip")

  # Habilitar trazado X-Ray
  tracing_config {
    mode = "Active"
  }

  # Variables de entorno para Lambda Web Adapter
  environment {
    variables = {
      AWS_CONNECTION_REUSE_ENABLED = "1"
      PORT                        = "8000"
      AWS_LWA_INVOKE_MODE        = "response_stream"
      AWS_LAMBDA_EXEC_WRAPPER    = "/opt/bootstrap"
    }
  }

  # Añadir capa de Lambda Web Adapter
  layers = [
    "arn:aws:lambda:${data.aws_region.current.name}:753240598075:layer:LambdaAdapterLayerX86:24"
  ]

  depends_on = [
    aws_iam_role_policy_attachment.lambda_logs,
    aws_cloudwatch_log_group.lambda_logs,
  ]
}

# Grupo de logs de CloudWatch para la función Lambda
resource "aws_cloudwatch_log_group" "lambda_logs" {
  name              = "/aws/lambda/my-api-handler"
  retention_in_days = 14
}

# Rol IAM para ejecución de Lambda
resource "aws_iam_role" "lambda_execution_role" {
  name = "my-api-lambda-execution-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

# Adjuntar política básica de ejecución
resource "aws_iam_role_policy_attachment" "lambda_logs" {
  role       = aws_iam_role.lambda_execution_role.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
}

# Adjuntar política de trazado X-Ray
resource "aws_iam_role_policy_attachment" "lambda_xray" {
  role       = aws_iam_role.lambda_execution_role.name
  policy_arn = "arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess"
}

# Lambda Function URL con soporte para streaming
resource "aws_lambda_function_url" "my_api_url" {
  function_name      = aws_lambda_function.my_api_handler.function_name
  authorization_type = "AWS_IAM"
  invoke_mode       = "RESPONSE_STREAM"

  cors {
    allow_credentials = false
    allow_origins     = ["*"]
    allow_methods     = ["*"]
    allow_headers = [
      "authorization",
      "content-type",
      "x-amz-content-sha256",
      "x-amz-date",
      "x-amz-security-token"
    ]
    expose_headers = ["date", "keep-alive"]
    max_age       = 86400
  }
}

# Output de la URL de la función
output "my_api_url" {
  description = "URL para la función Lambda de FastAPI con streaming"
  value       = aws_lambda_function_url.my_api_url.function_url
}

# Opcional: Crear parámetro SSM para configuración de runtime
resource "aws_ssm_parameter" "my_api_url" {
  name  = "/runtime-config/apis/MyApi"
  type  = "String"
  value = aws_lambda_function_url.my_api_url.function_url

  tags = {
    Environment = "production"
    Service     = "my-api"
  }
}

# Política IAM para conceder acceso de invocación a la Function URL
resource "aws_iam_policy" "my_api_invoke_policy" {
  name        = "my-api-invoke-policy"
  description = "Política para permitir invocar la Lambda Function URL de FastAPI con streaming"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = "lambda:InvokeFunctionUrl"
        Resource = aws_lambda_function.my_api_handler.arn
        Condition = {
          StringEquals = {
            "lambda:FunctionUrlAuthType" = "AWS_IAM"
          }
        }
      }
    ]
  })
}

# Ejemplo: Adjuntar la política de invocación a un rol (descomentar y modificar según sea necesario)
# resource "aws_iam_role_policy_attachment" "my_api_invoke_access" {
#   role       = var.authenticated_role_name
#   policy_arn = aws_iam_policy.my_api_invoke_policy.arn
# }
```

</details>

</Fragment>
</Infrastructure>

#### Implementación

Una vez actualizada la infraestructura para soportar streaming, puedes implementar una API de streaming en FastAPI. La API debe:

- Devolver un [`StreamingResponse`](https://fastapi.tiangolo.com/reference/responses/?h=streaming#fastapi.responses.StreamingResponse)
- Declarar el tipo de retorno de cada fragmento de respuesta
- Añadir la extensión de proveedor OpenAPI `x-streaming: true` si planeas usar <Link path="guides/api-connection/react-fastapi">API Connection</Link>.

Por ejemplo, si deseas transmitir una serie de objetos JSON desde tu API, puedes implementarlo de la siguiente manera:

```py /return (StreamingResponse)/ /openapi_extra[^)]*/ /-> (Chunk)/
from pydantic import BaseModel
from fastapi.responses import StreamingResponse

class Chunk(BaseModel):
  message: str
  timestamp: datetime

async def stream_chunks():
  for i in range(0, 100):
    yield Chunk(message=f"This is chunk {i}", timestamp=datetime.now())

@app.get("/stream", openapi_extra={'x-streaming': True})
def my_stream() -> Chunk:
    return StreamingResponse(stream_chunks(), media_type="application/json")
```

#### Consumo

Para consumir un stream de respuestas, puedes usar el <Link path="guides/api-connection/react-fastapi#consuming-a-stream">generador API Connection</Link> que provee un método tipado para iterar sobre los fragmentos transmitidos.

## Desplegando tu API FastAPI

El generador de FastAPI crea código de infraestructura CDK o Terraform según tu `iacProvider` seleccionado. Puedes usarlo para desplegar tu API FastAPI.

<Infrastructure>
<Fragment slot="cdk">
El constructo CDK para desplegar tu API está en la carpeta `common/constructs`. Puedes usarlo en una aplicación CDK:

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    // Añadir la API al stack
    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
    });
  }
}
```

Esto configura:

1. Una función AWS Lambda por cada operación en la aplicación FastAPI
2. API Gateway HTTP/REST API como trigger de la función
3. Roles y permisos IAM
4. Grupo de logs de CloudWatch
5. Configuración de trazado X-Ray
6. Namespace de métricas CloudWatch

<Snippet name="api/cors-configuration-cdk-note" />

:::note
Si seleccionaste autenticación `Cognito`, debes proveer la propiedad `identity` al constructo de la API:

```ts {9}
import { MyApi, UserIdentity } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const identity = new UserIdentity(this, 'Identity');

    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
      identity,
    });
  }
}
```

El constructo `UserIdentity` puede generarse con el <Link path="/guides/react-website-auth">generador `ts#react-website-auth`</Link>
:::
</Fragment>
<Fragment slot="terraform">
Los módulos Terraform para desplegar tu API están en la carpeta `common/terraform`. Puedes usarlos en una configuración Terraform:

```hcl {2}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Variables de entorno para la función Lambda
  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  # Políticas IAM adicionales si es necesario
  additional_iam_policy_statements = [
    # Añade los permisos adicionales que tu API necesite
  ]

  tags = local.common_tags
}
```

Esto configura:

1. Una función Lambda que sirve todas las rutas de FastAPI
2. API Gateway HTTP/REST API como trigger de la función
3. Roles y permisos IAM
4. Grupo de logs CloudWatch
5. Configuración de trazado X-Ray
6. Configuración CORS

<Snippet name="api/cors-configuration-terraform-note" />

:::note
Si seleccionaste autenticación `Cognito`, debes proveer su configuración:

```hcl {4-5}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  user_pool_id         = local.user_pool_id
  user_pool_client_ids = [local.client_id]

  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  tags = local.common_tags
}
```

Puedes configurar Cognito User Pool y Client usando los recursos o módulos Terraform apropiados.
:::

El módulo Terraform provee varios outputs que puedes usar:

```hcl
# Acceder al endpoint de la API
output "api_url" {
  value = module.my_api.stage_invoke_url
}

# Acceder a los detalles de la función Lambda
output "lambda_function_name" {
  value = module.my_api.lambda_function_name
}

# Acceder al rol IAM para conceder permisos adicionales
output "lambda_execution_role_arn" {
  value = module.my_api.lambda_execution_role_arn
}
```

Puedes personalizar la configuración CORS pasando variables al módulo:

```hcl
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  # Configuración CORS personalizada
  cors_allow_origins = ["https://myapp.com", "https://staging.myapp.com"]
  cors_allow_methods = ["GET", "POST", "PUT", "DELETE"]
  cors_allow_headers = [
    "authorization",
    "content-type",
    "x-custom-header"
  ]

  tags = local.common_tags
}
```

:::caution
Si seleccionaste `None` para `auth` al ejecutar el generador, puedes ver fallos en checks de Checkov como:

<Tabs syncKey="http-rest">
<TabItem label="HTTP API">
```
Check: CKV_AWS_309: "Ensure API GatewayV2 routes specify an authorization type"
 FAILED for resource: aws_apigatewayv2_route.proxy_routes["PUT"]
```
</TabItem>
<TabItem label="REST API">
```
Check: CKV_AWS_59: "Ensure there is no open access to back-end resources through API"
 FAILED for resource: aws_api_gateway_method.proxy_method
```
</TabItem>
</Tabs>

Puedes [añadir un comentario de supresión](https://www.checkov.io/2.Basics/Suppressing%20and%20Skipping%20Policies.html) si estás seguro de que deseas que tu API sea pública.
:::
</Fragment>
</Infrastructure>

### Integraciones

<Snippet name="api/type-safe-api-integrations" parentHeading="Integraciones" />

#### Generación de código

<Infrastructure>
<Fragment slot="cdk">
Dado que las operaciones en FastAPI se definen en Python y la infraestructura CDK en TypeScript, instrumentamos generación de código para proveer metadatos al constructo CDK y proporcionar una interfaz tipada para las integraciones.

Se añade un target `generate:<ApiName>-metadata` al `project.json` de los constructos comunes para facilitar esta generación de código, que emite un archivo como `packages/common/constructs/src/generated/my-api/metadata.gen.ts`. Dado que esto se genera en tiempo de build, se ignora en control de versiones.

:::note
Debes ejecutar un build cada vez que cambies tu API para asegurar que los tipos consumidos por el constructo CDK estén actualizados.

<NxCommands commands={["run-many --target build --all"]} />
:::

:::tip
Si trabajas activamente en tu infraestructura CDK y FastAPI simultáneamente, puedes usar [`nx watch`](https://nx.dev/nx-api/nx/documents/watch) para regenerar estos tipos cada vez que hagas cambios en la API:

<NxCommands
  commands={[
    'watch --projects=<FastAPIProject> -- \\ ',
    'run <InfraProject>:"generate:<ApiName>-metadata"',
  ]}
/>
:::
</Fragment>
<Fragment slot="terraform">
:::note
No soportamos integraciones tipadas para Terraform, por lo que no se configuran targets de generación de código si seleccionaste Terraform como `iacProvider`.
:::
</Fragment>
</Infrastructure>

### Concediendo acceso (solo IAM)

Si seleccionaste autenticación `IAM`, puedes usar el método `grantInvokeAccess` para conceder acceso a tu API:

<Infrastructure>
<Fragment slot="cdk">
```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```
</Fragment>
<Fragment slot="terraform">
```hcl
# Crear una política IAM para permitir invocar la API
resource "aws_iam_policy" "api_invoke_policy" {
  name        = "MyApiInvokePolicy"
  description = "Política para permitir invocar la FastAPI"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = "execute-api:Invoke"
        Resource = "${module.my_api.api_execution_arn}/*/*"
      }
    ]
  })
}

# Adjuntar la política a un rol IAM (por ejemplo, para usuarios autenticados)
resource "aws_iam_role_policy_attachment" "api_invoke_access" {
  role       = aws_iam_role.authenticated_user_role.name
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}

# O adjuntar a un rol existente por nombre
resource "aws_iam_role_policy_attachment" "api_invoke_access_existing" {
  role       = "MyExistingRole"
  policy_arn = aws_iam_policy.api_invoke_policy.arn
}
```

Los outputs clave del módulo API que puedes usar para políticas IAM son:

- `module.my_api.api_execution_arn` - Para conceder permisos execute-api:Invoke
- `module.my_api.api_arn` - El ARN de API Gateway
- `module.my_api.lambda_function_arn` - El ARN de la función Lambda
</Fragment>
</Infrastructure>

## Desarrollo local

El generador configura un servidor de desarrollo local que puedes ejecutar con:

<NxCommands commands={['run my-api:serve']} />

Esto inicia un servidor de desarrollo FastAPI local con:

- Recarga automática al cambiar el código
- Documentación interactiva de la API en `/docs` o `/redoc`
- Esquema OpenAPI en `/openapi.json`

## Invocando tu API FastAPI

Para invocar tu API desde un sitio React, puedes usar el generador <Link path="guides/api-connection/react-fastapi">`api-connection`</Link>.