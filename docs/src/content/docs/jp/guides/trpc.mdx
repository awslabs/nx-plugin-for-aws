---
title: "tRPC"
description: "tRPCのリファレンスドキュメント"
---



import { FileTree, Tabs, TabItem } from '@astrojs/starlight/components';
import AnchorHeading from '@astrojs/starlight/components/AnchorHeading.astro';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Infrastructure from '@components/infrastructure.astro';
import Snippet from '@components/snippet.astro';

[tRPC](https://trpc.io/) は、エンドツーエンドの型安全性を備えた TypeScript での API 構築フレームワークです。tRPC を使用すると、API 操作の入力と出力の更新が即座にクライアントコードに反映され、プロジェクトの再ビルドなしに IDE 上で可視化されます。

tRPC API ジェネレータは、AWS CDK または Terraform のインフラストラクチャ設定を備えた新しい tRPC API を作成します。生成されるバックエンドはサーバーレスデプロイに AWS Lambda を使用し、AWS API Gateway API を介して公開され、[Zod](https://zod.dev/) を使用したスキーマ検証が含まれます。また、ロギング、AWS X-Ray トレーシング、Cloudwatch メトリクスを含むオブザーバビリティのために [AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/) が設定されます。

## 使用方法

### tRPC API の生成

新しい tRPC API は2つの方法で生成できます:

<RunGenerator generator="ts#trpc-api" />

### オプション

<GeneratorParameters generator="ts#trpc-api" />

<Snippet name="api/api-choice-note" />

## ジェネレータの出力

ジェネレータは `<directory>/<api-name>` ディレクトリに以下のプロジェクト構造を作成します:

<FileTree>
  - src
    - init.ts バックエンド tRPC の初期化
    - router.ts tRPC ルーター定義（Lambda ハンドラーの API エントリーポイント）
    - schema Zod を使用したスキーマ定義
      - echo.ts 「echo」プロシージャの入力と出力の例
    - procedures API が公開するプロシージャ（操作）
      - echo.ts サンプルプロシージャ
    - middleware
      - error.ts エラーハンドリング用ミドルウェア
      - logger.ts AWS Powertools のロギング設定用ミドルウェア
      - tracer.ts AWS Powertools のトレーシング設定用ミドルウェア
      - metrics.ts AWS Powertools のメトリクス設定用ミドルウェア
    - local-server.ts ローカル開発サーバー用 tRPC スタンドアロンアダプターエントリーポイント
    - client
      - index.ts マシン間 API 呼び出し用型安全クライアント
  - tsconfig.json TypeScript 設定
  - project.json プロジェクト設定とビルドターゲット
</FileTree>

### インフラストラクチャ

<Snippet name="shared-constructs" />

<Snippet name="api/shared-constructs" />

## tRPC API の実装

大まかに言うと、tRPC API はリクエストを特定のプロシージャに委譲するルーターで構成されます。各プロシージャには Zod スキーマで定義された入力と出力があります。

### スキーマ

`src/schema` ディレクトリには、クライアントとサーバーコード間で共有される型が含まれます。これらは TypeScript ファーストのスキーマ宣言および検証ライブラリである [Zod](https://zod.dev/) を使用して定義されます。

スキーマの例:

```ts
import { z } from 'zod';

// スキーマ定義
export const UserSchema = z.object({
  name: z.string(),
  height: z.number(),
  dateOfBirth: z.string().datetime(),
});

// 対応する TypeScript 型
export type User = z.TypeOf<typeof UserSchema>;
```

上記スキーマの場合、`User` 型は以下の TypeScript と同等です:

```ts
interface User {
  name: string;
  height: number;
  dateOfBirth: string;
}
```

スキーマはサーバーとクライアントコードの両方で共有され、API で使用される構造を変更する際の単一の更新ポイントを提供します。

スキーマは実行時に tRPC API によって自動検証され、バックエンドでカスタム検証ロジックを手動で作成する手間を省きます。

Zod はスキーマを結合または派生させるための `.merge`、`.pick`、`.omit` などの強力なユーティリティを提供します。詳細は [Zod 公式ドキュメント](https://zod.dev/?id=basic-usage) を参照してください。

### ルーターとプロシージャ

API のエントリーポイントは `src/router.ts` にあります。このファイルには、呼び出される操作に基づいてリクエストを「プロシージャ」にルーティングする Lambda ハンドラーが含まれます。各プロシージャは期待される入力、出力、実装を定義します。

生成されるサンプルルーターには `echo` という単一の操作が含まれます:

```ts
import { echo } from './procedures/echo.js';

export const appRouter = router({
  echo,
});
```

サンプルの `echo` プロシージャは `src/procedures/echo.ts` に生成されます:

```ts
export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

上記の分解:

- `publicProcedure` は `src/middleware` に設定されたミドルウェアを含む API の公開メソッドを定義
- `input` は操作の期待される入力を定義する Zod スキーマを受け入れる
- `output` は操作の期待される出力を定義する Zod スキーマを受け入れる
- `query` は API の実装を定義する関数を受け入れる。`opts` には操作に渡された入力と、`opts.ctx` でミドルウェアが設定したコンテキストが含まれる

`query` の使用は操作が非変異的であることを示します。データ取得メソッドの定義に使用します。変異操作には `mutation` メソッドを使用します。

新しいプロシージャを追加する場合は、`src/router.ts` のルーターに登録してください。

## tRPC API のカスタマイズ

### エラー処理

実装では、`TRPCError` をスローしてクライアントにエラーレスポンスを返せます:

```ts
throw new TRPCError({
  code: 'NOT_FOUND',
  message: 'The requested resource could not be found',
});
```

### 操作の整理

API が成長するにつれ、関連する操作をグループ化したい場合があります。

ネストされたルーターを使用して操作をグループ化できます:

```ts
import { getUser } from './procedures/users/get.js';
import { listUsers } from './procedures/users/list.js';

const appRouter = router({
   users: router({
      get: getUser,
      list: listUsers,
   }),
   ...
})
```

クライアントはこの操作グループを受け取り、`listUsers` 操作の呼び出しは以下のようになります:

```ts
client.users.list.query();
```

### ロギング

AWS Lambda Powertools ロガーは `src/middleware/logger.ts` で設定され、`opts.ctx.logger` 経由で実装内でアクセス可能です:

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.logger.info('Operation called with input', opts.input);

      return ...;
   });
```

詳細は [AWS Lambda Powertools Logger ドキュメント](https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/) を参照。

### メトリクス記録

AWS Lambda Powertools メトリクスは `src/middleware/metrics.ts` で設定され、`opts.ctx.metrics` 経由でアクセス可能です:

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.metrics.addMetric('Invocations', 'Count', 1);

      return ...;
   });
```

詳細は [AWS Lambda Powertools Metrics ドキュメント](https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/) を参照。

### X-Ray トレーシングの微調整

AWS Lambda Powertools トレーサーは `src/middleware/tracer.ts` で設定され、`opts.ctx.tracer` 経由でアクセス可能です:

```ts {5-7}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      const subSegment = opts.ctx.tracer.getSegment()!.addNewSubsegment('MyAlgorithm');
      // ... トレース対象のアルゴリズムロジック
      subSegment.close();

      return ...;
   });
```

詳細は [AWS Lambda Powertools Tracer ドキュメント](https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/) を参照。

### カスタムミドルウェアの実装

コンテキストに追加の値を提供するミドルウェアを実装できます。

例: `src/middleware/identity.ts` に API 呼び出し元の詳細を抽出するミドルウェアを実装:

:::warning
この例は `auth` が `IAM` に設定されていることを想定。Cognito 認証の場合、`event` から関連クレームを抽出可能
:::

コンテキストに追加する内容を定義:

```ts
export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}
```

ミドルウェア実装の構造:

```ts
export const createIdentityPlugin = () => {
   const t = initTRPC.context<...>().create();
   return t.procedure.use(async (opts) => {
      // プロシージャ実行前のロジック

      const response = await opts.next(...);

      // プロシージャ実行後のロジック

      return response;
   });
};
```

<Tabs>
<TabItem label="REST">
```ts
// REST API 向け実装（原文のコードを保持）
```
</TabItem>
<TabItem label="HTTP">
```ts
// HTTP API 向け実装（原文のコードを保持）
```
</TabItem>
</Tabs>

## tRPC API のデプロイ

tRPC API ジェネレータは選択した `iacProvider` に基づき CDK または Terraform の IaC を生成します。

<Infrastructure>
<Fragment slot="cdk">
CDK コンストラクトの使用例:

```ts {6-8}
// CDK 実装例（原文のコードを保持）
```

:::note
Cognito 認証を選択した場合の設定例:

```ts {9}
// Cognito 認証設定例（原文のコードを保持）
```
:::
</Fragment>
<Fragment slot="terraform">
Terraform モジュールの使用例:

```hcl {6-8}
// Terraform 実装例（原文のコードを保持）
```

:::note
Cognito 認証を選択した場合の設定例:

```hcl {4-5}
// Cognito 認証設定例（原文のコードを保持）
```
:::
</Fragment>
</Infrastructure>

### インテグレーション

<Snippet name="api/type-safe-api-integrations" parentHeading="インテグレーション" />

:::tip
CDK を選択した場合、tRPC API でプロシージャを追加/削除すると、再ビルドなしで CDK コンストラクトに即時反映されます
:::

### アクセス権付与（IAM 認証時）

IAM 認証を選択した場合のアクセス権付与:

<Infrastructure>
<Fragment slot="cdk">
```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```
</Fragment>
<Fragment slot="terraform">
```hcl
# IAM ポリシー作成例（原文のコードを保持）
```
</Fragment>
</Infrastructure>

### バンドルターゲット

<Snippet name="ts-bundle" />

## ローカル tRPC サーバー

ローカルサーバーの起動:

<NxCommands commands={['run @my-scope/my-api:serve']} />

エントリーポイントは `src/local-server.ts` です。変更は自動的にリロードされます。

## tRPC API の呼び出し

型安全なクライアントを作成可能:

```ts
import { createMyApiClient } from ':my-scope/my-api';

const client = createMyApiClient({ url: 'https://my-api-url.example.com/' });

await client.echo.query({ message: 'Hello world!' });
```

React ウェブサイトからの呼び出しには <Link path="guides/api-connection/react-trpc">API 接続</Link> ジェネレータの使用を検討してください。

## 詳細情報

詳細は [tRPC 公式ドキュメント](https://trpc.io/docs) を参照してください。