---
title: "tRPC"
description: "tRPCのリファレンスドキュメント"
---



import { FileTree, Tabs, TabItem } from '@astrojs/starlight/components';
import AnchorHeading from '@astrojs/starlight/components/AnchorHeading.astro';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Infrastructure from '@components/infrastructure.astro';
import Snippet from '@components/snippet.astro';

[tRPC](https://trpc.io/) はエンドツーエンドの型安全性を備えたTypeScript API構築フレームワークです。tRPCを使用すると、API操作の入力と出力の更新が即座にクライアントコードに反映され、プロジェクトの再ビルドなしにIDE上で変更を確認できます。

tRPC APIジェネレータは、AWS CDKまたはTerraformのインフラストラクチャ設定を含む新しいtRPC APIを作成します。生成されるバックエンドはサーバーレスデプロイ用にAWS Lambdaを使用し、AWS API Gateway APIを介して公開され、[Zod](https://zod.dev/)を使用したスキーマ検証が含まれます。また、ロギング、AWS X-Rayトレーシング、Cloudwatchメトリクスを含むオブザーバビリティのために[AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/)を設定します。

## 使用方法

### tRPC APIの生成

新しいtRPC APIは2つの方法で生成できます：

<RunGenerator generator="ts#trpc-api" />

### オプション

<GeneratorParameters generator="ts#trpc-api" />

<Snippet name="api/api-choice-note" />

## ジェネレータの出力

ジェネレータは`<directory>/<api-name>`ディレクトリに以下のプロジェクト構造を作成します：

<FileTree>
  - src
    - init.ts バックエンドtRPC初期化
    - router.ts tRPCルータ定義（LambdaハンドラAPIエントリーポイント）
    - schema Zodを使用したスキーマ定義
      - echo.ts 「echo」プロシージャの入力・出力例定義
    - procedures APIが公開するプロシージャ（操作）
      - echo.ts サンプルプロシージャ
    - middleware
      - error.ts エラーハンドリング用ミドルウェア
      - logger.ts AWS Powertools for Lambdaロギング設定ミドルウェア
      - tracer.ts AWS Powertools for Lambdaトレーシング設定ミドルウェア
      - metrics.ts AWS Powertools for Lambdaメトリクス設定ミドルウェア
    - local-server.ts ローカル開発サーバー用tRPCスタンドアロンアダプタエントリーポイント
    - client
      - index.ts マシン間API呼び出し用型安全クライアント
  - tsconfig.json TypeScript設定
  - project.json プロジェクト設定とビルドターゲット
</FileTree>

### インフラストラクチャ

<Snippet name="shared-constructs" />

<Snippet name="api/shared-constructs" />

## tRPC APIの実装

大まかに言うと、tRPC APIはリクエストを特定のプロシージャに委譲するルータで構成されます。各プロシージャはZodスキーマで定義された入力と出力を持ちます。

### スキーマ

`src/schema`ディレクトリにはクライアントとサーバーコード間で共有される型が含まれます。これらはTypeScriptファーストのスキーマ宣言・検証ライブラリである[Zod](https://zod.dev/)を使用して定義されます。

サンプルスキーマの例：

```ts
import { z } from 'zod';

// スキーマ定義
export const UserSchema = z.object({
  name: z.string(),
  height: z.number(),
  dateOfBirth: z.string().datetime(),
});

// 対応するTypeScript型
export type User = z.TypeOf<typeof UserSchema>;
```

上記スキーマの場合、`User`型は以下のTypeScriptインターフェースと同等です：

```ts
interface User {
  name: string;
  height: number;
  dateOfBirth: string;
}
```

スキーマはサーバーとクライアントコードの両方で共有され、APIで使用される構造を変更する際の単一の更新ポイントを提供します。

スキーマは実行時にtRPC APIによって自動検証され、バックエンドでカスタム検証ロジックを手動で作成する必要がなくなります。

Zodはスキーマを結合または派生するための`.merge`、`.pick`、`.omit`などの強力なユーティリティを提供します。詳細は[Zod公式ドキュメント](https://zod.dev/?id=basic-usage)を参照してください。

### ルータとプロシージャ

APIのエントリポイントは`src/router.ts`にあります。このファイルには、呼び出される操作に基づいてリクエストを「プロシージャ」にルーティングするLambdaハンドラが含まれます。各プロシージャは期待される入力、出力、実装を定義します。

生成されるサンプルルータには`echo`という単一の操作が含まれます：

```ts
import { echo } from './procedures/echo.js';

export const appRouter = router({
  echo,
});
```

サンプルの`echo`プロシージャは`src/procedures/echo.ts`に生成されます：

```ts
export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

上記の構成要素：

- `publicProcedure`：`src/middleware`に設定されたミドルウェアを含むAPIの公開メソッドを定義
- `input`：操作の期待される入力を定義するZodスキーマを受け入れる
- `output`：操作の期待される出力を定義するZodスキーマを受け入れる
- `query`：APIの実装を定義する関数を受け入れる。`opts`には入力値と`opts.ctx`経由でミドルウェアが設定したコンテキストが含まれる

`query`の使用は操作が非変更的であることを示します。データ取得用メソッドに使用します。変更操作には`mutation`メソッドを使用します。

新しいプロシージャを追加する場合は、`src/router.ts`でルータに登録してください。

## tRPC APIのカスタマイズ

### エラー処理

実装では`TRPCError`をスローしてクライアントにエラーレスポンスを返せます：

```ts
throw new TRPCError({
  code: 'NOT_FOUND',
  message: '要求されたリソースが見つかりません',
});
```

### 操作の整理

APIが成長するにつれ、関連する操作をグループ化できます：

```ts
import { getUser } from './procedures/users/get.js';
import { listUsers } from './procedures/users/list.js';

const appRouter = router({
   users: router({
      get: getUser,
      list: listUsers,
   }),
   ...
})
```

クライアントはこのグループ化された操作を受け取り、`listUsers`操作の呼び出し例：

```ts
client.users.list.query();
```

### ロギング

AWS Lambda Powertoolsロガーは`src/middleware/logger.ts`で設定され、`opts.ctx.logger`経由でアクセス可能：

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.logger.info('操作が入力値で呼び出されました', opts.input);
      return ...;
   });
```

詳細は[AWS Lambda Powertools Loggerドキュメント](https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/)を参照。

### メトリクス記録

AWS Lambda Powertoolsメトリクスは`src/middleware/metrics.ts`で設定され、`opts.ctx.metrics`経由でアクセス可能：

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.metrics.addMetric('Invocations', 'Count', 1);
      return ...;
   });
```

詳細は[AWS Lambda Powertools Metricsドキュメント](https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/)を参照。

### X-Rayトレーシングの微調整

AWS Lambda Powertoolsトレーサーは`src/middleware/tracer.ts`で設定され、`opts.ctx.tracer`経由でアクセス可能：

```ts {5-7}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      const subSegment = opts.ctx.tracer.getSegment()!.addNewSubsegment('MyAlgorithm');
      // ... トレース対象のアルゴリズムロジック
      subSegment.close();
      return ...;
   });
```

詳細は[AWS Lambda Powertools Tracerドキュメント](https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/)を参照。

### カスタムミドルウェアの実装

コンテキストに追加の値を提供するミドルウェアを実装できます。例として、APIの呼び出し元ユーザー詳細を抽出するミドルウェア：

:::warning
この例は`auth`が`IAM`に設定されている場合を想定。Cognito認証の場合、`event`からクレームを抽出可能
:::

コンテキストインターフェース定義：

```ts
export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}
```

ミドルウェア実装（REST API用）：

<Tabs>
<TabItem label="REST">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEvent } from 'aws-lambda';

// ...（インターフェース定義は上記と同じ）

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEvent>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoAuthenticationProvider = opts.ctx.event.requestContext?.identity?.cognitoAuthenticationProvider;
    // ...（ユーザー情報取得ロジック）
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
<TabItem label="HTTP">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

// ...（インターフェース定義は上記と同じ）

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoIdentity = opts.ctx.event.requestContext?.authorizer?.iam
      ?.cognitoIdentity as unknown as
      | {
          amr: string[];
        }
      | undefined;
    // ...（ユーザー情報取得ロジック）
    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
</Tabs>

## tRPC APIのデプロイ

tRPC APIジェネレータは選択した`iacProvider`に基づきCDKまたはTerraformのインフラストラクチャコードを作成します。

<Infrastructure>
<Fragment slot="cdk">
`common/constructs`フォルダのCDKコンストラクトを使用：

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs`;

export class ExampleStack extends Stack {
   constructor(scope: Construct, id: string) {
      const api = new MyApi(this, 'MyApi', {
        integrations: MyApi.defaultIntegrations(this).build(),
      });
   }
}
```

Cognito認証を使用する場合：

```ts {9}
import { MyApi, UserIdentity } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const identity = new UserIdentity(this, 'Identity');
    const api = new MyApi(this, 'MyApi', {
      identity,
    });
  }
}
```
</Fragment>
<Fragment slot="terraform">
`common/terraform`フォルダのモジュールを使用：

```hcl {6-8}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  env = {
    ENVIRONMENT = var.environment
    LOG_LEVEL   = "INFO"
  }

  tags = local.common_tags
}
```

Cognito認証の場合：

```hcl {4-5}
module "my_api" {
  source = "../../common/terraform/src/app/apis/my-api"

  user_pool_id         = local.user_pool_id
  user_pool_client_ids = [local.client_id]
}
```
</Fragment>
</Infrastructure>

### 統合

<Snippet name="api/type-safe-api-integrations" parentHeading="統合" />

:::tip
CDKを選択した場合、プロシージャの追加/削除は再ビルドなしでCDKコンストラクトに即時反映されます
:::

### アクセス権付与（IAM認証時）

<Infrastructure>
<Fragment slot="cdk">
```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```
</Fragment>
<Fragment slot="terraform">
```hcl
resource "aws_iam_policy" "api_invoke_policy" {
  policy = jsonencode({
    Statement = [{
      Action = "execute-api:Invoke"
      Resource = "${module.my_api.api_execution_arn}/*/*"
    }]
  })
}
```
</Fragment>
</Infrastructure>

## ローカルtRPCサーバー

`serve`ターゲットでローカルサーバーを起動：

<NxCommands commands={['run @my-scope/my-api:serve']} />

## tRPC APIの呼び出し

型安全なクライアントを作成：

```ts
import { createMyApiClient } from ':my-scope/my-api';

const client = createMyApiClient({ url: 'https://my-api-url.example.com/' });
await client.echo.query({ message: 'Hello world!' });
```

## 詳細情報

[tRPC公式ドキュメント](https://trpc.io/docs)を参照してください。