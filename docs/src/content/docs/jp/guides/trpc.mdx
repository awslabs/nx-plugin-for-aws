---
title: "tRPC"
description: "tRPCのリファレンスドキュメント"
---



import { FileTree, Tabs, TabItem } from '@astrojs/starlight/components';
import AnchorHeading from '@astrojs/starlight/components/AnchorHeading.astro';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Snippet from '@components/snippet.astro';

<<<<<<< HEAD
[tRPC](https://trpc.io/)は、エンドツーエンドの型安全性を備えたTypeScript APIを構築するためのフレームワークです。tRPCを使用すると、API操作の入力と出力の更新が即座にクライアントコードに反映され、プロジェクトの再ビルドなしにIDEで確認できます。

tRPC APIジェネレータは、AWS CDKインフラストラクチャが設定された新しいtRPC APIを作成します。生成されるバックエンドはサーバーレスデプロイにAWS Lambdaを使用し、[Zod](https://zod.dev/)によるスキーマ検証を含みます。また、ロギング、AWS X-Rayトレーシング、CloudWatchメトリクスを含むオブザーバビリティのために[AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/)を設定します。
=======
[tRPC](https://trpc.io/)はエンドツーエンドの型安全性を備えたTypeScript API構築フレームワークです。tRPCを使用すると、API操作の入力と出力の変更が即座にクライアントコードに反映され、プロジェクトの再ビルドなしにIDE上で確認できます。

tRPC APIジェネレータは、AWS CDKインフラストラクチャがセットアップされた新しいtRPC APIを作成します。生成されるバックエンドはサーバーレスデプロイにAWS Lambdaを使用し、[Zod](https://zod.dev/)によるスキーマ検証を含みます。[AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/typescript/latest/)を設定し、ロギング、AWS X-Rayトレーシング、Cloudwatchメトリクスを含むオブザーバビリティを実現します。
>>>>>>> c5375c6 (docs: update translations)

## 使用方法

### tRPC APIの生成

新しいtRPC APIは2つの方法で生成できます:

<RunGenerator generator="ts#trpc-api" />

### オプション

<GeneratorParameters generator="ts#trpc-api" />

<Snippet name="api/api-choice-note" />

## ジェネレータの出力

ジェネレータは`<directory>/<api-name>`ディレクトリに以下のプロジェクト構造を作成します:

<FileTree>
  - src
    - init.ts バックエンドtRPC初期化
    - router.ts tRPCルーター定義（LambdaハンドラAPIエントリーポイント）
    - schema Zodを使用したスキーマ定義
      - echo.ts "echo"プロシージャの入力出力例
    - procedures APIが公開するプロシージャ（操作）
      - echo.ts サンプルプロシージャ
    - middleware
      - error.ts エラーハンドリング用ミドルウェア
      - logger.ts AWS Powertoolsロギング設定ミドルウェア
      - tracer.ts AWS Powertoolsトレーシング設定ミドルウェア
      - metrics.ts AWS Powertoolsメトリクス設定ミドルウェア
    - local-server.ts ローカル開発サーバー用tRPCスタンドアロンアダプター
    - client
      - index.ts マシン間API呼び出し用型安全クライアント
  - tsconfig.json TypeScript設定
  - project.json プロジェクト設定とビルドターゲット
</FileTree>

<<<<<<< HEAD
ジェネレータはまた、APIのデプロイに使用できるCDKコンストラクトを`packages/common/constructs`ディレクトリに作成します。
=======
ジェネレータはまた、APIデプロイに使用できるCDKコンストラクトを`packages/common/constructs`ディレクトリに作成します。
>>>>>>> c5375c6 (docs: update translations)

## tRPC APIの実装

tRPC APIは、リクエストを特定のプロシージャに委譲するルーターで構成されます。各プロシージャはZodスキーマで定義された入力と出力を持ちます。

### スキーマ

<<<<<<< HEAD
`src/schema`ディレクトリには、クライアントとサーバーコード間で共有される型が含まれます。これらの型はTypeScriptファーストのスキーマ宣言・検証ライブラリである[Zod](https://zod.dev/)を使用して定義されます。
=======
`src/schema`ディレクトリにはクライアントとサーバーコード間で共有される型が含まれます。これらの型はTypeScriptファーストのスキーマ宣言・検証ライブラリ[Zod](https://zod.dev/)を使用して定義されます。

:::note
モノレポのルートにある`tsconfig.base.json`にZodを[version 4.x](https://zod.dev/v4)に解決するエイリアスが追加されます。これはNPMにZod v4がリリースされた際にインポートパスを変更せずにアップグレードできるよう将来に備えるためです。
:::
>>>>>>> c5375c6 (docs: update translations)

スキーマの例:

```ts
import { z } from 'zod/v4';

// スキーマ定義
export const UserSchema = z.object({
  name: z.string(),
  height: z.number(),
  dateOfBirth: z.string().datetime(),
});

// 対応するTypeScript型
export type User = z.TypeOf<typeof UserSchema>;
```

上記スキーマの場合、`User`型は以下のTypeScriptと同等です:

```ts
interface User {
  name: string;
  height: number;
  dateOfBirth: string;
}
```

<<<<<<< HEAD
スキーマはサーバーとクライアントコードの両方で共有され、APIで使用される構造を変更する際の単一の更新ポイントを提供します。

スキーマは実行時にtRPC APIによって自動検証され、バックエンドでカスタム検証ロジックを手動で作成する必要がなくなります。
=======
スキーマはサーバーとクライアントコードの両方で共有され、APIで使用する構造を変更する際の単一の更新ポイントを提供します。

スキーマは実行時にtRPC APIによって自動検証され、バックエンドでカスタム検証ロジックを手動で作成する手間を省きます。
>>>>>>> c5375c6 (docs: update translations)

Zodはスキーマを結合・派生するための`.merge`、`.pick`、`.omit`など強力なユーティリティを提供します。詳細は[Zodドキュメント](https://zod.dev/?id=basic-usage)を参照してください。

### ルーターとプロシージャ

<<<<<<< HEAD
APIのエントリーポイントは`src/router.ts`にあります。このファイルには、呼び出される操作に基づいてリクエストを「プロシージャ」にルーティングするLambdaハンドラが含まれます。各プロシージャは入力、出力、実装を定義します。
=======
APIのエントリーポイントは`src/router.ts`にあります。このファイルには、操作ごとにリクエストを「プロシージャ」にルーティングするLambdaハンドラが含まれます。各プロシージャは入力、出力、実装を定義します。
>>>>>>> c5375c6 (docs: update translations)

サンプルルーターには`echo`という単一の操作が定義されています:

```ts
import { echo } from './procedures/echo.js';

export const appRouter = router({
  echo,
});
```

サンプルの`echo`プロシージャは`src/procedures/echo.ts`に生成されます:

```ts
export const echo = publicProcedure
  .input(EchoInputSchema)
  .output(EchoOutputSchema)
  .query((opts) => ({ result: opts.input.message }));
```

構成要素の解説:

<<<<<<< HEAD
- `publicProcedure`は、`src/middleware`に設定されたミドルウェアを含むAPIの公開メソッドを定義。このミドルウェアにはロギング、トレーシング、メトリクスのためのAWS Lambda Powertools統合が含まれます
- `input`は操作の期待入力を定義するZodスキーマを受け入れます。この操作へのリクエストは自動的にこのスキーマに対して検証されます
- `output`は操作の期待出力を定義するZodスキーマを受け入れます。スキーマに準拠しない出力を返すと実装で型エラーが発生します
- `query`はAPIの実装を定義する関数を受け入れます。この実装は`opts`を受け取り、ミドルウェアによって設定されたコンテキストを`opts.ctx`で利用可能です。`query`に渡す関数は`output`スキーマに準拠する出力を返す必要があります

`query`の使用は操作が非変異的であることを示します。データ取得メソッドの定義に使用します。変異操作を実装するには、代わりに`mutation`メソッドを使用します。
=======
- `publicProcedure`は`src/middleware`に設定されたミドルウェアを含むAPIの公開メソッドを定義
- `input`は操作の期待入力を定義するZodスキーマを受け入れ、リクエストを自動検証
- `output`は操作の期待出力を定義するZodスキーマを受け入れ、スキーマに準拠しない出力を返すと型エラーが発生
- `query`はAPIの実装を定義する関数を受け入れ、`opts.input`で入力値、`opts.ctx`でミドルウェアが設定したコンテキストにアクセス可能

`query`は非変異操作に使用します。データ変更操作には`mutation`メソッドを使用してください。
>>>>>>> c5375c6 (docs: update translations)

新しいプロシージャを追加する場合は、`src/router.ts`のルーターに登録してください。

## tRPC APIのカスタマイズ

### エラーハンドリング

<<<<<<< HEAD
実装では、`TRPCError`をスローしてクライアントにエラーレスポンスを返せます。エラータイプを示す`code`を受け入れます:
=======
実装では`TRPCError`をスローしてクライアントにエラー応答を返せます:
>>>>>>> c5375c6 (docs: update translations)

```ts
throw new TRPCError({
  code: 'NOT_FOUND',
<<<<<<< HEAD
  message: '要求されたリソースが見つかりませんでした',
=======
  message: 'リクエストされたリソースが見つかりません',
>>>>>>> c5375c6 (docs: update translations)
});
```

### 操作の整理

<<<<<<< HEAD
APIが成長するにつれ、関連する操作をグループ化したい場合があります。

ネストしたルーターを使用して操作をグループ化できます:
=======
関連する操作をグループ化するにはネストされたルーターを使用します:
>>>>>>> c5375c6 (docs: update translations)

```ts
import { getUser } from './procedures/users/get.js';
import { listUsers } from './procedures/users/list.js';

const appRouter = router({
   users: router({
      get: getUser,
      list: listUsers,
   }),
   ...
})
```

<<<<<<< HEAD
クライアントはこの操作グループを受け取り、例えば`listUsers`操作の呼び出しは以下のようになります:
=======
クライアントはこのグループ化された操作を呼び出せます:
>>>>>>> c5375c6 (docs: update translations)

```ts
client.users.list.query();
```

### ロギング

<<<<<<< HEAD
AWS Lambda Powertoolsロガーは`src/middleware/logger.ts`で設定され、API実装で`opts.ctx.logger`からアクセス可能です。CloudWatch Logsへのロギングや、構造化ログメッセージに含める追加値の制御に使用できます:
=======
AWS Lambda Powertoolsロガーは`src/middleware/logger.ts`で設定され、`opts.ctx.logger`でアクセス可能です:
>>>>>>> c5375c6 (docs: update translations)

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.logger.info('操作が入力値で呼び出されました', opts.input);
<<<<<<< HEAD

=======
>>>>>>> c5375c6 (docs: update translations)
      return ...;
   });
```

<<<<<<< HEAD
詳細は[AWS Lambda Powertools Loggerドキュメント](https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/)を参照してください。

### メトリクス記録

AWS Lambda Powertoolsメトリクスは`src/middleware/metrics.ts`で設定され、`opts.ctx.metrics`からアクセス可能です。AWS SDKをインポートせずにCloudWatchメトリクスを記録できます:
=======
詳細は[AWS Lambda Powertools Loggerドキュメント](https://docs.powertools.aws.dev/lambda/typescript/latest/core/logger/)を参照。

### メトリクス記録

AWS Lambda Powertoolsメトリクスは`src/middleware/metrics.ts`で設定され、`opts.ctx.metrics`でアクセス可能です:
>>>>>>> c5375c6 (docs: update translations)

```ts {5}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      opts.ctx.metrics.addMetric('Invocations', 'Count', 1);
      return ...;
   });
```

詳細は[AWS Lambda Powertools Metricsドキュメント](https://docs.powertools.aws.dev/lambda/typescript/latest/core/metrics/)を参照。

### X-Rayトレーシングの微調整

<<<<<<< HEAD
AWS Lambda Powertoolsトレーサーは`src/middleware/tracer.ts`で設定され、`opts.ctx.tracer`からアクセス可能です。APIリクエストのパフォーマンスとフローの詳細な可視化のため、AWS X-Rayトレースを追加できます:
=======
AWS Lambda Powertools Tracerは`src/middleware/tracer.ts`で設定され、`opts.ctx.tracer`でアクセス可能です:
>>>>>>> c5375c6 (docs: update translations)

```ts {5-7}
export const echo = publicProcedure
   .input(...)
   .output(...)
   .query(async (opts) => {
      const subSegment = opts.ctx.tracer.getSegment()!.addNewSubsegment('MyAlgorithm');
      // ... トレース対象のロジック
      subSegment.close();
      return ...;
   });
```

詳細は[AWS Lambda Powertools Tracerドキュメント](https://docs.powertools.aws.dev/lambda/typescript/latest/core/tracer/)を参照。

### カスタムミドルウェアの実装

<<<<<<< HEAD
ミドルウェアを実装することで、プロシージャに提供されるコンテキストに追加値を設定できます。

例として、APIから呼び出し元ユーザーの詳細を抽出するミドルウェアを`src/middleware/identity.ts`に実装します。

:::warning
この例は`auth`が`IAM`に設定されていることを想定。Cognito認証の場合、イベントから関連クレームを抽出する方が簡単です。
:::

まずコンテキストに追加する内容を定義:
=======
ミドルウェアを実装してプロシージャに提供するコンテキストに追加値を設定できます。

例として、`src/middleware/identity.ts`にAPI呼び出し元の詳細を抽出するミドルウェアを実装します。

:::warning
この例は`auth`が`IAM`に設定されている場合を想定。Cognito認証の場合、`event`からクレームを抽出する方が簡単です。
:::

コンテキストに追加するインターフェースを定義:
>>>>>>> c5375c6 (docs: update translations)

```ts
export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}
```

<<<<<<< HEAD
次にミドルウェアを実装:
=======
ミドルウェアの実装構造:

```ts
export const createIdentityPlugin = () => {
   const t = initTRPC.context<...>().create();
   return t.procedure.use(async (opts) => {
      // プロシージャ前処理

      const response = await opts.next(...);

      // プロシージャ後処理

      return response;
   });
};
```
>>>>>>> c5375c6 (docs: update translations)

<Tabs>
<TabItem label="REST">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEvent } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEvent>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoAuthenticationProvider = opts.ctx.event.requestContext?.identity?.cognitoAuthenticationProvider;

    let sub: string | undefined = undefined;
    if (cognitoAuthenticationProvider) {
      const providerParts = cognitoAuthenticationProvider.split(':');
      sub = providerParts[providerParts.length - 1];
    }

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `呼び出し元ユーザーを特定できません`,
      });
    }

    const { Users } = await cognito.listUsers({
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `subjectId ${sub}のユーザーが見つかりません`,
      });
    }

    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
<TabItem label="HTTP">
```ts
import { CognitoIdentityProvider } from '@aws-sdk/client-cognito-identity-provider';
import { initTRPC, TRPCError } from '@trpc/server';
import { CreateAWSLambdaContextOptions } from '@trpc/server/adapters/aws-lambda';
import { APIGatewayProxyEventV2WithIAMAuthorizer } from 'aws-lambda';

export interface IIdentityContext {
  identity?: {
    sub: string;
    username: string;
  };
}

export const createIdentityPlugin = () => {
  const t = initTRPC.context<IIdentityContext & CreateAWSLambdaContextOptions<APIGatewayProxyEventV2WithIAMAuthorizer>>().create();

  const cognito = new CognitoIdentityProvider();

  return t.procedure.use(async (opts) => {
    const cognitoIdentity = opts.ctx.event.requestContext?.authorizer?.iam
      ?.cognitoIdentity as unknown as
      | {
          amr: string[];
        }
      | undefined;

    const sub = (cognitoIdentity?.amr ?? [])
      .flatMap((s) => (s.includes(':CognitoSignIn:') ? [s] : []))
      .map((s) => {
        const parts = s.split(':');
        return parts[parts.length - 1];
      })?.[0];

    if (!sub) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `呼び出し元ユーザーを特定できません`,
      });
    }

    const { Users } = await cognito.listUsers({
      UserPoolId: process.env.USER_POOL_ID!,
      Limit: 1,
      Filter: `sub="${sub}"`,
    });

    if (!Users || Users.length !== 1) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: `subjectId ${sub}のユーザーが見つかりません`,
      });
    }

    return await opts.next({
      ctx: {
        ...opts.ctx,
        identity: {
          sub,
          username: Users[0].Username!,
        },
      },
    });
  });
};
```
</TabItem>
</Tabs>

## tRPC APIのデプロイ

<<<<<<< HEAD
tRPC APIジェネレータは`common/constructs`フォルダにAPIデプロイ用CDKコンストラクトを生成します。CDKアプリケーションで使用できます:
=======
tRPC APIジェネレータは`common/constructs`フォルダにデプロイ用CDKコンストラクトを生成します。CDKアプリケーションで使用例:
>>>>>>> c5375c6 (docs: update translations)

```ts {6-8}
import { MyApi } from ':my-scope/common-constructs`;

export class ExampleStack extends Stack {
   constructor(scope: Construct, id: string) {
      const api = new MyApi(this, 'MyApi', {
        integrations: MyApi.defaultIntegrations(this).build(),
      });
   }
}
```

<<<<<<< HEAD
これにより、AWS API Gateway REST/HTTP API、ビジネスロジック用Lambda関数、選択した`auth`メソッドに基づく認証が設定されます。
=======
この設定により、AWS API Gateway REST/HTTP API、ビジネスロジック用Lambda関数、選択した`auth`メソッドに基づく認証が構成されます。
>>>>>>> c5375c6 (docs: update translations)

:::note
Cognito認証を選択した場合、APIコンストラクトに`identity`プロパティを指定する必要があります:

```ts {9}
import { MyApi, UserIdentity } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    const identity = new UserIdentity(this, 'Identity');

    const api = new MyApi(this, 'MyApi', {
      integrations: MyApi.defaultIntegrations(this).build(),
      identity,
    });
  }
}
```

`UserIdentity`コンストラクトは<Link path="/guides/react-website-auth">`ts#react-website-auth`ジェネレータ</Link>で生成できます。
:::

### 型安全な統合

<Snippet name="api/type-safe-api-integrations" parentHeading="型安全な統合" />

:::tip
tRPC APIでプロシージャを追加/削除すると、再ビルドなしでCDKコンストラクトに即時反映されます。
:::

### アクセス権限付与（IAMのみ）

`IAM`認証を選択した場合、`grantInvokeAccess`メソッドでAPIアクセスを許可できます:

```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```

## ローカルtRPCサーバー

`serve`ターゲットでローカルサーバーを起動できます:

<NxCommands commands={['run @my-scope/my-api:serve']} />

<<<<<<< HEAD
ローカルサーバーのエントリーポイントは`src/local-server.ts`です。APIに変更を加えると自動リロードされます。

## tRPC APIの呼び出し

型安全な方法でAPIを呼び出すtRPCクライアントを作成できます。別のバックエンドからAPIを呼び出す場合、`src/client/index.ts`のクライアントを使用できます:
=======
ローカルサーバーのエントリーポイントは`src/local-server.ts`です。APIに変更を加えると自動でリロードされます。

## tRPC APIの呼び出し

型安全なtRPCクライアントを作成できます。別のバックエンドから呼び出す場合:
>>>>>>> c5375c6 (docs: update translations)

```ts
import { createMyApiClient } from ':my-scope/my-api';

const client = createMyApiClient({ url: 'https://my-api-url.example.com/' });

await client.echo.query({ message: 'Hello world!' });
```

<<<<<<< HEAD
ReactウェブサイトからAPIを呼び出す場合は、<Link path="guides/api-connection/react-trpc">API Connection</Link>ジェネレータを使用してクライアントを設定してください。

## 詳細情報

tRPCの詳細については、[tRPCドキュメント](https://trpc.io/docs)を参照してください。
=======
Reactウェブサイトから呼び出す場合は、<Link path="guides/api-connection/react-trpc">API接続</Link>ジェネレータの使用を検討してください。

## 詳細情報

tRPCの詳細は[tRPC公式ドキュメント](https://trpc.io/docs)を参照してください。
>>>>>>> c5375c6 (docs: update translations)
