---
title: "TypeScriptのLambda関数"
description: "TypeScriptのLambda関数を生成する"
---



import { FileTree } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import Infrastructure from '@components/infrastructure.astro';
import Snippet from '@components/snippet.astro';

TypeScript Lambda Function ジェネレータは、既存のTypeScriptプロジェクトにLambda関数を追加する機能を提供します。

このジェネレータはAWS CDKまたはTerraformのインフラストラクチャ設定を含む新しいTypeScript Lambdaハンドラを作成します。生成されたハンドラは、[AWS Lambda Powertools for TypeScript](https://docs.powertools.aws.dev/lambda/typescript/latest/)を使用して、ロギング、AWS X-Rayトレーシング、CloudWatchメトリクスなどの観測可能性を実現し、[AWS Lambda PowertoolsのParser](https://docs.powertools.aws.dev/lambda/typescript/latest/utilities/parser/)を使用したイベントの型安全性（オプション）を提供します。

## 使用方法

### TypeScript Lambda関数の生成

Lambda関数は2つの方法で生成できます:

<RunGenerator generator="ts#lambda-function" />

### オプション

<GeneratorParameters generator="ts#lambda-function" />

## ジェネレータの出力

ジェネレータはプロジェクトに以下のファイルを追加します:

<FileTree>

- \<project-name>
  - src/
    - \<lambda-function>.ts 関数の実装

</FileTree>

`functionPath`オプションが指定された場合、ジェネレータはプロジェクトのソースディレクトリ内の指定パスにハンドラを追加します:

<FileTree>

- \<project-name>
  - src/
    - \<custom-path>/
      - \<function-name>.ts 関数の実装

</FileTree>

### インフラストラクチャ

<Snippet name="shared-constructs" />

ジェネレータは選択した`iacProvider`に基づいて関数をデプロイするためのインフラストラクチャコードを作成します:

<Infrastructure>
<Fragment slot="cdk">
ジェネレータはCDKコンストラクトを作成します。このコンストラクトは`packages/common/constructs/src/app/lambda-functions`ディレクトリに配置され、関数のデプロイに使用できます。
</Fragment>
<Fragment slot="terraform">
ジェネレータはTerraformモジュールを作成します。このモジュールは`packages/common/terraform/src/app/lambda-functions/<function-name>`ディレクトリに配置され、関数のデプロイに使用できます。
</Fragment>
</Infrastructure>

## 関数の実装

メインの関数実装は`<function-name>.ts`にあります。以下は実装例です:

```typescript
import { parser } from '@aws-lambda-powertools/parser/middleware';
import { EventBridgeSchema } from '@aws-lambda-powertools/parser/schemas';
import middy from '@middy/core';
import { Tracer } from '@aws-lambda-powertools/tracer';
import { captureLambdaHandler } from '@aws-lambda-powertools/tracer/middleware';
import { injectLambdaContext } from '@aws-lambda-powertools/logger/middleware';
import { Logger } from '@aws-lambda-powertools/logger';
import { Metrics } from '@aws-lambda-powertools/metrics';
import { logMetrics } from '@aws-lambda-powertools/metrics/middleware';
import { z } from 'zod';

process.env.POWERTOOLS_METRICS_NAMESPACE = 'MyFunction';
process.env.POWERTOOLS_SERVICE_NAME = 'MyFunction';

const tracer = new Tracer();
const logger = new Logger();
const metrics = new Metrics();

export const myFunction = async (
  event: z.infer<typeof EventBridgeSchema>,
): Promise<void> => {
  logger.info('Received event', event);

  // TODO: 実装を追加
};

export const handler = middy()
  .use(captureLambdaHandler(tracer))
  .use(injectLambdaContext(logger))
  .use(logMetrics(metrics))
  .use(parser({ schema: EventBridgeSchema }))
  .handler(myFunction);

```

ジェネレータは以下の機能を自動的に設定します:

1. 拡張Lambda機能のための**Middyミドルウェアスタック**
2. 観測可能性のための**AWS Lambda Powertools統合**
3. CloudWatchを使った**メトリクス収集**
4. パーサーミドルウェアを使用した**型安全性**
5. Rolldownによる最適化されたデプロイパッケージの**バンドリング**

### AWS Lambda Powertoolsによる観測可能性

#### ロギング

ジェネレータはMiddyミドルウェアを通じた自動コンテキスト注入付きの構造化ロギングを設定します。

```typescript
export const handler = middy()
  .use(injectLambdaContext(logger))
  .handler(myFunction);
```

#### トレーシング

AWS X-Rayトレーシングは`captureLambdaHandler`ミドルウェアで自動設定されます。カスタムサブセグメントを追加できます:

```typescript
const tracer = new Tracer();

export const myFunction = async (
  event: z.infer<typeof EventBridgeSchema>,
): Promise<void> => {
  // 新しいサブセグメントを作成
  const subsegment = tracer.getSegment()?.addNewSubsegment('custom-operation');
  try {
    // ここにロジックを実装
  } catch (error) {
    subsegment?.addError(error as Error);
    throw error;
  } finally {
    subsegment?.close();
  }
};

export const handler = middy()
  .use(captureLambdaHandler(tracer))
  .handler(myFunction);
```

#### メトリクス

CloudWatchメトリクスは`logMetrics`ミドルウェアでリクエストごとに自動収集されます。カスタムメトリクスを追加できます:

```typescript
const metrics = new Metrics();

export const myFunction = async (
  event: z.infer<typeof EventBridgeSchema>,
): Promise<void> => {
  metrics.addMetric("CustomMetric", MetricUnit.Count, 1);
  metrics.addMetric("ProcessingTime", MetricUnit.Milliseconds, processingTime);
};

export const handler = middy()
  .use(logMetrics(metrics))
  .handler(myFunction);
```

### 型安全性

Lambda関数生成時に`eventSource`を選択した場合、関数は[AWS Lambda Powertoolsの`parser`ミドルウェア](https://docs.powertools.aws.dev/lambda/typescript/latest/utilities/parser/)で計装されます。例:

```typescript {4}
export const myFunction = async (
  event: z.infer<typeof EventBridgeSchema>,
): Promise<void> => {
  event.detail // <- IDEのオートコンプリートが効く型安全なアクセス
};

export const handler = middy()
  .use(parser({ schema: EventBridgeSchema }))
  .handler(myFunction);
```

これにより、コンパイル時の型安全性とランタイムバリデーションが提供されます。

:::caution
イベントがスキーマに適合しない場合にハンドラがエラーをスローしないようにするには、[`safeParse`オプション](https://docs.powertools.aws.dev/lambda/typescript/latest/utilities/parser/#safe-parsing)を使用できます。
:::

:::tip
DynamoDBストリームやEventBridgeイベント内のカスタムデータなど、ネストされたカスタムデータがある場合は、[Envelopes](https://docs.powertools.aws.dev/lambda/typescript/latest/utilities/parser/#envelopes)を使用して型安全性を確保できます。
:::

イベントの型指定を希望しない場合、`eventSource`に`Any`を選択すると、イベントパラメータは`any`型になります。

## バンドリング

<Snippet name="ts-bundle" />

## 関数のデプロイ

<Snippet name="lambda-function/deploying-your-function" parentHeading="Deploying your Function" />