---
title: "ReactからFastAPIへ"
description: "ReactウェブサイトをPython FastAPIに接続する"
---



import { FileTree, Steps } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import NxCommands from '@components/nx-commands.astro';
import Drawer from '@components/drawer.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import schema from '../../../../../../../packages/nx-plugin/src/api-connection/schema.json';

`api-connection`ジェネレータは、ReactウェブサイトとFastAPIバックエンドを迅速に統合する方法を提供します。タイプセーフな方法でFastAPIバックエンドに接続するためのすべての必要な設定（クライアントと[TanStack Query](https://tanstack.com/query/v5)フックの生成、AWS IAM認証のサポート、適切なエラーハンドリングを含む）を行います。

## 前提条件

このジェネレータを使用する前に、Reactアプリケーションが以下を備えていることを確認してください：

1. アプリケーションをレンダリングする`main.tsx`ファイル
2. 動作するFastAPIバックエンド（FastAPIジェネレータで生成されたもの）

<details>
<summary>必要な`main.tsx`構造の例</summary>

```tsx
import { StrictMode } from 'react';
import * as ReactDOM from 'react-dom/client';
import App from './app/app';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement,
);
root.render(
  <StrictMode>
    <App />
  </StrictMode>,
);
```

</details>

## 使用方法

### ジェネレータの実行

<RunGenerator generator="api-connection" />

### オプション

<GeneratorParameters schema={schema} />

## ジェネレータの出力

ジェネレータはFastAPIプロジェクトの以下のファイルを変更します：

<FileTree>

- scripts
  - generate_open_api.py APIのOpenAPI仕様を生成するスクリプトを追加
- project.json 上記生成スクリプトを呼び出す新しいビルドターゲットを追加

</FileTree>

ジェネレータはReactアプリケーションの以下のファイルを変更します：

<FileTree>

- src
  - components
    - \<ApiName>Provider.tsx APIクライアントのプロバイダ
    - QueryClientProvider.tsx TanStack React Queryクライアントプロバイダ
  - hooks
    - use\<ApiName>.tsx TanStack Queryで状態管理されたAPI呼び出し用フックを追加
    - use\<ApiName>Client.tsx 直接APIを呼び出すバニラクライアント生成用フックを追加
    - useSigV4.tsx IAM認証選択時にHTTPリクエストのSigV4署名用フックを追加
- project.json タイプセーフなクライアントを生成する新しいビルドターゲットを追加
- .gitignore 生成されたクライアントファイルをデフォルトで無視

</FileTree>

また、ジェネレータはウェブサイトインフラにRuntime Configを追加します（既存でない場合）。これによりFastAPIのAPI URLがウェブサイトで利用可能になり、`use<ApiName>.tsx`フックによって自動的に設定されます。

### コード生成

ビルド時に、FastAPIのOpenAPI仕様からタイプセーフなクライアントが生成されます。これによりReactアプリケーションに3つの新しいファイルが追加されます：

<FileTree>

- src
  - generated
    - \<ApiName>
      - types.gen.ts FastAPIで定義したpydanticモデルから生成された型
      - client.gen.ts API呼び出し用タイプセーフクライアント
      - options-proxy.gen.ts TanStack Queryフックオプション生成メソッドを提供

</FileTree>

:::tip
デフォルトでは生成クライアントはバージョン管理から除外されます。含めたい場合はReactアプリの`.gitignore`からエントリを削除できますが、`.gen.ts`ファイルへの手動変更はビルド時に上書きされます。
:::

## 生成コードの使用方法

生成されたタイプセーフクライアントはReactアプリケーションからFastAPIを呼び出すために使用できます。TanStack Queryフック経由での使用が推奨されますが、バニラクライアントも使用可能です。

:::note
FastAPIに変更を加えた場合、生成クライアントに反映するにはプロジェクトの再ビルドが必要です。例：

<NxCommands commands={['run-many --target build --all']} />
:::

:::tip
ReactアプリとFastAPIを同時開発する場合、[`nx watch`](https://nx.dev/nx-api/nx/documents/watch)を使用してAPI変更時にクライアントを再生成できます：

<NxCommands
  commands={[
    'watch --projects=<FastAPIProject> -- \\ ',
    'run <WebsiteProject>:"generate:<ApiName>-client"',
  ]}
/>
:::

### APIフックの使用

ジェネレータはTanStack QueryでAPIを呼び出すための`use<ApiName>`フックを提供します。

### クエリ

`useQuery`フックを使用する際には`queryOptions`メソッドを使用します：

```tsx {7}
import { useQuery } from '@tanstack/react-query';
import { useState, useEffect } from 'react';
import { useMyApi } from './hooks/useMyApi';

function MyComponent() {
  const api = useMyApi();
  const item = useQuery(api.getItem.queryOptions({ itemId: 'some-id' }));

  if (item.isLoading) return <div>Loading...</div>;
  if (item.isError) return <div>Error: {item.error.message}</div>;

  return <div>Item: {item.data.name}</div>;
}
```

<Drawer title="バニラクライアントの直接使用" trigger="クリックでバニラクライアント直接使用例を表示">
```tsx {5,13}
import { useState, useEffect } from 'react';
import { useMyApiClient } from './hooks/useMyApiClient';

function MyComponent() {
  const api = useMyApiClient();
  const [item, setItem] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchItem = async () => {
      try {
        const data = await api.getItem({ itemId: 'some-id' });
        setItem(data);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };
    fetchItem();
  }, [api]);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return <div>Item: {item.name}</div>;
}
```
</Drawer>

### ミューテーション

生成フックは`useMutation`を使用したミューテーションをサポートします：

```tsx {5-7,11}
import { useMutation } from '@tanstack/react-query';
import { useMyApi } from './hooks/useMyApi';

function CreateItemForm() {
  const api = useMyApi();
  const createItem = useMutation(api.createItem.mutationOptions());

  const handleSubmit = (e) => {
    e.preventDefault();
    createItem.mutate({ name: 'New Item', description: 'A new item' });
  };

  return (
    <form onSubmit={handleSubmit}>
      <button
        type="submit"
        disabled={createItem.isPending}
      >
        {createItem.isPending ? 'Creating...' : 'Create Item'}
      </button>

      {createItem.isSuccess && (
        <div className="success">
          Item created with ID: {createItem.data.id}
        </div>
      )}

      {createItem.isError && (
        <div className="error">
          Error: {createItem.error.message}
        </div>
      )}
    </form>
  );
}
```

コールバック追加例：

```tsx
const createItem = useMutation({
  ...api.createItem.mutationOptions(),
  onSuccess: (data) => {
    console.log('Item created:', data);
    navigate(`/items/${data.id}`);
  },
  onError: (error) => {
    console.error('Failed to create item:', error);
  },
  onSettled: () => {
    queryClient.invalidateQueries({ queryKey: api.listItems.queryKey() });
  }
});
```

<Drawer title="バニラクライアントでのミューテーション" trigger="クリックでバニラクライアント直接使用例を表示">
```tsx
import { useState } from 'react';
import { useMyApiClient } from './hooks/useMyApiClient';

function CreateItemForm() {
  const api = useMyApiClient();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [createdItem, setCreatedItem] = useState(null);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    try {
      const newItem = await api.createItem({
        name: 'New Item',
        description: 'A new item'
      });
      setCreatedItem(newItem);
    } catch (err) {
      setError(err);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <button
        type="submit"
        disabled={isLoading}
      >
        {isLoading ? 'Creating...' : 'Create Item'}
      </button>

      {createdItem && (
        <div className="success">
          Item created with ID: {createdItem.id}
        </div>
      )}

      {error && (
        <div className="error">
          Error: {error.message}
        </div>
      )}
    </form>
  );
}
```
</Drawer>

### 無限クエリによるページネーション

`cursor`パラメータを受け取るエンドポイント向けに、`useInfiniteQuery`を使用した無限クエリをサポート：

```tsx {5-14,24-26}
import { useInfiniteQuery } from '@tanstack/react-query';
import { useMyApi } from './hooks/useMyApi';

function ItemList() {
  const api = useMyApi();
  const items = useInfiniteQuery({
    ...api.listItems.infiniteQueryOptions({
      limit: 10,
    }, {
      getNextPageParam: (lastPage) =>
        lastPage.nextCursor || undefined
      }),
  });

  if (items.isLoading) return <LoadingSpinner />;

  if (items.isError) return <ErrorMessage message={items.error.message} />;

  return (
    <div>
      <ul>
        {items.data.pages.flatMap(page =>
          page.items.map(item => (
            <li key={item.id}>{item.name}</li>
          ))
        )}
      </ul>

      <button
        onClick={() => items.fetchNextPage()}
        disabled={!items.hasNextPage || items.isFetchingNextPage}
      >
        {items.isFetchingNextPage
          ? 'Loading more...'
          : items.hasNextPage
          ? 'Load More'
          : 'No more items'}
      </button>
    </div>
  );
}
```

<Drawer title="バニラクライアントでのページネーション" trigger="クリックでバニラクライアント直接使用例を表示">
```tsx
import { useState, useEffect } from 'react';
import { useMyApiClient } from './hooks/useMyApiClient';

function ItemList() {
  const api = useMyApiClient();
  const [items, setItems] = useState([]);
  const [nextCursor, setNextCursor] = useState(null);
  const [isFetchingMore, setIsFetchingMore] = useState(false);

  useEffect(() => {
    const fetchItems = async () => {
      const response = await api.listItems({ limit: 10 });
      setItems(response.items);
      setNextCursor(response.nextCursor);
    };
    fetchItems();
  }, [api]);

  const loadMore = async () => {
    try {
      setIsFetchingMore(true);
      const response = await api.listItems({
        limit: 10,
        cursor: nextCursor
      });
      setItems(prev => [...prev, ...response.items]);
      setNextCursor(response.nextCursor);
    } finally {
      setIsFetchingMore(false);
    }
  };

  return (
    <div>
      <ul>
        {items.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>

      <button
        onClick={loadMore}
        disabled={!nextCursor || isFetchingMore}
      >
        {isFetchingMore
          ? 'Loading more...'
          : nextCursor
          ? 'Load More'
          : 'No more items'}
      </button>
    </div>
  );
}
```
</Drawer>

### エラーハンドリング

OpenAPI仕様に基づいた型付きエラーレスポンスをサポート：

```tsx {12}
import { useMutation } from '@tanstack/react-query';

function MyComponent() {
  const api = useMyApi();
  const createItem = useMutation(api.createItem.mutationOptions());

  const handleClick = () => {
    createItem.mutate({ name: 'New Item' });
  };

  if (createItem.error) {
    switch (createItem.error.status) {
      case 400:
        return (
          <div>
            <h2>Invalid input:</h2>
            <p>{createItem.error.error.message}</p>
            <ul>
              {createItem.error.error.validationErrors.map((err) => (
                <li key={err.field}>{err.message}</li>
              ))}
            </ul>
          </div>
        );
      case 403:
        return (
          <div>
            <h2>Not authorized:</h2>
            <p>{createItem.error.error.reason}</p>
          </div>
        );
      case 500:
      case 502:
        return (
          <div>
            <h2>Server error:</h2>
            <p>{createItem.error.error.message}</p>
            <p>Trace ID: {createItem.error.error.traceId}</p>
          </div>
        );
    }
  }

  return <button onClick={handleClick}>Create Item</button>;
}
```

<Drawer title="バニラクライアントでのエラーハンドリング" trigger="クリックでバニラクライアント直接使用例を表示">
```tsx {9,15}
function MyComponent() {
  const api = useMyApiClient();
  const [error, setError] = useState<CreateItemError | null>(null);

  const handleClick = async () => {
    try {
      await api.createItem({ name: 'New Item' });
    } catch (e) {
      const err = e as CreateItemError;
      setError(err);
    }
  };

  if (error) {
    switch (error.status) {
      case 400:
        return (
          <div>
            <h2>Invalid input:</h2>
            <p>{error.error.message}</p>
            <ul>
              {error.error.validationErrors.map((err) => (
                <li key={err.field}>{err.message}</li>
              ))}
            </ul>
          </div>
        );
      case 403:
        return (
          <div>
            <h2>Not authorized:</h2>
            <p>{error.error.reason}</p>
          </div>
        );
      case 500:
      case 502:
        return (
          <div>
            <h2>Server error:</h2>
            <p>{error.error.message}</p>
            <p>Trace ID: {error.error.traceId}</p>
          </div>
        );
    }
  }

  return <button onClick={handleClick}>Create Item</button>;
}
```
</Drawer>

### ストリームの消費

ストリーミングAPIの使用例：

```tsx {3}
function MyStreamingComponent() {
  const api = useMyApi();
  const stream = useQuery(api.myStream.queryOptions());

  return (
    <ul>
      {(stream.data ?? []).map((chunk) => (
        <li>
          {chunk.timestamp.toISOString()}: {chunk.message}
        </li>
      ))}
    </ul>
  );
}
```

ストリームのライフサイクル：

<Steps>
  1. HTTPリクエスト送信
      - `isLoading`: `true`
      - `fetchStatus`: `'fetching'`
      - `data`: `undefined`

  2. 最初のチャンク受信
      - `isLoading`: `false`
      - `fetchStatus`: `'fetching'`
      - `data`: 最初のチャンクを含む配列

  3. 後続チャンク受信
      - `isLoading`: `false`
      - `fetchStatus`: `'fetching'`
      - `data`: 更新され続ける

  4. ストリーム完了
      - `isLoading`: `false`
      - `fetchStatus`: `'idle'`
      - `data`: 全チャンクを含む配列
</Steps>

<Drawer title="バニラクライアントでのストリーミング" trigger="クリックでバニラクライアント直接使用例を表示">
```tsx {8}
function MyStreamingComponent() {
  const api = useMyApiClient();
  const [chunks, setChunks] = useState<Chunk[]>([]);

  useEffect(() => {
    const streamChunks = async () => {
      for await (const chunk of api.myStream()) {
        setChunks((prev) => [...prev, chunk]);
      }
    };
    streamChunks();
  }, [api]);

  return (
    <ul>
      {chunks.map((chunk) => (
        <li>
          {chunk.timestamp.toISOString()}: {chunk.message}
        </li>
      ))}
    </ul>
  );
}
```
</Drawer>

## 生成コードのカスタマイズ

### クエリとミューテーションのカスタマイズ

HTTPメソッドのデフォルト動作を変更する例：

#### x-queryの使用

```python
@app.post(
    "/items",
    openapi_extra={
        "x-query": True
    }
)
def list_items():
    # ...
```

#### x-mutationの使用

```python
@app.get(
    "/start-processing",
    openapi_extra={
        "x-mutation": True
    }
)
def start_processing():
    # ...
```

### ページネーションカーソルのカスタマイズ

`x-cursor`拡張を使用したカスタマイズ例：

```python
@app.get(
    "/items",
    openapi_extra={
        "x-cursor": "page_token"
    }
)
def list_items(page_token: str = None, limit: int = 10):
    # ...
```

### 操作のグループ化

OpenAPIタグに基づく自動グループ化例：

```tsx
function ItemsAndUsers() {
  const api = useMyApi();
  const items = useQuery(api.items.list.queryOptions());
  const createItem = useMutation(api.items.create.mutationOptions());
  const users = useQuery(api.users.list.queryOptions());

  return (
    <div>
      <h2>Items</h2>
      <ul>
        {items.data?.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
      <button onClick={() => createItem.mutate({ name: 'New Item' })}>
        Add Item
      </button>

      <h2>Users</h2>
      <ul>
        {users.data?.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

<Drawer title="バニラクライアントでのグループ化操作" trigger="クリックでバニラクライアント直接使用例を表示">
```tsx
function ItemsAndUsers() {
  const api = useMyApiClient();
  const [items, setItems] = useState([]);
  const [users, setUsers] = useState([]);

  useEffect(() => {
    const fetchData = async () => {
      const itemsData = await api.items.list();
      const usersData = await api.users.list();
      setItems(itemsData);
      setUsers(usersData);
    };
    fetchData();
  }, [api]);

  const handleCreateItem = async () => {
    const newItem = await api.items.create({ name: 'New Item' });
    setItems(prev => [...prev, newItem]);
  };

  return (
    <div>
      <h2>Items</h2>
      <ul>
        {items.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
      <button onClick={handleCreateItem}>Add Item</button>

      <h2>Users</h2>
      <ul>
        {users.map(user => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}
```
</Drawer>

## ベストプラクティス

### ローディング状態の処理

ユーザー体験向上のためのローディング状態処理例：

```tsx
function ItemList() {
  const api = useMyApi();
  const items = useQuery(api.listItems.queryOptions());

  if (items.isLoading) return <LoadingSpinner />;

  if (items.isError) {
    const err = items.error;
    switch (err.status) {
      case 403: return <ErrorMessage message={err.error.reason} />;
      case 500: return <ServerError message={err.error.message} />;
      default: return <ErrorMessage message="Unknown error" />;
    }
  }

  return (
    <ul>
      {items.data.map((item) => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
```

### オプティミスティック更新

ユーザー体験向上のためのオプティミスティック更新実装例：

```tsx
function ItemList() {
  const queryClient = useQueryClient();
  const deleteMutation = useMutation({
    ...api.deleteItem.mutationOptions(),
    onMutate: async (itemId) => {
      await queryClient.cancelQueries(api.listItems.queryKey());
      const previousItems = queryClient.getQueryData(api.listItems.queryKey());
      queryClient.setQueryData(api.listItems.queryKey(), old => old.filter(item => item.id !== itemId));
      return { previousItems };
    },
    onError: (err, _, context) => {
      queryClient.setQueryData(api.listItems.queryKey(), context.previousItems);
    },
    onSettled: () => queryClient.invalidateQueries(api.listItems.queryKey()),
  });

  return (
    <ul>
      {itemsQuery.data.map((item) => (
        <li key={item.id}>
          {item.name}
          <button onClick={() => deleteMutation.mutate(item.id)}>
            {deleteMutation.isPending ? 'Deleting...' : 'Delete'}
          </button>
        </li>
      ))}
    </ul>
  );
}
```

## タイプセーフティ

エンドツーエンドのタイプセーフティを実現した使用例：

```tsx
function ItemForm() {
  const api = useMyApi();
  const createItem = useMutation({
    ...api.createItem.mutationOptions(),
    onSuccess: (data) => console.log(`Created ID: ${data.id}`),
  });

  const handleSubmit = (data: CreateItemInput) => {
    createItem.mutate(data);
  };

  if (createItem.error) {
    switch (createItem.error.status) {
      case 400: return <FormError errors={createItem.error.error.validationErrors} />;
      case 403: return <AuthError reason={createItem.error.error.reason} />;
      default: return <ServerError message={createItem.error.error.message} />;
    }
  }

  return (
    <form onSubmit={e => {
      e.preventDefault();
      handleSubmit({ name: 'New Item' });
    }}>
      <button type="submit" disabled={createItem.isPending}>
        {createItem.isPending ? 'Creating...' : 'Create Item'}
      </button>
    </form>
  );
}
```

生成された型はFastAPIのOpenAPIスキーマから自動生成されるため、API変更後はビルドするだけでフロントエンドコードに反映されます。