---
title: "FastAPI"
description: "FastAPIのリファレンスドキュメント"
---

import { FileTree } from '@astrojs/starlight/components';
import Link from '@components/link.astro';
import RunGenerator from '@components/run-generator.astro';
import GeneratorParameters from '@components/generator-parameters.astro';
import NxCommands from '@components/nx-commands.astro';
import schema from '../../../../../../packages/nx-plugin/src/py/fast-api/schema.json';

[FastAPI](https://fastapi.tiangolo.com/) は、Pythonで APIを構築するためのフレームワークです。

FastAPIジェネレーターは、AWS CDKインフラストラクチャのセットアップを含む新しいFastAPIを作成します。生成されたバックエンドは、AWS API Gateway HTTP APIを介して公開される、サーバーレスデプロイメントのためのAWS Lambdaを使用します。[AWS Lambda Powertools](https://docs.powertools.aws.dev/lambda/python/latest/)をセットアップし、ロギング、AWS X-Rayトレーシング、Cloudwatchメトリクスを含む可観測性を提供します。

## 使用方法

### FastAPIの生成

FastAPIは2つの方法で生成できます：

<RunGenerator generator="py#fast-api" />

### オプション

<GeneratorParameters schema={schema} />

## ジェネレーターの出力

ジェネレーターは、`<directory>/<api-name>` ディレクトリに次のプロジェクト構造を作成します：

<FileTree>

- project.json プロジェクト設定とビルドターゲット
- pyproject.toml Pythonプロジェクトの設定と依存関係
- \<module_name>
  - \_\_init\_\_.py モジュールの初期化
  - init.py FastAPI アプリの設定と Powertools ミドルウェアの構成
  - main.py API の実装

</FileTree>

ジェネレーターは、`packages/common/constructs` ディレクトリに配置される、APIをデプロイするために使用できるCDKコンストラクトも作成します。

## FastAPIの実装

メインのAPI実装は`main.py`にあります。ここでAPIルートとその実装を定義します。以下は例です：

```python
from .init import app, tracer
from pydantic import BaseModel

class Item(BaseModel):
  name: str

@app.get("/items/{item_id}")
def get_item(item_id: int) -> Item:
    return Item(name=...)

@app.post("/items")
def create_item(item: Item):
    return ...
```

ジェネレーターは自動的にいくつかの機能をセットアップします：

1. 可観測性のためのAWS Lambda Powertoolsの統合
2. エラーハンドリングミドルウェア
3. リクエスト/レスポンス相関
4. メトリクス収集
5. Mangumを使用したAWS Lambdaハンドラー

### AWS Lambda Powertoolsによる可観測性

#### ログ

ジェネレーターは、AWS Lambda Powertoolsを使用して構造化ログを設定します。ルートハンドラーでロガーにアクセスできます：

```python
from .init import app, logger

@app.get("/items/{item_id}")
def read_item(item_id: int):
    logger.info("Fetching item", extra={"item_id": item_id})
    return {"item_id": item_id}
```

ロガーは自動的に以下を含みます：

- リクエストトレーシングのための相関ID
- リクエストパスとメソッド
- Lambdaコンテキスト情報
- コールドスタート指標

#### トレーシング

AWS X-Rayトレーシングは自動的に設定されます。トレースにカスタムサブセグメントを追加できます：

```python
from .init import app, tracer

@app.get("/items/{item_id}")
@tracer.capture_method
def read_item(item_id: int):
    # 新しいサブセグメントを作成
    with tracer.provider.in_subsegment("fetch-item-details"):
        # ロジックをここに記述
        return {"item_id": item_id}
```

#### メトリクス

CloudWatchメトリクスは各リクエストに対して自動的に収集されます。カスタムメトリクスを追加できます：

```python
from .init import app, metrics
from aws_lambda_powertools.metrics import MetricUnit

@app.get("/items/{item_id}")
def read_item(item_id: int):
    metrics.add_metric(name="ItemViewed", unit=MetricUnit.Count, value=1)
    return {"item_id": item_id}
```

デフォルトのメトリクスには以下が含まれます：

- リクエスト数
- 成功/失敗数
- コールドスタートメトリクス
- ルートごとのメトリクス

### エラーハンドリング

ジェネレーターは包括的なエラーハンドリングを含みます：

```python
from fastapi import HTTPException

@app.get("/items/{item_id}")
def read_item(item_id: int):
    if item_id < 0:
        raise HTTPException(status_code=400, detail="Item ID must be positive")
    return {"item_id": item_id}
```

未処理の例外はミドルウェアによってキャッチされ、以下を行います：

1. スタックトレース付きの完全な例外をログ出力
2. 失敗メトリクスを記録
3. クライアントに安全な500レスポンスを返す
4. 相関IDを保持

:::tip
`api-connection`ジェネレーターを使用する場合、より良いコード生成のためにAPIオペレーションのレスポンスモデルを指定することをお勧めします。<Link path="guides/api-connection/react-fastapi#errors">詳細はこちらを参照</Link>。
:::

### ストリーミング

FastAPIでは、[`StreamingResponse`](https://fastapi.tiangolo.com/reference/responses/?h=streaming#fastapi.responses.StreamingResponse)レスポンスタイプを使用して、呼び出し元にレスポンスをストリーミングできます。

#### インフラストラクチャの変更

AWS API Gatewayはストリーミングレスポンスをサポートしていないため、ストリーミングをサポートするプラットフォームにFastAPIをデプロイする必要があります。最も簡単なオプションは、AWS Lambda関数URLを使用することです。これを実現するには、生成された`HttpApi`コンストラクトを変更してストリーミングのオプションを追加し、条件付きで関連するコンストラクトをインスタンス化します。

<details>
<summary>変更例</summary>

```diff lang="ts"
 import { Construct } from 'constructs';
-import { CfnOutput, Duration } from 'aws-cdk-lib';
+import { CfnOutput, Duration, Stack } from 'aws-cdk-lib';
 import {
   CorsHttpMethod,
   HttpApi as _HttpApi,
@@ -7,7 +7,16 @@ import {
   IHttpRouteAuthorizer,
 } from 'aws-cdk-lib/aws-apigatewayv2';

       },
     });

-    this.api = new _HttpApi(this, id, {
-      corsPreflight: {
-        allowOrigins: props.allowedOrigins ?? ['*'],
-        allowMethods: [CorsHttpMethod.ANY],
-        allowHeaders: [
-          'authorization',
-          'content-type',
-          'x-amz-content-sha256',
-          'x-amz-date',
-          'x-amz-security-token',
-        ],
-      },
-      defaultAuthorizer: props.defaultAuthorizer,
-    });
+    let apiUrl;
+    if (props.apiType === 'api-gateway') {
+      this.api = new _HttpApi(this, id, {
+        corsPreflight: {
+          allowOrigins: props.allowedOrigins ?? ['*'],
+          allowMethods: [CorsHttpMethod.ANY],
+          allowHeaders: [
+            'authorization',
+            'content-type',
+            'x-amz-content-sha256',
+            'x-amz-date',
+            'x-amz-security-token',
+          ],
+        },
+        defaultAuthorizer: props.defaultAuthorizer,
+      });

-    this.api.addRoutes({
-      path: '/{proxy+}',
-      methods: [
-        HttpMethod.GET,
-        HttpMethod.DELETE,
-        HttpMethod.POST,
-        HttpMethod.PUT,
-        HttpMethod.PATCH,
-        HttpMethod.HEAD,
-      ],
-      integration: new HttpLambdaIntegration(
-        'RouterIntegration',
-        this.routerFunction,
-      ),
-    });
+      this.api.addRoutes({
+        path: '/{proxy+}',
+        methods: [
+          HttpMethod.GET,
+          HttpMethod.DELETE,
+          HttpMethod.POST,
+          HttpMethod.PUT,
+          HttpMethod.PATCH,
+          HttpMethod.HEAD,
+        ],
+        integration: new HttpLambdaIntegration(
+          'RouterIntegration',
+          this.routerFunction,
+        ),
+      });
+      apiUrl = this.api.url;
+    } else {
+      const stack = Stack.of(this);
+      this.routerFunction.addLayers(
+        LayerVersion.fromLayerVersionArn(
+          this,
+          'LWALayer',
+          `arn:aws:lambda:${stack.region}:753240598075:layer:LambdaAdapterLayerX86:24`,
+        ),
+      );
+      this.routerFunction.addEnvironment('PORT', '8000');
+      this.routerFunction.addEnvironment(
+        'AWS_LWA_INVOKE_MODE',
+        'response_stream',
+      );
+      this.routerFunction.addEnvironment(
+        'AWS_LAMBDA_EXEC_WRAPPER',
+        '/opt/bootstrap',
+      );
+      this.routerFunctionUrl = this.routerFunction.addFunctionUrl({
+        authType: FunctionUrlAuthType.AWS_IAM,
+        invokeMode: InvokeMode.RESPONSE_STREAM,
+        cors: {
+          allowedOrigins: props.allowedOrigins ?? ['*'],
+          allowedHeaders: [
+            'authorization',
+            'content-type',
+            'x-amz-content-sha256',
+            'x-amz-date',
+            'x-amz-security-token',
+          ],
+        },
+      });
+      apiUrl = this.routerFunctionUrl.url;
+    }

-    new CfnOutput(this, `${props.apiName}Url`, { value: this.api.url! });
+    new CfnOutput(this, `${props.apiName}Url`, { value: apiUrl! });

     RuntimeConfig.ensure(this).config.httpApis = {
       ...RuntimeConfig.ensure(this).config.httpApis!,
-      [props.apiName]: this.api.url!,
+      [props.apiName]: apiUrl,
     };
   }

   public grantInvokeAccess(role: IRole) {
-    role.addToPrincipalPolicy(
-      new PolicyStatement({
-        effect: Effect.ALLOW,
-        actions: ['execute-api:Invoke'],
-        resources: [this.api.arnForExecuteApi('*', '/*', '*')],
-      }),
-    );
+    if (this.api) {
+      role.addToPrincipalPolicy(
+        new PolicyStatement({
+          effect: Effect.ALLOW,
+          actions: ['execute-api:Invoke'],
+          resources: [this.api.arnForExecuteApi('*', '/*', '*')],
+        }),
+      );
+    } else if (this.routerFunction) {
+      role.addToPrincipalPolicy(
+        new PolicyStatement({
+          effect: Effect.ALLOW,
+          actions: ['lambda:InvokeFunctionUrl'],
+          resources: [this.routerFunction.functionArn],
+          conditions: {
+            StringEquals: {
+              'lambda:FunctionUrlAuthType': 'AWS_IAM',
+            },
+          },
+        }),
+      );
+    }
   }
 }
```

</details>

これらの変更後、`packages/common/constructs/src/app/http-apis/<my-api>.ts`を更新して、新しい関数URLオプションを使用してください。

#### 実装

インフラストラクチャをストリーミングをサポートするように更新したら、FastAPIでストリーミングAPIを実装できます。APIは以下を満たす必要があります：

- [`StreamingResponse`](https://fastapi.tiangolo.com/reference/responses/?h=streaming#fastapi.responses.StreamingResponse)を返す
- 各レスポンスチャンクの戻り値の型を宣言する
- <Link path="guides/api-connection/react-fastapi">API接続</Link>を使用する場合、OpenAPIベンダー拡張子`x-streaming: true`を追加する

例えば、APIからJSONオブジェクトのシリーズをストリーミングする場合、以下のように実装できます：

```py /return (StreamingResponse)/ /openapi_extra[^)]*/ /-> (Chunk)/
from pydantic import BaseModel
from fastapi.responses import StreamingResponse

class Chunk(BaseModel):
  message: str
  timestamp: datetime

async def stream_chunks():
  for i in range(0, 100):
    yield Chunk(message=f"This is chunk {i}", timestamp=datetime.now())

@app.get("/stream", openapi_extra={'x-streaming': True})
def my_stream() -> Chunk:
    return StreamingResponse(stream_chunks(), media_type="application/json")
```

#### 消費

ストリーミングレスポンスを消費するには、<Link path="guides/api-connection/react-fastapi#consuming-a-stream">API接続ジェネレーター</Link>を使用して、ストリーミングチャンクを反復処理するタイプセーフな方法を提供できます。

## FastAPIのデプロイ

FastAPIジェネレーターは、`common/constructs`フォルダーにAPIをデプロイするためのCDKコンストラクトを作成します。これをCDKアプリケーションで使用できます：

```ts
import { MyApi } from ':my-scope/common-constructs';

export class ExampleStack extends Stack {
  constructor(scope: Construct, id: string) {
    // スタックにAPIを追加
    const api = new MyApi(this, 'MyApi');
  }
}
```

これにより以下が設定されます：

1. FastAPIアプリケーションを実行するAWS Lambdaファンクション
2. ファンクションのトリガーとしてのAPI Gateway HTTP API
3. IAMロールと権限
4. CloudWatchロググループ
5. X-Rayトレース設定
6. CloudWatchメトリクス名前空間

### アクセス権の付与

`grantInvokeAccess`メソッドを使用して、APIへのアクセス権を付与できます：

```ts
api.grantInvokeAccess(myIdentityPool.authenticatedRole);
```

## ローカル開発

ジェネレーターは、以下のコマンドで実行できるローカル開発サーバーを設定します：

<NxCommands commands={['run my-api:serve']} />

これにより、以下の機能を持つローカル FastAPI 開発サーバーが起動します：

- コード変更時の自動再読み込み
- `/docs` または `/redoc` での対話型 API ドキュメント
- `/openapi.json` での OpenAPI スキーマ

## FastAPIの呼び出し

ReactウェブサイトからAPIを呼び出すには、<Link path="guides/api-connection/react-fastapi">`api-connection`</Link>ジェネレーターを使用できます。