---
title: "デプロイ"
---



import { Steps, Tabs, TabItem } from '@astrojs/starlight/components';
import CreateNxWorkspaceCommand from '@components/create-nx-workspace-command.astro';
import RunGenerator from '@components/run-generator.astro';
import Link from '@components/link.astro';
import NxCommands from '@components/nx-commands.astro';
import Drawer from '@components/drawer.astro';
import InstallCommand from '@components/install-command.astro';

コードベースの完全な移行が完了したので、デプロイ方法を検討できます。この時点で選択可能な2つのアプローチがあります。

#### 新規リソースをすべて作成する（シンプルな方法）

最もシンプルなアプローチは、これを完全に新しいアプリケーションとして扱うことです。つまり、新しいDynamoDBテーブルとCognitoユーザープールを「最初から作成」し、既存のユーザーとそのショッピングリストをすべて失います。この方法では、以下の手順を実行するだけです：

<Steps>

1. `shopping_list`という名前のDynamoDBテーブルを削除

1. 新しいアプリケーションをデプロイ：

    <NxCommands commands={["deploy infra shopping-list-infra-sandbox/*"]} />

</Steps>

🎉 これで完了です！ 🎉

#### 既存のステートフルリソースをダウンタイムなしで移行（より複雑な方法）

実際には、既存のAWSリソースを新しいコードベースで管理できるように移行しつつ、顧客へのサービス停止を回避したい場合がほとんどでしょう。

:::danger
このアプローチはより複雑で繊細な作業が必要です。あくまで例示のため、本番環境以外（理想的には新しいsandboxスタック）で練習し、アプリケーション固有の正確な手順を文書化することを強く推奨します。また、手順が失敗したり予期せぬ結果が生じた場合の緊急時対応/ロールバック計画も作成することをお勧めします。
:::

:::note
PDKショッピングリストアプリケーションではカスタムドメインやDNSを定義していません。実際にはWebサイトやAPI用にドメインが設定されている可能性が高いです。このガイドのセクションでは、WebサイトとAPI用にRoute53でカスタムDNS名が設定されていると仮定します。
:::

ショッピングリストアプリケーションにおいて重要なステートフルリソースは、ユーザーのショッピングリストを含むDynamoDBテーブルと、登録ユーザーの詳細を含むユーザープールです。高レベルの計画としては、これら2つの主要リソースを保持し、新しいスタックで管理されるように移動した後、DNSを更新して新しいWebサイト（および顧客に公開されている場合はAPI）を指すようにします。

<Steps>

1. 保持したい既存リソースを参照するように新しいアプリケーションを更新

    ショッピングリストアプリケーションでは、DynamoDBテーブルに対して以下を実行：

    ```diff lang="ts"
    // constructs/database.ts
    -this.shoppingListTable = new Table(this, 'ShoppingList', {
    -  ...
    +this.shoppingListTable = Table.fromTableName(
    +  this,
    +  'ShoppingList',
    +  'shopping_list',
    +);
    ```

    Cognitoユーザープールに対しては：

    ```diff lang="ts"
    // packages/common/constructs/src/core/user-identity.ts
    -this.userPool = this.createUserPool();
    +this.userPool = UserPool.fromUserPoolId(
    +  this,
    +  'UserPool',
    +  '<your-user-pool-id>',
    +);
    ```

1. 新しいアプリケーションをビルドしてデプロイ：

    <NxCommands commands={["run-many --target build"]} />

    <NxCommands commands={["deploy infra shopping-list-infra-sandbox/*"]} />

    これで既存リソースを参照する新しいアプリケーションが起動しましたが、まだトラフィックは受けていません。

1. 完全な結合テストを実施し、新しいアプリケーションが期待通りに動作することを確認。ショッピングリストアプリケーションでは、Webサイトをロードしてサインイン、ショッピングリストの作成/表示/編集/削除が可能か確認。

1. 既存リソースを参照する変更を新しいアプリケーションで元に戻す（ただしまだデプロイしない）：

    ```diff lang="ts"
    // constructs/database.ts
    +this.shoppingListTable = new Table(this, 'ShoppingList', {
    +  ...
    -this.shoppingListTable = Table.fromTableName(
    -  this,
    -  'ShoppingList',
    -  'shopping_list',
    -);
    ```

    Cognitoユーザープールに対しては：

    ```diff lang="ts"
    // packages/common/constructs/src/core/user-identity.ts
    +this.userPool = this.createUserPool();
    -this.userPool = UserPool.fromUserPoolId(
    -  this,
    -  'UserPool',
    -  '<your-user-pool-id>',
    -);
    ```

    その後ビルドを実行：

    <NxCommands commands={["run-many --target build"]} />

1. 新しいアプリケーションの`packages/infra`フォルダで`cdk import`を実行し、インポート対象リソースを確認：

    ```bash title="New Application"
    cd packages/infra
    pnpm exec cdk import shopping-list-infra-sandbox/Application --force
    ```

    Enterキーを押してプロンプトを進めてください。リソースが別スタックで管理されているためインポートは失敗します（これは予期された動作です）。インポート対象リソースを確認するためだけのステップです。以下のような出力が表示されます：

    ```bash wrap
    shopping-list-infra-sandbox/Application/ApplicationUserIdentity/UserPool/smsRole/Resource (AWS::IAM::Role): enter RoleName (empty to skip)
    shopping-list-infra-sandbox/Application/ApplicationUserIdentity/UserPool/Resource (AWS::Cognito::UserPool): enter UserPoolId (empty to skip)
    shopping-list-infra-sandbox/Application/Database/ShoppingList/Resource (AWS::DynamoDB::Table): import with TableName=shopping_list (y/n) y
    ```

    これにより、実際には3つのリソースを新しいスタックにインポートする必要があることがわかります。

1. 前のステップで発見したリソースに対して、古いPDKプロジェクトで`RemovalPolicy`を`RETAIN`に設定：

    ```diff lang="ts"
    // application-stack.ts
    const userIdentity = new UserIdentity(this, `${id}UserIdentity`, {
      userPool,
    });

    +const smsRole = userIdentity.userPool.node.findAll().filter(
    +  c => CfnResource.isCfnResource(c) &&
    +    c.node.path.includes('/smsRole/'))[0] as CfnResource;
    +smsRole.applyRemovalPolicy(RemovalPolicy.RETAIN);
    ```

1. 削除ポリシーを適用するためPDKプロジェクトをデプロイ：

    ```bash title="PDK Application"
    cd packages/infra
    npx projen deploy
    ```

1. CloudFormationコンソールで`cdk import`ステップで要求された値を記録：

    1. ユーザープールID（例：`us-west-2_XXXXX`）
    2. SMSロール名（例：`infra-sandbox-UserIdentityUserPoolsmsRoleXXXXXX`）

1. リソースを作成する代わりに既存リソースを参照するようPDKプロジェクトを更新：

    ```diff lang="ts"
    // constructs/database.ts
    -this.shoppingListTable = new Table(this, 'ShoppingList', {
    -  ...
    +this.shoppingListTable = Table.fromTableName(
    +  this,
    +  'ShoppingList',
    +  'shopping_list',
    +);
    ```

    Cognitoユーザープールに対しては：

    ```diff lang="ts"
    // application-stack.ts
    +const userPool = UserPool.fromUserPoolId(
    +  this,
    +  'UserPool',
    +  '<your-user-pool-id>',
    +);
    const userIdentity = new UserIdentity(this, `${id}UserIdentity`, {
    +  // PDKコンストラクトはIUserPoolではなくUserPoolを受け取りますが、問題なく動作します！
    +  userPool: userPool as any,
    });
    ```

1. PDKプロジェクトを再度デプロイ（これによりリソースがPDKプロジェクトのCloudFormationスタックで管理されなくなります）：

    ```bash title="PDK Application"
    cd packages/infra
    npx projen deploy
    ```

1. リソースが管理対象外になったら、新しいアプリケーションで`cdk import`を実行して実際にインポート：

    ```bash title="New Application"
    cd packages/infra
    pnpm exec cdk import shopping-list-infra-sandbox/Application --force
    ```

    プロンプトで値を入力すると、インポートが正常に完了します。

1. 既存リソース（現在は新しいスタックで管理）への変更を適用するため、新しいアプリケーションを再度デプロイ：

    <NxCommands commands={["deploy infra shopping-list-infra-sandbox/*"]} />

1. 新しいアプリケーションの完全テストを再度実施

1. 新しいWebサイト（および必要に応じてAPI）を指すようDNSレコードを更新：

    Route53の[Weighted Routing](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-weighted.html)を使用した段階的な移行を推奨します。最初は一部のリクエストを新しいアプリケーションに転送し、メトリクスを監視しながら徐々に重みを増やしていき、最終的に古いPDKアプリケーションへのトラフィックをゼロにします。

    DNSがなくWebサイト/APIに自動生成ドメインを使用している場合は、[CloudFront HTTP origin](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_cloudfront_origins-readme.html#from-an-http-endpoint)や[API Gateway HTTP integration](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_apigateway.HttpIntegration.html)を使用してリクエストをプロキシできます。

1. PDKアプリケーションのメトリクスを監視してトラフィックがないことを確認後、古いCloudFormationスタックを削除：

    ```bash
    cd packages/infra
    npx projen destroy
    ```

</Steps>

かなり手間がかかりましたが、ユーザーをシームレスに新しいアプリケーションに移行できました！ 🎉🎉🎉

これで、PDKよりもNx Plugin for AWSの新しいメリットを享受できます：

- より高速なビルド
- ローカルAPI開発のサポート
- 快適なコーディングが可能なコードベース（<Link path="/get_started/building-with-ai">MCPサーバーを試してみてください！</Link>）
- より直感的なタイプセーフなクライアント/サーバーコード
- その他多数！